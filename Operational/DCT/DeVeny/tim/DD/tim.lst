Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  tim.s  Page 1



1                          ; This file is used to generate DSP code for the Gen III ARC-22/32/47
2                          ;    board set.  This one is for the DeVeny e2v CCD42-10
3                          ;
4                          ; This file contains two subroutines and X and Y data areas.  The two
5                          ; subroutines are RDCCD (with secondary entry point RCCD1) and CLOCK.
6                          ; These need to be in fast P memory.  The boot code and tim.s are there.
7                          ; tim.s includes timmisc.s, timCCDmisc.s and the waveforms file at the
8                          ; end.
9      
10                                   PAGE    132                               ; Printronix page width - 132 columns
11     
12                         ; Include a header file that defines global parameters
13     
14                                   INCLUDE "timboot.s"
15                         ;  This file is used to generate boot DSP code for the Gen III 250 MHz fiber
16                         ;       optic timing board = ARC22 using a DSP56303 as its main processor.
17     
18                         ; Various addressing control registers
19        FFFFFB           BCR       EQU     $FFFFFB                           ; Bus Control Register
20        FFFFF9           AAR0      EQU     $FFFFF9                           ; Address Attribute Register, channel 0
21        FFFFF8           AAR1      EQU     $FFFFF8                           ; Address Attribute Register, channel 1
22        FFFFF7           AAR2      EQU     $FFFFF7                           ; Address Attribute Register, channel 2
23        FFFFF6           AAR3      EQU     $FFFFF6                           ; Address Attribute Register, channel 3
24        FFFFFD           PCTL      EQU     $FFFFFD                           ; PLL control register
25        FFFFFE           IPRP      EQU     $FFFFFE                           ; Interrupt Priority register - Peripheral
26        FFFFFF           IPRC      EQU     $FFFFFF                           ; Interrupt Priority register - Core
27     
28                         ; Port E is the Synchronous Communications Interface (SCI) port
29        FFFF9F           PCRE      EQU     $FFFF9F                           ; Port Control Register
30        FFFF9E           PRRE      EQU     $FFFF9E                           ; Port Direction Register
31        FFFF9D           PDRE      EQU     $FFFF9D                           ; Port Data Register
32        FFFF9C           SCR       EQU     $FFFF9C                           ; SCI Control Register
33        FFFF9B           SCCR      EQU     $FFFF9B                           ; SCI Clock Control Register
34     
35        FFFF9A           SRXH      EQU     $FFFF9A                           ; SCI Receive Data Register, High byte
36        FFFF99           SRXM      EQU     $FFFF99                           ; SCI Receive Data Register, Middle byte
37        FFFF98           SRXL      EQU     $FFFF98                           ; SCI Receive Data Register, Low byte
38     
39        FFFF97           STXH      EQU     $FFFF97                           ; SCI Transmit Data register, High byte
40        FFFF96           STXM      EQU     $FFFF96                           ; SCI Transmit Data register, Middle byte
41        FFFF95           STXL      EQU     $FFFF95                           ; SCI Transmit Data register, Low byte
42     
43        FFFF94           STXA      EQU     $FFFF94                           ; SCI Transmit Address Register
44        FFFF93           SSR       EQU     $FFFF93                           ; SCI Status Register
45     
46        000009           SCITE     EQU     9                                 ; X:SCR bit set to enable the SCI transmitter
47        000008           SCIRE     EQU     8                                 ; X:SCR bit set to enable the SCI receiver
48        000000           TRNE      EQU     0                                 ; This is set in X:SSR when the transmitter
49                                                                             ;  shift and data registers are both empty
50        000001           TDRE      EQU     1                                 ; This is set in X:SSR when the transmitter
51                                                                             ;  data register is empty
52        000002           RDRF      EQU     2                                 ; X:SSR bit set when receiver register is full
53        00000F           SELSCI    EQU     15                                ; 1 for SCI to backplane, 0 to front connector
54     
55     
56                         ; ESSI Flags
57        000006           TDE       EQU     6                                 ; Set when transmitter data register is empty
58        000007           RDF       EQU     7                                 ; Set when receiver is full of data
59        000010           TE        EQU     16                                ; Transmitter enable
60     
61                         ; Phase Locked Loop initialization
62        050003           PLL_INIT  EQU     $050003                           ; PLL = 25 MHz x 2 = 100 MHz
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 2



63     
64                         ; Port B general purpose I/O
65        FFFFC4           HPCR      EQU     $FFFFC4                           ; Control register (bits 1-6 cleared for GPIO)
66        FFFFC9           HDR       EQU     $FFFFC9                           ; Data register
67        FFFFC8           HDDR      EQU     $FFFFC8                           ; Data Direction Register bits (=1 for output)
68     
69                         ; Port C is Enhanced Synchronous Serial Port 0 = ESSI0
70        FFFFBF           PCRC      EQU     $FFFFBF                           ; Port C Control Register
71        FFFFBE           PRRC      EQU     $FFFFBE                           ; Port C Data direction Register
72        FFFFBD           PDRC      EQU     $FFFFBD                           ; Port C GPIO Data Register
73        FFFFBC           TX00      EQU     $FFFFBC                           ; Transmit Data Register #0
74        FFFFB8           RX0       EQU     $FFFFB8                           ; Receive data register
75        FFFFB7           SSISR0    EQU     $FFFFB7                           ; Status Register
76        FFFFB6           CRB0      EQU     $FFFFB6                           ; Control Register B
77        FFFFB5           CRA0      EQU     $FFFFB5                           ; Control Register A
78     
79                         ; Port D is Enhanced Synchronous Serial Port 1 = ESSI1
80        FFFFAF           PCRD      EQU     $FFFFAF                           ; Port D Control Register
81        FFFFAE           PRRD      EQU     $FFFFAE                           ; Port D Data direction Register
82        FFFFAD           PDRD      EQU     $FFFFAD                           ; Port D GPIO Data Register
83        FFFFAC           TX10      EQU     $FFFFAC                           ; Transmit Data Register 0
84        FFFFA7           SSISR1    EQU     $FFFFA7                           ; Status Register
85        FFFFA6           CRB1      EQU     $FFFFA6                           ; Control Register B
86        FFFFA5           CRA1      EQU     $FFFFA5                           ; Control Register A
87     
88                         ; Timer module addresses
89        FFFF8F           TCSR0     EQU     $FFFF8F                           ; Timer control and status register
90        FFFF8E           TLR0      EQU     $FFFF8E                           ; Timer load register = 0
91        FFFF8D           TCPR0     EQU     $FFFF8D                           ; Timer compare register = exposure time
92        FFFF8C           TCR0      EQU     $FFFF8C                           ; Timer count register = elapsed time
93        FFFF83           TPLR      EQU     $FFFF83                           ; Timer prescaler load register => milliseconds
94        FFFF82           TPCR      EQU     $FFFF82                           ; Timer prescaler count register
95        000000           TIM_BIT   EQU     0                                 ; Set to enable the timer
96        000009           TRM       EQU     9                                 ; Set to enable the timer preloading
97        000015           TCF       EQU     21                                ; Set when timer counter = compare register
98     
99                         ; Board specific addresses and constants
100       FFFFF1           RDFO      EQU     $FFFFF1                           ; Read incoming fiber optic data byte
101       FFFFF2           WRFO      EQU     $FFFFF2                           ; Write fiber optic data replies
102       FFFFF3           WRSS      EQU     $FFFFF3                           ; Write switch state
103       FFFFF5           WRLATCH   EQU     $FFFFF5                           ; Write to a latch
104       010000           RDAD      EQU     $010000                           ; Read A/D values into the DSP
105       000009           EF        EQU     9                                 ; Serial receiver empty flag
106    
107                        ; DSP port A bit equates
108       000000           PWROK     EQU     0                                 ; Power control board says power is OK
109       000001           LED1      EQU     1                                 ; Control one of two LEDs
110       000002           LVEN      EQU     2                                 ; Low voltage power enable
111       000003           HVEN      EQU     3                                 ; High voltage power enable
112       00000E           SSFHF     EQU     14                                ; Switch state FIFO half full flag
113       00000A           EXT_IN0   EQU     10                                ; External digital I/O to the timing board
114       00000B           EXT_IN1   EQU     11
115       00000C           EXT_OUT0  EQU     12
116       00000D           EXT_OUT1  EQU     13
117    
118                        ; Port D equate
119       000001           SSFEF     EQU     1                                 ; Switch state FIFO empty flag
120    
121                        ; Other equates
122       000002           WRENA     EQU     2                                 ; Enable writing to the EEPROM
123    
124                        ; Latch U25 bit equates
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 3



125       000000           CDAC      EQU     0                                 ; Clear the analog board DACs
126       000002           ENCK      EQU     2                                 ; Enable the clock outputs
127       000004           SHUTTER   EQU     4                                 ; Control the shutter
128       000005           TIM_U_RST EQU     5                                 ; Reset the utility board
129    
130                        ; Software status bits, defined at X:<STATUS = X:0
131       000000           ST_RCV    EQU     0                                 ; Set to indicate word is from SCI = utility board
132       000002           IDLMODE   EQU     2                                 ; Set if need to idle after readout
133       000003           ST_SHUT   EQU     3                                 ; Set to indicate shutter is closed, clear for open
134       000004           ST_RDC    EQU     4                                 ; Set if executing 'RDC' command - reading out
135       000005           SPLIT_S   EQU     5                                 ; Set if split serial
136       000006           SPLIT_P   EQU     6                                 ; Set if split parallel
137       000007           MPP       EQU     7                                 ; Set if parallels are in MPP mode
138       000008           NOT_CLR   EQU     8                                 ; Set if not to clear CCD before exposure
139       00000A           TST_IMG   EQU     10                                ; Set if controller is to generate a test image
140       00000B           SHUT      EQU     11                                ; Set if opening shutter at beginning of exposure
141       00000C           ST_DITH   EQU     12                                ; Set if to dither during exposure
142       00000D           ST_SYNC   EQU     13                                ; Set if starting exposure on SYNC = high signal
143       00000E           ST_CNRD   EQU     14                                ; Set if in continous readout mode
144       00000F           ST_DIRTY  EQU     15                                ; Set if waveform tables need to be updated
145       000010           ST_SA     EQU     16                                ; Set if in subarray readout mode
146    
147                        ; Address for the table containing the incoming SCI words
148       000400           SCI_TABLE EQU     $400
149    
150    
151                        ; Specify controller configuration bits of the X:STATUS word
152                        ;   to describe the software capabilities of this application file
153                        ; The bit is set (=1) if the capability is supported by the controller
154    
155    
156                                COMMENT *
157    
158                        BIT #'s         FUNCTION
159                        2,1,0           Video Processor
160                                                000     ARC41, CCD Rev. 3
161                                                001     CCD Gen I
162                                                010     ARC42, dual readout CCD
163                                                011     ARC44, 4-readout IR coadder
164                                                100     ARC45. dual readout CCD
165                                                101     ARC46 = 8-channel IR
166                                                110     ARC48 = 8 channel CCD
167                                                111     ARC47 = 4-channel CCD
168    
169                        4,3             Timing Board
170                                                00      ARC20, Rev. 4, Gen II
171                                                01      Gen I
172                                                10      ARC22, Gen III, 250 MHz
173    
174                        6,5             Utility Board
175                                                00      No utility board
176                                                01      ARC50
177    
178                        7               Shutter
179                                                0       No shutter support
180                                                1       Yes shutter support
181    
182                        9,8             Temperature readout
183                                                00      No temperature readout
184                                                01      Polynomial Diode calibration
185                                                10      Linear temperature sensor calibration
186    
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 4



187                        10              Subarray readout
188                                                0       Not supported
189                                                1       Yes supported
190    
191                        11              Binning
192                                                0       Not supported
193                                                1       Yes supported
194    
195                        12              Split-Serial readout
196                                                0       Not supported
197                                                1       Yes supported
198    
199                        13              Split-Parallel readout
200                                                0       Not supported
201                                                1       Yes supported
202    
203                        14              MPP = Inverted parallel clocks
204                                                0       Not supported
205                                                1       Yes supported
206    
207                        16,15           Clock Driver Board
208                                                00      ARC30 or ARC31
209                                                01      ARC32, CCD and IR
210                                                11      No clock driver board (Gen I)
211    
212                        19,18,17                Special implementations
213                                                000     Somewhere else
214                                                001     Mount Laguna Observatory
215                                                010     NGST Aladdin
216                                                xxx     Other
217                                *
218    
219                        CCDVIDREV3B
220       000000                     EQU     $000000                           ; CCD Video Processor Rev. 3
221       000000           ARC41     EQU     $000000
222       000001           VIDGENI   EQU     $000001                           ; CCD Video Processor Gen I
223       000002           IRREV4    EQU     $000002                           ; IR Video Processor Rev. 4
224       000002           ARC42     EQU     $000002
225       000003           COADDER   EQU     $000003                           ; IR Coadder
226       000003           ARC44     EQU     $000003
227       000004           CCDVIDREV5 EQU    $000004                           ; Differential input CCD video Rev. 5
228       000004           ARC45     EQU     $000004
229       000005           ARC46     EQU     $000005                           ; 8-channel IR video board
230       000006           ARC48     EQU     $000006                           ; 8-channel CCD video board
231       000007           ARC47     EQU     $000007                           ; 4-channel CCD video board
232       000000           TIMREV4   EQU     $000000                           ; Timing Revision 4 = 50 MHz
233       000000           ARC20     EQU     $000000
234       000008           TIMGENI   EQU     $000008                           ; Timing Gen I = 40 MHz
235       000010           TIMREV5   EQU     $000010                           ; Timing Revision 5 = 250 MHz
236       000010           ARC22     EQU     $000010
237       008000           ARC32     EQU     $008000                           ; CCD & IR clock driver board
238       000020           UTILREV3  EQU     $000020                           ; Utility Rev. 3 supported
239       000020           ARC50     EQU     $000020
240       000080           SHUTTER_CC EQU    $000080                           ; Shutter supported
241       000100           TEMP_POLY EQU     $000100                           ; Polynomial calibration
242                        TEMP_LINEAR
243       000200                     EQU     $000200                           ; Linear calibration
244       000400           SUBARRAY  EQU     $000400                           ; Subarray readout supported
245       000800           BINNING   EQU     $000800                           ; Binning supported
246                        SPLIT_SERIAL
247       001000                     EQU     $001000                           ; Split serial supported
248                        SPLIT_PARALLEL
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 5



249       002000                     EQU     $002000                           ; Split parallel supported
250       004000           MPP_CC    EQU     $004000                           ; Inverted clocks supported
251       018000           CLKDRVGENI EQU    $018000                           ; No clock driver board - Gen I
252       020000           MLO       EQU     $020000                           ; Set if Mount Laguna Observatory
253       040000           NGST      EQU     $040000                           ; NGST Aladdin implementation
254       100000           CONT_RD   EQU     $100000                           ; Continuous readout implemented
255    
256                        ; Special address for two words for the DSP to bootstrap code from the EEPROM
257                                  IF      @SCP("HOST","ROM")
264                                  ENDIF
265    
266                                  IF      @SCP("HOST","HOST")
267       P:000000 P:000000                   ORG     P:0,P:0
268       P:000000 P:000000 0C0190            JMP     <INIT
269       P:000001 P:000001 000000            NOP
270                                           ENDIF
271    
272                                 ;  This ISR receives serial words a byte at a time over the asynchronous
273                                 ;    serial link (SCI) and squashes them into a single 24-bit word
274       P:000002 P:000002 602400  SCI_RCV   MOVE              R0,X:<SAVE_R0           ; Save R0
275       P:000003 P:000003 052139            MOVEC             SR,X:<SAVE_SR           ; Save Status Register
276       P:000004 P:000004 60A700            MOVE              X:<SCI_R0,R0            ; Restore R0 = pointer to SCI receive regist
er
277       P:000005 P:000005 542300            MOVE              A1,X:<SAVE_A1           ; Save A1
278       P:000006 P:000006 452200            MOVE              X1,X:<SAVE_X1           ; Save X1
279       P:000007 P:000007 54A600            MOVE              X:<SCI_A1,A1            ; Get SRX value of accumulator contents
280       P:000008 P:000008 45E000            MOVE              X:(R0),X1               ; Get the SCI byte
281       P:000009 P:000009 0AD041            BCLR    #1,R0                             ; Test for the address being $FFF6 = last by
te
282       P:00000A P:00000A 000000            NOP
283       P:00000B P:00000B 000000            NOP
284       P:00000C P:00000C 000000            NOP
285       P:00000D P:00000D 205862            OR      X1,A      (R0)+                   ; Add the byte into the 24-bit word
286       P:00000E P:00000E 0E0013            JCC     <MID_BYT                          ; Not the last byte => only restore register
s
287       P:00000F P:00000F 545C00  END_BYT   MOVE              A1,X:(R4)+              ; Put the 24-bit word into the SCI buffer
288       P:000010 P:000010 60F400            MOVE              #SRXL,R0                ; Re-establish first address of SCI interfac
e
                            FFFF98
289       P:000012 P:000012 2C0000            MOVE              #0,A1                   ; For zeroing out SCI_A1
290       P:000013 P:000013 602700  MID_BYT   MOVE              R0,X:<SCI_R0            ; Save the SCI receiver address
291       P:000014 P:000014 542600            MOVE              A1,X:<SCI_A1            ; Save A1 for next interrupt
292       P:000015 P:000015 05A139            MOVEC             X:<SAVE_SR,SR           ; Restore Status Register
293       P:000016 P:000016 54A300            MOVE              X:<SAVE_A1,A1           ; Restore A1
294       P:000017 P:000017 45A200            MOVE              X:<SAVE_X1,X1           ; Restore X1
295       P:000018 P:000018 60A400            MOVE              X:<SAVE_R0,R0           ; Restore R0
296       P:000019 P:000019 000004            RTI                                       ; Return from interrupt service
297    
298                                 ; Clear error condition and interrupt on SCI receiver
299       P:00001A P:00001A 077013  CLR_ERR   MOVEP             X:SSR,X:RCV_ERR         ; Read SCI status register
                            000025
300       P:00001C P:00001C 077018            MOVEP             X:SRXL,X:RCV_ERR        ; This clears any error
                            000025
301       P:00001E P:00001E 000004            RTI
302    
303       P:00001F P:00001F                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
304       P:000030 P:000030                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
305       P:000040 P:000040                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
306    
307                                 ; Tune the table so the following instruction is at P:$50 exactly.
308       P:000050 P:000050 0D0002            JSR     SCI_RCV                           ; SCI receive data interrupt
309       P:000051 P:000051 000000            NOP
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 6



310       P:000052 P:000052 0D001A            JSR     CLR_ERR                           ; SCI receive error interrupt
311       P:000053 P:000053 000000            NOP
312    
313                                 ; *******************  Command Processing  ******************
314    
315                                 ; Read the header and check it for self-consistency
316       P:000054 P:000054 609F00  START     MOVE              X:<IDL_ADR,R0
317       P:000055 P:000055 018FA0            JSET    #TIM_BIT,X:TCSR0,EXPOSING         ; If exposing go check the timer
                            00005A
318       P:000057 P:000057 0A00A4            JSET    #ST_RDC,X:<STATUS,CONTINUE_READING
                            00005A
319       P:000059 P:000059 0AE080            JMP     (R0)
320    
321       P:00005A P:00005A 330700  TST_RCV   MOVE              #<COM_BUF,R3
322       P:00005B P:00005B 0D00A5            JSR     <GET_RCV
323       P:00005C P:00005C 0E005B            JCC     *-1
324    
325                                 ; Check the header and read all the remaining words in the command
326       P:00005D P:00005D 0C00FF  PRC_RCV   JMP     <CHK_HDR                          ; Update HEADER and NWORDS
327       P:00005E P:00005E 578600  PR_RCV    MOVE              X:<NWORDS,B             ; Read this many words total in the command
328       P:00005F P:00005F 000000            NOP
329       P:000060 P:000060 01418C            SUB     #1,B                              ; We've already read the header
330       P:000061 P:000061 000000            NOP
331       P:000062 P:000062 06CF00            DO      B,RD_COM
                            00006A
332       P:000064 P:000064 205B00            MOVE              (R3)+                   ; Increment past what's been read already
333       P:000065 P:000065 0B0080  GET_WRD   JSCLR   #ST_RCV,X:STATUS,CHK_FO
                            0000A9
334       P:000067 P:000067 0B00A0            JSSET   #ST_RCV,X:STATUS,CHK_SCI
                            0000D5
335       P:000069 P:000069 0E0065            JCC     <GET_WRD
336       P:00006A P:00006A 000000            NOP
337       P:00006B P:00006B 330700  RD_COM    MOVE              #<COM_BUF,R3            ; Restore R3 = beginning of the command
338    
339                                 ; Is this command for the timing board?
340       P:00006C P:00006C 448500            MOVE              X:<HEADER,X0
341       P:00006D P:00006D 579B00            MOVE              X:<DMASK,B
342       P:00006E P:00006E 459A4E            AND     X0,B      X:<TIM_DRB,X1           ; Extract destination byte
343       P:00006F P:00006F 20006D            CMP     X1,B                              ; Does header = timing board number?
344       P:000070 P:000070 0EA080            JEQ     <COMMAND                          ; Yes, process it here
345       P:000071 P:000071 0E909D            JLT     <FO_XMT                           ; Send it to fiber optic transmitter
346    
347                                 ; Transmit the command to the utility board over the SCI port
348       P:000072 P:000072 060600            DO      X:<NWORDS,DON_XMT                 ; Transmit NWORDS
                            00007E
349       P:000074 P:000074 60F400            MOVE              #STXL,R0                ; SCI first byte address
                            FFFF95
350       P:000076 P:000076 44DB00            MOVE              X:(R3)+,X0              ; Get the 24-bit word to transmit
351       P:000077 P:000077 060380            DO      #3,SCI_SPT
                            00007D
352       P:000079 P:000079 019381            JCLR    #TDRE,X:SSR,*                     ; Continue ONLY if SCI XMT is empty
                            000079
353       P:00007B P:00007B 445800            MOVE              X0,X:(R0)+              ; Write to SCI, byte pointer + 1
354       P:00007C P:00007C 000000            NOP                                       ; Delay for the status flag to be set
355       P:00007D P:00007D 000000            NOP
356                                 SCI_SPT
357       P:00007E P:00007E 000000            NOP
358                                 DON_XMT
359       P:00007F P:00007F 0C0054            JMP     <START
360    
361                                 ; Process the receiver entry - is it in the command table ?
362       P:000080 P:000080 0203DF  COMMAND   MOVE              X:(R3+1),B              ; Get the command
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 7



363       P:000081 P:000081 205B00            MOVE              (R3)+
364       P:000082 P:000082 205B00            MOVE              (R3)+                   ; Point R3 to the first argument
365       P:000083 P:000083 302800            MOVE              #<COM_TBL,R0            ; Get the command table starting address
366       P:000084 P:000084 062080            DO      #NUM_COM,END_COM                  ; Loop over the command table
                            00008B
367       P:000086 P:000086 47D800            MOVE              X:(R0)+,Y1              ; Get the command table entry
368       P:000087 P:000087 62E07D            CMP     Y1,B      X:(R0),R2               ; Does receiver = table entries address?
369       P:000088 P:000088 0E208B            JNE     <NOT_COM                          ; No, keep looping
370       P:000089 P:000089 00008C            ENDDO                                     ; Restore the DO loop system registers
371       P:00008A P:00008A 0AE280            JMP     (R2)                              ; Jump execution to the command
372       P:00008B P:00008B 205800  NOT_COM   MOVE              (R0)+                   ; Increment the register past the table addr
ess
373                                 END_COM
374       P:00008C P:00008C 0C008D            JMP     <ERROR                            ; The command is not in the table
375    
376                                 ; It's not in the command table - send an error message
377       P:00008D P:00008D 479D00  ERROR     MOVE              X:<ERR,Y1               ; Send the message - there was an error
378       P:00008E P:00008E 0C0090            JMP     <FINISH1                          ; This protects against unknown commands
379    
380                                 ; Send a reply packet - header and reply
381       P:00008F P:00008F 479800  FINISH    MOVE              X:<DONE,Y1              ; Send 'DON' as the reply
382       P:000090 P:000090 578500  FINISH1   MOVE              X:<HEADER,B             ; Get header of incoming command
383       P:000091 P:000091 469C00            MOVE              X:<SMASK,Y0             ; This was the source byte, and is to
384       P:000092 P:000092 330700            MOVE              #<COM_BUF,R3            ;     become the destination byte
385       P:000093 P:000093 46935E            AND     Y0,B      X:<TWO,Y0
386       P:000094 P:000094 0C1ED1            LSR     #8,B                              ; Shift right eight bytes, add it to the
387       P:000095 P:000095 460600            MOVE              Y0,X:<NWORDS            ;     header, and put 2 as the number
388       P:000096 P:000096 469958            ADD     Y0,B      X:<SBRD,Y0              ;     of words in the string
389       P:000097 P:000097 200058            ADD     Y0,B                              ; Add source board's header, set Y1 for abov
e
390       P:000098 P:000098 000000            NOP
391       P:000099 P:000099 575B00            MOVE              B,X:(R3)+               ; Put the new header on the transmitter stac
k
392       P:00009A P:00009A 475B00            MOVE              Y1,X:(R3)+              ; Put the argument on the transmitter stack
393       P:00009B P:00009B 570500            MOVE              B,X:<HEADER
394       P:00009C P:00009C 0C006B            JMP     <RD_COM                           ; Decide where to send the reply, and do it
395    
396                                 ; Transmit words to the host computer over the fiber optics link
397       P:00009D P:00009D 63F400  FO_XMT    MOVE              #COM_BUF,R3
                            000007
398       P:00009F P:00009F 060600            DO      X:<NWORDS,DON_FFO                 ; Transmit all the words in the command
                            0000A3
399       P:0000A1 P:0000A1 57DB00            MOVE              X:(R3)+,B
400       P:0000A2 P:0000A2 0D00EB            JSR     <XMT_WRD
401       P:0000A3 P:0000A3 000000            NOP
402       P:0000A4 P:0000A4 0C0054  DON_FFO   JMP     <START
403    
404                                 ; Check for commands from the fiber optic FIFO and the utility board (SCI)
405       P:0000A5 P:0000A5 0D00A9  GET_RCV   JSR     <CHK_FO                           ; Check for fiber optic command from FIFO
406       P:0000A6 P:0000A6 0E80A8            JCS     <RCV_RTS                          ; If there's a command, check the header
407       P:0000A7 P:0000A7 0D00D5            JSR     <CHK_SCI                          ; Check for an SCI command
408       P:0000A8 P:0000A8 00000C  RCV_RTS   RTS
409    
410                                 ; Because of FIFO metastability require that EF be stable for two tests
411       P:0000A9 P:0000A9 0A8989  CHK_FO    JCLR    #EF,X:HDR,TST2                    ; EF = Low,  Low  => CLR SR, return
                            0000AC
412       P:0000AB P:0000AB 0C00AF            JMP     <TST3                             ;      High, Low  => try again
413       P:0000AC P:0000AC 0A8989  TST2      JCLR    #EF,X:HDR,CLR_CC                  ;      Low,  High => try again
                            0000D1
414       P:0000AE P:0000AE 0C00A9            JMP     <CHK_FO                           ;      High, High => read FIFO
415       P:0000AF P:0000AF 0A8989  TST3      JCLR    #EF,X:HDR,CHK_FO
                            0000A9
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 8



416    
417       P:0000B1 P:0000B1 08F4BB            MOVEP             #$028FE2,X:BCR          ; Slow down RDFO access
                            028FE2
418       P:0000B3 P:0000B3 000000            NOP
419       P:0000B4 P:0000B4 000000            NOP
420       P:0000B5 P:0000B5 5FF000            MOVE                          Y:RDFO,B
                            FFFFF1
421       P:0000B7 P:0000B7 2B0000            MOVE              #0,B2
422       P:0000B8 P:0000B8 0140CE            AND     #$FF,B
                            0000FF
423       P:0000BA P:0000BA 0140CD            CMP     #>$AC,B                           ; It must be $AC to be a valid word
                            0000AC
424       P:0000BC P:0000BC 0E20D1            JNE     <CLR_CC
425       P:0000BD P:0000BD 4EF000            MOVE                          Y:RDFO,Y0   ; Read the MS byte
                            FFFFF1
426       P:0000BF P:0000BF 0C1951            INSERT  #$008010,Y0,B
                            008010
427       P:0000C1 P:0000C1 4EF000            MOVE                          Y:RDFO,Y0   ; Read the middle byte
                            FFFFF1
428       P:0000C3 P:0000C3 0C1951            INSERT  #$008008,Y0,B
                            008008
429       P:0000C5 P:0000C5 4EF000            MOVE                          Y:RDFO,Y0   ; Read the LS byte
                            FFFFF1
430       P:0000C7 P:0000C7 0C1951            INSERT  #$008000,Y0,B
                            008000
431       P:0000C9 P:0000C9 000000            NOP
432       P:0000CA P:0000CA 516300            MOVE              B0,X:(R3)               ; Put the word into COM_BUF
433       P:0000CB P:0000CB 0A0000            BCLR    #ST_RCV,X:<STATUS                 ; Its a command from the host computer
434       P:0000CC P:0000CC 000000  SET_CC    NOP
435       P:0000CD P:0000CD 0AF960            BSET    #0,SR                             ; Valid word => SR carry bit = 1
436       P:0000CE P:0000CE 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
437       P:0000D0 P:0000D0 00000C            RTS
438       P:0000D1 P:0000D1 0AF940  CLR_CC    BCLR    #0,SR                             ; Not valid word => SR carry bit = 0
439       P:0000D2 P:0000D2 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
440       P:0000D4 P:0000D4 00000C            RTS
441    
442                                 ; Test the SCI (= synchronous communications interface) for new words
443       P:0000D5 P:0000D5 44F000  CHK_SCI   MOVE              X:(SCI_TABLE+33),X0
                            000421
444       P:0000D7 P:0000D7 228E00            MOVE              R4,A
445       P:0000D8 P:0000D8 209000            MOVE              X0,R0
446       P:0000D9 P:0000D9 200045            CMP     X0,A
447       P:0000DA P:0000DA 0EA0D1            JEQ     <CLR_CC                           ; There is no new SCI word
448       P:0000DB P:0000DB 44D800            MOVE              X:(R0)+,X0
449       P:0000DC P:0000DC 446300            MOVE              X0,X:(R3)
450       P:0000DD P:0000DD 220E00            MOVE              R0,A
451       P:0000DE P:0000DE 0140C5            CMP     #(SCI_TABLE+32),A                 ; Wrap it around the circular
                            000420
452       P:0000E0 P:0000E0 0EA0E4            JEQ     <INIT_PROCESSED_SCI               ;   buffer boundary
453       P:0000E1 P:0000E1 547000            MOVE              A1,X:(SCI_TABLE+33)
                            000421
454       P:0000E3 P:0000E3 0C00E9            JMP     <SCI_END
455                                 INIT_PROCESSED_SCI
456       P:0000E4 P:0000E4 56F400            MOVE              #SCI_TABLE,A
                            000400
457       P:0000E6 P:0000E6 000000            NOP
458       P:0000E7 P:0000E7 567000            MOVE              A,X:(SCI_TABLE+33)
                            000421
459       P:0000E9 P:0000E9 0A0020  SCI_END   BSET    #ST_RCV,X:<STATUS                 ; Its a utility board (SCI) word
460       P:0000EA P:0000EA 0C00CC            JMP     <SET_CC
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 9



461    
462                                 ; Transmit the word in B1 to the host computer over the fiber optic data link
463                                 XMT_WRD
464       P:0000EB P:0000EB 08F4BB            MOVEP             #$028FE2,X:BCR          ; Slow down RDFO access
                            028FE2
465       P:0000ED P:0000ED 60F400            MOVE              #FO_HDR+1,R0
                            000002
466       P:0000EF P:0000EF 060380            DO      #3,XMT_WRD1
                            0000F3
467       P:0000F1 P:0000F1 0C1D91            ASL     #8,B,B
468       P:0000F2 P:0000F2 000000            NOP
469       P:0000F3 P:0000F3 535800            MOVE              B2,X:(R0)+
470                                 XMT_WRD1
471       P:0000F4 P:0000F4 60F400            MOVE              #FO_HDR,R0
                            000001
472       P:0000F6 P:0000F6 61F400            MOVE              #WRFO,R1
                            FFFFF2
473       P:0000F8 P:0000F8 060480            DO      #4,XMT_WRD2
                            0000FB
474       P:0000FA P:0000FA 46D800            MOVE              X:(R0)+,Y0              ; Should be MOVEP  X:(R0)+,Y:WRFO
475       P:0000FB P:0000FB 4E6100            MOVE                          Y0,Y:(R1)
476                                 XMT_WRD2
477       P:0000FC P:0000FC 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
478       P:0000FE P:0000FE 00000C            RTS
479    
480                                 ; Check the command or reply header in X:(R3) for self-consistency
481       P:0000FF P:0000FF 46E300  CHK_HDR   MOVE              X:(R3),Y0
482       P:000100 P:000100 579600            MOVE              X:<MASK1,B              ; Test for S.LE.3 and D.LE.3 and N.LE.7
483       P:000101 P:000101 20005E            AND     Y0,B
484       P:000102 P:000102 0E208D            JNE     <ERROR                            ; Test failed
485       P:000103 P:000103 579700            MOVE              X:<MASK2,B              ; Test for either S.NE.0 or D.NE.0
486       P:000104 P:000104 20005E            AND     Y0,B
487       P:000105 P:000105 0EA08D            JEQ     <ERROR                            ; Test failed
488       P:000106 P:000106 579500            MOVE              X:<SEVEN,B
489       P:000107 P:000107 20005E            AND     Y0,B                              ; Extract NWORDS, must be > 0
490       P:000108 P:000108 0EA08D            JEQ     <ERROR
491       P:000109 P:000109 44E300            MOVE              X:(R3),X0
492       P:00010A P:00010A 440500            MOVE              X0,X:<HEADER            ; Its a correct header
493       P:00010B P:00010B 550600            MOVE              B1,X:<NWORDS            ; Number of words in the command
494       P:00010C P:00010C 0C005E            JMP     <PR_RCV
495    
496                                 ;  *****************  Boot Commands  *******************
497    
498                                 ; Test Data Link - simply return value received after 'TDL'
499       P:00010D P:00010D 47DB00  TDL       MOVE              X:(R3)+,Y1              ; Get the data value
500       P:00010E P:00010E 0C0090            JMP     <FINISH1                          ; Return from executing TDL command
501    
502                                 ; Read DSP or EEPROM memory ('RDM' address): read memory, reply with value
503       P:00010F P:00010F 47DB00  RDMEM     MOVE              X:(R3)+,Y1
504       P:000110 P:000110 20EF00            MOVE              Y1,B
505       P:000111 P:000111 0140CE            AND     #$0FFFFF,B                        ; Bits 23-20 need to be zeroed
                            0FFFFF
506       P:000113 P:000113 21B000            MOVE              B1,R0                   ; Need the address in an address register
507       P:000114 P:000114 20EF00            MOVE              Y1,B
508       P:000115 P:000115 000000            NOP
509       P:000116 P:000116 0ACF14            JCLR    #20,B,RDX                         ; Test address bit for Program memory
                            00011A
510       P:000118 P:000118 07E087            MOVE              P:(R0),Y1               ; Read from Program Memory
511       P:000119 P:000119 0C0090            JMP     <FINISH1                          ; Send out a header with the value
512       P:00011A P:00011A 0ACF15  RDX       JCLR    #21,B,RDY                         ; Test address bit for X: memory
                            00011E
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 10



513       P:00011C P:00011C 47E000            MOVE              X:(R0),Y1               ; Write to X data memory
514       P:00011D P:00011D 0C0090            JMP     <FINISH1                          ; Send out a header with the value
515       P:00011E P:00011E 0ACF16  RDY       JCLR    #22,B,RDR                         ; Test address bit for Y: memory
                            000122
516       P:000120 P:000120 4FE000            MOVE                          Y:(R0),Y1   ; Read from Y data memory
517       P:000121 P:000121 0C0090            JMP     <FINISH1                          ; Send out a header with the value
518       P:000122 P:000122 0ACF17  RDR       JCLR    #23,B,ERROR                       ; Test address bit for read from EEPROM memo
ry
                            00008D
519       P:000124 P:000124 479400            MOVE              X:<THREE,Y1             ; Convert to word address to a byte address
520       P:000125 P:000125 220600            MOVE              R0,Y0                   ; Get 16-bit address in a data register
521       P:000126 P:000126 2000B8            MPY     Y0,Y1,B                           ; Multiply
522       P:000127 P:000127 20002A            ASR     B                                 ; Eliminate zero fill of fractional multiply
523       P:000128 P:000128 213000            MOVE              B0,R0                   ; Need to address memory
524       P:000129 P:000129 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
525       P:00012A P:00012A 0D0178            JSR     <RD_WORD                          ; Read word from EEPROM
526       P:00012B P:00012B 21A700            MOVE              B1,Y1                   ; FINISH1 transmits Y1 as its reply
527       P:00012C P:00012C 0C0090            JMP     <FINISH1
528    
529                                 ; Program WRMEM ('WRM' address datum): write to memory, reply 'DON'.
530       P:00012D P:00012D 47DB00  WRMEM     MOVE              X:(R3)+,Y1              ; Get the address to be written to
531       P:00012E P:00012E 20EF00            MOVE              Y1,B
532       P:00012F P:00012F 0140CE            AND     #$0FFFFF,B                        ; Bits 23-20 need to be zeroed
                            0FFFFF
533       P:000131 P:000131 21B000            MOVE              B1,R0                   ; Need the address in an address register
534       P:000132 P:000132 20EF00            MOVE              Y1,B
535       P:000133 P:000133 46DB00            MOVE              X:(R3)+,Y0              ; Get datum into Y0 so MOVE works easily
536       P:000134 P:000134 0ACF14            JCLR    #20,B,WRX                         ; Test address bit for Program memory
                            000138
537       P:000136 P:000136 076086            MOVE              Y0,P:(R0)               ; Write to Program memory
538       P:000137 P:000137 0C008F            JMP     <FINISH
539       P:000138 P:000138 0ACF15  WRX       JCLR    #21,B,WRY                         ; Test address bit for X: memory
                            00013C
540       P:00013A P:00013A 466000            MOVE              Y0,X:(R0)               ; Write to X: memory
541       P:00013B P:00013B 0C008F            JMP     <FINISH
542       P:00013C P:00013C 0ACF16  WRY       JCLR    #22,B,WRR                         ; Test address bit for Y: memory
                            000140
543       P:00013E P:00013E 4E6000            MOVE                          Y0,Y:(R0)   ; Write to Y: memory
544       P:00013F P:00013F 0C008F            JMP     <FINISH
545       P:000140 P:000140 0ACF17  WRR       JCLR    #23,B,ERROR                       ; Test address bit for write to EEPROM
                            00008D
546       P:000142 P:000142 013D02            BCLR    #WRENA,X:PDRC                     ; WR_ENA* = 0 to enable EEPROM writing
547       P:000143 P:000143 460E00            MOVE              Y0,X:<SV_A1             ; Save the datum to be written
548       P:000144 P:000144 479400            MOVE              X:<THREE,Y1             ; Convert word address to a byte address
549       P:000145 P:000145 220600            MOVE              R0,Y0                   ; Get 16-bit address in a data register
550       P:000146 P:000146 2000B8            MPY     Y1,Y0,B                           ; Multiply
551       P:000147 P:000147 20002A            ASR     B                                 ; Eliminate zero fill of fractional multiply
552       P:000148 P:000148 213000            MOVE              B0,R0                   ; Need to address memory
553       P:000149 P:000149 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
554       P:00014A P:00014A 558E00            MOVE              X:<SV_A1,B1             ; Get the datum to be written
555       P:00014B P:00014B 060380            DO      #3,L1WRR                          ; Loop over three bytes of the word
                            000154
556       P:00014D P:00014D 07588D            MOVE              B1,P:(R0)+              ; Write each EEPROM byte
557       P:00014E P:00014E 0C1C91            ASR     #8,B,B
558       P:00014F P:00014F 469E00            MOVE              X:<C100K,Y0             ; Move right one byte, enter delay = 1 msec
559       P:000150 P:000150 06C600            DO      Y0,L2WRR                          ; Delay by 12 milliseconds for EEPROM write
                            000153
560       P:000152 P:000152 060CA0            REP     #12                               ; Assume 100 MHz DSP56303
561       P:000153 P:000153 000000            NOP
562                                 L2WRR
563       P:000154 P:000154 000000            NOP                                       ; DO loop nesting restriction
564                                 L1WRR
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 11



565       P:000155 P:000155 013D22            BSET    #WRENA,X:PDRC                     ; WR_ENA* = 1 to disable EEPROM writing
566       P:000156 P:000156 0C008F            JMP     <FINISH
567    
568                                 ; Load application code from P: memory into its proper locations
569       P:000157 P:000157 47DB00  LDAPPL    MOVE              X:(R3)+,Y1              ; Application number, not used yet
570       P:000158 P:000158 0D015A            JSR     <LOAD_APPLICATION
571       P:000159 P:000159 0C008F            JMP     <FINISH
572    
573                                 LOAD_APPLICATION
574       P:00015A P:00015A 60F400            MOVE              #$8000,R0               ; Starting EEPROM address
                            008000
575       P:00015C P:00015C 0D0178            JSR     <RD_WORD                          ; Number of words in boot code
576       P:00015D P:00015D 21A600            MOVE              B1,Y0
577       P:00015E P:00015E 479400            MOVE              X:<THREE,Y1
578       P:00015F P:00015F 2000B8            MPY     Y0,Y1,B
579       P:000160 P:000160 20002A            ASR     B
580       P:000161 P:000161 213000            MOVE              B0,R0                   ; EEPROM address of start of P: application
581       P:000162 P:000162 0AD06F            BSET    #15,R0                            ; To access EEPROM
582       P:000163 P:000163 0D0178            JSR     <RD_WORD                          ; Read number of words in application P:
583       P:000164 P:000164 61F400            MOVE              #(X_BOOT_START+1),R1    ; End of boot P: code that needs keeping
                            00022B
584       P:000166 P:000166 06CD00            DO      B1,RD_APPL_P
                            000169
585       P:000168 P:000168 0D0178            JSR     <RD_WORD
586       P:000169 P:000169 07598D            MOVE              B1,P:(R1)+
587                                 RD_APPL_P
588       P:00016A P:00016A 0D0178            JSR     <RD_WORD                          ; Read number of words in application X:
589       P:00016B P:00016B 61F400            MOVE              #END_COMMAND_TABLE,R1
                            000036
590       P:00016D P:00016D 06CD00            DO      B1,RD_APPL_X
                            000170
591       P:00016F P:00016F 0D0178            JSR     <RD_WORD
592       P:000170 P:000170 555900            MOVE              B1,X:(R1)+
593                                 RD_APPL_X
594       P:000171 P:000171 0D0178            JSR     <RD_WORD                          ; Read number of words in application Y:
595       P:000172 P:000172 310100            MOVE              #1,R1                   ; There is no Y: memory in the boot code
596       P:000173 P:000173 06CD00            DO      B1,RD_APPL_Y
                            000176
597       P:000175 P:000175 0D0178            JSR     <RD_WORD
598       P:000176 P:000176 5D5900            MOVE                          B1,Y:(R1)+
599                                 RD_APPL_Y
600       P:000177 P:000177 00000C            RTS
601    
602                                 ; Read one word from EEPROM location R0 into accumulator B1
603       P:000178 P:000178 060380  RD_WORD   DO      #3,L_RDBYTE
                            00017B
604       P:00017A P:00017A 07D88B            MOVE              P:(R0)+,B2
605       P:00017B P:00017B 0C1C91            ASR     #8,B,B
606                                 L_RDBYTE
607       P:00017C P:00017C 00000C            RTS
608    
609                                 ; Come to here on a 'STP' command so 'DON' can be sent
610                                 STOP_IDLE_CLOCKING
611       P:00017D P:00017D 305A00            MOVE              #<TST_RCV,R0            ; Execution address when idle => when not
612       P:00017E P:00017E 601F00            MOVE              R0,X:<IDL_ADR           ;   processing commands or reading out
613       P:00017F P:00017F 0A0002            BCLR    #IDLMODE,X:<STATUS                ; Don't idle after readout
614       P:000180 P:000180 0C008F            JMP     <FINISH
615    
616                                 ; Routines executed after the DSP boots and initializes
617       P:000181 P:000181 305A00  STARTUP   MOVE              #<TST_RCV,R0            ; Execution address when idle => when not
618       P:000182 P:000182 601F00            MOVE              R0,X:<IDL_ADR           ;   processing commands or reading out
619       P:000183 P:000183 44F400            MOVE              #50000,X0               ; Delay by 500 milliseconds
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 12



                            00C350
620       P:000185 P:000185 06C400            DO      X0,L_DELAY
                            000188
621       P:000187 P:000187 06E8A3            REP     #1000
622       P:000188 P:000188 000000            NOP
623                                 L_DELAY
624       P:000189 P:000189 57F400            MOVE              #$020002,B              ; Normal reply after booting is 'SYR'
                            020002
625       P:00018B P:00018B 0D00EB            JSR     <XMT_WRD
626       P:00018C P:00018C 57F400            MOVE              #'SYR',B
                            535952
627       P:00018E P:00018E 0D00EB            JSR     <XMT_WRD
628    
629       P:00018F P:00018F 0C0054            JMP     <START                            ; Start normal command processing
630    
631                                 ; *******************  DSP  INITIALIZATION  CODE  **********************
632                                 ; This code initializes the DSP right after booting, and is overwritten
633                                 ;   by application code
634       P:000190 P:000190 08F4BD  INIT      MOVEP             #PLL_INIT,X:PCTL        ; Initialize PLL to 100 MHz
                            050003
635       P:000192 P:000192 000000            NOP
636    
637                                 ; Set operation mode register OMR to normal expanded
638       P:000193 P:000193 0500BA            MOVEC             #$0000,OMR              ; Operating Mode Register = Normal Expanded
639       P:000194 P:000194 0500BB            MOVEC             #0,SP                   ; Reset the Stack Pointer SP
640    
641                                 ; Program the AA = address attribute pins
642       P:000195 P:000195 08F4B9            MOVEP             #$FFFC21,X:AAR0         ; Y = $FFF000 to $FFFFFF asserts commands
                            FFFC21
643       P:000197 P:000197 08F4B8            MOVEP             #$008909,X:AAR1         ; P = $008000 to $00FFFF accesses the EEPROM
                            008909
644       P:000199 P:000199 08F4B7            MOVEP             #$010C11,X:AAR2         ; X = $010000 to $010FFF reads A/D values
                            010C11
645       P:00019B P:00019B 08F4B6            MOVEP             #$080621,X:AAR3         ; Y = $080000 to $0BFFFF R/W from SRAM
                            080621
646    
647       P:00019D P:00019D 0A0F00            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
648       P:00019E P:00019E 0A0F02            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
649       P:00019F P:00019F 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                            00000F
650    
651                                 ; Program the DRAM memory access and addressing
652       P:0001A1 P:0001A1 08F4BB            MOVEP             #$028FE1,X:BCR          ; Bus Control Register
                            028FE1
653    
654                                 ; Program the Host port B for parallel I/O
655       P:0001A3 P:0001A3 08F484            MOVEP             #>1,X:HPCR              ; All pins enabled as GPIO
                            000001
656       P:0001A5 P:0001A5 08F489            MOVEP             #$810C,X:HDR
                            00810C
657       P:0001A7 P:0001A7 08F488            MOVEP             #$B10E,X:HDDR           ; Data Direction Register
                            00B10E
658                                                                                     ;  (1 for Output, 0 for Input)
659    
660                                 ; Port B conversion from software bits to schematic labels
661                                 ;       PB0 = PWROK             PB08 = PRSFIFO*
662                                 ;       PB1 = LED1              PB09 = EF*
663                                 ;       PB2 = LVEN              PB10 = EXT-IN0
664                                 ;       PB3 = HVEN              PB11 = EXT-IN1
665                                 ;       PB4 = STATUS0           PB12 = EXT-OUT0
666                                 ;       PB5 = STATUS1           PB13 = EXT-OUT1
667                                 ;       PB6 = STATUS2           PB14 = SSFHF*
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 13



668                                 ;       PB7 = STATUS3           PB15 = SELSCI
669    
670                                 ; Program the serial port ESSI0 = Port C for serial communication with
671                                 ;   the utility board
672       P:0001A9 P:0001A9 07F43F            MOVEP             #>0,X:PCRC              ; Software reset of ESSI0
                            000000
673       P:0001AB P:0001AB 07F435            MOVEP             #$180809,X:CRA0         ; Divide 100 MHz by 20 to get 5.0 MHz
                            180809
674                                                                                     ; DC[4:0] = 0 for non-network operation
675                                                                                     ; WL0-WL2 = 3 for 24-bit data words
676                                                                                     ; SSC1 = 0 for SC1 not used
677       P:0001AD P:0001AD 07F436            MOVEP             #$020020,X:CRB0         ; SCKD = 1 for internally generated clock
                            020020
678                                                                                     ; SCD2 = 0 so frame sync SC2 is an output
679                                                                                     ; SHFD = 0 for MSB shifted first
680                                                                                     ; FSL = 0, frame sync length not used
681                                                                                     ; CKP = 0 for rising clock edge transitions
682                                                                                     ; SYN = 0 for asynchronous
683                                                                                     ; TE0 = 1 to enable transmitter #0
684                                                                                     ; MOD = 0 for normal, non-networked mode
685                                                                                     ; TE0 = 0 to NOT enable transmitter #0 yet
686                                                                                     ; RE = 1 to enable receiver
687       P:0001AF P:0001AF 07F43F            MOVEP             #%111001,X:PCRC         ; Control Register (0 for GPIO, 1 for ESSI)
                            000039
688       P:0001B1 P:0001B1 07F43E            MOVEP             #%000110,X:PRRC         ; Data Direction Register (0 for In, 1 for O
ut)
                            000006
689       P:0001B3 P:0001B3 07F43D            MOVEP             #%000100,X:PDRC         ; Data Register - WR_ENA* = 1
                            000004
690    
691                                 ; Port C version = Analog boards
692                                 ;       MOVEP   #$000809,X:CRA0 ; Divide 100 MHz by 20 to get 5.0 MHz
693                                 ;       MOVEP   #$000030,X:CRB0 ; SCKD = 1 for internally generated clock
694                                 ;       MOVEP   #%100000,X:PCRC ; Control Register (0 for GPIO, 1 for ESSI)
695                                 ;       MOVEP   #%000100,X:PRRC ; Data Direction Register (0 for In, 1 for Out)
696                                 ;       MOVEP   #%000000,X:PDRC ; Data Register: 'not used' = 0 outputs
697    
698       P:0001B5 P:0001B5 07F43C            MOVEP             #0,X:TX00               ; Initialize the transmitter to zero
                            000000
699       P:0001B7 P:0001B7 000000            NOP
700       P:0001B8 P:0001B8 000000            NOP
701       P:0001B9 P:0001B9 013630            BSET    #TE,X:CRB0                        ; Enable the SSI transmitter
702    
703                                 ; Conversion from software bits to schematic labels for Port C
704                                 ;       PC0 = SC00 = UTL-T-SCK
705                                 ;       PC1 = SC01 = 2_XMT = SYNC on prototype
706                                 ;       PC2 = SC02 = WR_ENA*
707                                 ;       PC3 = SCK0 = TIM-U-SCK
708                                 ;       PC4 = SRD0 = UTL-T-STD
709                                 ;       PC5 = STD0 = TIM-U-STD
710    
711                                 ; Program the serial port ESSI1 = Port D for serial transmission to
712                                 ;   the analog boards and two parallel I/O input pins
713       P:0001BA P:0001BA 07F42F            MOVEP             #>0,X:PCRD              ; Software reset of ESSI0
                            000000
714       P:0001BC P:0001BC 07F425            MOVEP             #$000809,X:CRA1         ; Divide 100 MHz by 20 to get 5.0 MHz
                            000809
715                                                                                     ; DC[4:0] = 0
716                                                                                     ; WL[2:0] = ALC = 0 for 8-bit data words
717                                                                                     ; SSC1 = 0 for SC1 not used
718       P:0001BE P:0001BE 07F426            MOVEP             #$000030,X:CRB1         ; SCKD = 1 for internally generated clock
                            000030
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 14



719                                                                                     ; SCD2 = 1 so frame sync SC2 is an output
720                                                                                     ; SHFD = 0 for MSB shifted first
721                                                                                     ; CKP = 0 for rising clock edge transitions
722                                                                                     ; TE0 = 0 to NOT enable transmitter #0 yet
723                                                                                     ; MOD = 0 so its not networked mode
724       P:0001C0 P:0001C0 07F42F            MOVEP             #%100000,X:PCRD         ; Control Register (0 for GPIO, 1 for ESSI)
                            000020
725                                                                                     ; PD3 = SCK1, PD5 = STD1 for ESSI
726       P:0001C2 P:0001C2 07F42E            MOVEP             #%000100,X:PRRD         ; Data Direction Register (0 for In, 1 for O
ut)
                            000004
727       P:0001C4 P:0001C4 07F42D            MOVEP             #%000100,X:PDRD         ; Data Register: 'not used' = 0 outputs
                            000004
728       P:0001C6 P:0001C6 07F42C            MOVEP             #0,X:TX10               ; Initialize the transmitter to zero
                            000000
729       P:0001C8 P:0001C8 000000            NOP
730       P:0001C9 P:0001C9 000000            NOP
731       P:0001CA P:0001CA 012630            BSET    #TE,X:CRB1                        ; Enable the SSI transmitter
732    
733                                 ; Conversion from software bits to schematic labels for Port D
734                                 ; PD0 = SC10 = 2_XMT_? input
735                                 ; PD1 = SC11 = SSFEF* input
736                                 ; PD2 = SC12 = PWR_EN
737                                 ; PD3 = SCK1 = TIM-A-SCK
738                                 ; PD4 = SRD1 = PWRRST
739                                 ; PD5 = STD1 = TIM-A-STD
740    
741                                 ; Program the SCI port to communicate with the utility board
742       P:0001CB P:0001CB 07F41C            MOVEP             #$0B04,X:SCR            ; SCI programming: 11-bit asynchronous
                            000B04
743                                                                                     ;   protocol (1 start, 8 data, 1 even parity
,
744                                                                                     ;   1 stop); LSB before MSB; enable receiver
745                                                                                     ;   and its interrupts; transmitter interrup
ts
746                                                                                     ;   disabled.
747       P:0001CD P:0001CD 07F41B            MOVEP             #$0003,X:SCCR           ; SCI clock: utility board data rate =
                            000003
748                                                                                     ;   (390,625 kbits/sec); internal clock.
749       P:0001CF P:0001CF 07F41F            MOVEP             #%011,X:PCRE            ; Port Control Register = RXD, TXD enabled
                            000003
750       P:0001D1 P:0001D1 07F41E            MOVEP             #%000,X:PRRE            ; Port Direction Register (0 = Input)
                            000000
751    
752                                 ;       PE0 = RXD
753                                 ;       PE1 = TXD
754                                 ;       PE2 = SCLK
755    
756                                 ; Program one of the three timers as an exposure timer
757       P:0001D3 P:0001D3 07F403            MOVEP             #$C34F,X:TPLR           ; Prescaler to generate millisecond timer,
                            00C34F
758                                                                                     ;  counting from the system clock / 2 = 50 M
Hz
759       P:0001D5 P:0001D5 07F40F            MOVEP             #$208200,X:TCSR0        ; Clear timer complete bit and enable presca
ler
                            208200
760       P:0001D7 P:0001D7 07F40E            MOVEP             #0,X:TLR0               ; Timer load register
                            000000
761    
762                                 ; Enable interrupts for the SCI port only
763       P:0001D9 P:0001D9 08F4BF            MOVEP             #$000000,X:IPRC         ; No interrupts allowed
                            000000
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 15



764       P:0001DB P:0001DB 08F4BE            MOVEP             #>$80,X:IPRP            ; Enable SCI interrupt only, IPR = 1
                            000080
765       P:0001DD P:0001DD 00FCB8            ANDI    #$FC,MR                           ; Unmask all interrupt levels
766    
767                                 ; Initialize the fiber optic serial receiver circuitry
768       P:0001DE P:0001DE 061480            DO      #20,L_FO_INIT
                            0001E3
769       P:0001E0 P:0001E0 5FF000            MOVE                          Y:RDFO,B
                            FFFFF1
770       P:0001E2 P:0001E2 0605A0            REP     #5
771       P:0001E3 P:0001E3 000000            NOP
772                                 L_FO_INIT
773    
774                                 ; Pulse PRSFIFO* low to revive the CMDRST* instruction and reset the FIFO
775       P:0001E4 P:0001E4 44F400            MOVE              #1000000,X0             ; Delay by 10 milliseconds
                            0F4240
776       P:0001E6 P:0001E6 06C400            DO      X0,*+3
                            0001E8
777       P:0001E8 P:0001E8 000000            NOP
778       P:0001E9 P:0001E9 0A8908            BCLR    #8,X:HDR
779       P:0001EA P:0001EA 0614A0            REP     #20
780       P:0001EB P:0001EB 000000            NOP
781       P:0001EC P:0001EC 0A8928            BSET    #8,X:HDR
782    
783                                 ; Reset the utility board
784       P:0001ED P:0001ED 0A0F05            BCLR    #5,X:<LATCH
785       P:0001EE P:0001EE 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Clear reset utility board bit
                            00000F
786       P:0001F0 P:0001F0 06C8A0            REP     #200                              ; Delay by RESET* low time
787       P:0001F1 P:0001F1 000000            NOP
788       P:0001F2 P:0001F2 0A0F25            BSET    #5,X:<LATCH
789       P:0001F3 P:0001F3 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Clear reset utility board bit
                            00000F
790       P:0001F5 P:0001F5 56F400            MOVE              #200000,A               ; Delay 2 msec for utility boot
                            030D40
791       P:0001F7 P:0001F7 06CE00            DO      A,*+3
                            0001F9
792       P:0001F9 P:0001F9 000000            NOP
793    
794                                 ; Put all the analog switch inputs to low so they draw minimum current
795       P:0001FA P:0001FA 012F23            BSET    #3,X:PCRD                         ; Turn the serial clock on
796       P:0001FB P:0001FB 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                            0C3000
797       P:0001FD P:0001FD 20001B            CLR     B
798       P:0001FE P:0001FE 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC write
s
799       P:0001FF P:0001FF 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writ
es
                            001000
800       P:000201 P:000201 060F80            DO      #15,L_ANALOG                      ; Fifteen video processor boards maximum
                            000209
801       P:000203 P:000203 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
802       P:000204 P:000204 200040            ADD     X0,A
803       P:000205 P:000205 5F7000            MOVE                          B,Y:WRSS    ; This is for the fast analog switches
                            FFFFF3
804       P:000207 P:000207 0620A3            REP     #800                              ; Delay for the serial data transmission
805       P:000208 P:000208 000000            NOP
806       P:000209 P:000209 200068            ADD     X1,B                              ; Increment the video and clock driver numbe
rs
807                                 L_ANALOG
808       P:00020A P:00020A 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
809       P:00020B P:00020B 0C0223            JMP     <SKIP
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 16



810    
811                                 ; Transmit contents of accumulator A1 over the synchronous serial transmitter
812                                 XMIT_A_WORD
813       P:00020C P:00020C 07F42C            MOVEP             #0,X:TX10               ; This helps, don't know why
                            000000
814       P:00020E P:00020E 547000            MOVE              A1,X:SV_A1
                            00000E
815       P:000210 P:000210 000000            NOP
816       P:000211 P:000211 01A786            JCLR    #TDE,X:SSISR1,*                   ; Start bit
                            000211
817       P:000213 P:000213 07F42C            MOVEP             #$010000,X:TX10
                            010000
818       P:000215 P:000215 060380            DO      #3,L_X
                            00021B
819       P:000217 P:000217 01A786            JCLR    #TDE,X:SSISR1,*                   ; Three data bytes
                            000217
820       P:000219 P:000219 04CCCC            MOVEP             A1,X:TX10
821       P:00021A P:00021A 0C1E90            LSL     #8,A
822       P:00021B P:00021B 000000            NOP
823                                 L_X
824       P:00021C P:00021C 01A786            JCLR    #TDE,X:SSISR1,*                   ; Zeroes to bring transmitter low
                            00021C
825       P:00021E P:00021E 07F42C            MOVEP             #0,X:TX10
                            000000
826       P:000220 P:000220 54F000            MOVE              X:SV_A1,A1
                            00000E
827       P:000222 P:000222 00000C            RTS
828    
829                                 SKIP
830    
831                                 ; Set up the circular SCI buffer, 32 words in size
832       P:000223 P:000223 64F400            MOVE              #SCI_TABLE,R4
                            000400
833       P:000225 P:000225 051FA4            MOVE              #31,M4
834       P:000226 P:000226 647000            MOVE              R4,X:(SCI_TABLE+33)
                            000421
835    
836                                           IF      @SCP("HOST","ROM")
844                                           ENDIF
845    
846       P:000228 P:000228 44F400            MOVE              #>$AC,X0
                            0000AC
847       P:00022A P:00022A 440100            MOVE              X0,X:<FO_HDR
848    
849       P:00022B P:00022B 0C0181            JMP     <STARTUP
850    
851                                 ;  ****************  X: Memory tables  ********************
852    
853                                 ; Define the address in P: space where the table of constants begins
854    
855                                  X_BOOT_START
856       00022A                              EQU     @LCV(L)-2
857    
858                                           IF      @SCP("HOST","ROM")
860                                           ENDIF
861                                           IF      @SCP("HOST","HOST")
862       X:000000 X:000000                   ORG     X:0,X:0
863                                           ENDIF
864    
865                                 ; Special storage area - initialization constants and scratch space
866       X:000000 X:000000         STATUS    DC      $40004                            ; Controller status bits
867    
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 17



868       000001                    FO_HDR    EQU     STATUS+1                          ; Fiber optic write bytes
869       000005                    HEADER    EQU     FO_HDR+4                          ; Command header
870       000006                    NWORDS    EQU     HEADER+1                          ; Number of words in the command
871       000007                    COM_BUF   EQU     NWORDS+1                          ; Command buffer
872       00000E                    SV_A1     EQU     COM_BUF+7                         ; Save accumulator A1
873    
874                                           IF      @SCP("HOST","ROM")
879                                           ENDIF
880    
881                                           IF      @SCP("HOST","HOST")
882       X:00000F X:00000F                   ORG     X:$F,X:$F
883                                           ENDIF
884    
885                                 ; Parameter table in P: space to be copied into X: space during
886                                 ;   initialization, and is copied from ROM by the DSP boot
887       X:00000F X:00000F         LATCH     DC      $3A                               ; Starting value in latch chip U25
888                                  EXPOSURE_TIME
889       X:000010 X:000010                   DC      0                                 ; Exposure time in milliseconds
890                                  ELAPSED_TIME
891       X:000011 X:000011                   DC      0                                 ; Time elapsed so far in the exposure
892       X:000012 X:000012         ONE       DC      1                                 ; One
893       X:000013 X:000013         TWO       DC      2                                 ; Two
894       X:000014 X:000014         THREE     DC      3                                 ; Three
895       X:000015 X:000015         SEVEN     DC      7                                 ; Seven
896       X:000016 X:000016         MASK1     DC      $FCFCF8                           ; Mask for checking header
897       X:000017 X:000017         MASK2     DC      $030300                           ; Mask for checking header
898       X:000018 X:000018         DONE      DC      'DON'                             ; Standard reply
899       X:000019 X:000019         SBRD      DC      $020000                           ; Source Identification number
900       X:00001A X:00001A         TIM_DRB   DC      $000200                           ; Destination = timing board number
901       X:00001B X:00001B         DMASK     DC      $00FF00                           ; Mask to get destination board number
902       X:00001C X:00001C         SMASK     DC      $FF0000                           ; Mask to get source board number
903       X:00001D X:00001D         ERR       DC      'ERR'                             ; An error occurred
904       X:00001E X:00001E         C100K     DC      100000                            ; Delay for WRROM = 1 millisec
905       X:00001F X:00001F         IDL_ADR   DC      TST_RCV                           ; Address of idling routine
906       X:000020 X:000020         EXP_ADR   DC      0                                 ; Jump to this address during exposures
907    
908                                 ; Places for saving register values
909       X:000021 X:000021         SAVE_SR   DC      0                                 ; Status Register
910       X:000022 X:000022         SAVE_X1   DC      0
911       X:000023 X:000023         SAVE_A1   DC      0
912       X:000024 X:000024         SAVE_R0   DC      0
913       X:000025 X:000025         RCV_ERR   DC      0
914       X:000026 X:000026         SCI_A1    DC      0                                 ; Contents of accumulator A1 in RCV ISR
915       X:000027 X:000027         SCI_R0    DC      SRXL
916    
917                                 ; Command table
918       000028                    COM_TBL_R EQU     @LCV(R)
919       X:000028 X:000028         COM_TBL   DC      'TDL',TDL                         ; Test Data Link
920       X:00002A X:00002A                   DC      'RDM',RDMEM                       ; Read from DSP or EEPROM memory
921       X:00002C X:00002C                   DC      'WRM',WRMEM                       ; Write to DSP memory
922       X:00002E X:00002E                   DC      'LDA',LDAPPL                      ; Load application from EEPROM to DSP
923       X:000030 X:000030                   DC      'STP',STOP_IDLE_CLOCKING
924       X:000032 X:000032                   DC      'DON',START                       ; Nothing special
925       X:000034 X:000034                   DC      'ERR',START                       ; Nothing special
926    
927                                  END_COMMAND_TABLE
928       000036                              EQU     @LCV(R)
929    
930                                 ; The table at SCI_TABLE is for words received from the utility board, written by
931                                 ;   the interrupt service routine SCI_RCV. Note that it is 32 words long,
932                                 ;   hard coded, and the 33rd location contains the pointer to words that have
933                                 ;   been processed by moving them from the SCI_TABLE to the COM_BUF.
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timboot.s  Page 18



934    
935                                           IF      @SCP("HOST","ROM")
937                                           ENDIF
938    
939       000036                    END_ADR   EQU     @LCV(L)                           ; End address of P: code written to ROM
940                                           INCLUDE "timhdr.s"
941                                        COMMENT *
942    
943                                 This is a header file that has some HIPO-specific stuff in it.  It is
944                                 vastly stripped down compared to the original since most of the things in it
945                                 are now in timboot.asm.
946    
947                                 I believe that all the following stuff can be zapped out.  Comment out for now.
948    
949                                         PAGE    132     ; Printronix page width - 132 columns
950    
951                                 ; Some basic structural definitions
952                                 APL_ADR EQU     $130    ; P: memory location where application code begins
953                                 APL_LEN EQU     $200-APL_ADR ; Maximum length of application program
954    
955                                 ; CHANGING MISC_LEN FROM 0X280 TO A LARGER NUMBER BREAKS THE ROM COPY APPROACH!
956                                 ; However if all you do is download there is a lot more memory available.
957                                 MISC_LEN EQU    $450    ; Maximum length of "miscellanous" code
958                                 ;MISC_LEN EQU   $3F0    ; Maximum length of "miscellanous" code
959                                 ; MISC_LEN EQU  $280    ; Maximum length of "miscellanous" code
960    
961                                 COM_LEN EQU     $40     ; Length of memory for application commands
962                                 TIM_ISR EQU     $3C     ; DSP timer interrupt service routine address
963                                 PGM_CON EQU     $3E     ; Program continues on here
964                                 COM_TBL EQU     $80     ; Starting address of command table in X: memory
965                                 N_W_APL EQU     $500    ; Number of words in each application
966                                 NUM_COM EQU     40      ; Number of entries in command table
967    
968                                 RST_ISR EQU     $00     ; Hardware reset interrupt
969                                 ROM_ID  EQU     $06     ; Location of program Identification = SWI interrupt
970                                 START   EQU     $08     ; Starting address of program
971                                 RCV_BUF EQU     $60     ; Starting address of receiver buffer in X:
972                                 TBL_ADR EQU     $0F     ; (IR) Waveform tables starting address
973    
974                                 ROM_OFF EQU     $4000   ; Boot program offset address in EEPROM
975                                 LD_X    EQU     $4200   ; Assembler loads X: starting at this EEPROM address
976                                 RD_X    EQU     $C600   ; DSP reads X: from this EEPROM address
977    
978                                 ; Define DSP port addresses
979                                 WRSS    EQU     $FF80   ; Write clock driver and VP switch states
980                                 RDFO    EQU     $FFC0   ; Read serial receiver fiber optic contents
981                                 WRFO    EQU     $FFC0   ; Write to fiber optic serial transmitter
982                                 RDAD    EQU     $FFA0   ; Read A/D datum into DSP
983                                 RDAD0   EQU     $FFA0   ; Address for reading A/D #0
984                                 RDAD1   EQU     $FFA1   ; Address for reading A/D #1
985                                 WRLATCH EQU     $FFC1   ; Write to timing board latch
986                                 RSTWDT  EQU     $6000   ; Address to reset the timing board watchdog timer
987                                 BCR     EQU     $FFFE   ; Bus (=Port A) Control Register -> Wait States
988                                 PBC     EQU     $FFE0   ; Port B Control Register
989                                 PBDDR   EQU     $FFE2   ; Port B Data Direction Register
990                                 PBD     EQU     $FFE4   ; Port B Data Register
991                                 PCC     EQU     $FFE1   ; Port C Control Register
992                                 PCDDR   EQU     $FFE3   ; PortC Data Direction Register
993                                 PCD     EQU     $FFE5   ; Port C Data Register
994                                 IPR     EQU     $FFFF   ; Interrupt Priority Register
995                                 SSITX   EQU     $FFEF   ; SSI Transmit and Receive data register
996                                 SSIRX   EQU     $FFEF   ; SSI Transmit and Receive data register
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timhdr.s  Page 19



997                                 SSISR   EQU     $FFEE   ; SSI Status Register
998                                 CRA     EQU     $FFEC   ; SSI Control Register A
999                                 CRB     EQU     $FFED   ; SSI Control Regsiter B
1000                                TCSR    EQU     $FFDE   ; Timer control and status register
1001                                TCR     EQU     $FFDF   ; Timer count register
1002   
1003                                ; Hardware bit definitions all over the place
1004                                SSI_TDE EQU     6       ; SSI Transmitter data register empty
1005                                SSI_RDF EQU     7       ; SSI Receiver data register full
1006                                LVEN    EQU     2       ; Low voltage enable (+/-15 volt nominal)
1007                                HVEN    EQU     3       ; Enable high voltage (+32V nominal)
1008                                TIM_U_RST EQU   5       ; Timing to utility board reset bit number in U25
1009                                PWRST   EQU     13      ; Power control board reset
1010                                RST_FIFO EQU    7       ; Reset FIFO bit number in control latch U25
1011                                EF      EQU     9       ; FIFO empty flag, low true
1012                                TIM_BIT EQU     0       ; Timer status bit
1013                                WW      EQU     1       ; Word width = 1 for 16-bit image data, 0 for 24-bit
1014                                CDAC    EQU     0       ; Bit number in U25 for clearing DACs
1015                                ENCK    EQU     2       ; Bit number in U25 for enabling analog switches
1016                                DUALCLK EQU     1       ; Set to clock two halves of clock driver board together
1017   
1018                                ; Software status bits, defined at X:<STATUS = X:0
1019                                ST_RCV  EQU     0       ; Set if FO, cleared if SSI
1020                                TST_IMG EQU     10      ; Set if controller is to generate a test image
1021                                SHUT    EQU     11      ; Set if opening shutter at beginning of exposure
1022   
1023                                IDLMODE EQU     2       ; Set if need to idle after readout
1024                                ST_SHUT EQU     3       ; Set to indicate shutter is closed, clear for open
1025                                ST_RDC  EQU     4       ; Set if executing 'RDC' command - reading out
1026                                SPLIT_S EQU     5       ; Set if split serial
1027                                SPLIT_P EQU     6       ; Set if split parallel
1028                                MPP     EQU     7       ; Set if parallels are in MPP mode
1029   
1030                                END OF COMMENT HERE
1031                                        *
1032                                ; additional X:<STATUS bits
1033                                ; NOTE
1034                                ; NOTE
1035                                ; the NOT_CLR, and MPP X:<STATUS bits are pre-empted.
1036      000008                    ST_ABRT   EQU     8                                 ; Set if an abort (readout or exp) in progre
ss
1037      000007                    ST_EXP    EQU     7                                 ; Set if presently in EXPOSE or waiting for 
trigger
1038      00000A                    ST_SBFAIL EQU     10                                ; LATCHED if SETBIAS dac table bad
1039   
1040   
1041                                ; move IMGVAR down to $80 as per Confluence July 1 #1
1042                                ;IMGVAR_ADR EQU $100            ;  Special Image Mode variables Starting Address in X:
1043      000080                    IMGVAR_ADR EQU    $80                               ;  Special Image Mode variables Starting Add
ress in X:
1044   
1045                                ; Additional software status bit, defined at X:<STATUS = X:0
1046      000008                    TRIGGER   EQU     8                                 ; Set if a Hardware triggered exposure
1047   
1048                                ; add these HDR (port B) bits for thermo cool statuses
1049      000004                    STS0      EQU     4                                 ; STATUS 0, thermocool
1050      000005                    STS1      EQU     5                                 ; STATUS 1, thermocool
1051   
1052                                ; Image mode bits, defined at X:<IMAGE_MODE
1053   
1054      000000                    FDOTS     EQU     0                                 ; Fast Dots
1055      000001                    FIND      EQU     1                                 ; Find
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timhdr.s  Page 20



1056      000002                    SDOTS     EQU     2                                 ; Slow Dots
1057      000003                    SERIES    EQU     3                                 ; Series
1058      000004                    SINGLE    EQU     4                                 ; Single
1059      000005                    STRIP     EQU     5                                 ; Stripscan
1060      000006                    F_OCC     EQU     6                                 ; Fast occultation, keep as 6 for compatibil
ity
1061      000007                    B_OCC     EQU     7                                 ; Basic occultation
1062      000008                    P_OCC     EQU     8                                 ; Pipelined occultation
1063   
1064                                ; Image Status, define at X:<ISTATUS
1065      000000                    NO_SKIP   EQU     0                                 ; Set for slow dots, fast and pipelined occu
ltation mode
1066                                                                                    ; to avoid parallel skipping to the subframe
 boundary.
1067      000001                    OPEN_CLOSE EQU    1                                 ; Set if shutter opens/closes each image
1068                                                                                    ; Clear if shutter stays open for many image
s
1069      000002                    STORAGE   EQU     2                                 ; Set if storage area is to be clocked
1070   
1071      0000C8                    MAXDACTBL EQU     200                               ; largest table for SET_DAC (to verify R0 ad
dress)
1072   
1073                                          INCLUDE "infospec.s"
1074                                ; General DSP info field specifications.
1075                                ; These values are 'addresses' and used as the argument for the INF command.
1076   
1077                                 GET_VERSION
1078      000000                              EQU     0                                 ; IVERSION field
1079      000001                    GET_FLAVOR EQU    1                                 ; IFLAVOR field
1080      000002                    GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
1081      000003                    GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
1082      000004                    GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if availabl
e)
1083                                 GET_TEMP2STS
1084      000005                              EQU     5                                 ; two bits of thermo cool status for GWAVES
1085   
1086                                          INCLUDE "timinfospec.s"
1087                                ; TIM DSP info field specifications.
1088                                ; These values are 'addresses' and used as the argument for the INF command.
1089   
1090                                 GET_CAPABLE
1091      000100                              EQU     $100                              ; ICAPABLE field (what dsp supports).
1092                                 GET_INT_TIM
1093      000101                              EQU     $101                              ; Integration time per pixel in leach units
1094                                 GET_R_DELAY
1095      000102                              EQU     $102                              ; Serial overlap in leach units
1096                                 GET_SI_DELAY
1097      000103                              EQU     $103                              ; Parallel overlap in leach units
1098   
1099                                          INCLUDE "timinfo.s"
1100                                ; DSP Version
1101      04507F                    IVERSION  EQU     282751                            ; 1.5/1
1102   
1103      612020                    IFLAVOR   EQU     'a  '                             ; a
1104   
1105      003682                    ITIME0    EQU     13954                             ; lo order time: 2014 5 30  7:42:58 GMT
1106   
1107      005388                    ITIME1    EQU     21384                             ; hi order time: 2014 5 30  7:42:58 GMT
1108   
1109      000000                    ISVNREV   EQU     0                                 ; most recent code svn rev
1110   
1111                                ; this need to be defined externally due to a problem in timboot.s
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  tim.s  Page 21



1112                                ; as per Confluence, July 6, #1
1113      00005A                    EXPOSING  EQU     TST_RCV                           ; Address if exposing
1114                                 CONTINUE_READING
1115      00005A                              EQU     TST_RCV                           ; Address if reading out
1116   
1117                                ; tim capability definitions
1118                                 FINDCAPABLE
1119      000001                              EQU     1                                 ; Find exposure mode
1120                                 SNGLCAPABLE
1121      000002                              EQU     2                                 ; Single exposure mode
1122                                 SERICAPABLE
1123      000004                              EQU     4                                 ; Series exposure mode
1124                                 BASCCAPABLE
1125      000008                              EQU     8                                 ; Basic occ exposure mode
1126                                 FASTCAPABLE
1127      000010                              EQU     16                                ; Fast occ exposure mode
1128                                 PIPECAPABLE
1129      000020                              EQU     32                                ; Pipeline occ exposure mode
1130                                 FDOTCAPABLE
1131      000040                              EQU     64                                ; Fast dots exposure mode
1132                                 SDOTCAPABLE
1133      000080                              EQU     128                               ; Slow dots exposure mode
1134                                 STRPCAPABLE
1135      000100                              EQU     256                               ; Slow dots exposure mode
1136      0001C3                    TIMCAPABLE EQU    FINDCAPABLE+SNGLCAPABLE+STRPCAPABLE+FDOTCAPABLE+SDOTCAPABLE
1137   
1138      P:00022C P:00022C                   ORG     P:,P:
1139   
1140                                ; Remove SHUTTER_CC advertisement as per Confluence July 4 #3
1141                                ;CC     EQU     ARC22+ARC47+SHUTTER_CC+SPLIT_SERIAL+SUBARRAY+BINNING
1142      000C97                    CC        EQU     ARC22+ARC47+SUBARRAY+BINNING+SHUTTER_CC
1143   
1144                                ; Put number of words of application in P: for loading application from EEPROM
1145      P:00022C P:00022C                   DC      TIMBOOT_X_MEMORY-@LCV(L)-1
1146   
1147                                ;**************************************************************************
1148                                ;                                                                         *
1149                                ;    Permanent address register assignments                               *
1150                                ;        R1 - Address of SSI receiver contents                            *
1151                                ;        R2 - Address of SCI receiver contents                            *
1152                                ;        R3 - Pointer to current top of command buffer                    *
1153                                ;        R4 - Pointer to processed contents of command buffer             *
1154                                ;        R5 - Temporary register for processing SSI and SCI contents      *
1155                                ;        R6 - CCD clock driver address for CCD #0 = $FF80                 *
1156                                ;                It is also the A/D address of analog board #0            *
1157                                ;        R6 CURRENTLY UNUSED (geniii)
1158                                ;                                                                         *
1159                                ;    Other registers                                                      *
1160                                ;        R0, R7 - Temporary registers used all over the place.            *
1161                                ;        R5 - Can be used as a temporary register but is circular,        *
1162                                ;               modulo 32.                                                *
1163                                ;**************************************************************************
1164   
1165                                ;  ***********************   CCD  READOUT   ***********************
1166                                ; RDCCD is now a subroutine
1167                                ; Adding several CLOCK_WAITs as per Jun 29 #8.
1168                                ; CCD42-10 isn't frame transfer so comment out the part about that.
1169   
1170                                RDCCD
1171                                ;       JSET    #STORAGE,X:ISTATUS,RCCD1
1172                                ; Do the frame transfer if STORAGE==0, else skip it.
1173                                ;       MOVE    Y:<S_SIZE,X1
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  tim.s  Page 22



1174                                ;       JSR     <CLOCK_WAIT
1175                                ; mitigation attempt 2- remove ishift
1176                                ;       JSR     ISHIFT          ; Do the frame transfer
1177                                ;       JSR     <CLOCK_WAIT  ; mitigation attempt 1
1178   
1179                                ; Calculate some readout parameters.
1180                                ; This is also an alternative entry point for skipping the frame transfer
1181                                ; STORAGE also selects ganged or storage only parallels during readout
1182                                ; NO_SKIP skips over the section that parallel skips to the subframe start
1183   
1184      P:00022D P:00022D 5E9A00  RCCD1     MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1185      P:00022E P:00022E 200003            TST     A
1186      P:00022F P:00022F 0E223A            JNE     <SUB_IMG
1187      P:000230 P:000230 5C1700            MOVE                          A1,Y:<NP_SKIP ; Zero these all out.  Full frame
1188      P:000231 P:000231 5C1800            MOVE                          A1,Y:<NS_SKP1
1189      P:000232 P:000232 5C1900            MOVE                          A1,Y:<NS_SKP2
1190      P:000233 P:000233 5E8100            MOVE                          Y:<NSR,A    ; NSERIALS_READ = NSR
1191      P:000234 P:000234 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            000237
1192      P:000236 P:000236 200022            ASR     A                                 ; Split serials require / 2
1193      P:000237 P:000237 000000            NOP
1194      P:000238 P:000238 5E1100            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1195      P:000239 P:000239 0C024A            JMP     <SETUP
1196   
1197                                ; Loop over the required number of subimage boxes if NBOXES > 0
1198      P:00023A P:00023A 67F400  SUB_IMG   MOVE              #READ_TABLE,R7          ; Parameter table for subimage readout
                            00001E
1199      P:00023C P:00023C 061A40            DO      Y:<NBOXES,L_NBOXES                ; Loop over number of boxes
                            0002D3
1200      P:00023E P:00023E 4CDF00            MOVE                          Y:(R7)+,X0
1201      P:00023F P:00023F 4C1700            MOVE                          X0,Y:<NP_SKIP
1202      P:000240 P:000240 4CDF00            MOVE                          Y:(R7)+,X0
1203      P:000241 P:000241 4C1800            MOVE                          X0,Y:<NS_SKP1
1204      P:000242 P:000242 4CDF00            MOVE                          Y:(R7)+,X0
1205      P:000243 P:000243 4C1900            MOVE                          X0,Y:<NS_SKP2
1206      P:000244 P:000244 5E9C00            MOVE                          Y:<NS_READ,A
1207      P:000245 P:000245 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                            000248
1208      P:000247 P:000247 200022            ASR     A
1209      P:000248 P:000248 000000            NOP
1210      P:000249 P:000249 5E1100            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1211   
1212                                ; Calculate the fast readout parameters
1213      P:00024A P:00024A 0D03AC  SETUP     JSR     <SETUP_SUBROUTINE
1214      P:00024B P:00024B 0D04BD            JSR     <CLOCK_WAIT
1215   
1216                                ; Skip over the required number of rows for subimage readout
1217                                ; If #NO_SKIP == 0 skip rows up to first subframe, storage clocks only
1218      P:00024C P:00024C 0A20A0            JSET    #NO_SKIP,X:ISTATUS,CLR_SR
                            000259
1219      P:00024E P:00024E 5E9700            MOVE                          Y:<NP_SKIP,A ; Number of rows NP_SKIP to skip
1220      P:00024F P:00024F 200003            TST     A
1221      P:000250 P:000250 0EA259            JEQ     <CLR_SR                           ; If zero, skip this shift
1222      P:000251 P:000251 061740            DO      Y:<NP_SKIP,L_SKIP1                ; Clock number of rows to skip
                            000258
1223      P:000253 P:000253 688F00            MOVE                          Y:<IS_PAR_CLR,R0 ; SR kept clear with DG
1224      P:000254 P:000254 0A20A2            JSET    #STORAGE,X:ISTATUS,GANG_SK        ; if STORAGE == 0 store clocks only
                            000257
1225                                ;        mitigation attempt 3- don't use S_PAR_CLR (but it was a full fr test)
1226      P:000256 P:000256 689000            MOVE                          Y:<S_PAR_CLR,R0 ; SR kept clear with DG
1227                                GANG_SK
1228      P:000257 P:000257 0D02DA            JSR     <CLOCK
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  tim.s  Page 23



1229      P:000258 P:000258 000000            NOP
1230                                L_SKIP1
1231   
1232                                ; Clear out the accumulated charge from the serial shift register
1233                                ; Leave this commented-out code in until we can test it with a subframe
1234                                ; CLR_SR MOVE   #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1235                                ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1236                                ;       NOP
1237                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1238                                ;       DO      Y:<NSCLR,*+3            ; Number of waveform entries total
1239                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1240                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1241   
1242      P:000259 P:000259 60F400  CLR_SR    MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel skip
                            000244
1243      P:00025B P:00025B 0D02DA            JSR     <CLOCK
1244   
1245                                ; Parallel shift the image into the serial shift register
1246      P:00025C P:00025C 4C8200            MOVE                          Y:<NPR,X0   ; Number of rows set by host computer
1247      P:00025D P:00025D 5E9A00            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1248      P:00025E P:00025E 200003            TST     A
1249      P:00025F P:00025F 0EA261            JEQ     *+2
1250      P:000260 P:000260 4C9D00            MOVE                          Y:<NP_READ,X0 ; If NBOXES .NE. 0 use subimage table
1251   
1252                                ; Main loop over each line to be read out
1253                                ; If split parallels have to divide NPR by two to be loop counter
1254                                ; Subimages implicitly assumes that parallels are not split
1255      P:000261 P:000261 0A0086            JCLR    #SPLIT_P,X:STATUS,PLOOP           ; skip this if not split parallels
                            000268
1256      P:000263 P:000263 5EF000            MOVE                          Y:NPR,A     ; Get NPR
                            000002
1257      P:000265 P:000265 200022            ASR     A                                 ; Divide by 2
1258      P:000266 P:000266 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1259      P:000267 P:000267 21C400            MOVE              A,X0                    ; Overwrite loop counter in X0
1260   
1261                                ; Finally start the row loop
1262      P:000268 P:000268 06C400  PLOOP     DO      X0,LPR                            ; Number of rows to read out
                            0002D2
1263   
1264                                ; Check for a command once per line. Only the ABORT command is allowed
1265                                ; NOT DONE- check for ABEXP in expose only
1266                                ;       JSR     <GET_RCV                ; Was a command received?
1267                                ;       JCC     <CONTINUE_RD            ; If no, continue reading out
1268                                ; as per Confluence July 5 #7
1269                                ;       JMP     <PRC_RCV                ; If yes, go process it
1270      P:00026A P:00026A 0C0272            JMP     <CONTINUE_RD
1271   
1272                                ; Abort the readout currently underway (cmd destination)
1273                                ABR_RDC
1274      P:00026B P:00026B 200013            CLR     A
1275      P:00026C P:00026C 5EBD00            MOVE                          Y:<TESTLOC1,A
1276      P:00026D P:00026D 014180            ADD     #1,A
1277      P:00026E P:00026E 0A0028            BSET    #ST_ABRT,X:<STATUS
1278      P:00026F P:00026F 5C3D00            MOVE                          A1,Y:<TESTLOC1
1279   
1280      P:000270 P:000270 0A0084            JCLR    #ST_RDC,X:<STATUS,ABORT_EXPOSURE
                            0004FB
1281                                ; "Can't happen"
1282                                ; already in readout- so just fall thru and continue,
1283                                ; having set the ST_ABRT flag.
1284                                ; currently we just let this readout segment run to the end and
1285                                ; handle the abort in the outer xxx_PROC code- this has
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  tim.s  Page 24



1286                                ; the advantage of ending the overall exposure on a frame boundary
1287                                ; in the case of 3-d images.
1288                                ; A more abrupt ending of the RDCCD code could be arranged if needed.
1289   
1290                                ;       ENDDO                           ; Properly terminate row loop
1291                                ;       MOVE    Y:<NBOXES,A             ; NBOXES = 0 => full image readout
1292                                ;       TST     A
1293                                ;       JEQ     *+2
1294                                ;       ENDDO                           ; Properly terminate box loop
1295                                ;       NOP
1296                                ;       CLR     A
1297                                ;       INC     A
1298                                ;       NOP
1299                                ;       MOVE    A0,Y:<IFLPCNT
1300                                ;       RTS                             ; Return early from subroutine
1301   
1302                                ; Move the row into the serial register.
1303                                 CONTINUE_RD
1304      P:000272 P:000272 060640            DO      Y:<NPBIN,LPR_I                    ; Transfer # of rows, with binning
                            000279
1305      P:000274 P:000274 688D00            MOVE                          Y:<IS_PAR_CLK,R0
1306      P:000275 P:000275 0A20A2            JSET    #STORAGE,X:ISTATUS,GANGED         ; if STORAGE == 1 ganged parallels
                            000278
1307                                ;       mitigation attempt 4- don't use S_PAR_CLK- seemed to work
1308      P:000277 P:000277 688E00            MOVE                          Y:<S_PAR_CLK,R0 ; if STORAGE == 0 store clocks only
1309      P:000278 P:000278 0D02DA  GANGED    JSR     <CLOCK                            ; Parallel clocking
1310      P:000279 P:000279 000000            NOP
1311                                LPR_I
1312   
1313                                ; Skip over NS_SKP1 columns for subimage readout
1314                                ;       MOVE    Y:<NS_SKP1,A            ; Number of columns to skip
1315      P:00027A P:00027A 5E9300            MOVE                          Y:<NSKIP1,A ; Number of waveforms for skip
1316      P:00027B P:00027B 200003            TST     A
1317      P:00027C P:00027C 0EA281            JEQ     <L_READ
1318                                ;       MOVE    #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1319      P:00027D P:00027D 0506A1            MOVE              #<(END_SERIAL_SKIP_WAVE-SERIAL_SKIP_WAVE-1),M1 ; Modularity
1320   
1321                                ;       Fix for new interface CLOCKCT
1322                                ;       June 30 bottom "questions and comments" #2,3
1323      P:00027E P:00027E 698900            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1324      P:00027F P:00027F 218400            MOVE              A1,X0                   ; how many
1325      P:000280 P:000280 0D02E0            JSR     <CLOCKCT
1326                                ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1327                                ;       NOP
1328                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1329                                ;       DO      Y:<NSKIP1,LS_SKIP1      ; Number of waveform entries total
1330                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1331                                ;LS_SKIP1
1332                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1333   
1334                                ; Finally read some real pixels - this is the serial binning routine
1335      P:000281 P:000281 200013  L_READ    CLR     A
1336      P:000282 P:000282 20001B            CLR     B
1337      P:000283 P:000283 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1338      P:000284 P:000284 50F400            MOVE              #>5,A0                  ; If binning > 4, do general binning
                            000005
1339      P:000286 P:000286 200005            CMP     B,A                               ; else do special waveforms via NO_BIN
1340      P:000287 P:000287 0E7299            JGT     <NO_BIN                           ; Skip over general serial binning software
1341      P:000288 P:000288 00000B            DEC     B                                 ; serial binning factor minus 1
1342      P:000289 P:000289 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1343      P:00028A P:00028A 212700            MOVE              B0,Y1
1344      P:00028B P:00028B 061140            DO      Y:<NSERIALS_READ,LSR_BIN          ; Number of pixels to read out
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  tim.s  Page 25



                            000297
1345      P:00028D P:00028D 688C00            MOVE                          Y:<INITIAL_CLOCK,R0 ; (already /2 if split serials)
1346      P:00028E P:00028E 0D02DA            JSR     <CLOCK
1347                                ;       DO      Y:<NSBIN,LSR_I          ; Bin serially NSBIN times
1348      P:00028F P:00028F 06C700            DO      Y1,LSR_I                          ; Bin serially NSBIN times
                            000293
1349      P:000291 P:000291 688B00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1350      P:000292 P:000292 0D02DA            JSR     <CLOCK                            ;   shift register
1351      P:000293 P:000293 000000            NOP
1352                                LSR_I
1353      P:000294 P:000294 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                            00005D
1354      P:000296 P:000296 0D02DA            JSR     <CLOCK
1355                                ;       MOVE    Y1,Y:<INTERVAL          ; HACK.  Use for debugging
1356      P:000297 P:000297 000000            NOP
1357                                LSR_BIN
1358      P:000298 P:000298 0C029F            JMP     <OVER_RD                          ; All done binning
1359   
1360                                ; This is the routine for serial binning from 1 to 4 using hardwired waveforms
1361      P:000299 P:000299 588A00  NO_BIN    MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1362      P:00029A P:00029A 00000A            DEC     A                                 ; waveform - 1 into M1
1363      P:00029B P:00029B 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1364      P:00029C P:00029C 04C8A1            MOVE              A0,M1                   ; Modularity
1365                                ;       Fix for new interface CLOCKCT
1366                                ;       June 30 bottom "questions and comments" #2,3
1367      P:00029D P:00029D 4C9400            MOVE                          Y:<NREAD,X0 ; how many
1368      P:00029E P:00029E 0D02E0            JSR     <CLOCKCT
1369                                ;       NOP
1370                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1371                                ;       DO      Y:<NREAD,LSR            ; Number of waveform entries total
1372                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1373                                ;LSR
1374                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1375   
1376                                ; If NR_BIAS=0 clobber SR with DG and skip to end of row loop
1377      P:00029F P:00029F 5E9B00  OVER_RD   MOVE                          Y:<NR_BIAS,A ; Is NR_BIAS zero?
1378      P:0002A0 P:0002A0 200003            TST     A
1379      P:0002A1 P:0002A1 0E22A7            JNE     <OVR_RD1                          ; no, go to the NS_SKP2 section
1380      P:0002A2 P:0002A2 60F400            MOVE              #DUMP_SERIAL,R0         ; yes, clobber SR with DG
                            000244
1381      P:0002A4 P:0002A4 0D02DA            JSR     <CLOCK
1382      P:0002A5 P:0002A5 0AF080            JMP     END_ROW                           ; and go to the end of the row loop
                            0002D2
1383                                ; Skip over NS_SKP2 columns for subimage readout to get to overscan region
1384      P:0002A7 P:0002A7 5E9900  OVR_RD1   MOVE                          Y:<NS_SKP2,A ; Number of columns to skip
1385      P:0002A8 P:0002A8 200003            TST     A
1386      P:0002A9 P:0002A9 0EA2AE            JEQ     <L_BIAS
1387                                ;       MOVE    #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1388      P:0002AA P:0002AA 0506A1            MOVE              #<(END_SERIAL_SKIP_WAVE-SERIAL_SKIP_WAVE-1),M1 ; Modularity
1389      P:0002AB P:0002AB 698900            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1390                                ;       Fix for new interface CLOCKCT
1391                                ;       June 30 bottom "questions and comments" #2,3
1392      P:0002AC P:0002AC 4C9500            MOVE                          Y:<NSKIP2,X0 ; how many
1393      P:0002AD P:0002AD 0D02E0            JSR     <CLOCKCT
1394                                ;       NOP
1395                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1396                                ;       DO      Y:<NSKIP2,LS_SKIP2      ; Number of waveform entries total
1397                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1398                                ;LS_SKIP2
1399                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1400   
1401                                ; And read the bias pixels if in subimage readout mode
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  tim.s  Page 26



1402                                ; I think this means that if NBOXES==0 you have to have NSR include bias px.
1403      P:0002AE P:0002AE 5E9A00  L_BIAS    MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1404      P:0002AF P:0002AF 200003            TST     A
1405      P:0002B0 P:0002B0 0EA2D2            JEQ     <END_ROW
1406   
1407                                ; Finally read some real bias pixels
1408      P:0002B1 P:0002B1 200013            CLR     A
1409      P:0002B2 P:0002B2 20001B            CLR     B
1410      P:0002B3 P:0002B3 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1411      P:0002B4 P:0002B4 50F400            MOVE              #>5,A0                  ; If binning > 4, do general binning
                            000005
1412      P:0002B6 P:0002B6 200005            CMP     B,A                               ; else do special waveforms via NO_BIN_BIAS
1413      P:0002B7 P:0002B7 0E72CC            JGT     <NO_BIN_BIAS                      ; Skip over general serial binning software
1414      P:0002B8 P:0002B8 00000B            DEC     B                                 ; serial binning factor minus 1
1415      P:0002B9 P:0002B9 5E9B00            MOVE                          Y:<NR_BIAS,A
1416      P:0002BA P:0002BA 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            0002BD
1417      P:0002BC P:0002BC 200022            ASR     A                                 ; Split serials require / 2
1418      P:0002BD P:0002BD 212700            MOVE              B0,Y1
1419      P:0002BE P:0002BE 06CE00            DO      A,LBIAS_BIN                       ; Number of pixels to read out
                            0002CA
1420      P:0002C0 P:0002C0 688C00            MOVE                          Y:<INITIAL_CLOCK,R0
1421      P:0002C1 P:0002C1 0D02DA            JSR     <CLOCK
1422      P:0002C2 P:0002C2 06C700            DO      Y1,LBIAS_I                        ; Bin serially NSBIN times
                            0002C6
1423                                ;       DO      Y:<NSBIN,LBIAS_I        ; Bin serially NSBIN times
1424      P:0002C4 P:0002C4 688B00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1425      P:0002C5 P:0002C5 0D02DA            JSR     <CLOCK                            ;   shift register
1426      P:0002C6 P:0002C6 000000            NOP
1427                                LBIAS_I
1428      P:0002C7 P:0002C7 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                            00005D
1429      P:0002C9 P:0002C9 0D02DA            JSR     <CLOCK
1430      P:0002CA P:0002CA 000000            NOP
1431                                LBIAS_BIN
1432      P:0002CB P:0002CB 0C02D2            JMP     <END_ROW                          ; All done binning
1433   
1434                                ; This is the routine for serial binning from 1 to 4 using hardwired waveforms
1435                                ; NBIAS is already divided by 2 in SETUP_SUBROUTINE if split serials.
1436                                NO_BIN_BIAS
1437      P:0002CC P:0002CC 588A00            MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1438      P:0002CD P:0002CD 00000A            DEC     A                                 ; waveform - 1 into M1
1439      P:0002CE P:0002CE 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1440      P:0002CF P:0002CF 04C8A1            MOVE              A0,M1                   ; Modularity
1441                                ;       Fix for new interface CLOCKCT
1442                                ;       June 30 bottom "questions and comments" #2,3
1443      P:0002D0 P:0002D0 4C9600            MOVE                          Y:<NBIAS,X0 ; how many
1444      P:0002D1 P:0002D1 0D02E0            JSR     <CLOCKCT
1445                                ;       NOP
1446                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1447                                ;       DO      Y:<NBIAS,*+3            ; Number of waveform entries total
1448                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1449                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1450      P:0002D2 P:0002D2 000000  END_ROW   NOP
1451      P:0002D3 P:0002D3 000000  LPR       NOP                                       ; End of parallel loop
1452      P:0002D4 P:0002D4 000000  L_NBOXES  NOP                                       ; End of subimage boxes loop
1453      P:0002D5 P:0002D5 000000            NOP
1454      P:0002D6 P:0002D6 305B00            MOVE              #<DCRST_LAST,R0         ; get DC Restore going
1455      P:0002D7 P:0002D7 0D02DA            JSR     <CLOCK
1456      P:0002D8 P:0002D8 0D04BD            JSR     <CLOCK_WAIT
1457      P:0002D9 P:0002D9 00000C            RTS
1458   
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  tim.s  Page 27



1459                                ; ***************** END OF CCD READOUT SUBROUTINE  ************
1460   
1461                                ; Core subroutine for clocking out CCD charge
1462                                ; Must keep in tim.s to insure that it is in fast P memory
1463                                ; Modified for FIFO magement and new processor as per
1464                                ; June 30 bottom "questions and comments" #2,3
1465   
1466                                ; CLOCK assumes waveform in R0, which begins with a count field
1467                                ; NOTE: in geniii, this count is 1 larger than genii because it
1468                                ; is a straight count of the # of points in the wave- gen-ii
1469                                ; needed a count 1 smaller since there was a pipeline that was
1470                                ; primed with a starter pixel.
1471                                CLOCK
1472      P:0002DA P:0002DA 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002DA
1473      P:0002DC P:0002DC 065860            REP     Y:(R0)+
1474      P:0002DD P:0002DD 09D8F3            MOVEP             Y:(R0)+,Y:WRSS          ; next piece of the waveform
1475      P:0002DE P:0002DE 000000            NOP                                       ; just in case
1476      P:0002DF P:0002DF 00000C            RTS
1477   
1478                                ; CLOCKCT assumes waveform in R1, without a count field, and the
1479                                ; count in X0, and modulus counter in M1.
1480                                ; In order to manage the FIFO (SSFHF) we copy the wave out in a block of 16 pts
1481                                ; at a time. The SSFHF check happens at the start of each block.
1482                                ; Note that count in X0 is again a straight count requiring a fix to FASTSKP
1483                                ; CLOCKCT trashes A
1484                                CLOCKCT
1485      P:0002E0 P:0002E0 200013            CLR     A
1486      P:0002E1 P:0002E1 208E00            MOVE              X0,A
1487                                CLKBLKFULL
1488                                                                                    ; see if we can do a full block in the wavef
orm.
1489      P:0002E2 P:0002E2 015085            CMP     #16,A
1490      P:0002E3 P:0002E3 0E92EA            JLT     <CLKBLKREM
1491                                                                                    ; 16 or more points remain
1492      P:0002E4 P:0002E4 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002E4
1493      P:0002E6 P:0002E6 0610A0            REP     #16
1494      P:0002E7 P:0002E7 09D9F3            MOVEP             Y:(R1)+,Y:WRSS          ; next modulo piece of the waveform
1495      P:0002E8 P:0002E8 015084            SUB     #16,A
1496      P:0002E9 P:0002E9 0C02E2            JMP     <CLKBLKFULL
1497                                CLKBLKREM
1498                                                                                    ; last little bit..
1499      P:0002EA P:0002EA 200003            TST     A
1500      P:0002EB P:0002EB 0EF2F1            JLE     <CLOCK1                           ; no it divided evenly so all done--
1501                                                                                    ; do the remainder of 1 to 15 pts.
1502      P:0002EC P:0002EC 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002EC
1503      P:0002EE P:0002EE 06CE00            DO      A,CLOCK1
                            0002F0
1504      P:0002F0 P:0002F0 09D9F3            MOVEP             Y:(R1)+,Y:WRSS          ; next modulo piece of the waveform
1505                                CLOCK1
1506      P:0002F1 P:0002F1 000000            NOP                                       ; just in case
1507      P:0002F2 P:0002F2 00000C            RTS
1508   
1509                                ;CLOCK   MOVE    Y:(R0)+,X0             ; # of waveform entries
1510                                ;        MOVE    Y:(R0)+,A              ; Start the pipeline
1511                                ;        DO      X0,CLK1                 ; Repeat X0 times
1512                                ;        MOVE    A,X:(R6) Y:(R0)+,A      ; Send out the waveform
1513                                ;CLK1
1514                                ;        MOVE    A,X:(R6)               ; Flush out the pipeline
1515                                ;        RTS                            ; Return from subroutine
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  tim.s  Page 28



1516   
1517                                ; Include miscellaneous timing commands
1518                                          INCLUDE "timmisc.s"                       ; Custom
1519                                ; This file is for utilities that are in common to all the timing board
1520                                ;   programs, located starting at P:$200 in external SRAM
1521   
1522                                          IF      @SCP("10","50")
1524                                          ENDIF
1525                                          IF      @SCP("10","200")
1527                                          ENDIF
1528                                          IF      @SCP("10","10")
1529      00000A                    SDELAY    EQU     10
1530                                          ENDIF
1531   
1532   
1533                                ;  ****************  PROGRAM CODE IN SRAM PROGRAM SPACE    *******************
1534                                ; Put all the following code in SRAM, starting at P:$200.
1535                                          IF      @SCP("HOST","HOST")
1536                                ; as per Confluence, July 9
1537                                ;       ORG     P:$200,P:$200   ; Download address
1538      P:0002F3 P:0002F3                   ORG     P:,P:                             ; Download address
1539                                          ELSE
1541                                          ENDIF
1542   
1543                                ; Fast clear of CCD, executed as a command
1544      P:0002F3 P:0002F3 0D02F5  CLEAR     JSR     <CLR_CCD
1545      P:0002F4 P:0002F4 0C008F            JMP     <FINISH
1546   
1547                                ; Fast clear image before each exposure, executed as a subroutine.  Uses DG
1548      P:0002F5 P:0002F5 060440  CLR_CCD   DO      Y:<NPCLR,LPCLR                    ; Loop over number of lines in image
                            0002FA
1549      P:0002F7 P:0002F7 60F400            MOVE              #PARALLEL_CLEAR,R0      ; Address of parallel transfer waveform
                            000238
1550      P:0002F9 P:0002F9 0D02DA            JSR     <CLOCK                            ; Go clock out the CCD charge
1551      P:0002FA P:0002FA 000000            NOP                                       ; Do loop restriction
1552                                LPCLR
1553      P:0002FB P:0002FB 60F400            MOVE              #DUMP_SERIAL,R0
                            000244
1554      P:0002FD P:0002FD 0D02DA            JSR     <CLOCK                            ; and wipe out the dregs in the SR
1555      P:0002FE P:0002FE 245A00            MOVE              #TST_RCV,X0             ; Wait for commands during exposure
1556      P:0002FF P:0002FF 441F00            MOVE              X0,X:<IDL_ADR           ;  instead of idling
1557      P:000300 P:000300 00000C            RTS
1558   
1559                                ; Keep the CCD idling when not reading out
1560      P:000301 P:000301 060340  IDLE      DO      Y:<NS_CLR,IDL1                    ; Loop over number of pixels per line
                            00030A
1561      P:000303 P:000303 303F00            MOVE              #<SERIAL_IDLE,R0        ; Serial transfer on pixel
1562      P:000304 P:000304 0D02DA            JSR     <CLOCK                            ; Go to it
1563      P:000305 P:000305 330700            MOVE              #COM_BUF,R3
1564      P:000306 P:000306 0D00A5            JSR     <GET_RCV                          ; Check for FO or SSI commands
1565      P:000307 P:000307 0E030A            JCC     <NO_COM                           ; Continue IDLE if no commands received
1566      P:000308 P:000308 00008C            ENDDO
1567      P:000309 P:000309 0C005D            JMP     <PRC_RCV                          ; Go process header and command
1568      P:00030A P:00030A 000000  NO_COM    NOP
1569                                IDL1
1570      P:00030B P:00030B 60F400            MOVE              #PARALLEL_CLEAR,R0      ; Address of parallel clocking waveform
                            000238
1571      P:00030D P:00030D 0D02DA            JSR     <CLOCK                            ; Go clock out the CCD charge
1572      P:00030E P:00030E 0C0301            JMP     <IDLE
1573   
1574                                ; Start the exposure timer and monitor its progress
1575      P:00030F P:00030F 07F40E  EXPOSE    MOVEP             #0,X:TLR0               ; Load 0 into counter timer
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 29



                            000000
1576      P:000311 P:000311 240000            MOVE              #0,X0
1577      P:000312 P:000312 441100            MOVE              X0,X:<ELAPSED_TIME      ; Set elapsed exposure time to zero
1578                                ;       CLR     B                       ; possibly fix bug as per
1579      P:000313 P:000313 579000            MOVE              X:<EXPOSURE_TIME,B
1580      P:000314 P:000314 20000B            TST     B                                 ; Special test for zero exposure time
1581      P:000315 P:000315 0EA321            JEQ     <END_EXP                          ; Don't even start an exposure
1582      P:000316 P:000316 01418C            SUB     #1,B                              ; Timer counts from X:TCPR0+1 to zero
1583      P:000317 P:000317 010F20            BSET    #TIM_BIT,X:TCSR0                  ; Enable the timer #0
1584      P:000318 P:000318 577000            MOVE              B,X:TCPR0
                            FFFF8D
1585      P:00031A P:00031A 0A8989  CHK_RCV   JCLR    #EF,X:HDR,CHK_TIM                 ; Simple test for fast execution
                            00031F
1586      P:00031C P:00031C 330700            MOVE              #COM_BUF,R3             ; The beginning of the command buffer
1587      P:00031D P:00031D 0D00A5            JSR     <GET_RCV                          ; Check for an incoming command
1588      P:00031E P:00031E 0E805D            JCS     <PRC_RCV                          ; If command is received, go check it
1589      P:00031F P:00031F 018F95  CHK_TIM   JCLR    #TCF,X:TCSR0,CHK_RCV              ; Wait for timer to equal compare value
                            00031A
1590      P:000321 P:000321 010F00  END_EXP   BCLR    #TIM_BIT,X:TCSR0                  ; Disable the timer
1591      P:000322 P:000322 0AE780            JMP     (R7)                              ; This contains the return address
1592   
1593                                ; Select which readouts to process
1594                                ;   'SOS'  Amplifier_name
1595                                ;       Amplifier_names = '__A', '__B', '__C', '__D', '_AB', '_CD', '_BD', 'ALL'
1596   
1597                                ;       Correct command ptr to R3 as per "Four Points" #2
1598   
1599      P:000323 P:000323 44DB00  SEL_OS    MOVE              X:(R3)+,X0              ; Get amplifier(s) name
1600      P:000324 P:000324 0D0326            JSR     <SELECT_OUTPUT_SOURCE
1601      P:000325 P:000325 0C0090            JMP     <FINISH1
1602   
1603                                ; A massive subroutine for setting all the addresses depending on the
1604                                ; output source(s) selection and binning parameter.  Most of the
1605                                ; waveforms are in fast Y memory (< 0xFF) but there isn't enough
1606                                ; space for the fast serial binning waveforms for binning factors
1607                                ; 1 through 4.  These are in high Y memory and have to be copied in.
1608   
1609                                SELECT_OUTPUT_SOURCE
1610   
1611                                ; Set all the waveform addresses depending on which readout/binning mode
1612                                ; Only one amplifier to eliminate all the checks and skips.
1613                                ; Still need to worry about binning, though.
1614   
1615      P:000326 P:000326 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value, whatever it is
1616                                ; Copy in clock waveforms even though they are compiled in.
1617      P:000327 P:000327 46F400            MOVE              #PARALLEL,Y0
                            00022F
1618      P:000329 P:000329 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
1619      P:00032B P:00032B 46F400            MOVE              #PARALLEL,Y0
                            00022F
1620      P:00032D P:00032D 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1621      P:00032F P:00032F 46F400            MOVE              #PARALLEL_CLEAR,Y0
                            000238
1622      P:000331 P:000331 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1623      P:000333 P:000333 46F400            MOVE              #PARALLEL_CLEAR,Y0
                            000238
1624      P:000335 P:000335 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1625   
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 30



1626                                ; serials for general binning
1627      P:000337 P:000337 46F400            MOVE              #SERIAL_SKIP_WAVE,Y0
                            0000E8
1628      P:000339 P:000339 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
1629      P:00033B P:00033B 46F400            MOVE              #INITIAL_CLOCK_WAVE,Y0
                            00004D
1630      P:00033D P:00033D 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
1631      P:00033F P:00033F 46F400            MOVE              #SERIAL_CLOCK_WAVE,Y0
                            000054
1632      P:000341 P:000341 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
1633   
1634                                ; important to set the split bits in STATUS
1635      P:000343 P:000343 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1636      P:000344 P:000344 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1637   
1638                                ; Now go through copying in the serial read waveform if binning more than 4.
1639      P:000345 P:000345 200013            CLR     A
1640      P:000346 P:000346 20001B            CLR     B
1641      P:000347 P:000347 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1642      P:000349 P:000349 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1643      P:00034A P:00034A 50F400            MOVE              #>4,A0
                            000004
1644      P:00034C P:00034C 200005            CMP     B,A
1645      P:00034D P:00034D 0E9374            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1646      P:00034E P:00034E 0D0381            JSR     <SET_BINBIT                       ; else set BINBIT
1647      P:00034F P:00034F 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1648      P:000350 P:000350 0A1E81  TRY_1_A   JCLR    #1,X:BINBIT,TRY_2_A
                            000359
1649                                ;       MOVE    #1,A0                   ; HACK
1650                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1651      P:000352 P:000352 51F400            MOVE              #(END_SERIAL_READ_1-SERIAL_READ_1),B0
                            00000E
1652      P:000354 P:000354 60F400            MOVE              #SERIAL_READ_1,R0       ; Here if bin by 1
                            00024A
1653      P:000356 P:000356 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1654      P:000357 P:000357 0D037A            JSR     <WAVECPY                          ; Copy the waveform
1655      P:000358 P:000358 0C0374            JMP     <CMP_END
1656      P:000359 P:000359 0A1E82  TRY_2_A   JCLR    #2,X:BINBIT,TRY_3_A
                            000362
1657      P:00035B P:00035B 51F400            MOVE              #(END_SERIAL_READ_2-SERIAL_READ_2),B0
                            000014
1658      P:00035D P:00035D 60F400            MOVE              #SERIAL_READ_2,R0       ; Here if bin by 2
                            000258
1659      P:00035F P:00035F 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1660      P:000360 P:000360 0D037A            JSR     <WAVECPY                          ; Copy the waveform
1661      P:000361 P:000361 0C0374            JMP     <CMP_END
1662      P:000362 P:000362 0A1E83  TRY_3_A   JCLR    #3,X:<BINBIT,TRY_4_A
                            00036B
1663      P:000364 P:000364 51F400            MOVE              #(END_SERIAL_READ_3-SERIAL_READ_3),B0
                            00001A
1664      P:000366 P:000366 60F400            MOVE              #SERIAL_READ_3,R0       ; Here if bin by 3
                            00026C
1665      P:000368 P:000368 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1666      P:000369 P:000369 0D037A            JSR     <WAVECPY                          ; Copy the waveform
1667      P:00036A P:00036A 0C0374            JMP     <CMP_END
1668      P:00036B P:00036B 0A1E84  TRY_4_A   JCLR    #4,X:BINBIT,CMP_ERROR
                            000377
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 31



1669      P:00036D P:00036D 51F400            MOVE              #(END_SERIAL_READ_4-SERIAL_READ_4),B0
                            000020
1670      P:00036F P:00036F 60F400            MOVE              #SERIAL_READ_4,R0       ; Here if bin by 4
                            000286
1671      P:000371 P:000371 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1672      P:000372 P:000372 0D037A            JSR     <WAVECPY                          ; Copy the waveform
1673      P:000373 P:000373 0C0374            JMP     <CMP_END
1674   
1675                                ;       returns modified as per "Four points", #1
1676      P:000374 P:000374 47F400  CMP_END   MOVE              #'DON',Y1
                            444F4E
1677      P:000376 P:000376 00000C            RTS
1678                                CMP_ERROR
1679      P:000377 P:000377 47F400            MOVE              #'ERR',Y1
                            455252
1680      P:000379 P:000379 00000C            RTS
1681   
1682                                ; Short function to copy in waveforms from high Y to fast Y memory.
1683                                ; R0 is the source address, R7 the destination, and X0 is intermediary reg.
1684                                WAVECPY
1685      P:00037A P:00037A 06C900            DO      B0,WAVELP                         ; Copy the waveform; B0 is SERWAVLEN already
                            00037E
1686      P:00037C P:00037C 4CD800            MOVE                          Y:(R0)+,X0
1687      P:00037D P:00037D 4C5F00            MOVE                          X0,Y:(R7)+
1688      P:00037E P:00037E 000000            NOP
1689                                WAVELP
1690      P:00037F P:00037F 000000            NOP
1691      P:000380 P:000380 00000C            RTS
1692   
1693                                ; Short function to set the correct bit in BINBIT based on NSBIN
1694                                ; Called only if NSBIN is less than 6.
1695   
1696                                SET_BINBIT
1697                                ;       MOVE    Y:<TESTLOC1,A0                  ; HACK - test if this code is executed
1698                                ;       INC     A                               ; HACK
1699                                ;       MOVE    A0,Y:<TESTLOC1                  ; HACK
1700      P:000381 P:000381 50F400            MOVE              #>1,A0                  ; Put a bit in A and shift to right spot
                            000001
1701      P:000383 P:000383 060540            DO      Y:<NSBIN,BINLOOP                  ; Bit zero position not used, 1-5 used
                            000385
1702      P:000385 P:000385 200032            ASL     A
1703                                BINLOOP
1704      P:000386 P:000386 507000            MOVE              A0,X:BINBIT             ; set bit 1-5 for SELECT_OUTPUT_SOURCE jump 
table
                            00001E
1705      P:000388 P:000388 00000C            RTS
1706   
1707   
1708                                ; Set the number of rows and columns and binning factors
1709                                ;       Correct command ptr to R3 as per "Four Points" #2
1710                                SET_ROWS_COLUMNS
1711      P:000389 P:000389 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NSR = NAXIS1
1712      P:00038A P:00038A 4C7000            MOVE                          X0,Y:NSR
                            000001
1713      P:00038C P:00038C 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NPR = NAXIS2
1714      P:00038D P:00038D 4C7000            MOVE                          X0,Y:NPR
                            000002
1715      P:00038F P:00038F 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NSBIN
1716      P:000390 P:000390 4C7000            MOVE                          X0,Y:NSBIN
                            000005
1717      P:000392 P:000392 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NPBIN
1718      P:000393 P:000393 4C7000            MOVE                          X0,Y:NPBIN
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 32



                            000006
1719      P:000395 P:000395 4CBB00            MOVE                          Y:<AMPVAL,X0 ; Get ampval in X0 for SOS call
1720      P:000396 P:000396 0D0326            JSR     <SELECT_OUTPUT_SOURCE             ; Update serial read waveform in case binnin
g changed
1721      P:000397 P:000397 0C008F            JMP     <FINISH                           ; no error return possible
1722   
1723                                ; Set the variables for the time-resolved modes
1724                                ;       Correct command ptr to R3 as per "Four Points" #2
1725                                SET_IMAGE_PARAM
1726      P:000398 P:000398 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Image mode
1727      P:000399 P:000399 447000            MOVE              X0,X:IMAGE_MODE
                            000080
1728      P:00039B P:00039B 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Iframes = NAXIS3
1729      P:00039C P:00039C 4C7000            MOVE                          X0,Y:IFRAMES
                            000038
1730      P:00039E P:00039E 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Srows
1731      P:00039F P:00039F 4C7000            MOVE                          X0,Y:SROWS
                            000036
1732      P:0003A1 P:0003A1 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Interval
1733                                ;       MOVE    X0,Y:INTERVAL           ; HACK - Using Interval as a test location
1734      P:0003A2 P:0003A2 0C008F            JMP     <FINISH
1735   
1736   
1737                                ; Set the hardware trigger bit, executed as a command
1738                                ;       Correct command ptr to R3 as per "Four Points" #2
1739                                ; Disable h/w trigger and return error (for now) as per June 30, #8
1740                                ; Disabled temporarily for DeVeny as well.
1741                                SET_TRIGGER
1742      P:0003A3 P:0003A3 44DB00            MOVE              X:(R3)+,X0              ; Get the trigger value
1743      P:0003A4 P:0003A4 56F400            MOVE              #'_ON',A
                            5F4F4E
1744      P:0003A6 P:0003A6 200045            CMP     X0,A
1745      P:0003A7 P:0003A7 0AF0A2            JNE     NO_TRIGGER
                            0003AA
1746                                ;       JSET    #11,X:PBD,TRIG_CLR      ; Is Trigger running?
1747      P:0003A9 P:0003A9 0C008D            JMP     <ERROR                            ; Yes! report Error!  Why do this?
1748                                ;TRIG_CLR
1749                                ;       BSET    #TRIGGER,X:<STATUS      ; Set status bit, hardware trigger
1750                                ;       JMP     <FINISH
1751                                NO_TRIGGER
1752      P:0003AA P:0003AA 0A0008            BCLR    #TRIGGER,X:<STATUS                ; Clear Status bit, software timing
1753      P:0003AB P:0003AB 0C008F            JMP     <FINISH
1754   
1755                                ; Calculate the fast read parameters for each readout box
1756                                SETUP_SUBROUTINE
1757      P:0003AC P:0003AC 4C8A00            MOVE                          Y:<SERWAVLEN,X0 ; # of waveforms
1758      P:0003AD P:0003AD 4D9100            MOVE                          Y:<NSERIALS_READ,X1 ; Number of pixels to read
1759      P:0003AE P:0003AE 0D04C8            JSR     <FASTSKP                          ; Compute number of clocks required
1760      P:0003AF P:0003AF 4D1400            MOVE                          X1,Y:<NREAD ; Number of waveforms per line
1761      P:0003B0 P:0003B0 5E9B00            MOVE                          Y:<NR_BIAS,A ; Number of pixels to read
1762      P:0003B1 P:0003B1 0A0085            JCLR    #SPLIT_S,X:STATUS,USPLS           ; Split serials require / 2
                            0003B5
1763      P:0003B3 P:0003B3 200022            ASR     A
1764      P:0003B4 P:0003B4 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1765                                USPLS
1766      P:0003B5 P:0003B5 21C500            MOVE              A,X1                    ; Number of waveforms per line
1767      P:0003B6 P:0003B6 0D04C8            JSR     <FASTSKP                          ; Compute number of clocks required
1768      P:0003B7 P:0003B7 4D1600            MOVE                          X1,Y:<NBIAS ; Number of waveforms per line
1769      P:0003B8 P:0003B8 44F400            MOVE              #(END_SERIAL_SKIP_WAVE-SERIAL_SKIP_WAVE),X0 ; # of waveforms
                            000007
1770      P:0003BA P:0003BA 4D8300            MOVE                          Y:<NS_CLR,X1 ; Number of pixels to skip
1771      P:0003BB P:0003BB 0D04C8            JSR     <FASTSKP                          ; Compute number of clocks required
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 33



1772      P:0003BC P:0003BC 4D1200            MOVE                          X1,Y:<NSCLR ; Number of waveforms per line
1773      P:0003BD P:0003BD 4D9800            MOVE                          Y:<NS_SKP1,X1 ; Number of pixels to skip
1774      P:0003BE P:0003BE 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
1775      P:0003BF P:0003BF 2000F0            MPY     Y1,X1,A
1776      P:0003C0 P:0003C0 200022            ASR     A
1777      P:0003C1 P:0003C1 210500            MOVE              A0,X1
1778      P:0003C2 P:0003C2 0D04C8            JSR     <FASTSKP                          ; Compute number of clocks required
1779      P:0003C3 P:0003C3 4D1300            MOVE                          X1,Y:<NSKIP1 ; Number of waveforms per line
1780      P:0003C4 P:0003C4 4D9900            MOVE                          Y:<NS_SKP2,X1 ; Number of pixels to skip
1781      P:0003C5 P:0003C5 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
1782      P:0003C6 P:0003C6 2000F0            MPY     Y1,X1,A
1783      P:0003C7 P:0003C7 200022            ASR     A
1784      P:0003C8 P:0003C8 210500            MOVE              A0,X1
1785      P:0003C9 P:0003C9 0D04C8            JSR     <FASTSKP                          ; Compute number of clocks required
1786      P:0003CA P:0003CA 4D1500            MOVE                          X1,Y:<NSKIP2 ; Number of waveforms per line
1787      P:0003CB P:0003CB 4D9700            MOVE                          Y:<NP_SKIP,X1
1788      P:0003CC P:0003CC 4F8600            MOVE                          Y:<NPBIN,Y1
1789      P:0003CD P:0003CD 2000F0            MPY     X1,Y1,A
1790      P:0003CE P:0003CE 200022            ASR     A
1791      P:0003CF P:0003CF 581700            MOVE                          A0,Y:<NP_SKIP
1792      P:0003D0 P:0003D0 00000C            RTS
1793   
1794                                ; Returns immediately if hardware triggering is not being used
1795                                ; Blocks until the trigger is found to be high twice in a row.
1796                                ; Waits until the trigger goes high
1797                                ; Trigger support disabled temporarily for DeVeny as well.
1798                                WAIT_UNTIL_TRIGGER
1799      P:0003D1 P:0003D1 0A0088            JCLR    #TRIGGER,X:STATUS,UNTIL_TRIGGER_RETURN
                            0003D6
1800      P:0003D3 P:0003D3 000000            NOP
1801                                ;       JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER       ; Is Trigger Low?
1802      P:0003D4 P:0003D4 000000            NOP                                       ; Pause
1803                                ;       JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER       ; Is Trigger still Low?
1804      P:0003D5 P:0003D5 000000            NOP
1805                                UNTIL_TRIGGER_RETURN
1806      P:0003D6 P:0003D6 00000C            RTS
1807   
1808                                ; Returns immediately if hardware triggering is not being used
1809                                ; Blocks until the trigger is found to be low twice in a row.
1810                                ; Waits while the trigger is high
1811                                ; Trigger support disabled temporarily for DeVeny as well.
1812                                WAIT_WHILE_TRIGGER
1813      P:0003D7 P:0003D7 0A0088            JCLR    #TRIGGER,X:STATUS,WHILE_TRIGGER_RETURN
                            0003DC
1814      P:0003D9 P:0003D9 000000            NOP
1815                                ;       JSET    #11,X:PBD,WAIT_WHILE_TRIGGER       ; Is Trigger High?
1816      P:0003DA P:0003DA 000000            NOP                                       ; Pause
1817                                ;       JSET    #11,X:PBD,WAIT_WHILE_TRIGGER       ; Is Trigger still High?
1818      P:0003DB P:0003DB 000000            NOP
1819                                WHILE_TRIGGER_RETURN
1820      P:0003DC P:0003DC 00000C            RTS
1821   
1822                                ; Like WAIT_WHILE_TRIGGER but clears the CCD while waiting
1823                                ; Pro:  Clears CCD while waiting.  Con: timing rattiness of 1 parallel time
1824                                ; Returns immediately if hardware triggering is not being used
1825                                ; Blocks until the trigger is found to be low twice in a row.
1826                                ; Waits while the trigger is high
1827                                ; Trigger support disabled temporarily for DeVeny as well.
1828                                CLEAR_WHILE_TRIGGER
1829      P:0003DD P:0003DD 0A0088            JCLR    #TRIGGER,X:STATUS,CLEAR_TRIG_RETURN
                            0003E1
1830                                ;       MOVE    #IS_PAR_CLR,R0          ; Address of parallel transfer waveform
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 34



1831                                ;       JSR     <CLOCK                  ; Go clock out the CCD charge
1832                                ;       JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER       ; Is Trigger High?
1833      P:0003DF P:0003DF 000000            NOP                                       ; Pause
1834                                ;       JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER      ; Is Trigger still High?
1835      P:0003E0 P:0003E0 000000            NOP
1836                                CLEAR_TRIG_RETURN
1837      P:0003E1 P:0003E1 00000C            RTS
1838   
1839                                ; Subroutine to compute SROWS in unbinned pixels and store in UBSROWS
1840   
1841                                UB_CONV
1842      P:0003E2 P:0003E2 4CB600            MOVE                          Y:<SROWS,X0
1843      P:0003E3 P:0003E3 4D8600            MOVE                          Y:<NPBIN,X1 ; Adjust for for parallel binning factor
1844      P:0003E4 P:0003E4 2000A0            MPY     X0,X1,A
1845      P:0003E5 P:0003E5 200022            ASR     A
1846      P:0003E6 P:0003E6 583700            MOVE                          A0,Y:<UBSROWS ; Put unbinned number in UBSROWS
1847      P:0003E7 P:0003E7 00000C            RTS
1848   
1849                                ; Key code segments for the HIPO modes.
1850                                ; Jump table to the various modes - see also timhdr.s
1851                                START_FT_EXPOSURE
1852      P:0003E8 P:0003E8 0BF080            JSR     CSHUT                             ; Unconditionally close the shutter; done wi
th DeVeny slit viewing camera
                            0004E8
1853      P:0003EA P:0003EA 0A0008            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of lingering abort flag
1854      P:0003EB P:0003EB 0A00AA            JSET    #ST_SBFAIL,X:<STATUS,EXPMODE_ST
                            0003F7
1855                                ; go to transition bias levels and then to DD
1856      P:0003ED P:0003ED 60F400            MOVE              #DACS_TRANS,R0
                            0001CA
1857   
1858                                          IF      @SCP("DACSLOG","SUPPORTED")
1862                                          ENDIF
1863   
1864      P:0003EF P:0003EF 0BF080            JSR     SET_BIASES
                            000565
1865   
1866   
1867      P:0003F1 P:0003F1 0A00AA            JSET    #ST_SBFAIL,X:<STATUS,EXPMODE_ST
                            0003F7
1868                                ; go to deep depletion bias levels, preparation for imaging
1869      P:0003F3 P:0003F3 60F400            MOVE              #DACS_DD,R0
                            000100
1870      P:0003F5 P:0003F5 0BF080            JSR     SET_BIASES
                            000565
1871   
1872                                          IF      @SCP("DACSLOG","SUPPORTED")
1885                                          ENDIF
1886   
1887                                EXPMODE_ST
1888   
1889      P:0003F7 P:0003F7 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
1890      P:0003F9 P:0003F9 0AC421            JSET    #FIND,X0,SINGLE_PROC
                            00042C
1891      P:0003FB P:0003FB 0AC424            JSET    #SINGLE,X0,SINGLE_PROC
                            00042C
1892                                ;       JSET    #SERIES,X0,SERIES_PROC        ; defunct.  Use basic occ.
1893      P:0003FD P:0003FD 0AC420            JSET    #FDOTS,X0,FDOT_PROC
                            000406
1894      P:0003FF P:0003FF 0AC422            JSET    #SDOTS,X0,SDOT_PROC               ; slow dots & strips use sdot_proc
                            000464
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 35



1895      P:000401 P:000401 0AC425            JSET    #STRIP,X0,SDOT_PROC
                            000464
1896                                ;        JSET    #B_OCC,X0,SINGLE_PROC          ; basic occ uses single_proc
1897                                ;        JSET    #F_OCC,X0,FPO_PROC             ; fast & pipelined occ use occ_proc
1898                                ;        JSET    #P_OCC,X0,FPO_PROC
1899      P:000403 P:000403 44F400            MOVE              #'ERR',X0               ; error if not a valid mode
                            455252
1900      P:000405 P:000405 0C008D            JMP     <ERROR
1901   
1902                                FDOT_PROC                                           ; used by fdots only
1903                                ; Start by replacing SROWS (binned rows) with unbinned rows.  Will get rewritten on next SEX com
mand
1904                                ; Leave the DO loop in here - no reason to change it - won't exceed 65535 dots, for sure!
1905      P:000406 P:000406 0D03E2            JSR     UB_CONV                           ; Fill in unbinned SROWS
1906      P:000407 P:000407 4C8200            MOVE                          Y:<NPR,X0
1907      P:000408 P:000408 4C1D00            MOVE                          X0,Y:<NP_READ ; Make sure that NP_READ=NPR in case of su
bframe
1908      P:000409 P:000409 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
1909      P:00040A P:00040A 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for FDOTS
1910      P:00040B P:00040B 0A2020            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe bou
ndary
1911      P:00040C P:00040C 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            00048E
1912      P:00040E P:00040E 0D02F5            JSR     <CLR_CCD                          ; Clear out the CCD
1913      P:00040F P:00040F 0D03D7            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
1914                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
1915      P:000410 P:000410 0D04DF            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
1916      P:000411 P:000411 063840            DO      Y:<IFRAMES,FDOT_LOOP              ; Loop over the number of FDOTS
                            000422
1917      P:000413 P:000413 0A00A8            JSET    #TRIGGER,X:STATUS,FDX_END         ; If no triggering jump to expose image func
tion
                            000419
1918      P:000415 P:000415 67F400            MOVE              #FDX_END,R7             ; Store the Address into R7
                            000419
1919      P:000417 P:000417 0A0027            BSET    #ST_EXP,X:<STATUS
1920      P:000418 P:000418 0C030F            JMP     <EXPOSE                           ; Delay for specified exposure time
1921                                FDX_END
1922      P:000419 P:000419 0A0007            BCLR    #ST_EXP,X:<STATUS
1923      P:00041A P:00041A 0A0088            JCLR    #ST_ABRT,X:<STATUS,FDX_NXT        ; got abort underway?
                            00041E
1924      P:00041C P:00041C 00008C            ENDDO
1925      P:00041D P:00041D 0C042A            JMP     <FDOT_FINI
1926                                FDX_NXT
1927      P:00041E P:00041E 0D03D1            JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
1928      P:00041F P:00041F 4DB700            MOVE                          Y:<UBSROWS,X1 ; Number of unbinned rows per shift
1929      P:000420 P:000420 0D04AF            JSR     <ISHIFT                           ; Clock out the waveforms
1930      P:000421 P:000421 0D03D7            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
1931      P:000422 P:000422 000000            NOP
1932                                FDOT_LOOP
1933      P:000423 P:000423 0D04E6            JSR     <C_CSHUT                          ; Conditionally close shutter
1934      P:000424 P:000424 063840            DO      Y:<IFRAMES,FDOT_LP1               ; Loop over the number of FDOTS during reado
ut
                            000429
1935      P:000426 P:000426 0A0024            BSET    #ST_RDC,X:<STATUS
1936      P:000427 P:000427 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD
1937      P:000428 P:000428 0A0004            BCLR    #ST_RDC,X:<STATUS
1938      P:000429 P:000429 000000            NOP
1939                                FDOT_LP1
1940                                FDOT_FINI
1941                                ;       CLOSE SHUTTER if abt??
1942                                ;       JSR     <WAIT_UNTIL_TRIGGER             ; If taking more than one set of dots sync. trig
ger.  Vestigial?
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 36



1943      P:00042A P:00042A 0AF080            JMP     CLEANUP                           ; clean up after command.
                            000496
1944   
1945                                SINGLE_PROC                                         ; Used by find, single, and basic occ
1946      P:00042C P:00042C 0A2001            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for find & basic occ
1947      P:00042D P:00042D 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
1948      P:00042F P:00042F 0AC404            JCLR    #SINGLE,X0,NOT_SINGM              ; But if single mode,
                            000432
1949      P:000431 P:000431 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
1950                                NOT_SINGM
1951   
1952                                ; Note: DeVeny has no storage area.
1953      P:000432 P:000432 0A2002            BCLR    #STORAGE,X:<ISTATUS               ; Do the FT, no storage clocks only during r
eadout
1954      P:000433 P:000433 0AC427            JSET    #B_OCC,X0,AN_OCC                  ; STORAGE=0 for basic, 1 otherwise
                            000436
1955      P:000435 P:000435 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't do the FT, ganged clocks only during
 readout
1956                                AN_OCC
1957   
1958      P:000436 P:000436 0A2000            BCLR    #NO_SKIP,X:<ISTATUS               ; Do parallel skip up to the subframe bounda
ry
1959                                          IF      @SCP("10","0")
1960                                          ELSE
1961      P:000437 P:000437 060A80            DO      #SDELAY,SNGL_DELAY1
                            00043E
1962      P:000439 P:000439 44F400            MOVE              #25000,X0
                            0061A8
1963      P:00043B P:00043B 06C400            DO      X0,SNGL_DELAY0
                            00043D
1964      P:00043D P:00043D 000000            NOP
1965                                 SNGL_DELAY0
1966      P:00043E P:00043E 000000            NOP
1967                                 SNGL_DELAY1
1968      P:00043F P:00043F 000000            NOP
1969                                          ENDIF
1970   
1971      P:000440 P:000440 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            00048E
1972      P:000442 P:000442 0D02F5            JSR     <CLR_CCD                          ; Clear out the CCD
1973      P:000443 P:000443 0D03D7            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
1974                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
1975      P:000444 P:000444 4CB800            MOVE                          Y:<IFRAMES,X0
1976      P:000445 P:000445 4C3C00            MOVE                          X0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
1977      P:000446 P:000446 0D04DF  SN_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
1978                                ;        JSET    #TRIGGER,X:STATUS,SNX_END       ; If no triggering jump to expose image functio
n
1979      P:000447 P:000447 67F400            MOVE              #SNX_END,R7             ; Store the Address into R7
                            00044B
1980      P:000449 P:000449 0A0027            BSET    #ST_EXP,X:<STATUS
1981      P:00044A P:00044A 0C030F            JMP     <EXPOSE                           ; Delay for specified exposure time
1982                                SNX_END
1983      P:00044B P:00044B 0A0007            BCLR    #ST_EXP,X:<STATUS
1984      P:00044C P:00044C 0A00A8            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                            00045D
1985   
1986      P:00044E P:00044E 0D03D1            JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
1987      P:00044F P:00044F 0D04E6            JSR     <C_CSHUT                          ; Close shutter if open-close bit is set
1988      P:000450 P:000450 0A0024            BSET    #ST_RDC,X:<STATUS
1989      P:000451 P:000451 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD
1990      P:000452 P:000452 0A0004            BCLR    #ST_RDC,X:<STATUS
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 37



1991      P:000453 P:000453 0D03D7            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
1992      P:000454 P:000454 0A00A8            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                            00045D
1993      P:000456 P:000456 200013            CLR     A
1994      P:000457 P:000457 58BC00            MOVE                          Y:<IFLPCNT,A0
1995      P:000458 P:000458 00000A            DEC     A                                 ; Get loop count, decrement, and loop till z
ero
1996      P:000459 P:000459 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1997      P:00045A P:00045A 583C00            MOVE                          A0,Y:<IFLPCNT
1998      P:00045B P:00045B 200003            TST     A
1999      P:00045C P:00045C 0E2446            JNE     SN_LP                             ; End of IFRAMES loop
2000                                SNX_FINI
2001      P:00045D P:00045D 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2002                                                                                    ; if you abort a find does the shutter close
?
2003      P:00045F P:00045F 0AC421            JSET    #FIND,X0,SNX_DONE
                            000462
2004      P:000461 P:000461 0D04E8            JSR     <CSHUT                            ; Close the shutter unless in find mode
2005                                SNX_DONE
2006      P:000462 P:000462 0AF080            JMP     CLEANUP                           ; clean up after command.
                            000496
2007   
2008                                ; NO abort support
2009                                SDOT_PROC                                           ; Used by slow dots and strips
2010      P:000464 P:000464 4CB600            MOVE                          Y:<SROWS,X0
2011      P:000465 P:000465 4C1D00            MOVE                          X0,Y:<NP_READ ; Make sure that NP_READ=SROWS
2012      P:000466 P:000466 0A2001            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for strips
2013      P:000467 P:000467 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2014      P:000469 P:000469 0AC402            JCLR    #SDOTS,X0,SDOT_STORE              ; But if sdots mode,
                            00046C
2015      P:00046B P:00046B 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
2016                                SDOT_STORE
2017      P:00046C P:00046C 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for SDOTS an
d strips
2018      P:00046D P:00046D 0A2020            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe bou
ndary
2019      P:00046E P:00046E 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            00048E
2020      P:000470 P:000470 0D02F5            JSR     <CLR_CCD                          ; Clear out the CCD
2021      P:000471 P:000471 0D03D7            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2022                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2023      P:000472 P:000472 4CB800            MOVE                          Y:<IFRAMES,X0
2024      P:000473 P:000473 4C3C00            MOVE                          X0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
2025      P:000474 P:000474 0D04DF  SD_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2026      P:000475 P:000475 0A00A8            JSET    #TRIGGER,X:STATUS,SDX_END         ; If no triggering jump to expose image func
tion
                            00047E
2027      P:000477 P:000477 67F400            MOVE              #SDX_END,R7             ; Store the Address into R7
                            00047E
2028      P:000479 P:000479 0A0027            BSET    #ST_EXP,X:<STATUS
2029      P:00047A P:00047A 0C030F            JMP     <EXPOSE                           ; Delay for specified exposure time
2030      P:00047B P:00047B 0A0007            BCLR    #ST_EXP,X:<STATUS
2031      P:00047C P:00047C 0A00A8            JSET    #ST_ABRT,X:<STATUS,SDX_FINI       ; got abort underway?
                            00048B
2032      P:00047E P:00047E 0D03D1  SDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2033      P:00047F P:00047F 0D04E6            JSR     <C_CSHUT                          ; Close shutter if open-close is set
2034      P:000480 P:000480 0A0024            BSET    #ST_RDC,X:<STATUS
2035      P:000481 P:000481 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD.
2036      P:000482 P:000482 0A0004            BCLR    #ST_RDC,X:<STATUS
2037                                                                                    ; No FT or parallel skip since STORAGE=1
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 38



2038      P:000483 P:000483 0D03D7            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2039      P:000484 P:000484 200013            CLR     A
2040      P:000485 P:000485 58BC00            MOVE                          Y:<IFLPCNT,A0
2041      P:000486 P:000486 00000A            DEC     A                                 ; Get loop count, decrement, and loop till z
ero
2042      P:000487 P:000487 000000            NOP
2043      P:000488 P:000488 583C00            MOVE                          A0,Y:<IFLPCNT
2044      P:000489 P:000489 200003            TST     A
2045      P:00048A P:00048A 0E2474            JNE     SD_LP                             ; End of IFRAMES loop
2046                                SDX_FINI
2047      P:00048B P:00048B 0D04E8            JSR     <CSHUT                            ; Unconditionally close shutter
2048      P:00048C P:00048C 0AF080            JMP     CLEANUP                           ; clean up after command.
                            000496
2049   
2050                                ; Fast/Pipeline Occultations NOT supported- LMI isn't a fast camera
2051                                        COMMENT *
2052   
2053                                FPO_PROC                                        ; Used by fast and pipelined occultation modes
2054                                        MOVE    Y:<NP_READ,X0
2055                                        MOVE    X0,Y:<SROWS                     ; Make sure that SROWS=NP_READ
2056                                        JSR     UB_CONV                         ; Fill in unbinned SROWS in UBSROWS
2057                                        BCLR    #OPEN_CLOSE,X:<ISTATUS          ; clear open-close for both of these modes
2058                                        BCLR    #STORAGE,X:<ISTATUS             ; Storage clocks only during readout
2059                                        BSET    #NO_SKIP,X:<ISTATUS             ; Don't parallel skip up to the subframe boundar
y
2060                                        JSR     IMG_INI                         ; Set up the status bits and PCI card
2061                                        JSR     <CLR_CCD                        ; Clear out the CCD
2062                                        JSR     <WAIT_WHILE_TRIGGER             ; wait for low trigger, or
2063                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2064                                        JSR     <C_OSHUT                        ; Open shutter if not a dark frame
2065                                        MOVE    Y:<IFRAMES,X0
2066                                        MOVE    X0,Y:<IFLPCNT                   ; Set up 24-bit loop counter in IFLPCNT
2067                                FP_LP   JSET    #TRIGGER,X:STATUS,FPO_END       ; If no triggering jump to expose image function
2068                                        MOVE    #FPO_END,R7                     ; Store the Address into R7
2069                                        BSET    #ST_EXP,X:<STATUS
2070                                        JMP     <EXPOSE                         ; Delay for specified exposure time
2071                                        BCLR    #ST_EXP,X:<STATUS
2072                                        JSET    #ST_ABRT,X:<STATUS,FPO_FINI     ; got abort underway?
2073                                FPO_END JSR     <WAIT_UNTIL_TRIGGER             ; wait for high trigger or fall through
2074                                        MOVE    Y:<UBSROWS,X1                   ; Shift down UBSROWS unbinned rows
2075                                        JSR     ISHIFT                          ; Clock down subframe height
2076                                        MOVE    X:IMAGE_MODE,X0
2077                                        JSET    #P_OCC,X0,FPO_RD        ; Shift the rest of the way for F_OCC
2078                                                                                ; Go straight to readout if P_OCC
2079                                        MOVE    Y:S_SIZE,X0
2080                                        MOVE    X0,A                            ; Get only least significant 24 bits
2081                                        MOVE    Y:<UBSROWS,X0
2082                                        SUB     X0,A                            ;
2083                                        NOP                                     ; 56300 pipeline as per July 5 #4
2084                                        MOVE    A,X1                            ; X1 = S_SIZE - UBSROWS
2085                                        JSR     SSHIFT                          ; Clock storage the rest of the way
2086                                        BSET    #ST_RDC,X:<STATUS
2087                                FPO_RD  JSR     <RCCD1                          ; Finally, read out the CCD.  Skip the FT
2088                                        BCLR    #ST_RDC,X:<STATUS
2089                                        MOVE    X:IMAGE_MODE,X0
2090                                        JSET    #F_OCC,X0,FPO_SK        ; Shift back up by UBSROWS if P_OCC
2091                                        MOVE    Y:<UBSROWS,X1                   ; Shift UBSROWS unbinned rows back up
2092                                        JSR     RSHIFT                          ; Clock subframe height back up
2093                                FPO_SK  JSR     <WAIT_WHILE_TRIGGER             ; wait for low trigger
2094                                        CLR     A
2095                                        MOVE    Y:<IFLPCNT,A0
2096                                        DEC     A                               ; Get loop count, decrement, and loop till zero
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 39



2097                                        NOP                                     ; 56300 pipeline as per July 5 #4
2098                                        MOVE    A0,Y:<IFLPCNT
2099                                        TST     A
2100                                        JNE     FP_LP                           ; End of IFRAMES loop
2101                                FPO_FINI
2102                                        JSR     <CSHUT                          ; Unconditionally close shutter
2103                                        JMP     CLEANUP                         ; clean up after command.
2104                                        *
2105   
2106                                ; Support subroutines and code fragments used in the various mode code
2107                                ; IMG_INI, CLEANUP, ISHIFT, SSHIFT, RSHIFT
2108                                ;  Image initialization subroutine.  Sets up status bits & PCI card
2109                                ; Correct XMT_FO to XMT_WRD in timboot.s and change the input arg to B1
2110                                ; as per "Four Points" #3
2111   
2112      P:00048E P:00048E 55F400  IMG_INI   MOVE              #$020102,B1             ; Transmit header word
                            020102
2113      P:000490 P:000490 0D00EB            JSR     <XMT_WRD
2114      P:000491 P:000491 55F400            MOVE              #'IIA',B1               ; Initialize Image Address
                            494941
2115      P:000493 P:000493 0D00EB            JSR     <XMT_WRD
2116                                ;        BSET    #ST_RDC,X:<STATUS       ; Set status to reading out
2117      P:000494 P:000494 0D0630            JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
2118      P:000495 P:000495 00000C            RTS
2119   
2120                                ; Cleanup code fragment (not a subroutine) for the end all modes.  JMP to it.
2121                                ; remove WW mode reference and also do a CLOCK wait.
2122                                ; support no idling mode as per MLO code.
2123                                ; all as per July 4 confluence #1
2124   
2125                                ;CLEANUP BCLR    #WW,X:PBD               ; Clear WW to 0 for 32-bit commands
2126                                CLEANUP
2127      P:000496 P:000496 0A00AA            JSET    #ST_SBFAIL,X:<STATUS,EXPMODE_IDL
                            0004A2
2128                                ; go to transition bias levels, then to standard levels
2129   
2130                                          IF      @SCP("DACSLOG","SUPPORTED")
2134                                          ENDIF
2135   
2136      P:000498 P:000498 60F400            MOVE              #DACS_TRANS,R0
                            0001CA
2137      P:00049A P:00049A 0BF080            JSR     SET_BIASES
                            000565
2138      P:00049C P:00049C 0A00AA            JSET    #ST_SBFAIL,X:<STATUS,EXPMODE_IDL
                            0004A2
2139                                ; go to standard inverted bias levels, preparation for idling
2140      P:00049E P:00049E 60F400            MOVE              #DACS_INV,R0
                            000165
2141      P:0004A0 P:0004A0 0BF080            JSR     SET_BIASES
                            000565
2142   
2143                                          IF      @SCP("DACSLOG","SUPPORTED")
2156                                          ENDIF
2157   
2158   
2159                                EXPMODE_IDL
2160                                ; Restore the controller to non-image data transfer and idling if necessary
2161      P:0004A2 P:0004A2 0A0082            JCLR    #IDLMODE,X:<STATUS,NO_IDL         ; Don't idle after readout
                            0004A7
2162      P:0004A4 P:0004A4 60F400            MOVE              #IDLE,R0
                            000301
2163      P:0004A6 P:0004A6 0C04A8            JMP     <CLEAN1
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 40



2164      P:0004A7 P:0004A7 305A00  NO_IDL    MOVE              #TST_RCV,R0
2165                                CLEAN1
2166      P:0004A8 P:0004A8 0BF080            JSR     CLOCK_WAIT                        ; so everything is transferred
                            0004BD
2167      P:0004AA P:0004AA 601F00            MOVE              R0,X:<IDL_ADR
2168   
2169                                ;        BCLR    #ST_RDC,X:<STATUS       ; Clear status to NOT reading out
2170      P:0004AB P:0004AB 0A0008            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of any abort flag
2171      P:0004AC P:0004AC 0BF080            JSR     OSHUT                             ; Unconditionally open shutter so slit viewi
ng camera can see slit
                            0004E1
2172      P:0004AE P:0004AE 0C0054            JMP     <START                            ; Wait for a new command
2173   
2174                                ; Shift image and storage areas down by the number of rows in X1
2175                                ISHIFT
2176                                ; NO IMO for LMI
2177                                ;       IF      @SCP("IMOMODE","IMO")
2178                                ;       MOVE    #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2179                                ;       JSR     <CLOCK                  ; IMO
2180                                ;       NOP                             ; IMO
2181                                ;       ENDIF
2182   
2183      P:0004AF P:0004AF 06C500            DO      X1,ISH_LOOP                       ; Number of rows to shift is in X1
                            0004B4
2184      P:0004B1 P:0004B1 68F000            MOVE                          Y:IS_PAR_CLR,R0 ; Ganged clocks with DG running
                            00000F
2185                                ; mitigation 5
2186                                ;        JSET    #STORAGE,X:ISTATUS,GANG_SF  ; if STORAGE == 0 store clocks only
2187                                ;GANG_SF
2188   
2189      P:0004B3 P:0004B3 0D02DA            JSR     <CLOCK                            ; Parallel clocking
2190      P:0004B4 P:0004B4 000000            NOP
2191                                ISH_LOOP
2192      P:0004B5 P:0004B5 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                            000244
2193      P:0004B7 P:0004B7 0D02DA            JSR     <CLOCK
2194                                ;       MOVE    #<IMO_LAST_CLOCK,R0             ; set clocks to 0
2195                                ;       JSR     <CLOCK
2196      P:0004B8 P:0004B8 00000C            RTS                                       ; End of ISHIFT
2197   
2198                                        COMMENT *
2199                                ; Shift storage area only down by the number of rows in X1
2200                                SSHIFT
2201                                ; NO IMO for LMI
2202                                ;       IF      @SCP("IMOMODE","IMO")
2203                                ;       MOVE    #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2204                                ;       JSR     <CLOCK                  ; IMO
2205                                ;       NOP                             ; IMO
2206                                ;       ENDIF
2207                                        DO      X1,SSH_LOOP             ; Number of rows to shift is in X1
2208                                        MOVE    Y:<S_PAR_CLR,R0         ; Storage clocks only with DG running
2209                                        JSR     <CLOCK                  ; Parallel clocking
2210                                        NOP
2211                                SSH_LOOP
2212                                        MOVE    #DUMP_SERIAL,R0         ; clear the SR after parallel clear
2213                                        JSR     <CLOCK
2214                                        RTS                     ; End of SSHIFT
2215   
2216                                ; Used by pipelined occultation mode to move the storage area back up to
2217                                ; the seam following read of a subframe
2218                                RSHIFT
2219                                        IF      @SCP("IMOMODE","IMO")
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timmisc.s  Page 41



2220                                        MOVE    #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2221                                        JSR     <CLOCK                  ; IMO
2222                                        NOP                             ; IMO
2223                                        ENDIF
2224                                        DO      X1,RVS_SHIFT            ; Number of rows to read out
2225                                        MOVE    #<R_S_PARALLEL,R0       ; Reverse parallel waveform
2226                                        JSR     <CLOCK                  ; Parallel clocking
2227                                        NOP
2228                                RVS_SHIFT
2229                                        RTS                     ; End of RSHIFT
2230                                        *
2231                                          INCLUDE "timCCDmisc.s"                    ; Generic
2232                                ; This file is for utilities that are in common to all the timing board
2233                                ;   programs, located starting at P:$200 in external SRAM
2234   
2235                                        COMMENT *
2236   
2237                                The following commands are supported in this "timmisc.s" file
2238                                PAL_DLY                 Subroutine to delay by about 8 microseconds
2239                                SET_DAC                 Transfer DAC values in (R0) table to the DACs
2240                                FASTSKP                 Compute number of waveform table entries in a readout
2241                                                                for fast clocking
2242                                OSHUT                   Subroutine call for opening the shutter
2243                                CSHUT                   Subroutine call for closing the shutter
2244                                OPEN_SHUTTER            Command for opening the shutter
2245                                CLOSE_SHUTTER           Command for closing the shutter
2246                                SET_EXP_TIME            Write desired exposure time to timing board variable
2247                                RD_EXP_TIME             Read elapsed exposure time
2248                                START_EXPOSURE          Start an exposure - 'DON' reply, clear FPA, open
2249                                                        shutter, expose, close shutter, delay Y:SH_DLY, readout
2250                                PAUSE_EXPOSURE          Close shutter, stop exposure timer
2251                                RESUME_EXPOSURE         Open shutter if necessary, resume exposure timer
2252                                ABORT_EXPOSURE          Close shutter, stop exposure timer
2253                                INF                     Return version and timing information
2254                                IDL                     Put FPA to clocking when not processing commands or
2255                                                        reading out
2256                                READ_CONTROLLER_CONFIGURATION
2257   
2258                                PWR_OFF                 Turn off ananlog power supply voltages to backplane
2259                                PWR_ON                  Turn on analog power supply voltages to backplane
2260                                SETBIAS                 Command to call SET_BIASES and reply 'DON'
2261                                SET_BIASES              Subroutine to turn on all bias and clock voltages
2262                                                        by reading them from the waveform tables and writing
2263                                                        them to the DACs
2264                                SER_ANA                 Direct the timing board DSP's synchronous serial
2265                                                        transmitter to the analog boards (clock driver, video)
2266                                SER_UTL                 Direct the timing board DSP's synchronous serial
2267                                                        transmitter to the utility board
2268                                CLR_SWS                 Clear the analog switches in the clock driver and
2269                                                        video boards to lower their power consumption, as a
2270                                                        command with a 'DON' reply
2271                                CLEAR_SWITCHES          A subroutine call for CLR_WSW
2272                                ST_GAIN                 Set the video processor gain to one of four values
2273                                WR_CNTRL
2274                                SET_DC
2275                                SET_BIAS_NUMBER
2276                                SET_MUX
2277   
2278                                        *
2279   
2280                                ; These become a single line macros, as per June 30 #12
2281                                ; Enable serial communication to the analog boards
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timCCDmisc.s  Page 42



2282                                SER_ANA   MACRO
2283 m                                        BSET    #3,X:PCRD                         ; Turn on the serial clock
2284 m                                        ENDM
2285                                ; Enable serial communication to the utility board
2286                                SER_UTL   MACRO
2287 m                                        BCLR    #3,X:PCRD                         ; Turn off the serial clock
2288 m                                        ENDM
2289   
2290   
2291                                ; Delay for serial writes to the PALs and DACs by 8 microsec
2292                                ; Conformed to gen-iii MLO as per CCDmisc comments June 30 #1
2293      P:0004B9 P:0004B9 062083  PAL_DLY   DO      #800,*+3                          ; Wait 8 usec for serial data transmission
                            0004BB
2294      P:0004BB P:0004BB 000000            NOP
2295      P:0004BC P:0004BC 00000C            RTS
2296   
2297                                ; Wait for clocking to be complete before proceeding
2298                                ; Code added as per June 29 #5
2299                                CLOCK_WAIT
2300      P:0004BD P:0004BD 01ADA1            JSET    #SSFEF,X:PDRD,*                   ; Wait for the SS FIFO to be empty
                            0004BD
2301      P:0004BF P:0004BF 00000C            RTS
2302   
2303   
2304   
2305                                ;  Update the DACs
2306                                ; Remove cruft as per June 30 #2
2307      P:0004C0 P:0004C0 4CD800  SET_DAC   MOVE                          Y:(R0)+,X0  ; Get the number of table entries
2308      P:0004C1 P:0004C1 06C400            DO      X0,SET_L0                         ; Repeat X0 times
                            0004C6
2309      P:0004C3 P:0004C3 5ED800            MOVE                          Y:(R0)+,A   ; Send out the waveform
2310      P:0004C4 P:0004C4 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
2311      P:0004C5 P:0004C5 0D04B9            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
2312      P:0004C6 P:0004C6 000000            NOP                                       ; Do loop restriction
2313                                SET_L0
2314      P:0004C7 P:0004C7 00000C            RTS                                       ; Return from subroutine
2315   
2316                                ; Subroutine for computing number of fast clocks needed
2317                                ; remove the offset for gen-iii, as per June 30 general comment #3
2318      P:0004C8 P:0004C8 2000A8  FASTSKP   MPY     X0,X1,B                           ; X1 = number of pixels to skip,
2319                                                                                    ; X0 = number of waveform table entries
2320      P:0004C9 P:0004C9 20002A            ASR     B                                 ; Correct for multiplication left shift
2321      P:0004CA P:0004CA 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2322      P:0004CB P:0004CB 212500            MOVE              B0,X1                   ; Get only least significant 24 bits
2323      P:0004CC P:0004CC 00000C            RTS
2324   
2325                                ; open (X0 = 0) or close (X0=10) shutter, h/w only.
2326                                SET_SHUTTER_STATE
2327      P:0004CD P:0004CD 568F00            MOVE              X:LATCH,A
2328      P:0004CE P:0004CE 0140C6            AND     #$FFEF,A
                            00FFEF
2329      P:0004D0 P:0004D0 200042            OR      X0,A
2330      P:0004D1 P:0004D1 000000            NOP
2331      P:0004D2 P:0004D2 540F00            MOVE              A1,X:LATCH
2332      P:0004D3 P:0004D3 09CC35            MOVEP             A1,Y:WRLATCH
2333      P:0004D4 P:0004D4 00000C            RTS
2334   
2335                                ; Open the shutter from the timing board, executed as a command
2336                                OPEN_SHUTTER
2337      P:0004D5 P:0004D5 0A0023            BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
2338                                ;       MOVE    #0,X0
2339      P:0004D6 P:0004D6 44F400            MOVE              #>$10,X0
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timCCDmisc.s  Page 43



                            000010
2340      P:0004D8 P:0004D8 0D04CD            JSR     <SET_SHUTTER_STATE
2341      P:0004D9 P:0004D9 0C008F            JMP     <FINISH
2342   
2343                                ; Close the shutter from the timing board, executed as a command
2344                                CLOSE_SHUTTER
2345      P:0004DA P:0004DA 0A0003            BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
2346                                ;       MOVE    #>$10,X0
2347      P:0004DB P:0004DB 44F400            MOVE              #>0,X0
                            000000
2348      P:0004DD P:0004DD 0D04CD            JSR     <SET_SHUTTER_STATE
2349      P:0004DE P:0004DE 0C008F            JMP     <FINISH
2350   
2351                                ; Subroutine with two entry points.  C_OSHUT is conditional on SHUT
2352                                ; Open the shutter conditionally based on the shutter status bit #SHUT
2353                                ; This is set by the host using dspwrm to the X:<STATUS unless the frame
2354                                ; is a dark
2355                                ; Open the shutter by calling SET_SHUTTER_STATE
2356                                C_OSHUT
2357      P:0004DF P:0004DF 0A008B            JCLR    #SHUT,X:STATUS,OSH_RTN
                            0004E5
2358                                OSHUT
2359      P:0004E1 P:0004E1 0A0023            BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
2360                                ;       MOVE    #0,X0
2361      P:0004E2 P:0004E2 44F400            MOVE              #>$10,X0
                            000010
2362      P:0004E4 P:0004E4 0D04CD            JSR     <SET_SHUTTER_STATE
2363      P:0004E5 P:0004E5 00000C  OSH_RTN   RTS
2364   
2365                                ; Subroutine with two entry points.  C_CSHUT is conditional on OPEN_CLOSE
2366                                ; Close the shutter conditionally based on the open-close ISTATUS bit
2367                                ; Close the shutter by calling SET_SHUTTER_STATE
2368      P:0004E6 P:0004E6 0A2081  C_CSHUT   JCLR    #OPEN_CLOSE,X:ISTATUS,CSH_RTN     ; Don't close if always open
                            0004F7
2369      P:0004E8 P:0004E8 0A0003  CSHUT     BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
2370                                ;       MOVE    #>$10,X0
2371      P:0004E9 P:0004E9 240000            MOVE              #0,X0
2372      P:0004EA P:0004EA 0D04CD            JSR     <SET_SHUTTER_STATE
2373   
2374                                ; after closing shutter be sure to wait SH_DEL msec to let the blades close
2375                                ; before shifting the CCD array for readout.
2376      P:0004EB P:0004EB 5E8700            MOVE                          Y:<SH_DEL,A
2377      P:0004EC P:0004EC 200003            TST     A
2378      P:0004ED P:0004ED 0EF4F6            JLE     <S_DEL0
2379      P:0004EE P:0004EE 44F400            MOVE              #25000,X0
                            0061A8
2380      P:0004F0 P:0004F0 06CE00            DO      A,S_DEL0                          ; Delay by Y:SH_DEL milliseconds
                            0004F5
2381      P:0004F2 P:0004F2 06C400            DO      X0,S_DEL1
                            0004F4
2382      P:0004F4 P:0004F4 000000            NOP
2383      P:0004F5 P:0004F5 000000  S_DEL1    NOP
2384      P:0004F6 P:0004F6 000000  S_DEL0    NOP
2385   
2386      P:0004F7 P:0004F7 00000C  CSH_RTN   RTS
2387   
2388                                ; Set the desired exposure time
2389                                ;       Correct command ptr to R3 as per "Four Points" #2
2390                                ;       Modify exposure time var name as per June 30 #5
2391                                SET_EXP_TIME
2392      P:0004F8 P:0004F8 44DB00            MOVE              X:(R3)+,X0
2393      P:0004F9 P:0004F9 441000            MOVE              X0,X:<EXPOSURE_TIME
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timCCDmisc.s  Page 44



2394                                ;       MOVE    X0,X:<TGT_TIM
2395      P:0004FA P:0004FA 0C008F            JMP     <FINISH
2396   
2397   
2398                                ; Abort exposure - close the shutter, stop the timer and resume idle mode
2399                                ; Modified to match gen-iii MLO code- as per June 30 #6
2400                                ABORT_EXPOSURE
2401      P:0004FB P:0004FB 0A00A7            JSET    #ST_EXP,X:<STATUS,DO_ABEXP
                            0004FE
2402                                ; assume we got here via the idle rcv loop
2403                                ; not currently exposing, so this is a no-op.
2404      P:0004FD P:0004FD 0C008F            JMP     <FINISH
2405                                DO_ABEXP
2406   
2407      P:0004FE P:0004FE 0D04E8            JSR     <CSHUT                            ; Close the shutter
2408      P:0004FF P:0004FF 010F00            BCLR    #TIM_BIT,X:TCSR0                  ; Disable the DSP exposure timer
2409   
2410                                ; The place to return must be in R7-
2411      P:000500 P:000500 0AE780            JMP     (R7)                              ; 'return' from EXPOSE
2412   
2413   
2414   
2415                                ;       Process INF according to the single addressing parameter
2416                                ;       Correct FINISH1 datum as per "Four Points" #1
2417                                ;       Correct command ptr to R3 as per "Four Points" #2
2418                                GET_INFO
2419      P:000501 P:000501 56DB00            MOVE              X:(R3)+,A               ; 0-4 is generic, >= 0x100 tim specific
2420                                ; Remove for gen-iii per June 6 #2
2421      P:000502 P:000502 47F400            MOVE              #IVERSION,Y1
                            04507F
2422      P:000504 P:000504 46F400            MOVE              #>GET_VERSION,Y0
                            000000
2423      P:000506 P:000506 200055            CMP     Y0,A
2424      P:000507 P:000507 0EA090            JEQ     <FINISH1
2425                                ; Remove for gen-iii per June 6 #2
2426      P:000508 P:000508 47F400            MOVE              #IFLAVOR,Y1
                            612020
2427      P:00050A P:00050A 46F400            MOVE              #>GET_FLAVOR,Y0
                            000001
2428      P:00050C P:00050C 200055            CMP     Y0,A
2429      P:00050D P:00050D 0EA090            JEQ     <FINISH1
2430      P:00050E P:00050E 47F400            MOVE              #ITIME0,Y1
                            003682
2431      P:000510 P:000510 46F400            MOVE              #>GET_TIME0,Y0
                            000002
2432      P:000512 P:000512 200055            CMP     Y0,A
2433      P:000513 P:000513 0EA090            JEQ     <FINISH1                          ; Is it Time0?
2434      P:000514 P:000514 47F400            MOVE              #ITIME1,Y1
                            005388
2435      P:000516 P:000516 46F400            MOVE              #>GET_TIME1,Y0
                            000003
2436      P:000518 P:000518 200055            CMP     Y0,A
2437      P:000519 P:000519 0EA090            JEQ     <FINISH1                          ; Is it Time1?
2438      P:00051A P:00051A 270000            MOVE              #ISVNREV,Y1
2439      P:00051B P:00051B 46F400            MOVE              #>GET_SVNREV,Y0
                            000004
2440      P:00051D P:00051D 200055            CMP     Y0,A
2441      P:00051E P:00051E 0EA090            JEQ     <FINISH1                          ; Is it Svn rev?
2442      P:00051F P:00051F 47F400            MOVE              #TIMCAPABLE,Y1
                            0001C3
2443      P:000521 P:000521 46F400            MOVE              #>GET_CAPABLE,Y0
                            000100
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timCCDmisc.s  Page 45



2444      P:000523 P:000523 200055            CMP     Y0,A
2445      P:000524 P:000524 0EA090            JEQ     <FINISH1                          ; Is it Tim Capabilities?
2446      P:000525 P:000525 47F400            MOVE              #INT_TIM,Y1
                            520000
2447      P:000527 P:000527 46F400            MOVE              #>GET_INT_TIM,Y0
                            000101
2448      P:000529 P:000529 200055            CMP     Y0,A
2449      P:00052A P:00052A 0EA090            JEQ     <FINISH1                          ; Is it Integration time?
2450      P:00052B P:00052B 47F400            MOVE              #R_DELAY,Y1
                            000000
2451      P:00052D P:00052D 46F400            MOVE              #>GET_R_DELAY,Y0
                            000102
2452      P:00052F P:00052F 200055            CMP     Y0,A
2453      P:000530 P:000530 0EA090            JEQ     <FINISH1                          ; Is it Serial time?
2454      P:000531 P:000531 47F400            MOVE              #SI_DELAY,Y1
                            880000
2455      P:000533 P:000533 46F400            MOVE              #>GET_SI_DELAY,Y0
                            000103
2456      P:000535 P:000535 200055            CMP     Y0,A
2457      P:000536 P:000536 0EA090            JEQ     <FINISH1                          ; Is it Parallel time?
2458      P:000537 P:000537 0C008D            JMP     ERROR                             ; unknown info argument
2459   
2460                                ; LMI does not use the thermocooler status bits
2461                                        COMMENT *
2462                                        MOVE    #>GET_TEMP2STS,Y0       ; Is it 2 bit temp status
2463                                        CMP     Y0,A
2464                                        JNE     <ERROR
2465                                        CLR     A
2466                                        JSET    #STS1,X:HDR,GET_STS0
2467                                        ADD     #<2,A
2468                                GET_STS0
2469                                        JSET    #STS0,X:HDR,RES_TEMPS
2470                                        ADD     #<1,A
2471                                RES_TEMPS
2472                                        NOP
2473                                        MOVE    A1,Y1
2474                                        JMP     <FINISH1
2475                                        *
2476   
2477   
2478                                ; Set software to IDLE mode
2479      P:000538 P:000538 44F400  IDL       MOVE              #IDLE,X0                ; Exercise clocks when idling
                            000301
2480      P:00053A P:00053A 441F00            MOVE              X0,X:<IDL_ADR
2481      P:00053B P:00053B 0A0022            BSET    #IDLMODE,X:<STATUS                ; Idle after readout
2482      P:00053C P:00053C 0C008F            JMP     <FINISH                           ; Need to send header and 'DON'
2483   
2484                                ; Come to here on a 'STP' command so 'DON' can be sent
2485   
2486                                ; Let the host computer read the controller configuration
2487                                ;       Correct FINISH1 datum as per "Four Points" #1
2488                                READ_CONTROLLER_CONFIGURATION
2489      P:00053D P:00053D 4F8800            MOVE                          Y:<CONFIG,Y1 ; Just transmit the configuration
2490      P:00053E P:00053E 0C0090            JMP     <FINISH1
2491   
2492                                ; Power off
2493      P:00053F P:00053F 0D058E  PWR_OFF   JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
2494      P:000540 P:000540 0A8922            BSET    #LVEN,X:HDR
2495      P:000541 P:000541 0A8923            BSET    #HVEN,X:HDR
2496      P:000542 P:000542 0C008F            JMP     <FINISH
2497   
2498                                ; Start power-on cycle
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timCCDmisc.s  Page 46



2499                                PWR_ON
2500      P:000543 P:000543 0D058E            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
2501      P:000544 P:000544 0D0557            JSR     <PON                              ; Turn on the power control board
2502      P:000545 P:000545 0A8980            JCLR    #PWROK,X:HDR,PWR_ERR              ; Test if the power turned on properly
                            000554
2503      P:000547 P:000547 200013            CLR     A
2504      P:000548 P:000548 60F400            MOVE              #DACS_INV,R0            ;  standard (IDLE) INV levels here
                            000165
2505   
2506                                          IF      @SCP("DACSLOG","SUPPORTED")
2508                                          ENDIF
2509   
2510      P:00054A P:00054A 5E3E00            MOVE                          A,Y:<DUALDD_STAT
2511      P:00054B P:00054B 0D0565            JSR     <SET_BIASES                       ; Turn on the DC bias supplies
2512   
2513                                          IF      @SCP("DACSLOG","SUPPORTED")
2518                                          ENDIF
2519   
2520      P:00054C P:00054C 60F400            MOVE              #IDLE,R0                ; Put controller in IDLE state
                            000301
2521      P:00054E P:00054E 601F00            MOVE              R0,X:<IDL_ADR
2522   
2523                                ;       as per Confluence July 4 2010 #5
2524      P:00054F P:00054F 312400            MOVE              #$24,R1
2525      P:000550 P:000550 610000            MOVE              R1,X:<STATUS
2526                                ;       as per Confluence July 4 2010 #4 and July 21 note
2527      P:000551 P:000551 4CBB00            MOVE                          Y:<AMPVAL,X0
2528      P:000552 P:000552 0D0326            JSR     <SELECT_OUTPUT_SOURCE
2529      P:000553 P:000553 0C008F            JMP     <FINISH
2530   
2531                                ; The power failed to turn on because of an error on the power control board
2532      P:000554 P:000554 0A8922  PWR_ERR   BSET    #LVEN,X:HDR                       ; Turn off the low voltage emable line
2533      P:000555 P:000555 0A8923            BSET    #HVEN,X:HDR                       ; Turn off the high voltage emable line
2534      P:000556 P:000556 0C008D            JMP     <ERROR
2535   
2536                                ; As a subroutine, turn on the low voltages (+/- 6.5V, +/- 16.5V) and delay
2537      P:000557 P:000557 0A8902  PON       BCLR    #LVEN,X:HDR                       ; Set these signals to DSP outputs
2538      P:000558 P:000558 44F400            MOVE              #2000000,X0
                            1E8480
2539      P:00055A P:00055A 06C400            DO      X0,*+3                            ; Wait 20 millisec for settling
                            00055C
2540      P:00055C P:00055C 000000            NOP
2541   
2542                                ; Turn on the high +36 volt power line and then delay
2543      P:00055D P:00055D 0A8903            BCLR    #HVEN,X:HDR                       ; HVEN = Low => Turn on +36V
2544      P:00055E P:00055E 44F400            MOVE              #2000000,X0
                            1E8480
2545      P:000560 P:000560 06C400            DO      X0,*+3                            ; Wait 20 millisec for settling
                            000562
2546      P:000562 P:000562 000000            NOP
2547      P:000563 P:000563 00000C            RTS
2548   
2549                                ; DeVeny uses VRD2!  Don't mess with it!
2550                                        COMMENT *
2551                                ;prototype code- to set leds on gwaves
2552                                SETVRDS
2553                                        MOVE    X:(R3)+,X0
2554                                        CLR     A
2555                                        MOVE    X0,A
2556                                        AND     #$3FFF,A
2557                                        ADD     #VID0+DAC_RegD,A
2558                                        MOVE    X:(R3)+,X0
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timCCDmisc.s  Page 47



2559                                        MOVE    A1,Y:VRD2_V
2560                                        MOVE    X0,A
2561                                        AND     #$3FFF,A
2562                                        ADD     #VID0+DAC_RegD,A
2563                                        MOVE    #SET_VRD2_3,R0
2564                                        MOVE    A1,Y:VRD3_V
2565                                        JSR     <SET_BIASES
2566                                        JMP     <FINISH
2567                                        *
2568   
2569                                ; This is not accessible from LOIS, so make it a no-op. If it were to be
2570                                ; implemented would need an argument
2571                                ;
2572                                SETBIAS
2573                                ;       MOVE    #DACS,R0                ; Get starting address of DAC values
2574                                ;       JSR     <SET_BIASES
2575      P:000564 P:000564 0C008F            JMP     <FINISH
2576   
2577                                ; Set all the DC bias voltages and video processor offset values, reading
2578                                ;   them from the 'DACS' table provided in R0
2579                                SET_BIASES
2580                                          SER_ANA
2582      P:000566 P:000566 0A0F01            BCLR    #1,X:<LATCH                       ; Separate updates of clock driver
2583      P:000567 P:000567 0A0F20            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
2584      P:000568 P:000568 0A0F22            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
2585      P:000569 P:000569 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                            00000F
2586      P:00056B P:00056B 0D04B9            JSR     <PAL_DLY                          ; Delay for all this to happen
2587   
2588                                ;  VALIDATE X0 here (between 1 and something reasonable)
2589      P:00056C P:00056C 200013            CLR     A
2590      P:00056D P:00056D 5CE000            MOVE                          Y:(R0),A1
2591      P:00056E P:00056E 000000            NOP
2592      P:00056F P:00056F 000000            NOP
2593      P:000570 P:000570 0140C4            SUB     #MAXDACTBL,A
                            0000C8
2594      P:000572 P:000572 0AF0A1            JGE     SB_FAIL
                            000581
2595                                ;       TST     A
2596                                ;       JLT     SB_FAIL
2597                                ;        CLR     A
2598                                ;        CMP     X0,A
2599                                ;        JGE     SB_FAIL
2600   
2601                                ; Read DAC values from a table, and write them to the DACs
2602      P:000574 P:000574 000000            NOP
2603      P:000575 P:000575 065840            DO      Y:(R0)+,L_DAC                     ; Repeat Y:(R0)+ times
                            000579
2604      P:000577 P:000577 5ED800            MOVE                          Y:(R0)+,A   ; Read the table entry
2605   
2606                                          IF      @SCP("DACSLOG","SUPPORTED")
2609                                          ENDIF
2610   
2611      P:000578 P:000578 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
2612      P:000579 P:000579 000000            NOP
2613                                L_DAC
2614      P:00057A P:00057A 5EBE00            MOVE                          Y:<DUALDD_STAT,A
2615      P:00057B P:00057B 000000            NOP
2616      P:00057C P:00057C 014180            ADD     #1,A
2617      P:00057D P:00057D 000000            NOP
2618      P:00057E P:00057E 5E3E00            MOVE                          A,Y:<DUALDD_STAT
2619   
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timCCDmisc.s  Page 48



2620      P:00057F P:00057F 0AF080            JMP     SB_DONE
                            000585
2621   
2622                                SB_FAIL
2623      P:000581 P:000581 56F400            MOVE              #$FFFF,A
                            00FFFF
2624      P:000583 P:000583 000000            NOP
2625      P:000584 P:000584 5E3E00            MOVE                          A,Y:<DUALDD_STAT
2626                                ;        BSET    #ST_SBFAIL,X:<STATUS    ; we don't ever clear this
2627   
2628                                SB_DONE
2629   
2630                                ; Let the DAC voltages all ramp up before exiting
2631      P:000585 P:000585 44F400            MOVE              #400000,X0
                            061A80
2632      P:000587 P:000587 06C400            DO      X0,*+3                            ; 4 millisec delay
                            000589
2633      P:000589 P:000589 000000            NOP
2634                                          SER_UTL
2636      P:00058B P:00058B 00000C            RTS
2637   
2638   
2639                                ; Enable serial communication to the analog boards
2640                                ; This becomes a single line macro above, as per June 30 #12
2641   
2642                                ;SER_ANA        BSET    #0,X:PBD                ; Set H0 for analog boards SSI
2643                                ;       MOVEP   #$0000,X:PCC            ; Software reset of SSI
2644                                ;       BCLR    #10,X:CRB               ; SSI -> continuous clock for analog
2645                                ;       MOVEP   #$0160,X:PCC            ; Re-enable the SSI
2646                                ;       RTS
2647   
2648                                ; Enable serial communication to the utility board
2649                                ; This becomes a single line macro above, as per June 30 #12
2650   
2651                                ;SER_UTL        MOVEP   #$0000,X:PCC            ; Software reset of SSI
2652                                ;       BSET    #10,X:CRB               ; SSI -> gated clock for util board
2653                                ;       MOVEP   #$0160,X:PCC            ; Enable the SSI
2654                                ;       BCLR    #0,X:PBD                ; Clear H0 for utility board SSI
2655                                ;       RTS
2656   
2657      P:00058C P:00058C 0D058E  CLR_SWS   JSR     <CLEAR_SWITCHES
2658      P:00058D P:00058D 0C008F            JMP     <FINISH
2659   
2660                                ; Clear all video processor analog switches to lower their power dissipation
2661                                CLEAR_SWITCHES
2662                                          SER_ANA
2664      P:00058F P:00058F 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                            0C3000
2665      P:000591 P:000591 20001B            CLR     B
2666      P:000592 P:000592 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC write
s
2667      P:000593 P:000593 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writ
es
                            001000
2668      P:000595 P:000595 060F80            DO      #15,L_VIDEO                       ; Fifteen video processor boards maximum
                            00059C
2669      P:000597 P:000597 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
2670      P:000598 P:000598 200040            ADD     X0,A
2671      P:000599 P:000599 5F7000            MOVE                          B,Y:WRSS
                            FFFFF3
2672      P:00059B P:00059B 0D04B9            JSR     <PAL_DLY                          ; Delay for the serial data transmission
2673      P:00059C P:00059C 200068            ADD     X1,B
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timCCDmisc.s  Page 49



2674                                L_VIDEO
2675      P:00059D P:00059D 0A0F00            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
2676      P:00059E P:00059E 0A0F02            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
2677      P:00059F P:00059F 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                            00000F
2678                                          SER_UTL
2680      P:0005A2 P:0005A2 00000C            RTS
2681   
2682                                ; Set the clock multiplexers
2683                                ;       Correct command ptr to R3 as per "Four Points" #2
2684                                SET_MUX
2685                                          SER_ANA                                   ; Set SSI to analog board communication
2687      P:0005A4 P:0005A4 56DB00            MOVE              X:(R3)+,A               ; Clock driver board number
2688      P:0005A5 P:0005A5 0614A0            REP     #20
2689      P:0005A6 P:0005A6 200033            LSL     A
2690      P:0005A7 P:0005A7 44F400            MOVE              #$003000,X0
                            003000
2691      P:0005A9 P:0005A9 200042            OR      X0,A
2692      P:0005AA P:0005AA 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2693      P:0005AB P:0005AB 21C500            MOVE              A,X1                    ; Move here for storage
2694   
2695                                ; Get the first MUX number
2696      P:0005AC P:0005AC 56DB00            MOVE              X:(R3)+,A               ; Get the first MUX number
2697      P:0005AD P:0005AD 0AF0A9            JLT     ERR_SM1
                            0005F4
2698      P:0005AF P:0005AF 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                            000018
2699      P:0005B1 P:0005B1 200045            CMP     X0,A
2700      P:0005B2 P:0005B2 0AF0A1            JGE     ERR_SM1
                            0005F4
2701      P:0005B4 P:0005B4 21CF00            MOVE              A,B
2702      P:0005B5 P:0005B5 44F400            MOVE              #>7,X0
                            000007
2703      P:0005B7 P:0005B7 20004E            AND     X0,B
2704      P:0005B8 P:0005B8 44F400            MOVE              #>$18,X0
                            000018
2705      P:0005BA P:0005BA 200046            AND     X0,A
2706      P:0005BB P:0005BB 0E25BE            JNE     <SMX_1                            ; Test for 0 <= MUX number <= 7
2707      P:0005BC P:0005BC 0ACD63            BSET    #3,B1
2708      P:0005BD P:0005BD 0C05C9            JMP     <SMX_A
2709      P:0005BE P:0005BE 44F400  SMX_1     MOVE              #>$08,X0
                            000008
2710      P:0005C0 P:0005C0 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
2711      P:0005C1 P:0005C1 0E25C4            JNE     <SMX_2
2712      P:0005C2 P:0005C2 0ACD64            BSET    #4,B1
2713      P:0005C3 P:0005C3 0C05C9            JMP     <SMX_A
2714      P:0005C4 P:0005C4 44F400  SMX_2     MOVE              #>$10,X0
                            000010
2715      P:0005C6 P:0005C6 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
2716      P:0005C7 P:0005C7 0E25F4            JNE     <ERR_SM1
2717      P:0005C8 P:0005C8 0ACD65            BSET    #5,B1
2718      P:0005C9 P:0005C9 20006A  SMX_A     OR      X1,B1                             ; Add prefix to MUX numbers
2719      P:0005CA P:0005CA 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2720      P:0005CB P:0005CB 21A700            MOVE              B1,Y1
2721   
2722                                ; Add on the second MUX number
2723      P:0005CC P:0005CC 56DB00            MOVE              X:(R3)+,A               ; Get the next MUX number
2724      P:0005CD P:0005CD 0AF0A9            JLT     ERR_SM2
                            0005F5
2725      P:0005CF P:0005CF 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                            000018
2726      P:0005D1 P:0005D1 200045            CMP     X0,A
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timCCDmisc.s  Page 50



2727      P:0005D2 P:0005D2 0AF0A1            JGE     ERR_SM2
                            0005F5
2728      P:0005D4 P:0005D4 0606A0            REP     #6
2729      P:0005D5 P:0005D5 200033            LSL     A
2730      P:0005D6 P:0005D6 44F400            MOVE              #$1C0,X0
                            0001C0
2731      P:0005D8 P:0005D8 21CF00            MOVE              A,B
2732      P:0005D9 P:0005D9 20004E            AND     X0,B
2733      P:0005DA P:0005DA 44F400            MOVE              #>$600,X0
                            000600
2734      P:0005DC P:0005DC 200046            AND     X0,A
2735      P:0005DD P:0005DD 0E25E0            JNE     <SMX_3                            ; Test for 0 <= MUX number <= 7
2736      P:0005DE P:0005DE 0ACD69            BSET    #9,B1
2737      P:0005DF P:0005DF 0C05EB            JMP     <SMX_B
2738      P:0005E0 P:0005E0 44F400  SMX_3     MOVE              #>$200,X0
                            000200
2739      P:0005E2 P:0005E2 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
2740      P:0005E3 P:0005E3 0E25E6            JNE     <SMX_4
2741      P:0005E4 P:0005E4 0ACD6A            BSET    #10,B1
2742      P:0005E5 P:0005E5 0C05EB            JMP     <SMX_B
2743      P:0005E6 P:0005E6 44F400  SMX_4     MOVE              #>$400,X0
                            000400
2744      P:0005E8 P:0005E8 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
2745      P:0005E9 P:0005E9 0E25F5            JNE     <ERR_SM2
2746      P:0005EA P:0005EA 0ACD6B            BSET    #11,B1
2747      P:0005EB P:0005EB 200078  SMX_B     ADD     Y1,B                              ; Add prefix to MUX numbers
2748                                ; change to match gen-iii, as per June 30, #14
2749      P:0005EC P:0005EC 000000            NOP
2750      P:0005ED P:0005ED 21AE00            MOVE              B1,A
2751      P:0005EE P:0005EE 0140C6            AND     #$F01FFF,A                        ; Just to be sure
                            F01FFF
2752      P:0005F0 P:0005F0 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
2753   
2754      P:0005F1 P:0005F1 0D04B9            JSR     <PAL_DLY                          ; Delay for all this to happen
2755                                          SER_UTL                                   ; Return SSI to utility board communication
2757      P:0005F3 P:0005F3 0C008F            JMP     <FINISH
2758      P:0005F4 P:0005F4 56DB00  ERR_SM1   MOVE              X:(R3)+,A
2759                                ERR_SM2
2760                                          SER_UTL                                   ; Return SSI to utility board communication
2762      P:0005F6 P:0005F6 0C008D            JMP     <ERROR
2763   
2764   
2765                                ; Set the video processor gain and integrator speed for all video boards
2766                                ; Now modified as per manual for ARC-47 (1E) video board and ARC-E2V57
2767                                ; sample code
2768                                ;  Command syntax is  SGN [ #BD]  #GAIN  #SPEED, #GAIN = 0-15 (1.0-4.75)
2769                                ;                                         #SPEED = 1-15
2770                                ;       Correct command ptr to R3 as per "Four Points" #2
2771                                ;  fixes to match gen-iii as per June 30, #15
2772                                ; replaced with ARC version for E2V57- except BD is set unconditionally
2773                                ; to 0 for backwards compatibility at the LOIS end.
2774                                ;
2775   
2776                                ST_GAIN
2777                                ;       MOVE    X:(R3)+,A       ; Board number
2778                                ;       LSL     #20,A
2779      P:0005F7 P:0005F7 200013            CLR     A                                 ; Video bd must be at 0.
2780      P:0005F8 P:0005F8 240D00            MOVE              #$0D0000,X0
2781      P:0005F9 P:0005F9 218500            MOVE              A1,X1
2782      P:0005FA P:0005FA 200042            OR      X0,A
2783      P:0005FB P:0005FB 44DB00            MOVE              X:(R3)+,X0              ; Gain
2784      P:0005FC P:0005FC 200042            OR      X0,A
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timCCDmisc.s  Page 51



2785                                ;
2786      P:0005FD P:0005FD 000000            NOP
2787      P:0005FE P:0005FE 5E7000            MOVE                          A,Y:DAC_GNSPD
                            000133
2788                                ;        JSR     <XMIT_A_WORD    ; Transmit A to TIM-A-STD
2789   
2790      P:000600 P:000600 56DB00            MOVE              X:(R3)+,A               ; Time constant (speed)
2791      P:000601 P:000601 0C1E88            LSL     #4,A
2792      P:000602 P:000602 200062            OR      X1,A1                             ; Board number is in bits #23-20
2793      P:000603 P:000603 44F400            MOVE              #$0C0100,X0
                            0C0100
2794      P:000605 P:000605 200042            OR      X0,A
2795      P:000606 P:000606 000000            NOP
2796      P:000607 P:000607 5E3D00            MOVE                          A,Y:<TESTLOC1 ; debug
2797      P:000608 P:000608 5E7000            MOVE                          A,Y:DAC_GNSPD+1
                            000134
2798                                ;        JSR     <XMIT_A_WORD    ; Transmit A to TIM-A-STD
2799      P:00060A P:00060A 0C008F            JMP     <FINISH
2800   
2801   
2802                                ; traditional gain-speed code
2803                                        COMMENT *
2804   
2805                                ;       SER_ANA ; Set SSI to analog board communication
2806                                        MOVE    X:(R3)+,A       ; Gain value (1,2,5 or 10)
2807                                ; making this a no-op for now
2808                                        MOVE    X:(R3)+,A       ; Gain value (1,2,5 or 10)
2809                                        JMP     <FINISH
2810                                        MOVE    #>1,X0
2811                                        CMP     X0,A            ; Check for gain = x1
2812                                        JNE     <STG2
2813                                        MOVE    #>$77,B
2814                                        JMP     <STG_A
2815                                STG2    MOVE    #>2,X0          ; Check for gain = x2
2816                                        CMP     X0,A
2817                                        JNE     <STG5
2818                                        MOVE    #>$BB,B
2819                                        JMP     <STG_A
2820                                STG5    MOVE    #>5,X0          ; Check for gain = x5
2821                                        CMP     X0,A
2822                                        JNE     <STG10
2823                                        MOVE    #>$DD,B
2824                                        JMP     <STG_A
2825                                STG10   MOVE    #>10,X0         ; Check for gain = x10
2826                                        CMP     X0,A
2827                                        JNE     <ERROR
2828                                        MOVE    #>$EE,B
2829   
2830                                STG_A   MOVE    X:(R3)+,A       ; Integrator Speed (0 for slow, 1 for fast)
2831                                        NOP
2832                                        JCLR    #0,A1,STG_B
2833                                        BSET    #8,B1
2834                                        NOP
2835                                        BSET    #9,B1
2836                                STG_B   MOVE    #$0C3C00,X0
2837                                        OR      X0,B
2838                                        NOP
2839                                        MOVE    B,Y:<GAIN       ; Store the GAIN value for later us
2840   
2841                                ; Send this same value to 15 video processor boards whether they exist or not
2842                                        MOVE    #$100000,X0     ; Increment value
2843                                        DO      #15,STG_LOOP
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timCCDmisc.s  Page 52



2844                                        MOVE    B1,A1
2845                                        JSR     <XMIT_A_WORD    ; Transmit A to TIM-A-STD
2846   
2847                                ;       MOVE    B,X:SSITX       ; Transmit the SSI word
2848                                        JSR     <PAL_DLY        ; Wait for SSI and PAL to be empty
2849                                        ADD     X0,B            ; Increment the video processor board number
2850                                        NOP
2851                                STG_LOOP
2852   
2853                                        SER_UTL                 ; Return SSI to utility board communication
2854                                        JMP     <FINISH
2855                                        *
2856   
2857   
2858                                ; Specify subarray readout coordinates, one rectangle only
2859                                ; Call this subroutine BEFORE SET_SUBARRAY_POSITIONS since it
2860                                ; initializes NBOXES
2861                                ;       Correct command ptr to R3 as per "Four Points" #2
2862                                SET_SUBARRAY_SIZES
2863      P:00060B P:00060B 200013            CLR     A
2864      P:00060C P:00060C 44DB00            MOVE              X:(R3)+,X0
2865      P:00060D P:00060D 5E1A00            MOVE                          A,Y:<NBOXES ; Number of subimage boxes = 0 to start
2866      P:00060E P:00060E 4C1B00            MOVE                          X0,Y:<NR_BIAS ; Number of bias pixels to read
2867      P:00060F P:00060F 44DB00            MOVE              X:(R3)+,X0
2868      P:000610 P:000610 4C1C00            MOVE                          X0,Y:<NS_READ ; Number of columns in subimage read
2869      P:000611 P:000611 44DB00            MOVE              X:(R3)+,X0
2870      P:000612 P:000612 4C1D00            MOVE                          X0,Y:<NP_READ ; Number of rows in subimage read
2871      P:000613 P:000613 0C008F            JMP     <FINISH
2872   
2873                                ; Call this routine once for every subarray to be added to the table
2874                                ; Note that the way the variables are arranged the subframes all are the
2875                                ; same dimensions.  They also cannot overlap in the row direction.
2876                                ; SET_SUBARRAY_SIZES must be called first to initialize NBOXES
2877                                SET_SUBARRAY_POSITIONS
2878      P:000614 P:000614 4C9A00            MOVE                          Y:<NBOXES,X0 ; Next available slot
2879      P:000615 P:000615 459400            MOVE              X:<THREE,X1
2880      P:000616 P:000616 2000A0            MPY     X0,X1,A
2881      P:000617 P:000617 200022            ASR     A
2882      P:000618 P:000618 210C00            MOVE              A0,A1
2883                                ; PARAMETERIZE
2884      P:000619 P:000619 44F400            MOVE              #>21,X0
                            000015
2885      P:00061B P:00061B 200045            CMP     X0,A
2886      P:00061C P:00061C 0E708D            JGT     <ERROR                            ; Error if number of boxes > 9
2887      P:00061D P:00061D 44F400            MOVE              #READ_TABLE,X0
                            00001E
2888      P:00061F P:00061F 200040            ADD     X0,A
2889      P:000620 P:000620 44DB00            MOVE              X:(R3)+,X0
2890      P:000621 P:000621 219700            MOVE              A1,R7
2891      P:000622 P:000622 000000            NOP
2892      P:000623 P:000623 000000            NOP
2893      P:000624 P:000624 000000            NOP
2894      P:000625 P:000625 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of rows (parallels) to clear
2895      P:000626 P:000626 44DB00            MOVE              X:(R3)+,X0
2896      P:000627 P:000627 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears before
2897      P:000628 P:000628 44DB00            MOVE              X:(R3)+,X0              ;  the box readout
2898      P:000629 P:000629 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears after
2899      P:00062A P:00062A 5E9A00            MOVE                          Y:<NBOXES,A ;  the box readout
2900      P:00062B P:00062B 449200            MOVE              X:<ONE,X0
2901      P:00062C P:00062C 200040            ADD     X0,A                              ; Update the next available slot position
2902      P:00062D P:00062D 000000            NOP
2903      P:00062E P:00062E 5E1A00            MOVE                          A,Y:<NBOXES
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  timCCDmisc.s  Page 53



2904      P:00062F P:00062F 0C008F            JMP     <FINISH
2905   
2906                                ; Alert the PCI interface board that images are coming soon
2907                                ; This tells the PCI card how many pixels to expect for each SEX command
2908                                ; This is fairly complex.  The first value sent is NPR*IFRAMES (NAXIS2*NAXIS3).
2909                                ; The second value is NSR aka NAXIS1, but if NBOXES > 0, it is NSR*NBOXES
2910                                ; this matches nasa42, but since naxis1,2 for a full frame is > 2^12
2911                                ; there's a max of 1024 for IFRAMES. If we used an adaptive algorithm we
2912                                ; could do better.
2913                                ; Meantime LOIS will have to enforce these limits.
2914   
2915                                ; Correct XMT_FO to XMT_WRD in timboot.s and change the input arg to B1
2916                                ; as per "Four Points" #3
2917                                PCI_READ_IMAGE
2918      P:000630 P:000630 55F400            MOVE              #$020104,B1             ; Send header word to the FO transmitter
                            020104
2919      P:000632 P:000632 0D00EB            JSR     <XMT_WRD
2920      P:000633 P:000633 55F400            MOVE              #'RDA',B1
                            524441
2921      P:000635 P:000635 0D00EB            JSR     <XMT_WRD
2922      P:000636 P:000636 4CF000            MOVE                          Y:NPR,X0    ; NPR = NAXIS2
                            000002
2923      P:000638 P:000638 4DF000            MOVE                          Y:IFRAMES,X1 ; IFRAMES = NAXIS3
                            000038
2924      P:00063A P:00063A 2000A8            MPY     X0,X1,B
2925      P:00063B P:00063B 20002A            ASR     B                                 ; Correct for multiplication left shift
2926      P:00063C P:00063C 212D00            MOVE              B0,B1
2927      P:00063D P:00063D 0D00EB            JSR     <XMT_WRD                          ; Send NPR*IFRAMES to PCI card
2928      P:00063E P:00063E 4CF000            MOVE                          Y:NSR,X0    ; NSR = NAXIS1
                            000001
2929      P:000640 P:000640 5E9A00            MOVE                          Y:<NBOXES,A ; If NBOXES = 0, transmit that to PCI
2930      P:000641 P:000641 208D00            MOVE              X0,B1
2931      P:000642 P:000642 200003            TST     A
2932      P:000643 P:000643 0AF0AA            JEQ     XMT
                            000649
2933      P:000645 P:000645 4D9A00            MOVE                          Y:<NBOXES,X1 ; If NBOXES = 0, transmit that to PCI
2934      P:000646 P:000646 2000A8            MPY     X0,X1,B                           ; If not, multiply by NBOXES, then send
2935      P:000647 P:000647 20002A            ASR     B                                 ; Correct for multiplication left shift
2936      P:000648 P:000648 212D00            MOVE              B0,B1                   ; Get only least significant 24 bits
2937      P:000649 P:000649 000000  XMT       NOP
2938      P:00064A P:00064A 0D00EB            JSR     <XMT_WRD
2939      P:00064B P:00064B 00000C            RTS
2940   
2941                                 TIMBOOT_X_MEMORY
2942      00064C                              EQU     @LCV(L)
2943   
2944                                ;  ****************  Setup memory tables in X: space ********************
2945   
2946                                ; Define the address in P: space where the table of constants begins
2947   
2948                                          IF      @SCP("HOST","HOST")
2949      X:000036 X:000036                   ORG     X:END_COMMAND_TABLE,X:END_COMMAND_TABLE
2950                                          ENDIF
2951   
2952                                          IF      @SCP("HOST","ROM")
2954                                          ENDIF
2955   
2956      X:000036 X:000036                   DC      'IDL',IDL                         ; Put CCD in IDLE mode
2957                                ; Remove for gen-iii since it is in timboot as per June 30 #9
2958                                ;       DC      'STP',STP               ; Exit IDLE mode
2959                                ;       DC      'SVR',SETVRDS           ; set VRD2,3
2960      X:000038 X:000038                   DC      'SBV',SETBIAS                     ; Set DC bias supply voltages
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  tim.s  Page 54



2961      X:00003A X:00003A                   DC      'RDC',RDCCD                       ; Begin CCD readout
2962      X:00003C X:00003C                   DC      'CLR',CLEAR                       ; Fast clear the CCD
2963      X:00003E X:00003E                   DC      'SGN',ST_GAIN                     ; Set video processor gain
2964      X:000040 X:000040                   DC      'SMX',SET_MUX                     ; Set clock driver MUX output
2965   
2966      X:000042 X:000042                   DC      'ABR',ABR_RDC                     ; Abort readout
2967      X:000044 X:000044                   DC      'CRD',CONT_RD                     ; Continue reading out
2968      X:000046 X:000046                   DC      'CSW',CLR_SWS                     ; Clear analog switches to lower power
2969      X:000048 X:000048                   DC      'SOS',SEL_OS                      ; Select output source
2970      X:00004A X:00004A                   DC      'RCC',READ_CONTROLLER_CONFIGURATION
2971      X:00004C X:00004C                   DC      'SSS',SET_SUBARRAY_SIZES
2972      X:00004E X:00004E                   DC      'SSP',SET_SUBARRAY_POSITIONS
2973      X:000050 X:000050                   DC      'DON',START                       ; Nothing special
2974      X:000052 X:000052                   DC      'OSH',OPEN_SHUTTER
2975      X:000054 X:000054                   DC      'CSH',CLOSE_SHUTTER
2976      X:000056 X:000056                   DC      'PON',PWR_ON                      ; Turn on all camera biases and clocks
2977      X:000058 X:000058                   DC      'POF',PWR_OFF                     ; Turn +/- 15V power supplies off
2978      X:00005A X:00005A                   DC      'SET',SET_EXP_TIME                ; Set exposure time
2979      X:00005C X:00005C                   DC      'SEX',START_FT_EXPOSURE           ; Goes to mode-dependent jump table
2980      X:00005E X:00005E                   DC      'AEX',ABORT_EXPOSURE
2981      X:000060 X:000060                   DC      'STG',SET_TRIGGER                 ;  Set Trigger Mode on or off
2982      X:000062 X:000062                   DC      'SIP',SET_IMAGE_PARAM
2983      X:000064 X:000064                   DC      'SRC',SET_ROWS_COLUMNS            ; Set NSR, NPR, and binning
2984      X:000066 X:000066                   DC      'INF',GET_INFO                    ; info command for versioning and more
2985   
2986                                 END_APPLICATON_COMMAND_TABLE
2987      000068                              EQU     @LCV(L)
2988   
2989                                          IF      @SCP("HOST","HOST")
2990      000020                    NUM_COM   EQU     (@LCV(R)-COM_TBL_R)/2             ; No. of boot & application commands
2991                                ;EXPOSING                EQU     CHK_TIM                 ; Address if exposing
2992                                ;CONTINUE_READING        EQU     RDCCD                   ; Address if reading out
2993                                          ENDIF
2994   
2995                                ; ***********  DATA AREAS - READOUT PARAMETERS AND WAVEFORMS  ************
2996                                          IF      @SCP("HOST","HOST")
2997      X:000080 X:000080                   ORG     X:IMGVAR_ADR,X:IMGVAR_ADR
2998      X:000080 X:000080         IMAGE_MODE DC     0
2999                                ; ISTATUS                       DC              0
3000                                ; bum an unused location in low X: for ISTATUS so JSETs work
3001                                ; as per Confluence July 5 #3
3002      000020                    ISTATUS   EQU     EXP_ADR                           ; dangerous!
3003   
3004                                ; some X: variables removed as per Confluence July 1 #4
3005                                ;DSP_VERS       DC      VERSION ; code version must stay in loc,n 102!!
3006                                ;DSP_FLAV       DC      FLAVOR ;  type of dsp support must stay in loc,n 103!!
3007                                ; The next three locations are for tracking the readout timing for gain
3008                                ; calculation, exp-int calculation, and greed factor calculation
3009                                ; They are locations 0x104, 105, and 106
3010                                ;INTTIM         DC      INT_TIM ; per-pixel integration in Leach units
3011                                ;RDELAY         DC      R_DELAY ; serial overlap in Leach units
3012                                ;SIDELAY                DC      SI_DELAY ; parallel overlap in Leach units
3013   
3014                                ;BINBIT         DC      2       ; Bit representation of bin factor, bits 1-5
3015                                                                                    ; 2 = bit 1 set. Bit zero not used.
3016                                ; bum a rarely used location in low X: for BINBIT so JSETs work
3017                                ; as per Confluence July 5 #5
3018      00001E                    BINBIT    EQU     C100K                             ; dangerous!
3019                                                                                    ; Bit representation of bin factor, bits 1-5
3020                                                                                    ; 2 = bit 1 set. Bit zero not used.
3021   
3022                                          IF      @SCP("DACSLOG","SUPPORTED")
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  tim.s  Page 55



3027                                          ENDIF
3028   
3029                                 END_APPLICATION_X_MEMORY
3030      000081                              EQU     @LCV(L)
3031                                          ENDIF
3032   
3033                                          IF      @SCP("HOST","HOST")
3034      Y:000000 Y:000000                   ORG     Y:0,Y:0                           ; Download address
3035                                          ELSE
3037                                          ENDIF
3038   
3039                                ; NSR, NPR, NSBIN, and NPBIN are set by SET_ROWS_COLUMNS
3040      Y:000000 Y:000000         GAIN      DC      0                                 ; Video processor gain and integrator speed
3041      Y:000001 Y:000001         NSR       DC      280                               ; Number Serial Read, prescan + image + bias
3042      Y:000002 Y:000002         NPR       DC      264                               ; Number Parallel Read
3043                                ;NS_CLR DC      280             ; To clear serial register, twice
3044                                          IF      @SCP("2098","2098")
3045      Y:000003 Y:000003         NS_CLR    DC      2100                              ; To clear serial register, twice
3046                                          ENDIF
3047                                          IF      @SCP("515","515")
3048      Y:000004 Y:000004         NPCLR     DC      1030                              ; To clear parallel register, twice
3049                                          ENDIF
3050                                ;NPCLR   DC      528            ; To clear parallel register, twice
3051      Y:000005 Y:000005         NSBIN     DC      1                                 ; Serial binning parameter
3052      Y:000006 Y:000006         NPBIN     DC      1                                 ; Parallel binning parameter
3053                                ;NROWS  DC      264             ; Number of physical rows in CCD
3054                                ;NCOLS  DC      280             ; Number of physical columns in CCD
3055   
3056                                ; Miscellaneous definitions
3057                                ; Delete TST_DAT since it isn't used.  Need the space so S_SIZE doesn't barf.
3058                                ; TST_DAT       DC      0               ; Temporary definition for test images
3059                                          IF      @SCP("100","10")
3063                                          ENDIF
3064                                          IF      @SCP("100","100")
3065      Y:000007 Y:000007         SH_DEL    DC      100                               ; Delay in milliseconds between shutter clos
ing
3066                                                                                    ;   and image readout.  Actual delay is 1.5x
3067                                                                                    ;   as long as advertised, e.g. 4.5 ms for 3
.
3068                                          ENDIF
3069      Y:000008 Y:000008         CONFIG    DC      CC                                ; Controller configuration
3070                                ; Readout peculiarity parameters
3071                                 SERIAL_SKIP
3072      Y:000009 Y:000009                   DC      SERIAL_SKIP_WAVE                  ; Serial skipping waveforms
3073      Y:00000A Y:00000A         SERWAVLEN DC      5                                 ; Serial read waveform table length
3074   
3075                                 SERIAL_CLOCK
3076      Y:00000B Y:00000B                   DC      SERIAL_CLOCK_WAVE                 ; Serial waveform table
3077                                 INITIAL_CLOCK
3078      Y:00000C Y:00000C                   DC      INITIAL_CLOCK_WAVE                ; Serial waveform table
3079      Y:00000D Y:00000D         IS_PAR_CLK DC     PARALLEL                          ; Addr. of ganged parallel clocking
3080      Y:00000E Y:00000E         S_PAR_CLK DC      PARALLEL                          ; Addr. of storage parallel clocking
3081      Y:00000F Y:00000F         IS_PAR_CLR DC     PARALLEL_CLEAR                    ; Addr. of ganged parallel clear
3082      Y:000010 Y:000010         S_PAR_CLR DC      PARALLEL_CLEAR                    ; Addr. of storage parallel clear
3083   
3084   
3085                                 NSERIALS_READ
3086      Y:000011 Y:000011                   DC      0                                 ; Number of serials to read
3087      Y:000012 Y:000012         NSCLR     DC      0                                 ; Number of waveforms in fast mode
3088      Y:000013 Y:000013         NSKIP1    DC      0                                 ; Number of waveforms in fast mode
3089      Y:000014 Y:000014         NREAD     DC      0                                 ; Number of waveforms in fast mode
3090      Y:000015 Y:000015         NSKIP2    DC      0                                 ; Number of waveforms in fast mode
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  tim.s  Page 56



3091      Y:000016 Y:000016         NBIAS     DC      0                                 ; Number of waveforms in fast mode
3092   
3093                                ; These three parameters are read from the READ_TABLE when needed by the
3094                                ;   RDCCD routine as it loops through the required number of boxes
3095      Y:000017 Y:000017         NP_SKIP   DC      0                                 ; Number of rows to skip
3096      Y:000018 Y:000018         NS_SKP1   DC      0                                 ; Number of serials to clear before read
3097      Y:000019 Y:000019         NS_SKP2   DC      0                                 ; Number of serials to clear after read
3098   
3099                                ; Subimage readout parameters. Ten subimage boxes maximum.
3100                                ; All subimage boxes are the same size, NS_READ x NP_READ
3101                                ; NR_BIAS, NS_READ, and NP_READ are set by SET_SUBARRAY_SIZES
3102                                ; The READ_TABLE entries and implicitly NBOXES are set by SET_SUBARRAY_POSITIONS
3103      Y:00001A Y:00001A         NBOXES    DC      0                                 ; Number of boxes to read
3104      Y:00001B Y:00001B         NR_BIAS   DC      0                                 ; Number of bias pixels to read
3105      Y:00001C Y:00001C         NS_READ   DC      0                                 ; Number of columns per box
3106      Y:00001D Y:00001D         NP_READ   DC      0                                 ; Number of rows per box
3107      Y:00001E Y:00001E         READ_TABLE DC     0,0,0                             ; #1 = Number of rows to clear,
3108      Y:000021 Y:000021                   DC      0,0,0                             ; #2 = Number of columns to skip before
3109      Y:000024 Y:000024                   DC      0,0,0                             ;   subimage read
3110      Y:000027 Y:000027                   DC      0,0,0                             ; #3 = Number of columns to clear after
3111      Y:00002A Y:00002A                   DC      0,0,0                             ;   subimage read to get to overscan area
3112      Y:00002D Y:00002D                   DC      0,0,0
3113      Y:000030 Y:000030                   DC      0,0,0
3114      Y:000033 Y:000033                   DC      0,0,0
3115                                ;       DC      0,0,0
3116   
3117                                ; IMAGE_MODE, SROWS, IFRAMES, and INTERVAL are set by SET_IMAGE_PARAM
3118                                ; UBSROWS is set later on by UB_CONV.  S_SIZE is hardwired.
3119      Y:000036 Y:000036         SROWS     DC      1                                 ; Number of Storage image rows to Loop over
3120      Y:000037 Y:000037         UBSROWS   DC      1                                 ; SROWS in unbinned pixels.  Set by UB_CONV
3121      Y:000038 Y:000038         IFRAMES   DC      1                                 ; Number of Series frames to Loop over
3122      Y:000039 Y:000039         S_SIZE    DC      1000                              ; storage area =  half of total rows.  Not u
sed for DeVeny
3123      Y:00003A Y:00003A         INTERVAL  DC      7                                 ; Interval to pause for soft trigger
3124      Y:00003B Y:00003B         AMPVAL    DC      0                                 ; Amplifier selected
3125      Y:00003C Y:00003C         IFLPCNT   DC      0                                 ; 24-bit IFRAMES loop counter for timmisc.s
3126      Y:00003D Y:00003D         TESTLOC1  DC      0                                 ; Test location
3127                                 DUALDD_STAT
3128      Y:00003E Y:00003E                   DC      0
3129                                ; NOTE:  TESTLOC1 is address 63 in the Y memory.  There are addressing problems
3130                                ; starting at the next address (64).
3131   
3132                                ; Include the waveform table
3133                                          INCLUDE "deveny.waveforms.s"              ; Readout and clocking waveforms
3134                                ; Waveform tables and definitions for the e2v CCD42-10 2Kx512 DD CCD for DeVeny
3135                                ; Based on DSP for LMI.  The boards in the two controllers are the same.
3136   
3137                                ; CCD clock voltage definitions
3138      000000                    VIDEO     EQU     $000000                           ; Video processor board select = 0
3139      002000                    CLK2      EQU     $002000                           ; Clock driver board select = 2
3140      003000                    CLK3      EQU     $003000                           ; Clock driver board select = 3
3141      200000                    CLKV      EQU     $200000                           ; Clock driver board DAC voltage selection a
ddress
3142      000000                    VID0      EQU     $000000                           ; Address of video board DACS
3143      0E0000                    DAC_ADDR  EQU     $0E0000                           ; DAC Channel Address
3144      0F4000                    DAC_RegM  EQU     $0F4000                           ; DAC m Register
3145      0F8000                    DAC_RegC  EQU     $0F8000                           ; DAC c Register
3146      0FC000                    DAC_RegD  EQU     $0FC000                           ; DAC X1 Register
3147      1.300000E+001             Vmax      EQU     13.0                              ; Maximum clock driver voltage
3148      0.000000E+000             ZERO      EQU     0.0                               ; Unused pins
3149   
3150   
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 57



3151                                ; For NASA42 we uncommented one of these lines at a time
3152                                ;INT_TIM        EQU     $080000 ; 1.0 us/px - use gain 9.5, clips at PRAM
3153                                ;INT_TIM        EQU     $130000 ; 1.4 us/px - use gain 4.75, clips at PRAM
3154                                ;INT_TIM                EQU     $1D0000 ; 1.8 us/px - use gain 2
3155                                ;INT_TIM        EQU     $2D0000 ; 2.5 us/px - use gain 2, doesn't clip
3156                                ;INT_TIM        EQU     $600000 ; 4.7 us/px - use gain 1; Doesn't clip
3157   
3158                                ; INT_TIM, controlled by Makefile def'n INTTIM_SETTING
3159                                ; as per Confluence July 1 2010 end commentary
3160   
3161                                          IF      @SCP("52","08")
3164                                          ENDIF
3165                                          IF      @SCP("52","13")
3168                                          ENDIF
3169                                          IF      @SCP("52","1D")
3173                                          ENDIF
3174                                          IF      @SCP("52","2D")
3178                                          ENDIF
3179                                          IF      @SCP("52","E")
3182                                          ENDIF
3183                                          IF      @SCP("52","52")
3184                                ; Gen III DeVeny to match full well to ADC.
3185      520000                    INT_TIM   EQU     $520000
3186                                          ENDIF
3187                                          IF      @SCP("52","60")
3190                                          ENDIF
3191   
3192   
3193                                ;ADC_TIM                EQU     $0C0000 ; Slow ADC TIME
3194      000000                    ADC_TIM   EQU     $000000                           ; Fast ADC TIME
3195   
3196   
3197                                ; Delay numbers in clocking
3198                                ;SI_DELAY       EQU     $A70000 ; 25 microsecond parallel delay time
3199   
3200                                ; SI_DELAY, controlled by Makefile def'n SIDELAY_SETTING
3201                                ; as per Confluence July 1 2010 end commentary
3202                                          IF      @SCP("88","88")
3203                                ; 5 us parallel delay time
3204      880000                    SI_DELAY  EQU     $880000                           ; Fast Storage/Image Delay
3205                                          ENDIF
3206                                          IF      @SCP("88","A7")
3209                                          ENDIF
3210   
3211   
3212      880000                    DG_DELAY  EQU     $880000                           ; 25 microsecond dump gate delay time
3213                                ;
3214                                ;R_DELAY                EQU     $060000 ; Fast serial regisiter transfer delay.  Set to $0x06000
0.
3215   
3216                                ; R_DELAY, controlled by Makefile def'n RDELAY_SETTING
3217                                ; as per Confluence July 1 2010 end commentary
3218                                          IF      @SCP("00","00")
3219   
3220      000000                    R_DELAY   EQU     $000000                           ; Fast serial register transfer delay
3221                                          ENDIF
3222                                          IF      @SCP("00","06")
3224                                          ENDIF
3225   
3226   
3227      030000                    CDS_TIM   EQU     $030000                           ; Delay for single clock between reset & dat
a
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 58



3228   
3229                                ; bitwise symbols for integrator manipulation.
3230                                ; Video processor bit definition
3231                                ;             6     5    4     3      2        1         0
3232                                ;            xfer, A/D, integ, Pol-, fixed 0, DCrestore, rst (1 => switch open)
3233                                ; for the ARC-47 1C (incl. all of gen-ii) it was
3234                                ;            xfer, A/D, integ, Pol+, Pol-,    DCrestore, rst (1 => switch open)
3235   
3236                                ; goes with VIDEO
3237      000078                    INT_INIT  EQU     %1111000                          ; Change nearly everything
3238                                ; goes with VIDEO
3239      00007B                    INT_RSTOFF EQU    %1111011                          ; Stop resetting integrator
3240                                ; goes with VIDEO and INT_TIM
3241      00000B                    INT_MINUS EQU     %0001011                          ; Integrate reset level
3242                                ; goes with VIDEO
3243      000013                    INT_STOP  EQU     %0010011                          ; Stop Integrate
3244                                ; goes with VIDEO and INT_TIM
3245      000003                    INT_PLUS  EQU     %0000011                          ; Integrate signal level
3246                                ; goes with VIDEO and ADC_TIM
3247      000013                    INT_SMPL  EQU     %0010011                          ; Stop integrate, A/D is sampling
3248                                ; goes with VIDEO
3249      000010                    INT_DCR   EQU     %0010000                          ; Reset integ. and DC restore
3250   
3251   
3252                                ; DEEP DEPLETION LEVELS
3253                                ; These are available for use during integration & readout
3254   
3255                                ; Clock voltages in volts
3256      9.000000E+000             RG_HI_D   EQU     +9.0                              ; Reset
3257      -3.000000E+000            RG_LO_D   EQU     -3.0                              ;
3258      8.000000E+000             R_HI_D    EQU     +8.0                              ; Serials
3259      -2.000000E+000            R_LO_D    EQU     -2.0                              ;
3260      8.000000E+000             SW_HI_D   EQU     +8.0                              ; Summing well, mode 1
3261      -2.000000E+000            SW_LO_D   EQU     -2.0                              ;
3262      9.000000E+000             SI_HI_D   EQU     +9.0                              ; Parallels
3263      -3.000000E+000            SI_LO_D   EQU     -3.0                              ;
3264      9.000000E+000             DG_HI_D   EQU     +9.0                              ; Dump Gate
3265      -3.000000E+000            DG_LO_D   EQU     -3.0                              ;
3266   
3267                                ; DC Bias voltages in volts
3268      2.850000E+001             VOD_D     EQU     28.5                              ; Output Drain Left.
3269                                ; VOD is 1 volt lower than specified because of IR drop in lopass filts.
3270      1.600000E+001             VRD_D     EQU     16.0                              ; Reset Drain Left
3271                                ;VRD     EQU     18.0    ; Reset Drain Left
3272   
3273      0.000000E+000             VOG1_D    EQU     0.0                               ; output Gate 1
3274      1.000000E+000             VOG2_D    EQU     +1.0                              ; Output Gate 2
3275      2.100000E+001             VDD_D     EQU     +21.0                             ; Dump Drain
3276      -3.000000E+000            VSG_D     EQU     -3.0                              ; Spare Gate
3277   
3278                                ; from gwaves_CCD67.  Not used in this DSP.
3279                                ; these don't fit into the 3 level scheme, so comment out.
3280                                ;VABG    EQU     -6.0    ; Anti-blooming gate
3281      6.000000E+000             PWR_D     EQU     +6.0                              ; Preamp power - xxx Not used, keep as place
holder
3282   
3283   
3284      002640                    OFFSET    EQU     $2640
3285                                ;OFFSET0        EQU     $2CB2   ; e2v E, Peter's C, board 0, ch 0
3286                                ; FOR ENG grade!
3287                                ;OFFSET0        EQU     $28B2   ; e2v E, Peter's C, board 0, ch 0
3288                                ; FOR SCI grade!
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 59



3289      002300                    OFFSET0   EQU     $2300                             ; e2v E, Peter's C, board 0, ch 0
3290   
3291                                ;OFFSET1        EQU     $2A17   ; e2v F, Peter's D, board 0, ch 1
3292                                ; FOR ENG grade!
3293                                ;OFFSET1        EQU     $2617   ; e2v F, Peter's D, board 0, ch 1
3294                                ; FOR SCI grade!
3295      002377                    OFFSET1   EQU     $2377                             ; e2v F, Peter's D, board 0, ch 1
3296   
3297                                ;OFFSET2        EQU     $2F3C   ; e2v G, Peter's B, board 1, ch 0
3298                                ; FOR ENG grade!
3299                                ;OFFSET2        EQU     $7B3C   ; e2v G, Peter's B, board 1, ch 0
3300                                ; FOR SCI grade!
3301      001B00                    OFFSET2   EQU     $1B00                             ; deveny, bare ctrlr bias ~1000 ADU
3302   
3303                                ;OFFSET3        EQU     $2640   ; e2v H, Peter's A, board 1, ch 1
3304                                ; FOR ENG AND SCI grade!
3305                                ;OFFSET3        EQU     $2240   ; e2v H, Peter's A, board 1, ch 1
3306                                ;OFFSET3        EQU     $1B00   ; deveny, bare ctrlr bias ~1000 ADU
3307      001E20                    OFFSET3   EQU     $1E20                             ; deveny, bare ctrlr bias ~1000 ADU
3308   
3309                                ; INVERTED LEVELS
3310                                ; These are available for use during startup & idling
3311                                ; they are the DD levels minus 9 volts
3312   
3313                                ; Clock voltages in volts
3314      4.000000E+000             RG_HI_I   EQU     +4.0                              ; Reset
3315      -8.000000E+000            RG_LO_I   EQU     -8.0                              ;
3316      4.000000E+000             R_HI_I    EQU     +4.0                              ; Serials
3317      -7.000000E+000            R_LO_I    EQU     -7.0                              ;
3318      4.000000E+000             SW_HI_I   EQU     +4.0                              ; Summing well, mode 1
3319      -7.000000E+000            SW_LO_I   EQU     -7.0                              ;
3320      4.000000E+000             SI_HI_I   EQU     +4.0                              ; Parallels
3321      -8.000000E+000            SI_LO_I   EQU     -8.0                              ;
3322      4.000000E+000             DG_HI_I   EQU     +4.0                              ; Dump Gate
3323      -8.000000E+000            DG_LO_I   EQU     -8.0                              ;
3324   
3325                                ; DC Bias voltages in volts
3326      2.250000E+001             VOD_I     EQU     22.5                              ; Output Drain Left.
3327                                ; VOD is 1 volt lower than specified because of IR drop in lopass filts.
3328      1.000000E+001             VRD_I     EQU     10.0                              ; Reset Drain Left
3329                                ;VRD     EQU     18.0    ; Reset Drain Left
3330   
3331      -5.000000E+000            VOG1_I    EQU     -5.0                              ; output Gate 1
3332      -4.000000E+000            VOG2_I    EQU     -4.0                              ; Output Gate 2
3333      1.600000E+001             VDD_I     EQU     +16.0                             ; Dump Drain
3334      -8.000000E+000            VSG_I     EQU     -8.0                              ; Spare Gate
3335   
3336                                ; from gwaves_CCD67.  Not used in this DSP.
3337                                ; these don't fit into the 3 level scheme, so comment out.
3338                                ;VABG    EQU     -6.0    ; Anti-blooming gate
3339      6.000000E+000             PWR_I     EQU     +6.0                              ; Preamp power - xxx Not used, keep as place
holder
3340   
3341                                ; TRANSITION LEVELS
3342                                ; These are available for the sole purpose of buffering voltage swings
3343   
3344                                ; Clock voltages in volts
3345      4.000000E+000             RG_HI_T   EQU     +4.0                              ; Reset
3346      -3.000000E+000            RG_LO_T   EQU     -3.0                              ;
3347      4.000000E+000             R_HI_T    EQU     +4.0                              ; Serials
3348      -2.000000E+000            R_LO_T    EQU     -2.0                              ;
3349      4.000000E+000             SW_HI_T   EQU     +4.0                              ; Summing well, mode 1
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 60



3350      -2.000000E+000            SW_LO_T   EQU     -2.0                              ;
3351      4.000000E+000             SI_HI_T   EQU     +4.0                              ; Parallels
3352      -3.000000E+000            SI_LO_T   EQU     -3.0                              ;
3353      4.000000E+000             DG_HI_T   EQU     +4.0                              ; Dump Gate
3354      -3.000000E+000            DG_LO_T   EQU     -3.0                              ;
3355   
3356                                ; DC Bias voltages in volts
3357      2.250000E+001             VOD_T     EQU     22.5                              ; Output Drain Left.
3358                                ; VOD is 1 volt lower than specified because of IR drop in lopass filts.
3359      1.000000E+001             VRD_T     EQU     10.0                              ; Reset Drain Left
3360                                ;VRD     EQU     18.0    ; Reset Drain Left
3361   
3362      0.000000E+000             VOG1_T    EQU     0.0                               ; output Gate 1
3363      1.000000E+000             VOG2_T    EQU     +1.0                              ; Output Gate 2
3364      1.600000E+001             VDD_T     EQU     +16.0                             ; Dump Drain
3365      -3.000000E+000            VSG_T     EQU     -3.0                              ; Spare Gate
3366   
3367                                ; from gwaves_CCD67.  Not used in this DSP.
3368                                ; these don't fit into the 3 level scheme, so comment out.
3369                                ;VABG    EQU     -6.0    ; Anti-blooming gate
3370      6.000000E+000             PWR_T     EQU     +6.0                              ; Preamp power - xxx Not used, keep as place
holder
3371   
3372   
3373                                ; Define switch state bits for the lower CCD clock driver bank CLK2
3374                                ; The CCD42-10 uses only 5 fast clocks.  It has only one amplifier.
3375                                ; The fast clocks are out of order to make the cable work better
3376                                ;SEH1   EQU     1       ; Serial #1 E & H registers, Pin 1 - clock 0
3377                                ;SEH2   EQU     2       ; Serial #2 E & H registers, Pin 2 - clock 1
3378                                ;SEH3   EQU     4       ; Serial #3 E & F registers, Pin 3 - clock 2
3379                                ;SFG1   EQU     8       ; Serial #1 F & G registers, Pin 4 - clock 3
3380      000010                    S3        EQU     $10                               ; Serial #3,    Pin 5 - clock 4
3381      000020                    R         EQU     $20                               ; Reset Gate,   Pin 6 - clock 5
3382      000040                    SW        EQU     $40                               ; Summing well, Pin 7 - clock 6
3383      000080                    S2        EQU     $80                               ; Serial #2,    Pin 8 - clock 7
3384      000100                    S1        EQU     $100                              ; Serial #1,    Pin 9 - clock 8
3385                                ;RFG    EQU     $200    ; Reset Gate F & G registers, Pin 10 - clock 9
3386   
3387                                ; Define switch state bits for the upper CCD clock driver bank CLK3
3388                                ; Only 4 of these are used.  The 42-10 has no transfer gate.
3389      000001                    P1        EQU     1                                 ; Parallel A & B, phase #1, Pin 13 - clock 1
2
3390      000002                    P2        EQU     2                                 ; Parallel A & B, phase #2, Pin 14 - clock 1
3
3391      000004                    P3        EQU     4                                 ; Parallel A & B, phase #3, Pin 15 - clock 1
4
3392                                ;AB4    EQU     8       ; Parallel A & B, phase #4, Pin 16 - clock 15
3393                                ;CD1    EQU     $10     ; Parallel C & D, phase #1, Pin 17 - clock 16
3394                                ;CD2    EQU     $20     ; Parallel C & D, phase #2, Pin 18 - clock 17
3395                                ;CD3    EQU     $40     ; Parallel C & D, phase #3, Pin 19 - clock 18
3396                                ;CD4    EQU     $80     ; Parallel C & D, phase #4, Pin 33 - clock 19
3397                                ;TGA    EQU     $100    ; Transfer Gate A, Pin 34 - clock 20
3398                                ;TGD    EQU     $200    ; Transfer Gate D, Pin 35 - clock 21
3399      000400                    DG        EQU     $400                              ; Dump Gate, Pin 36 - clock 22
3400                                ;DGD    EQU     $800    ; Dump Gate D, Pin 37 - clock 23
3401   
3402                                ;                                      Output end
3403                                ; ... S1  S2  S3  S1  S2  SW  OG1  OG2  Amp
3404                                ; Clock SW like S3 for unbinned operation
3405   
3406                                ; Columns dump into serial 1 and 2 so they need to be high for par. shift
3407                                ; Reset and serial 1 & 2 are high between serial clock code lumps.
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 61



3408                                ; Parallels go ... 1 -> 2 -> 3 -> 1 -> register.  P2 high during int.
3409   
3410                                ; Serial clock convention:    R S1 S2 S3 SW
3411                                ; Parallel clock convention:  P1 P2 P3 DG
3412   
3413                                ; Video processor bit definition
3414                                ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3415   
3416                                SERIAL_IDLE                                         ; Split serial during idle
3417      Y:00003F Y:00003F                   DC      END_SERIAL_IDLE-SERIAL_IDLE-1
3418      Y:000040 Y:000040                   DC      CLK2+R_DELAY+R+S1+S2+00+00
3419      Y:000041 Y:000041                   DC      VIDEO+INT_INIT                    ; Change nearly everything
3420      Y:000042 Y:000042                   DC      CLK2+R_DELAY+0+00+S2+00+00
3421      Y:000043 Y:000043                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
3422      Y:000044 Y:000044                   DC      CLK2+R_DELAY+0+00+00+S3+SW
3423      Y:000045 Y:000045                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
3424      Y:000046 Y:000046                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
3425      Y:000047 Y:000047                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3426      Y:000048 Y:000048                   DC      VIDEO+INT_STOP                    ; Stop Integrate
3427      Y:000049 Y:000049                   DC      CLK2+CDS_TIM+0+S1+00+00+00
3428      Y:00004A Y:00004A                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3429      Y:00004B Y:00004B                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
3430      Y:00004C Y:00004C                   DC      CLK2+R_DELAY+0+S1+S2+00+00
3431                                END_SERIAL_IDLE
3432   
3433                                ; The following waveforms are for binned operation.
3434   
3435                                INITIAL_CLOCK_WAVE
3436      Y:00004D Y:00004D                   DC      END_INITIAL_CLOCK_WAVE-INITIAL_CLOCK_WAVE-1
3437      Y:00004E Y:00004E                   DC      CLK2+R_DELAY+R+S1+S2+00+00
3438      Y:00004F Y:00004F                   DC      VIDEO+INT_INIT                    ; Change nearly everything
3439      Y:000050 Y:000050                   DC      CLK2+R_DELAY+0+00+S2+00+00
3440      Y:000051 Y:000051                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
3441      Y:000052 Y:000052                   DC      CLK2+R_DELAY+0+00+00+S3+SW
3442      Y:000053 Y:000053                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
3443                                END_INITIAL_CLOCK_WAVE
3444   
3445                                SERIAL_CLOCK_WAVE
3446      Y:000054 Y:000054                   DC      END_SERIAL_CLOCK_WAVE-SERIAL_CLOCK_WAVE-1
3447      Y:000055 Y:000055                   DC      CLK2+R_DELAY+0+S1+00+00+SW
3448      Y:000056 Y:000056                   DC      CLK2+R_DELAY+0+S1+S2+00+SW
3449      Y:000057 Y:000057                   DC      CLK2+R_DELAY+0+00+S2+00+SW
3450      Y:000058 Y:000058                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
3451      Y:000059 Y:000059                   DC      CLK2+R_DELAY+0+00+00+S3+SW
3452      Y:00005A Y:00005A                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
3453                                END_SERIAL_CLOCK_WAVE
3454   
3455                                DCRST_LAST
3456      Y:00005B Y:00005B                   DC      DCRST_LAST_END-DCRST_LAST-1
3457      Y:00005C Y:00005C                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
3458                                DCRST_LAST_END
3459   
3460                                VIDEO_PROCESS
3461      Y:00005D Y:00005D                   DC      END_VIDEO_PROCESS-VIDEO_PROCESS-1
3462                                SXMIT_VP
3463                                ;       DC  $00F082  ; OS connected to input C.  A/D data to fiber; overwritten by SOS
3464      Y:00005E Y:00005E                   DC      $00F0C3                           ; OS connected to input D.  A/D data to fibe
r; not overwritten by SOS
3465      Y:00005F Y:00005F                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
3466      Y:000060 Y:000060                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3467      Y:000061 Y:000061                   DC      VIDEO+INT_STOP                    ; Stop Integrate
3468                                CCLK_1                                              ; Only one amplifier, so no need to overwrit
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 62



e this by SOS in timmisc.s
3469      Y:000062 Y:000062                   DC      CLK2+CDS_TIM+0+S1+00+00+00
3470      Y:000063 Y:000063                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3471      Y:000064 Y:000064                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
3472      Y:000065 Y:000065                   DC      CLK2+R_DELAY+0+S1+S2+00+00
3473                                END_VIDEO_PROCESS
3474   
3475                                ; Starting Y: address of circular waveforms for no-overhead access
3476      0000C0                    STRT_CIR  EQU     $C0
3477                                ;ROM_DISP       EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+STRT_CIR
3478                                ;DAC_DISP       EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+$100
3479   
3480                                ; Check for Y: data memory overflow
3481                                          IF      @CVS(N,*)>STRT_CIR
3483                                          ENDIF                                     ;  will not overflow
3484   
3485                                ; The fast serial code with the circulating address register must start
3486                                ;   on a boundary that is a multiple of the address register modulus.
3487   
3488                                          IF      @SCP("HOST","HOST")
3489      Y:0000C0 Y:0000C0                   ORG     Y:STRT_CIR,Y:STRT_CIR             ; Download address
3490                                          ELSE
3492                                          ENDIF
3493   
3494                                ; This is an area to copy in the serial fast binned waveforms from high Y memory
3495                                ; It is 0x28 = 40 locations long, enough to put in a binned-by-four waveform
3496                                ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3497                                SERIAL_READ                                         ; Split serial during idle
3498      Y:0000C0 Y:0000C0                   DC      CLK2+R_DELAY+R+S1+S2+00+00
3499      Y:0000C1 Y:0000C1                   DC      VIDEO+INT_INIT                    ; Change nearly everything
3500      Y:0000C2 Y:0000C2                   DC      CLK2+R_DELAY+0+00+S2+00+00
3501      Y:0000C3 Y:0000C3                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
3502      Y:0000C4 Y:0000C4                   DC      CLK2+R_DELAY+0+00+00+S3+SW
3503      Y:0000C5 Y:0000C5                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
3504      Y:0000C6 Y:0000C6                   DC      CLK2+R_DELAY+0+S1+00+00+SW
3505      Y:0000C7 Y:0000C7                   DC      CLK2+R_DELAY+R+S1+S2+00+SW
3506      Y:0000C8 Y:0000C8                   DC      CLK2+R_DELAY+0+00+S2+00+SW
3507      Y:0000C9 Y:0000C9                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
3508      Y:0000CA Y:0000CA                   DC      CLK2+R_DELAY+0+00+00+S3+SW
3509      Y:0000CB Y:0000CB                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
3510      Y:0000CC Y:0000CC                   DC      CLK2+R_DELAY+0+S1+00+00+SW
3511      Y:0000CD Y:0000CD                   DC      CLK2+R_DELAY+R+S1+S2+00+SW
3512      Y:0000CE Y:0000CE                   DC      CLK2+R_DELAY+0+00+S2+00+SW
3513      Y:0000CF Y:0000CF                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
3514      Y:0000D0 Y:0000D0                   DC      CLK2+R_DELAY+0+00+00+S3+SW
3515      Y:0000D1 Y:0000D1                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
3516      Y:0000D2 Y:0000D2                   DC      CLK2+R_DELAY+0+S1+00+00+SW
3517      Y:0000D3 Y:0000D3                   DC      CLK2+R_DELAY+R+S1+S2+00+SW
3518      Y:0000D4 Y:0000D4                   DC      CLK2+R_DELAY+0+00+S2+00+SW
3519      Y:0000D5 Y:0000D5                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
3520      Y:0000D6 Y:0000D6                   DC      CLK2+R_DELAY+0+00+00+S3+SW
3521      Y:0000D7 Y:0000D7                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
3522                                SXMIT
3523                                                                                    ;DC     $00F082                 ; Transmit A
/D data to host; overwritten by SOS
3524      Y:0000D8 Y:0000D8                   DC      $00F0C3                           ; Transmit A/D data to host on D; not overwr
itten by SOS
3525      Y:0000D9 Y:0000D9                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
3526      Y:0000DA Y:0000DA                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3527      Y:0000DB Y:0000DB                   DC      VIDEO+INT_STOP                    ; Stop Integrate
3528      Y:0000DC Y:0000DC                   DC      CLK2+CDS_TIM+0+S1+00+00+00
3529      Y:0000DD Y:0000DD                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 63



3530      Y:0000DE Y:0000DE                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
3531      Y:0000DF Y:0000DF                   DC      CLK2+R_DELAY+0+S1+S2+00+00
3532                                END_SERIAL_READ
3533   
3534   
3535                                ; Serial clocking waveform for skipping
3536                                          IF      @SCP("HOST","HOST")
3537      Y:0000E8 Y:0000E8                   ORG     Y:STRT_CIR+$28,Y:STRT_CIR+$28     ; Download address
3538                                          ELSE
3540                                          ENDIF
3541   
3542                                ; There is only one serial skip waveform
3543                                SERIAL_SKIP_WAVE
3544      Y:0000E8 Y:0000E8                   DC      CLK2+R_DELAY+R+S1+S2+00+00
3545      Y:0000E9 Y:0000E9                   DC      CLK2+R_DELAY+0+00+S2+00+00
3546      Y:0000EA Y:0000EA                   DC      CLK2+R_DELAY+0+00+S2+S3+00
3547      Y:0000EB Y:0000EB                   DC      CLK2+R_DELAY+0+00+00+S3+00
3548      Y:0000EC Y:0000EC                   DC      CLK2+R_DELAY+0+S1+00+S3+00
3549      Y:0000ED Y:0000ED                   DC      CLK2+R_DELAY+0+S1+00+00+00
3550      Y:0000EE Y:0000EE                   DC      CLK2+R_DELAY+0+S1+S2+00+00
3551                                END_SERIAL_SKIP_WAVE
3552   
3553                                ; Put all the following code in SRAM.
3554                                          IF      @SCP("HOST","HOST")
3555      Y:000100 Y:000100                   ORG     Y:$100,Y:$100                     ; Download address
3556                                          ELSE
3558                                          ENDIF
3559   
3560                                ; Initialization of clock driver and video processor DACs and switches
3561                                ; for DD levels used during integration & readout
3562                                ; This is for the ARC 47 4-channel video board
3563      Y:000100 Y:000100         DACS_DD   DC      END_DACS_DD-DACS_DD-1
3564      Y:000101 Y:000101                   DC      CLKV+$0A0080                      ; DAC = unbuffered mode
3565      Y:000102 Y:000102                   DC      CLKV+$000100+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #1, NC
3566      Y:000103 Y:000103                   DC      CLKV+$000200+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3567      Y:000104 Y:000104                   DC      CLKV+$000400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #2, NC
3568      Y:000105 Y:000105                   DC      CLKV+$000800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3569      Y:000106 Y:000106                   DC      CLKV+$002000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #3, NC
3570      Y:000107 Y:000107                   DC      CLKV+$004000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3571      Y:000108 Y:000108                   DC      CLKV+$008000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #4, NC
3572      Y:000109 Y:000109                   DC      CLKV+$010000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3573      Y:00010A Y:00010A                   DC      CLKV+$020100+@CVI((R_HI_D+Vmax)/(2*Vmax)*255) ; Pin #5, S3
3574      Y:00010B Y:00010B                   DC      CLKV+$020200+@CVI((R_LO_D+Vmax)/(2*Vmax)*255)
3575      Y:00010C Y:00010C                   DC      CLKV+$020400+@CVI((RG_HI_D+Vmax)/(2*Vmax)*255) ; Pin #6, Rst
3576      Y:00010D Y:00010D                   DC      CLKV+$020800+@CVI((RG_LO_D+Vmax)/(2*Vmax)*255)
3577      Y:00010E Y:00010E                   DC      CLKV+$022000+@CVI((SW_HI_D+Vmax)/(2*Vmax)*255) ; Pin #7, SW
3578      Y:00010F Y:00010F                   DC      CLKV+$024000+@CVI((SW_LO_D+Vmax)/(2*Vmax)*255)
3579      Y:000110 Y:000110                   DC      CLKV+$028000+@CVI((R_HI_D+Vmax)/(2*Vmax)*255) ; Pin #8, S2
3580      Y:000111 Y:000111                   DC      CLKV+$030000+@CVI((R_LO_D+Vmax)/(2*Vmax)*255)
3581      Y:000112 Y:000112                   DC      CLKV+$040100+@CVI((R_HI_D+Vmax)/(2*Vmax)*255) ; Pin #9, S1
3582      Y:000113 Y:000113                   DC      CLKV+$040200+@CVI((R_LO_D+Vmax)/(2*Vmax)*255)
3583      Y:000114 Y:000114                   DC      CLKV+$040400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #10, NC
3584      Y:000115 Y:000115                   DC      CLKV+$040800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3585      Y:000116 Y:000116                   DC      CLKV+$042000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #11, NC
3586      Y:000117 Y:000117                   DC      CLKV+$044000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3587      Y:000118 Y:000118                   DC      CLKV+$048000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #12, NC
3588      Y:000119 Y:000119                   DC      CLKV+$050000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3589   
3590      Y:00011A Y:00011A                   DC      CLKV+$060100+@CVI((SI_HI_D+Vmax)/(2*Vmax)*255) ; Pin #13, P1
3591      Y:00011B Y:00011B                   DC      CLKV+$060200+@CVI((SI_LO_D+Vmax)/(2*Vmax)*255)
3592      Y:00011C Y:00011C                   DC      CLKV+$060400+@CVI((SI_HI_D+Vmax)/(2*Vmax)*255) ; Pin #14, P2
3593      Y:00011D Y:00011D                   DC      CLKV+$060800+@CVI((SI_LO_D+Vmax)/(2*Vmax)*255)
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 64



3594      Y:00011E Y:00011E                   DC      CLKV+$062000+@CVI((SI_HI_D+Vmax)/(2*Vmax)*255) ; Pin #15, P3
3595      Y:00011F Y:00011F                   DC      CLKV+$064000+@CVI((SI_LO_D+Vmax)/(2*Vmax)*255)
3596      Y:000120 Y:000120                   DC      CLKV+$068000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #16, NC
3597      Y:000121 Y:000121                   DC      CLKV+$070000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3598      Y:000122 Y:000122                   DC      CLKV+$080100+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #17, NC
3599      Y:000123 Y:000123                   DC      CLKV+$080200+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3600      Y:000124 Y:000124                   DC      CLKV+$080400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #18, NC
3601      Y:000125 Y:000125                   DC      CLKV+$080800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3602      Y:000126 Y:000126                   DC      CLKV+$082000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #19, NC
3603      Y:000127 Y:000127                   DC      CLKV+$084000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3604      Y:000128 Y:000128                   DC      CLKV+$088000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #33, NC
3605      Y:000129 Y:000129                   DC      CLKV+$090000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3606      Y:00012A Y:00012A                   DC      CLKV+$0A0100+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #34, NC
3607      Y:00012B Y:00012B                   DC      CLKV+$0A0200+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3608      Y:00012C Y:00012C                   DC      CLKV+$0A0400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #35, NC
3609      Y:00012D Y:00012D                   DC      CLKV+$0A0800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3610      Y:00012E Y:00012E                   DC      CLKV+$0A2000+@CVI((DG_HI_D+Vmax)/(2*Vmax)*255) ; Pin #36, DG
3611      Y:00012F Y:00012F                   DC      CLKV+$0A4000+@CVI((DG_LO_D+Vmax)/(2*Vmax)*255)
3612      Y:000130 Y:000130                   DC      CLKV+$0A8000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #37, NC
3613      Y:000131 Y:000131                   DC      CLKV+$0B0000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3614   
3615                                ; Commands for the ARC-47 video board
3616      Y:000132 Y:000132                   DC      VID0+$0C0000                      ; Normal Image data D17-D2
3617   
3618                                ; Gain : $0D000g, g = 0 to %1111, Gain = 1.00 to 4.75 in steps of 0.25
3619                                ; See Bob's ARC47 manual for the gain table.
3620                                ; define for DD levels -only-
3621                                DAC_GNSPD
3622      Y:000133 Y:000133                   DC      VID0+$0D000F                      ; This is for 4.75 gain
3623                                ;       DC      VID0+$0D0000    ; fix for arc-47 gen-iii default gain 1
3624   
3625                                ; Integrator time constant: $0C01t0, t = 0 to %1111.
3626                                ; See Bob's ARC47 manual for integration time constant table.
3627      Y:000134 Y:000134                   DC      VID0+$0C0180                      ; integrator parameter for 0.5 us (integrato
r gain = 1.0)
3628   
3629                                ; Only make these defiitions once
3630      3.045000E+001             VOD_MAX   EQU     30.45
3631      1.990000E+001             VRD_MAX   EQU     19.90
3632      8.700000E+000             VOG_MAX   EQU     8.70
3633      001FFF                    DAC_ZERO  EQU     $1FFF                             ; Bipolar
3634   
3635                                ; VOG and VRS have the same scale.
3636                                ; VRD and VOD are different from VOG and each other.
3637      003BE5                    DAC_VOD_D EQU     @CVI((VOD_D/VOD_MAX)*16384-1)     ; Unipolar
3638      003374                    DAC_VRD_D EQU     @CVI((VRD_D/VRD_MAX)*16384-1)     ; Unipolar
3639      001FFF                    DAC_VOG1_D EQU    @CVI(((VOG1_D+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3640      0023AC                    DAC_VOG2_D EQU    @CVI(((VOG2_D+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3641      0014F6                    DAC_VSG_D EQU     @CVI(((VSG_D+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3642      002C22                    DAC_VDD_D EQU     @CVI((VDD_D/VOD_MAX)*16384-1)     ; Unipolar
3643      003610                    DAC_PWR_D EQU     @CVI(((PWR_D+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3644   
3645                                ; Initialize the ARC-47 DAC For DC_BIAS
3646      Y:000135 Y:000135                   DC      VID0+DAC_ADDR+$000000             ; Vod0, pin 52, NC
3647      Y:000136 Y:000136                   DC      VID0+DAC_RegD+DAC_ZERO
3648      Y:000137 Y:000137                   DC      VID0+DAC_ADDR+$000004             ; Vrd0, pin 13, NC
3649      Y:000138 Y:000138                   DC      VID0+DAC_RegD+DAC_ZERO
3650      Y:000139 Y:000139                   DC      VID0+DAC_ADDR+$000008             ; Vog0, pin 29, SG
3651      Y:00013A Y:00013A                   DC      VID0+DAC_RegD+DAC_VSG_D
3652      Y:00013B Y:00013B                   DC      VID0+DAC_ADDR+$00000C             ; Vrs0, pin 5, NC
3653      Y:00013C Y:00013C                   DC      VID0+DAC_RegD+DAC_ZERO
3654   
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 65



3655      Y:00013D Y:00013D                   DC      VID0+DAC_ADDR+$000001             ; Vod1, pin 32, OD
3656      Y:00013E Y:00013E                   DC      VID0+DAC_RegD+DAC_VOD_D
3657      Y:00013F Y:00013F                   DC      VID0+DAC_ADDR+$000005             ; Vrd1, pin 55, NC
3658      Y:000140 Y:000140                   DC      VID0+DAC_RegD+DAC_ZERO
3659      Y:000141 Y:000141                   DC      VID0+DAC_ADDR+$000009             ; Vog1, pin 8, NC
3660      Y:000142 Y:000142                   DC      VID0+DAC_RegD+DAC_ZERO
3661      Y:000143 Y:000143                   DC      VID0+DAC_ADDR+$00000D             ; Vrs1, pin 47, NC
3662      Y:000144 Y:000144                   DC      VID0+DAC_RegD+DAC_ZERO
3663   
3664      Y:000145 Y:000145                   DC      VID0+DAC_ADDR+$000002             ; Vod2, pin 11, NC
3665      Y:000146 Y:000146                   DC      VID0+DAC_RegD+DAC_ZERO
3666      Y:000147 Y:000147                   DC      VID0+DAC_ADDR+$000006             ; Vrd2, pin 35, RD
3667      Y:000148 Y:000148                   DC      VID0+DAC_RegD+DAC_VRD_D
3668      Y:000149 Y:000149                   DC      VID0+DAC_ADDR+$00000A             ; Vog2, pin 50, NC
3669      Y:00014A Y:00014A                   DC      VID0+DAC_RegD+DAC_ZERO
3670      Y:00014B Y:00014B                   DC      VID0+DAC_ADDR+$00000E             ; Vrs2, pin 27, OG2
3671      Y:00014C Y:00014C                   DC      VID0+DAC_RegD+DAC_VOG2_D
3672   
3673      Y:00014D Y:00014D                   DC      VID0+DAC_ADDR+$000003             ; Vod3, pin 53, NC
3674      Y:00014E Y:00014E                   DC      VID0+DAC_RegD+DAC_ZERO
3675      Y:00014F Y:00014F                   DC      VID0+DAC_ADDR+$000007             ; Vrd3, pin 14, NC
3676      Y:000150 Y:000150                   DC      VID0+DAC_RegD+DAC_ZERO
3677      Y:000151 Y:000151                   DC      VID0+DAC_ADDR+$00000B             ; Vog3, pin 30, OG1
3678      Y:000152 Y:000152                   DC      VID0+DAC_RegD+DAC_VOG1_D
3679      Y:000153 Y:000153                   DC      VID0+DAC_ADDR+$00000F             ; Vrs3, pin 6, NC
3680      Y:000154 Y:000154                   DC      VID0+DAC_RegD+DAC_ZERO
3681   
3682      Y:000155 Y:000155                   DC      VID0+DAC_ADDR+$000010             ; Vod4, pin 33, DD
3683      Y:000156 Y:000156                   DC      VID0+DAC_RegD+DAC_VDD_D
3684      Y:000157 Y:000157                   DC      VID0+DAC_ADDR+$000011             ; Vrd4, pin 56, NC
3685      Y:000158 Y:000158                   DC      VID0+DAC_RegD+DAC_ZERO
3686      Y:000159 Y:000159                   DC      VID0+DAC_ADDR+$000012             ; Vog4, pin 9, NC
3687      Y:00015A Y:00015A                   DC      VID0+DAC_RegD+DAC_ZERO
3688      Y:00015B Y:00015B                   DC      VID0+DAC_ADDR+$000013             ; Vrs4,pin 48, NC
3689      Y:00015C Y:00015C                   DC      VID0+DAC_RegD+DAC_ZERO
3690   
3691                                ; Initialize the ARC-47 DAC For Video Offsets
3692      Y:00015D Y:00015D                   DC      VID0+DAC_ADDR+$000014
3693      Y:00015E Y:00015E                   DC      VID0+DAC_RegD+OFFSET0
3694      Y:00015F Y:00015F                   DC      VID0+DAC_ADDR+$000015
3695      Y:000160 Y:000160                   DC      VID0+DAC_RegD+OFFSET1
3696      Y:000161 Y:000161                   DC      VID0+DAC_ADDR+$000016
3697      Y:000162 Y:000162                   DC      VID0+DAC_RegD+OFFSET2
3698      Y:000163 Y:000163                   DC      VID0+DAC_ADDR+$000017
3699      Y:000164 Y:000164                   DC      VID0+DAC_RegD+OFFSET3
3700   
3701                                END_DACS_DD
3702   
3703                                ; Initialization of clock driver and video processor DACs and switches
3704   
3705                                ; for Inverted levels used during startup & idling
3706                                ; This is for the ARC 47 4-channel video board
3707      Y:000165 Y:000165         DACS_INV  DC      END_DACS_INV-DACS_INV-1
3708      Y:000166 Y:000166                   DC      CLKV+$0A0080                      ; DAC = unbuffered mode
3709      Y:000167 Y:000167                   DC      CLKV+$000100+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #1, NC
3710      Y:000168 Y:000168                   DC      CLKV+$000200+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3711      Y:000169 Y:000169                   DC      CLKV+$000400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #2, NC
3712      Y:00016A Y:00016A                   DC      CLKV+$000800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3713      Y:00016B Y:00016B                   DC      CLKV+$002000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #3, NC
3714      Y:00016C Y:00016C                   DC      CLKV+$004000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3715      Y:00016D Y:00016D                   DC      CLKV+$008000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #4, NC
3716      Y:00016E Y:00016E                   DC      CLKV+$010000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 66



3717      Y:00016F Y:00016F                   DC      CLKV+$020100+@CVI((R_HI_I+Vmax)/(2*Vmax)*255) ; Pin #5, S3
3718      Y:000170 Y:000170                   DC      CLKV+$020200+@CVI((R_LO_I+Vmax)/(2*Vmax)*255)
3719      Y:000171 Y:000171                   DC      CLKV+$020400+@CVI((RG_HI_I+Vmax)/(2*Vmax)*255) ; Pin #6, Rst
3720      Y:000172 Y:000172                   DC      CLKV+$020800+@CVI((RG_LO_I+Vmax)/(2*Vmax)*255)
3721      Y:000173 Y:000173                   DC      CLKV+$022000+@CVI((SW_HI_I+Vmax)/(2*Vmax)*255) ; Pin #7, SW
3722      Y:000174 Y:000174                   DC      CLKV+$024000+@CVI((SW_LO_I+Vmax)/(2*Vmax)*255)
3723      Y:000175 Y:000175                   DC      CLKV+$028000+@CVI((R_HI_I+Vmax)/(2*Vmax)*255) ; Pin #8, S2
3724      Y:000176 Y:000176                   DC      CLKV+$030000+@CVI((R_LO_I+Vmax)/(2*Vmax)*255)
3725      Y:000177 Y:000177                   DC      CLKV+$040100+@CVI((R_HI_I+Vmax)/(2*Vmax)*255) ; Pin #9, S1
3726      Y:000178 Y:000178                   DC      CLKV+$040200+@CVI((R_LO_I+Vmax)/(2*Vmax)*255)
3727      Y:000179 Y:000179                   DC      CLKV+$040400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #10, NC
3728      Y:00017A Y:00017A                   DC      CLKV+$040800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3729      Y:00017B Y:00017B                   DC      CLKV+$042000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #11, NC
3730      Y:00017C Y:00017C                   DC      CLKV+$044000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3731      Y:00017D Y:00017D                   DC      CLKV+$048000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #12, NC
3732      Y:00017E Y:00017E                   DC      CLKV+$050000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3733   
3734      Y:00017F Y:00017F                   DC      CLKV+$060100+@CVI((SI_HI_I+Vmax)/(2*Vmax)*255) ; Pin #13, P1
3735      Y:000180 Y:000180                   DC      CLKV+$060200+@CVI((SI_LO_I+Vmax)/(2*Vmax)*255)
3736      Y:000181 Y:000181                   DC      CLKV+$060400+@CVI((SI_HI_I+Vmax)/(2*Vmax)*255) ; Pin #14, P2
3737      Y:000182 Y:000182                   DC      CLKV+$060800+@CVI((SI_LO_I+Vmax)/(2*Vmax)*255)
3738      Y:000183 Y:000183                   DC      CLKV+$062000+@CVI((SI_HI_I+Vmax)/(2*Vmax)*255) ; Pin #15, P3
3739      Y:000184 Y:000184                   DC      CLKV+$064000+@CVI((SI_LO_I+Vmax)/(2*Vmax)*255)
3740      Y:000185 Y:000185                   DC      CLKV+$068000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #16, NC
3741      Y:000186 Y:000186                   DC      CLKV+$070000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3742      Y:000187 Y:000187                   DC      CLKV+$080100+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #17, NC
3743      Y:000188 Y:000188                   DC      CLKV+$080200+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3744      Y:000189 Y:000189                   DC      CLKV+$080400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #18, NC
3745      Y:00018A Y:00018A                   DC      CLKV+$080800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3746      Y:00018B Y:00018B                   DC      CLKV+$082000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #19, NC
3747      Y:00018C Y:00018C                   DC      CLKV+$084000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3748      Y:00018D Y:00018D                   DC      CLKV+$088000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #33, NC
3749      Y:00018E Y:00018E                   DC      CLKV+$090000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3750      Y:00018F Y:00018F                   DC      CLKV+$0A0100+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #34, NC
3751      Y:000190 Y:000190                   DC      CLKV+$0A0200+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3752      Y:000191 Y:000191                   DC      CLKV+$0A0400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #35, NC
3753      Y:000192 Y:000192                   DC      CLKV+$0A0800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3754      Y:000193 Y:000193                   DC      CLKV+$0A2000+@CVI((DG_HI_I+Vmax)/(2*Vmax)*255) ; Pin #36, DG
3755      Y:000194 Y:000194                   DC      CLKV+$0A4000+@CVI((DG_LO_I+Vmax)/(2*Vmax)*255)
3756      Y:000195 Y:000195                   DC      CLKV+$0A8000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #37, NC
3757      Y:000196 Y:000196                   DC      CLKV+$0B0000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3758   
3759                                ; Commands for the ARC-47 video board
3760      Y:000197 Y:000197                   DC      VID0+$0C0000                      ; Normal Image data D17-D2
3761   
3762                                ; Gain : $0D000g, g = 0 to %1111, Gain = 1.00 to 4.75 in steps of 0.25
3763                                ; See Bob's ARC47 manual for the gain table.
3764                                ; the label is not defined here- the setgain command will not touch
3765                                ;DAC_GNSPD
3766      Y:000198 Y:000198                   DC      VID0+$0D000F                      ; This is for 4.75 gain
3767                                ;       DC      VID0+$0D0000    ; fix for arc-47 gen-iii default gain 1
3768   
3769                                ; Integrator time constant: $0C01t0, t = 0 to %1111.
3770                                ; See Bob's ARC47 manual for integration time constant table.
3771      Y:000199 Y:000199                   DC      VID0+$0C0180                      ; integrator parameter for 0.5 us (integrato
r gain = 1.0)
3772   
3773                                ; VOG and VRS have the same scale.
3774                                ; VRD and VOD are different from VOG and each other.
3775      002F49                    DAC_VOD_I EQU     @CVI((VOD_I/VOD_MAX)*16384-1)     ; Unipolar
3776      002028                    DAC_VRD_I EQU     @CVI((VRD_I/VRD_MAX)*16384-1)     ; Unipolar
3777      000D9A                    DAC_VOG1_I EQU    @CVI(((VOG1_I+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 67



3778      001148                    DAC_VOG2_I EQU    @CVI(((VOG2_I+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3779      000292                    DAC_VSG_I EQU     @CVI(((VSG_I+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3780      00219F                    DAC_VDD_I EQU     @CVI((VDD_I/VOD_MAX)*16384-1)     ; Unipolar
3781      003610                    DAC_PWR_I EQU     @CVI(((PWR_I+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3782   
3783                                ; Initialize the ARC-47 DAC For DC_BIAS
3784      Y:00019A Y:00019A                   DC      VID0+DAC_ADDR+$000000             ; Vod0, pin 52, NC
3785      Y:00019B Y:00019B                   DC      VID0+DAC_RegD+DAC_ZERO
3786      Y:00019C Y:00019C                   DC      VID0+DAC_ADDR+$000004             ; Vrd0, pin 13, NC
3787      Y:00019D Y:00019D                   DC      VID0+DAC_RegD+DAC_ZERO
3788      Y:00019E Y:00019E                   DC      VID0+DAC_ADDR+$000008             ; Vog0, pin 29, SG
3789      Y:00019F Y:00019F                   DC      VID0+DAC_RegD+DAC_VSG_I
3790      Y:0001A0 Y:0001A0                   DC      VID0+DAC_ADDR+$00000C             ; Vrs0, pin 5, NC
3791      Y:0001A1 Y:0001A1                   DC      VID0+DAC_RegD+DAC_ZERO
3792   
3793      Y:0001A2 Y:0001A2                   DC      VID0+DAC_ADDR+$000001             ; Vod1, pin 32, OD
3794      Y:0001A3 Y:0001A3                   DC      VID0+DAC_RegD+DAC_VOD_I
3795      Y:0001A4 Y:0001A4                   DC      VID0+DAC_ADDR+$000005             ; Vrd1, pin 55, NC
3796      Y:0001A5 Y:0001A5                   DC      VID0+DAC_RegD+DAC_ZERO
3797      Y:0001A6 Y:0001A6                   DC      VID0+DAC_ADDR+$000009             ; Vog1, pin 8, NC
3798      Y:0001A7 Y:0001A7                   DC      VID0+DAC_RegD+DAC_ZERO
3799      Y:0001A8 Y:0001A8                   DC      VID0+DAC_ADDR+$00000D             ; Vrs1, pin 47, NC
3800      Y:0001A9 Y:0001A9                   DC      VID0+DAC_RegD+DAC_ZERO
3801   
3802      Y:0001AA Y:0001AA                   DC      VID0+DAC_ADDR+$000002             ; Vod2, pin 11, NC
3803      Y:0001AB Y:0001AB                   DC      VID0+DAC_RegD+DAC_ZERO
3804      Y:0001AC Y:0001AC                   DC      VID0+DAC_ADDR+$000006             ; Vrd2, pin 35, RD
3805      Y:0001AD Y:0001AD                   DC      VID0+DAC_RegD+DAC_VRD_I
3806      Y:0001AE Y:0001AE                   DC      VID0+DAC_ADDR+$00000A             ; Vog2, pin 50, NC
3807      Y:0001AF Y:0001AF                   DC      VID0+DAC_RegD+DAC_ZERO
3808      Y:0001B0 Y:0001B0                   DC      VID0+DAC_ADDR+$00000E             ; Vrs2, pin 27, OG2
3809      Y:0001B1 Y:0001B1                   DC      VID0+DAC_RegD+DAC_VOG2_I
3810   
3811      Y:0001B2 Y:0001B2                   DC      VID0+DAC_ADDR+$000003             ; Vod3, pin 53, NC
3812      Y:0001B3 Y:0001B3                   DC      VID0+DAC_RegD+DAC_ZERO
3813      Y:0001B4 Y:0001B4                   DC      VID0+DAC_ADDR+$000007             ; Vrd3, pin 14, NC
3814      Y:0001B5 Y:0001B5                   DC      VID0+DAC_RegD+DAC_ZERO
3815      Y:0001B6 Y:0001B6                   DC      VID0+DAC_ADDR+$00000B             ; Vog3, pin 30, OG1
3816      Y:0001B7 Y:0001B7                   DC      VID0+DAC_RegD+DAC_VOG1_I
3817      Y:0001B8 Y:0001B8                   DC      VID0+DAC_ADDR+$00000F             ; Vrs3, pin 6, NC
3818      Y:0001B9 Y:0001B9                   DC      VID0+DAC_RegD+DAC_ZERO
3819   
3820      Y:0001BA Y:0001BA                   DC      VID0+DAC_ADDR+$000010             ; Vod4, pin 33, DD
3821      Y:0001BB Y:0001BB                   DC      VID0+DAC_RegD+DAC_VDD_I
3822      Y:0001BC Y:0001BC                   DC      VID0+DAC_ADDR+$000011             ; Vrd4, pin 56, NC
3823      Y:0001BD Y:0001BD                   DC      VID0+DAC_RegD+DAC_ZERO
3824      Y:0001BE Y:0001BE                   DC      VID0+DAC_ADDR+$000012             ; Vog4, pin 9, NC
3825      Y:0001BF Y:0001BF                   DC      VID0+DAC_RegD+DAC_ZERO
3826      Y:0001C0 Y:0001C0                   DC      VID0+DAC_ADDR+$000013             ; Vrs4,pin 48, NC
3827      Y:0001C1 Y:0001C1                   DC      VID0+DAC_RegD+DAC_ZERO
3828   
3829                                ; Initialize the ARC-47 DAC For Video Offsets
3830      Y:0001C2 Y:0001C2                   DC      VID0+DAC_ADDR+$000014
3831      Y:0001C3 Y:0001C3                   DC      VID0+DAC_RegD+OFFSET0
3832      Y:0001C4 Y:0001C4                   DC      VID0+DAC_ADDR+$000015
3833      Y:0001C5 Y:0001C5                   DC      VID0+DAC_RegD+OFFSET1
3834      Y:0001C6 Y:0001C6                   DC      VID0+DAC_ADDR+$000016
3835      Y:0001C7 Y:0001C7                   DC      VID0+DAC_RegD+OFFSET2
3836      Y:0001C8 Y:0001C8                   DC      VID0+DAC_ADDR+$000017
3837      Y:0001C9 Y:0001C9                   DC      VID0+DAC_RegD+OFFSET3
3838   
3839                                END_DACS_INV
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 68



3840   
3841   
3842                                ; Initialization of clock driver and video processor DACs and switches
3843   
3844                                ; for Transition levels used moving to or from the DD levels
3845                                ; This is for the ARC 47 4-channel video board
3846      Y:0001CA Y:0001CA         DACS_TRANS DC     END_DACS_TRANS-DACS_TRANS-1
3847      Y:0001CB Y:0001CB                   DC      CLKV+$0A0080                      ; DAC = unbuffered mode
3848      Y:0001CC Y:0001CC                   DC      CLKV+$000100+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #1, NC
3849      Y:0001CD Y:0001CD                   DC      CLKV+$000200+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3850      Y:0001CE Y:0001CE                   DC      CLKV+$000400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #2, NC
3851      Y:0001CF Y:0001CF                   DC      CLKV+$000800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3852      Y:0001D0 Y:0001D0                   DC      CLKV+$002000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #3, NC
3853      Y:0001D1 Y:0001D1                   DC      CLKV+$004000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3854      Y:0001D2 Y:0001D2                   DC      CLKV+$008000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #4, NC
3855      Y:0001D3 Y:0001D3                   DC      CLKV+$010000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3856      Y:0001D4 Y:0001D4                   DC      CLKV+$020100+@CVI((R_HI_T+Vmax)/(2*Vmax)*255) ; Pin #5, S3
3857      Y:0001D5 Y:0001D5                   DC      CLKV+$020200+@CVI((R_LO_T+Vmax)/(2*Vmax)*255)
3858      Y:0001D6 Y:0001D6                   DC      CLKV+$020400+@CVI((RG_HI_T+Vmax)/(2*Vmax)*255) ; Pin #6, Rst
3859      Y:0001D7 Y:0001D7                   DC      CLKV+$020800+@CVI((RG_LO_T+Vmax)/(2*Vmax)*255)
3860      Y:0001D8 Y:0001D8                   DC      CLKV+$022000+@CVI((SW_HI_T+Vmax)/(2*Vmax)*255) ; Pin #7, SW
3861      Y:0001D9 Y:0001D9                   DC      CLKV+$024000+@CVI((SW_LO_T+Vmax)/(2*Vmax)*255)
3862      Y:0001DA Y:0001DA                   DC      CLKV+$028000+@CVI((R_HI_T+Vmax)/(2*Vmax)*255) ; Pin #8, S2
3863      Y:0001DB Y:0001DB                   DC      CLKV+$030000+@CVI((R_LO_T+Vmax)/(2*Vmax)*255)
3864      Y:0001DC Y:0001DC                   DC      CLKV+$040100+@CVI((R_HI_I+Vmax)/(2*Vmax)*255) ; Pin #9, S1
3865      Y:0001DD Y:0001DD                   DC      CLKV+$040200+@CVI((R_LO_T+Vmax)/(2*Vmax)*255)
3866      Y:0001DE Y:0001DE                   DC      CLKV+$040400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #10, NC
3867      Y:0001DF Y:0001DF                   DC      CLKV+$040800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3868      Y:0001E0 Y:0001E0                   DC      CLKV+$042000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #11, NC
3869      Y:0001E1 Y:0001E1                   DC      CLKV+$044000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3870      Y:0001E2 Y:0001E2                   DC      CLKV+$048000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #12, NC
3871      Y:0001E3 Y:0001E3                   DC      CLKV+$050000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3872   
3873      Y:0001E4 Y:0001E4                   DC      CLKV+$060100+@CVI((SI_HI_T+Vmax)/(2*Vmax)*255) ; Pin #13, P1
3874      Y:0001E5 Y:0001E5                   DC      CLKV+$060200+@CVI((SI_LO_T+Vmax)/(2*Vmax)*255)
3875      Y:0001E6 Y:0001E6                   DC      CLKV+$060400+@CVI((SI_HI_T+Vmax)/(2*Vmax)*255) ; Pin #14, P2
3876      Y:0001E7 Y:0001E7                   DC      CLKV+$060800+@CVI((SI_LO_T+Vmax)/(2*Vmax)*255)
3877      Y:0001E8 Y:0001E8                   DC      CLKV+$062000+@CVI((SI_HI_T+Vmax)/(2*Vmax)*255) ; Pin #15, P3
3878      Y:0001E9 Y:0001E9                   DC      CLKV+$064000+@CVI((SI_LO_T+Vmax)/(2*Vmax)*255)
3879      Y:0001EA Y:0001EA                   DC      CLKV+$068000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #16, NC
3880      Y:0001EB Y:0001EB                   DC      CLKV+$070000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3881      Y:0001EC Y:0001EC                   DC      CLKV+$080100+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #17, NC
3882      Y:0001ED Y:0001ED                   DC      CLKV+$080200+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3883      Y:0001EE Y:0001EE                   DC      CLKV+$080400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #18, NC
3884      Y:0001EF Y:0001EF                   DC      CLKV+$080800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3885      Y:0001F0 Y:0001F0                   DC      CLKV+$082000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #19, NC
3886      Y:0001F1 Y:0001F1                   DC      CLKV+$084000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3887      Y:0001F2 Y:0001F2                   DC      CLKV+$088000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #33, NC
3888      Y:0001F3 Y:0001F3                   DC      CLKV+$090000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3889      Y:0001F4 Y:0001F4                   DC      CLKV+$0A0100+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #34, NC
3890      Y:0001F5 Y:0001F5                   DC      CLKV+$0A0200+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3891      Y:0001F6 Y:0001F6                   DC      CLKV+$0A0400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #35, NC
3892      Y:0001F7 Y:0001F7                   DC      CLKV+$0A0800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3893      Y:0001F8 Y:0001F8                   DC      CLKV+$0A2000+@CVI((DG_HI_T+Vmax)/(2*Vmax)*255) ; Pin #36, DG
3894      Y:0001F9 Y:0001F9                   DC      CLKV+$0A4000+@CVI((DG_LO_T+Vmax)/(2*Vmax)*255)
3895      Y:0001FA Y:0001FA                   DC      CLKV+$0A8000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #37, NC
3896      Y:0001FB Y:0001FB                   DC      CLKV+$0B0000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3897   
3898                                ; Commands for the ARC-47 video board
3899      Y:0001FC Y:0001FC                   DC      VID0+$0C0000                      ; Normal Image data D17-D2
3900   
3901                                ; Gain : $0D000g, g = 0 to %1111, Gain = 1.00 to 4.75 in steps of 0.25
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 69



3902                                ; See Bob's ARC47 manual for the gain table.
3903                                ; the label is not defined here- the setgain command will not touch
3904                                ;DAC_GNSPD
3905      Y:0001FD Y:0001FD                   DC      VID0+$0D000F                      ; This is for 4.75 gain
3906                                ;       DC      VID0+$0D0000    ; fix for arc-47 gen-iii default gain 1
3907   
3908                                ; Integrator time constant: $0C01t0, t = 0 to %1111.
3909                                ; See Bob's ARC47 manual for integration time constant table.
3910      Y:0001FE Y:0001FE                   DC      VID0+$0C0180                      ; integrator parameter for 0.5 us (integrato
r gain = 1.0)
3911   
3912                                ; VOG and VRS have the same scale.
3913                                ; VRD and VOD are different from VOG and each other.
3914      002F49                    DAC_VOD_T EQU     @CVI((VOD_T/VOD_MAX)*16384-1)     ; Unipolar
3915      002028                    DAC_VRD_T EQU     @CVI((VRD_T/VRD_MAX)*16384-1)     ; Unipolar
3916      001FFF                    DAC_VOG1_T EQU    @CVI(((VOG1_T+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3917      0023AC                    DAC_VOG2_T EQU    @CVI(((VOG2_T+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3918      0014F6                    DAC_VSG_T EQU     @CVI(((VSG_T+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3919      00219F                    DAC_VDD_T EQU     @CVI((VDD_T/VOD_MAX)*16384-1)     ; Unipolar
3920      003610                    DAC_PWR_T EQU     @CVI(((PWR_T+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3921   
3922                                ; Initialize the ARC-47 DAC For DC_BIAS
3923      Y:0001FF Y:0001FF                   DC      VID0+DAC_ADDR+$000000             ; Vod0, pin 52, NC
3924      Y:000200 Y:000200                   DC      VID0+DAC_RegD+DAC_ZERO
3925      Y:000201 Y:000201                   DC      VID0+DAC_ADDR+$000004             ; Vrd0, pin 13, NC
3926      Y:000202 Y:000202                   DC      VID0+DAC_RegD+DAC_ZERO
3927      Y:000203 Y:000203                   DC      VID0+DAC_ADDR+$000008             ; Vog0, pin 29, SG
3928      Y:000204 Y:000204                   DC      VID0+DAC_RegD+DAC_VSG_T
3929      Y:000205 Y:000205                   DC      VID0+DAC_ADDR+$00000C             ; Vrs0, pin 5, NC
3930      Y:000206 Y:000206                   DC      VID0+DAC_RegD+DAC_ZERO
3931   
3932      Y:000207 Y:000207                   DC      VID0+DAC_ADDR+$000001             ; Vod1, pin 32, OD
3933      Y:000208 Y:000208                   DC      VID0+DAC_RegD+DAC_VOD_T
3934      Y:000209 Y:000209                   DC      VID0+DAC_ADDR+$000005             ; Vrd1, pin 55, NC
3935      Y:00020A Y:00020A                   DC      VID0+DAC_RegD+DAC_ZERO
3936      Y:00020B Y:00020B                   DC      VID0+DAC_ADDR+$000009             ; Vog1, pin 8, NC
3937      Y:00020C Y:00020C                   DC      VID0+DAC_RegD+DAC_ZERO
3938      Y:00020D Y:00020D                   DC      VID0+DAC_ADDR+$00000D             ; Vrs1, pin 47, NC
3939      Y:00020E Y:00020E                   DC      VID0+DAC_RegD+DAC_ZERO
3940   
3941      Y:00020F Y:00020F                   DC      VID0+DAC_ADDR+$000002             ; Vod2, pin 11, NC
3942      Y:000210 Y:000210                   DC      VID0+DAC_RegD+DAC_ZERO
3943      Y:000211 Y:000211                   DC      VID0+DAC_ADDR+$000006             ; Vrd2, pin 35, RD
3944      Y:000212 Y:000212                   DC      VID0+DAC_RegD+DAC_VRD_T
3945      Y:000213 Y:000213                   DC      VID0+DAC_ADDR+$00000A             ; Vog2, pin 50, NC
3946      Y:000214 Y:000214                   DC      VID0+DAC_RegD+DAC_ZERO
3947      Y:000215 Y:000215                   DC      VID0+DAC_ADDR+$00000E             ; Vrs2, pin 27, OG2
3948      Y:000216 Y:000216                   DC      VID0+DAC_RegD+DAC_VOG2_T
3949   
3950      Y:000217 Y:000217                   DC      VID0+DAC_ADDR+$000003             ; Vod3, pin 53, NC
3951      Y:000218 Y:000218                   DC      VID0+DAC_RegD+DAC_ZERO
3952      Y:000219 Y:000219                   DC      VID0+DAC_ADDR+$000007             ; Vrd3, pin 14, NC
3953      Y:00021A Y:00021A                   DC      VID0+DAC_RegD+DAC_ZERO
3954      Y:00021B Y:00021B                   DC      VID0+DAC_ADDR+$00000B             ; Vog3, pin 30, OG1
3955      Y:00021C Y:00021C                   DC      VID0+DAC_RegD+DAC_VOG1_T
3956      Y:00021D Y:00021D                   DC      VID0+DAC_ADDR+$00000F             ; Vrs3, pin 6, NC
3957      Y:00021E Y:00021E                   DC      VID0+DAC_RegD+DAC_ZERO
3958   
3959      Y:00021F Y:00021F                   DC      VID0+DAC_ADDR+$000010             ; Vod4, pin 33, DD
3960      Y:000220 Y:000220                   DC      VID0+DAC_RegD+DAC_VDD_T
3961      Y:000221 Y:000221                   DC      VID0+DAC_ADDR+$000011             ; Vrd4, pin 56, NC
3962      Y:000222 Y:000222                   DC      VID0+DAC_RegD+DAC_ZERO
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 70



3963      Y:000223 Y:000223                   DC      VID0+DAC_ADDR+$000012             ; Vog4, pin 9, NC
3964      Y:000224 Y:000224                   DC      VID0+DAC_RegD+DAC_ZERO
3965      Y:000225 Y:000225                   DC      VID0+DAC_ADDR+$000013             ; Vrs4,pin 48, NC
3966      Y:000226 Y:000226                   DC      VID0+DAC_RegD+DAC_ZERO
3967   
3968                                ; Initialize the ARC-47 DAC For Video Offsets
3969      Y:000227 Y:000227                   DC      VID0+DAC_ADDR+$000014
3970      Y:000228 Y:000228                   DC      VID0+DAC_RegD+OFFSET0
3971      Y:000229 Y:000229                   DC      VID0+DAC_ADDR+$000015
3972      Y:00022A Y:00022A                   DC      VID0+DAC_RegD+OFFSET1
3973      Y:00022B Y:00022B                   DC      VID0+DAC_ADDR+$000016
3974      Y:00022C Y:00022C                   DC      VID0+DAC_RegD+OFFSET2
3975      Y:00022D Y:00022D                   DC      VID0+DAC_ADDR+$000017
3976      Y:00022E Y:00022E                   DC      VID0+DAC_RegD+OFFSET3
3977   
3978                                END_DACS_TRANS
3979   
3980                                ;  ***  Definitions for Y: memory waveform tables  *****
3981                                ; Put the parallel clock waveforms in slow external Y memory since there isn't
3982                                ; enough room in the fast memory for everything we need.
3983   
3984                                ; Columns dump into serial 1 and 2 so they need to be high for par. shift
3985                                ; Reset and serial 1 & 2 are high between serial clock code lumps.
3986                                ; Parallels go ... 1 -> 2 -> 3 -> 1 -> register.  P2 high during int.
3987   
3988                                ; Serial clock convention:    R S1 S2 S3 SW
3989                                ; Parallel clock convention:  P1 P2 P3 DG
3990   
3991                                ; ADD DC RESTORE based on gwaves!
3992                                ; Clock whole CCD down toward the serial register.  Serial phases 1 & 2 high.
3993                                PARALLEL
3994      Y:00022F Y:00022F                   DC      END_PARALLEL-PARALLEL-1
3995      Y:000230 Y:000230                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
3996      Y:000231 Y:000231                   DC      CLK2+SI_DELAY+R+S1+S2+00+00
3997      Y:000232 Y:000232                   DC      CLK3+SI_DELAY+00+P2+P3+00
3998      Y:000233 Y:000233                   DC      CLK3+SI_DELAY+00+00+P3+00
3999      Y:000234 Y:000234                   DC      CLK3+SI_DELAY+P1+00+P3+00
4000      Y:000235 Y:000235                   DC      CLK3+SI_DELAY+P1+00+00+00
4001      Y:000236 Y:000236                   DC      CLK3+SI_DELAY+P1+P2+00+00
4002      Y:000237 Y:000237                   DC      CLK3+SI_DELAY+00+P2+00+00
4003                                END_PARALLEL
4004   
4005                                ; Clear whole CCD down toward the serial register.  Serial phases 1 & 2 high.
4006                                ; ADD DC RESTORE based on gwaves!
4007                                PARALLEL_CLEAR
4008      Y:000238 Y:000238                   DC      END_PARALLEL_CLEAR-PARALLEL_CLEAR-1
4009      Y:000239 Y:000239                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4010      Y:00023A Y:00023A                   DC      CLK2+SI_DELAY+R+S1+S2+00+00
4011      Y:00023B Y:00023B                   DC      CLK3+SI_DELAY+00+P2+P3+DG
4012      Y:00023C Y:00023C                   DC      CLK3+SI_DELAY+00+00+P3+DG
4013      Y:00023D Y:00023D                   DC      CLK3+SI_DELAY+P1+00+P3+DG
4014      Y:00023E Y:00023E                   DC      CLK3+SI_DELAY+P1+00+00+DG
4015      Y:00023F Y:00023F                   DC      CLK3+SI_DELAY+P1+P2+00+DG
4016      Y:000240 Y:000240                   DC      CLK3+SI_DELAY+00+P2+00+DG
4017      Y:000241 Y:000241                   DC      CLK2+SI_DELAY+R+00+00+00+00
4018      Y:000242 Y:000242                   DC      CLK3+SI_DELAY+00+P2+00+00
4019      Y:000243 Y:000243                   DC      CLK2+SI_DELAY+R+S1+S2+00+00
4020                                END_PARALLEL_CLEAR
4021   
4022                                ; Dump the serial register using DG
4023                                DUMP_SERIAL
4024      Y:000244 Y:000244                   DC      END_DUMP_SERIAL-DUMP_SERIAL-1
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 71



4025      Y:000245 Y:000245                   DC      CLK2+DG_DELAY+R+S1+S2+00+00
4026      Y:000246 Y:000246                   DC      CLK3+DG_DELAY+00+P2+00+DG
4027      Y:000247 Y:000247                   DC      CLK2+DG_DELAY+R+00+00+00+00
4028      Y:000248 Y:000248                   DC      CLK3+DG_DELAY+00+P2+00+00
4029      Y:000249 Y:000249                   DC      CLK2+DG_DELAY+R+S1+S2+00+00
4030                                END_DUMP_SERIAL
4031   
4032                                ; Parallel waveforms done.  Move on to the layered serial ones.
4033   
4034                                ; These are the 4 fast serial read waveforms for binning factors from 1 to 4.
4035   
4036                                ;       Unbinned waveform
4037                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4038                                SERIAL_READ_1
4039      Y:00024A Y:00024A                   DC      CLK2+R_DELAY+R+S1+S2+00+00
4040      Y:00024B Y:00024B                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4041      Y:00024C Y:00024C                   DC      CLK2+R_DELAY+0+00+S2+00+00
4042      Y:00024D Y:00024D                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
4043      Y:00024E Y:00024E                   DC      CLK2+R_DELAY+0+00+00+S3+SW
4044      Y:00024F Y:00024F                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
4045                                SXMIT_1
4046                                ;       DC      $00F082                 ; Transmit A/D data to host; overwritten by SOS
4047      Y:000250 Y:000250                   DC      $00F0C3                           ; Transmit A/D data to host on D; not overwr
itten by SOS
4048      Y:000251 Y:000251                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4049      Y:000252 Y:000252                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4050      Y:000253 Y:000253                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4051      Y:000254 Y:000254                   DC      CLK2+CDS_TIM+0+S1+00+00+00
4052      Y:000255 Y:000255                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4053      Y:000256 Y:000256                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4054      Y:000257 Y:000257                   DC      CLK2+R_DELAY+0+S1+S2+00+00
4055                                END_SERIAL_READ_1
4056   
4057                                ;       Bin by 2 waveform
4058                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4059                                SERIAL_READ_2
4060      Y:000258 Y:000258                   DC      CLK2+R_DELAY+R+S1+S2+00+00
4061      Y:000259 Y:000259                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4062      Y:00025A Y:00025A                   DC      CLK2+R_DELAY+0+00+S2+00+00
4063      Y:00025B Y:00025B                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
4064      Y:00025C Y:00025C                   DC      CLK2+R_DELAY+0+00+00+S3+SW
4065      Y:00025D Y:00025D                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
4066      Y:00025E Y:00025E                   DC      CLK2+R_DELAY+0+S1+00+00+SW
4067      Y:00025F Y:00025F                   DC      CLK2+R_DELAY+R+S1+S2+00+SW
4068      Y:000260 Y:000260                   DC      CLK2+R_DELAY+0+00+S2+00+SW
4069      Y:000261 Y:000261                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
4070      Y:000262 Y:000262                   DC      CLK2+R_DELAY+0+00+00+S3+SW
4071      Y:000263 Y:000263                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
4072                                SXMIT_2
4073                                ;       DC      $00F082                 ; Transmit A/D data to host; overwritten by SOS
4074      Y:000264 Y:000264                   DC      $00F0C3                           ; Transmit A/D data to host on D; not overwr
itten by SOS
4075      Y:000265 Y:000265                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4076      Y:000266 Y:000266                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4077      Y:000267 Y:000267                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4078      Y:000268 Y:000268                   DC      CLK2+CDS_TIM+0+S1+00+00+00
4079      Y:000269 Y:000269                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4080      Y:00026A Y:00026A                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4081      Y:00026B Y:00026B                   DC      CLK2+R_DELAY+0+S1+S2+00+00
4082                                END_SERIAL_READ_2
4083   
4084                                ;       Bin by 3 waveform
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 72



4085                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4086                                SERIAL_READ_3
4087      Y:00026C Y:00026C                   DC      CLK2+R_DELAY+R+S1+S2+00+00
4088      Y:00026D Y:00026D                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4089      Y:00026E Y:00026E                   DC      CLK2+R_DELAY+0+00+S2+00+00
4090      Y:00026F Y:00026F                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
4091      Y:000270 Y:000270                   DC      CLK2+R_DELAY+0+00+00+S3+SW
4092      Y:000271 Y:000271                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
4093      Y:000272 Y:000272                   DC      CLK2+R_DELAY+0+S1+00+00+SW
4094      Y:000273 Y:000273                   DC      CLK2+R_DELAY+R+S1+S2+00+SW
4095      Y:000274 Y:000274                   DC      CLK2+R_DELAY+0+00+S2+00+SW
4096      Y:000275 Y:000275                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
4097      Y:000276 Y:000276                   DC      CLK2+R_DELAY+0+00+00+S3+SW
4098      Y:000277 Y:000277                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
4099      Y:000278 Y:000278                   DC      CLK2+R_DELAY+0+S1+00+00+SW
4100      Y:000279 Y:000279                   DC      CLK2+R_DELAY+R+S1+S2+00+SW
4101      Y:00027A Y:00027A                   DC      CLK2+R_DELAY+0+00+S2+00+SW
4102      Y:00027B Y:00027B                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
4103      Y:00027C Y:00027C                   DC      CLK2+R_DELAY+0+00+00+S3+SW
4104      Y:00027D Y:00027D                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
4105                                SXMIT_3
4106                                ;       DC      $00F082                 ; Transmit A/D data to host; overwritten by SOS
4107      Y:00027E Y:00027E                   DC      $00F0C3                           ; Transmit A/D data to host on D; not overwr
itten by SOS
4108      Y:00027F Y:00027F                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4109      Y:000280 Y:000280                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4110      Y:000281 Y:000281                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4111      Y:000282 Y:000282                   DC      CLK2+CDS_TIM+0+S1+00+00+00
4112      Y:000283 Y:000283                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4113      Y:000284 Y:000284                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4114      Y:000285 Y:000285                   DC      CLK2+R_DELAY+0+S1+S2+00+00
4115                                END_SERIAL_READ_3
4116   
4117                                ;       Bin by 4 waveforms
4118                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4119                                SERIAL_READ_4
4120      Y:000286 Y:000286                   DC      CLK2+R_DELAY+R+S1+S2+00+00
4121      Y:000287 Y:000287                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4122      Y:000288 Y:000288                   DC      CLK2+R_DELAY+0+00+S2+00+00
4123      Y:000289 Y:000289                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
4124      Y:00028A Y:00028A                   DC      CLK2+R_DELAY+0+00+00+S3+SW
4125      Y:00028B Y:00028B                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
4126      Y:00028C Y:00028C                   DC      CLK2+R_DELAY+0+S1+00+00+SW
4127      Y:00028D Y:00028D                   DC      CLK2+R_DELAY+R+S1+S2+00+SW
4128      Y:00028E Y:00028E                   DC      CLK2+R_DELAY+0+00+S2+00+SW
4129      Y:00028F Y:00028F                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
4130      Y:000290 Y:000290                   DC      CLK2+R_DELAY+0+00+00+S3+SW
4131      Y:000291 Y:000291                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
4132      Y:000292 Y:000292                   DC      CLK2+R_DELAY+0+S1+00+00+SW
4133      Y:000293 Y:000293                   DC      CLK2+R_DELAY+R+S1+S2+00+SW
4134      Y:000294 Y:000294                   DC      CLK2+R_DELAY+0+00+S2+00+SW
4135      Y:000295 Y:000295                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
4136      Y:000296 Y:000296                   DC      CLK2+R_DELAY+0+00+00+S3+SW
4137      Y:000297 Y:000297                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
4138      Y:000298 Y:000298                   DC      CLK2+R_DELAY+0+S1+00+00+SW
4139      Y:000299 Y:000299                   DC      CLK2+R_DELAY+R+S1+S2+00+SW
4140      Y:00029A Y:00029A                   DC      CLK2+R_DELAY+0+00+S2+00+SW
4141      Y:00029B Y:00029B                   DC      CLK2+R_DELAY+0+00+S2+S3+SW
4142      Y:00029C Y:00029C                   DC      CLK2+R_DELAY+0+00+00+S3+SW
4143      Y:00029D Y:00029D                   DC      CLK2+R_DELAY+0+S1+00+S3+SW
4144                                SXMIT_4
4145                                ;       DC      $00F082                 ; Transmit A/D data to host; overwritten by SOS
Motorola DSP56300 Assembler  Version 6.2.23   114-05-30  00:43:00  deveny.waveforms.s  Page 73



4146      Y:00029E Y:00029E                   DC      $00F0C3                           ; Transmit A/D data to host on D; not overwr
itten by SOS
4147      Y:00029F Y:00029F                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4148      Y:0002A0 Y:0002A0                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4149      Y:0002A1 Y:0002A1                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4150      Y:0002A2 Y:0002A2                   DC      CLK2+CDS_TIM+0+S1+00+00+00
4151      Y:0002A3 Y:0002A3                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4152      Y:0002A4 Y:0002A4                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4153      Y:0002A5 Y:0002A5                   DC      CLK2+R_DELAY+0+S1+S2+00+00
4154                                END_SERIAL_READ_4
4155   
4156                                 END_APPLICATON_Y_MEMORY
4157      0002A6                              EQU     @LCV(L)
4158   
4159                                ;  End of program
4160                                          END

0    Errors
0    Warnings


