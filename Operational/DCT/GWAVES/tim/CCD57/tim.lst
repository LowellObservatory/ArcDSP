Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  tim.s  Page 1



1                          ; This file is used to generate DSP code for the Gen III ARC-22/32/47
2                          ;    board set.
3                          ;
4                          ; This file contains two subroutines and X and Y data areas.  The two
5                          ; subroutines are RDCCD (with secondary entry point RCCD1) and CLOCK.
6                          ; These need to be in fast P memory.  The boot code and tim.s are there.
7                          ; tim.s includes timmisc.s, timCCDmisc.s and the waveforms file at the
8                          ; end.
9      
10                                   PAGE    132                               ; Printronix page width - 132 columns
11     
12                         ; Include a header file that defines global parameters
13     
14                                   INCLUDE "timboot.s"
15                         ;  This file is used to generate boot DSP code for the Gen III 250 MHz fiber
16                         ;       optic timing board = ARC22 using a DSP56303 as its main processor.
17     
18                         ; Various addressing control registers
19        FFFFFB           BCR       EQU     $FFFFFB                           ; Bus Control Register
20        FFFFF9           AAR0      EQU     $FFFFF9                           ; Address Attribute Register, channel 0
21        FFFFF8           AAR1      EQU     $FFFFF8                           ; Address Attribute Register, channel 1
22        FFFFF7           AAR2      EQU     $FFFFF7                           ; Address Attribute Register, channel 2
23        FFFFF6           AAR3      EQU     $FFFFF6                           ; Address Attribute Register, channel 3
24        FFFFFD           PCTL      EQU     $FFFFFD                           ; PLL control register
25        FFFFFE           IPRP      EQU     $FFFFFE                           ; Interrupt Priority register - Peripheral
26        FFFFFF           IPRC      EQU     $FFFFFF                           ; Interrupt Priority register - Core
27     
28                         ; Port E is the Synchronous Communications Interface (SCI) port
29        FFFF9F           PCRE      EQU     $FFFF9F                           ; Port Control Register
30        FFFF9E           PRRE      EQU     $FFFF9E                           ; Port Direction Register
31        FFFF9D           PDRE      EQU     $FFFF9D                           ; Port Data Register
32        FFFF9C           SCR       EQU     $FFFF9C                           ; SCI Control Register
33        FFFF9B           SCCR      EQU     $FFFF9B                           ; SCI Clock Control Register
34     
35        FFFF9A           SRXH      EQU     $FFFF9A                           ; SCI Receive Data Register, High byte
36        FFFF99           SRXM      EQU     $FFFF99                           ; SCI Receive Data Register, Middle byte
37        FFFF98           SRXL      EQU     $FFFF98                           ; SCI Receive Data Register, Low byte
38     
39        FFFF97           STXH      EQU     $FFFF97                           ; SCI Transmit Data register, High byte
40        FFFF96           STXM      EQU     $FFFF96                           ; SCI Transmit Data register, Middle byte
41        FFFF95           STXL      EQU     $FFFF95                           ; SCI Transmit Data register, Low byte
42     
43        FFFF94           STXA      EQU     $FFFF94                           ; SCI Transmit Address Register
44        FFFF93           SSR       EQU     $FFFF93                           ; SCI Status Register
45     
46        000009           SCITE     EQU     9                                 ; X:SCR bit set to enable the SCI transmitter
47        000008           SCIRE     EQU     8                                 ; X:SCR bit set to enable the SCI receiver
48        000000           TRNE      EQU     0                                 ; This is set in X:SSR when the transmitter
49                                                                             ;  shift and data registers are both empty
50        000001           TDRE      EQU     1                                 ; This is set in X:SSR when the transmitter
51                                                                             ;  data register is empty
52        000002           RDRF      EQU     2                                 ; X:SSR bit set when receiver register is full
53        00000F           SELSCI    EQU     15                                ; 1 for SCI to backplane, 0 to front connector
54     
55     
56                         ; ESSI Flags
57        000006           TDE       EQU     6                                 ; Set when transmitter data register is empty
58        000007           RDF       EQU     7                                 ; Set when receiver is full of data
59        000010           TE        EQU     16                                ; Transmitter enable
60     
61                         ; Phase Locked Loop initialization
62        050003           PLL_INIT  EQU     $050003                           ; PLL = 25 MHz x 2 = 100 MHz
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 2



63     
64                         ; Port B general purpose I/O
65        FFFFC4           HPCR      EQU     $FFFFC4                           ; Control register (bits 1-6 cleared for GPIO)
66        FFFFC9           HDR       EQU     $FFFFC9                           ; Data register
67        FFFFC8           HDDR      EQU     $FFFFC8                           ; Data Direction Register bits (=1 for output)
68     
69                         ; Port C is Enhanced Synchronous Serial Port 0 = ESSI0
70        FFFFBF           PCRC      EQU     $FFFFBF                           ; Port C Control Register
71        FFFFBE           PRRC      EQU     $FFFFBE                           ; Port C Data direction Register
72        FFFFBD           PDRC      EQU     $FFFFBD                           ; Port C GPIO Data Register
73        FFFFBC           TX00      EQU     $FFFFBC                           ; Transmit Data Register #0
74        FFFFB8           RX0       EQU     $FFFFB8                           ; Receive data register
75        FFFFB7           SSISR0    EQU     $FFFFB7                           ; Status Register
76        FFFFB6           CRB0      EQU     $FFFFB6                           ; Control Register B
77        FFFFB5           CRA0      EQU     $FFFFB5                           ; Control Register A
78     
79                         ; Port D is Enhanced Synchronous Serial Port 1 = ESSI1
80        FFFFAF           PCRD      EQU     $FFFFAF                           ; Port D Control Register
81        FFFFAE           PRRD      EQU     $FFFFAE                           ; Port D Data direction Register
82        FFFFAD           PDRD      EQU     $FFFFAD                           ; Port D GPIO Data Register
83        FFFFAC           TX10      EQU     $FFFFAC                           ; Transmit Data Register 0
84        FFFFA7           SSISR1    EQU     $FFFFA7                           ; Status Register
85        FFFFA6           CRB1      EQU     $FFFFA6                           ; Control Register B
86        FFFFA5           CRA1      EQU     $FFFFA5                           ; Control Register A
87     
88                         ; Timer module addresses
89        FFFF8F           TCSR0     EQU     $FFFF8F                           ; Timer control and status register
90        FFFF8E           TLR0      EQU     $FFFF8E                           ; Timer load register = 0
91        FFFF8D           TCPR0     EQU     $FFFF8D                           ; Timer compare register = exposure time
92        FFFF8C           TCR0      EQU     $FFFF8C                           ; Timer count register = elapsed time
93        FFFF83           TPLR      EQU     $FFFF83                           ; Timer prescaler load register => milliseconds
94        FFFF82           TPCR      EQU     $FFFF82                           ; Timer prescaler count register
95        000000           TIM_BIT   EQU     0                                 ; Set to enable the timer
96        000009           TRM       EQU     9                                 ; Set to enable the timer preloading
97        000015           TCF       EQU     21                                ; Set when timer counter = compare register
98     
99                         ; Board specific addresses and constants
100       FFFFF1           RDFO      EQU     $FFFFF1                           ; Read incoming fiber optic data byte
101       FFFFF2           WRFO      EQU     $FFFFF2                           ; Write fiber optic data replies
102       FFFFF3           WRSS      EQU     $FFFFF3                           ; Write switch state
103       FFFFF5           WRLATCH   EQU     $FFFFF5                           ; Write to a latch
104       010000           RDAD      EQU     $010000                           ; Read A/D values into the DSP
105       000009           EF        EQU     9                                 ; Serial receiver empty flag
106    
107                        ; DSP port A bit equates
108       000000           PWROK     EQU     0                                 ; Power control board says power is OK
109       000001           LED1      EQU     1                                 ; Control one of two LEDs
110       000002           LVEN      EQU     2                                 ; Low voltage power enable
111       000003           HVEN      EQU     3                                 ; High voltage power enable
112       00000E           SSFHF     EQU     14                                ; Switch state FIFO half full flag
113       00000A           EXT_IN0   EQU     10                                ; External digital I/O to the timing board
114       00000B           EXT_IN1   EQU     11
115       00000C           EXT_OUT0  EQU     12
116       00000D           EXT_OUT1  EQU     13
117    
118                        ; Port D equate
119       000001           SSFEF     EQU     1                                 ; Switch state FIFO empty flag
120    
121                        ; Other equates
122       000002           WRENA     EQU     2                                 ; Enable writing to the EEPROM
123    
124                        ; Latch U25 bit equates
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 3



125       000000           CDAC      EQU     0                                 ; Clear the analog board DACs
126       000002           ENCK      EQU     2                                 ; Enable the clock outputs
127       000004           SHUTTER   EQU     4                                 ; Control the shutter
128       000005           TIM_U_RST EQU     5                                 ; Reset the utility board
129    
130                        ; Software status bits, defined at X:<STATUS = X:0
131       000000           ST_RCV    EQU     0                                 ; Set to indicate word is from SCI = utility board
132       000002           IDLMODE   EQU     2                                 ; Set if need to idle after readout
133       000003           ST_SHUT   EQU     3                                 ; Set to indicate shutter is closed, clear for open
134       000004           ST_RDC    EQU     4                                 ; Set if executing 'RDC' command - reading out
135       000005           SPLIT_S   EQU     5                                 ; Set if split serial
136       000006           SPLIT_P   EQU     6                                 ; Set if split parallel
137       000007           MPP       EQU     7                                 ; Set if parallels are in MPP mode
138       000008           NOT_CLR   EQU     8                                 ; Set if not to clear CCD before exposure
139       00000A           TST_IMG   EQU     10                                ; Set if controller is to generate a test image
140       00000B           SHUT      EQU     11                                ; Set if opening shutter at beginning of exposure
141       00000C           ST_DITH   EQU     12                                ; Set if to dither during exposure
142       00000D           ST_SYNC   EQU     13                                ; Set if starting exposure on SYNC = high signal
143       00000E           ST_CNRD   EQU     14                                ; Set if in continous readout mode
144       00000F           ST_DIRTY  EQU     15                                ; Set if waveform tables need to be updated
145       000010           ST_SA     EQU     16                                ; Set if in subarray readout mode
146    
147                        ; Address for the table containing the incoming SCI words
148       000400           SCI_TABLE EQU     $400
149    
150    
151                        ; Specify controller configuration bits of the X:STATUS word
152                        ;   to describe the software capabilities of this application file
153                        ; The bit is set (=1) if the capability is supported by the controller
154    
155    
156                                COMMENT *
157    
158                        BIT #'s         FUNCTION
159                        2,1,0           Video Processor
160                                                000     ARC41, CCD Rev. 3
161                                                001     CCD Gen I
162                                                010     ARC42, dual readout CCD
163                                                011     ARC44, 4-readout IR coadder
164                                                100     ARC45. dual readout CCD
165                                                101     ARC46 = 8-channel IR
166                                                110     ARC48 = 8 channel CCD
167                                                111     ARC47 = 4-channel CCD
168    
169                        4,3             Timing Board
170                                                00      ARC20, Rev. 4, Gen II
171                                                01      Gen I
172                                                10      ARC22, Gen III, 250 MHz
173    
174                        6,5             Utility Board
175                                                00      No utility board
176                                                01      ARC50
177    
178                        7               Shutter
179                                                0       No shutter support
180                                                1       Yes shutter support
181    
182                        9,8             Temperature readout
183                                                00      No temperature readout
184                                                01      Polynomial Diode calibration
185                                                10      Linear temperature sensor calibration
186    
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 4



187                        10              Subarray readout
188                                                0       Not supported
189                                                1       Yes supported
190    
191                        11              Binning
192                                                0       Not supported
193                                                1       Yes supported
194    
195                        12              Split-Serial readout
196                                                0       Not supported
197                                                1       Yes supported
198    
199                        13              Split-Parallel readout
200                                                0       Not supported
201                                                1       Yes supported
202    
203                        14              MPP = Inverted parallel clocks
204                                                0       Not supported
205                                                1       Yes supported
206    
207                        16,15           Clock Driver Board
208                                                00      ARC30 or ARC31
209                                                01      ARC32, CCD and IR
210                                                11      No clock driver board (Gen I)
211    
212                        19,18,17                Special implementations
213                                                000     Somewhere else
214                                                001     Mount Laguna Observatory
215                                                010     NGST Aladdin
216                                                xxx     Other
217                                *
218    
219                        CCDVIDREV3B
220       000000                     EQU     $000000                           ; CCD Video Processor Rev. 3
221       000000           ARC41     EQU     $000000
222       000001           VIDGENI   EQU     $000001                           ; CCD Video Processor Gen I
223       000002           IRREV4    EQU     $000002                           ; IR Video Processor Rev. 4
224       000002           ARC42     EQU     $000002
225       000003           COADDER   EQU     $000003                           ; IR Coadder
226       000003           ARC44     EQU     $000003
227       000004           CCDVIDREV5 EQU    $000004                           ; Differential input CCD video Rev. 5
228       000004           ARC45     EQU     $000004
229       000005           ARC46     EQU     $000005                           ; 8-channel IR video board
230       000006           ARC48     EQU     $000006                           ; 8-channel CCD video board
231       000007           ARC47     EQU     $000007                           ; 4-channel CCD video board
232       000000           TIMREV4   EQU     $000000                           ; Timing Revision 4 = 50 MHz
233       000000           ARC20     EQU     $000000
234       000008           TIMGENI   EQU     $000008                           ; Timing Gen I = 40 MHz
235       000010           TIMREV5   EQU     $000010                           ; Timing Revision 5 = 250 MHz
236       000010           ARC22     EQU     $000010
237       008000           ARC32     EQU     $008000                           ; CCD & IR clock driver board
238       000020           UTILREV3  EQU     $000020                           ; Utility Rev. 3 supported
239       000020           ARC50     EQU     $000020
240       000080           SHUTTER_CC EQU    $000080                           ; Shutter supported
241       000100           TEMP_POLY EQU     $000100                           ; Polynomial calibration
242                        TEMP_LINEAR
243       000200                     EQU     $000200                           ; Linear calibration
244       000400           SUBARRAY  EQU     $000400                           ; Subarray readout supported
245       000800           BINNING   EQU     $000800                           ; Binning supported
246                        SPLIT_SERIAL
247       001000                     EQU     $001000                           ; Split serial supported
248                        SPLIT_PARALLEL
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 5



249       002000                     EQU     $002000                           ; Split parallel supported
250       004000           MPP_CC    EQU     $004000                           ; Inverted clocks supported
251       018000           CLKDRVGENI EQU    $018000                           ; No clock driver board - Gen I
252       020000           MLO       EQU     $020000                           ; Set if Mount Laguna Observatory
253       040000           NGST      EQU     $040000                           ; NGST Aladdin implementation
254       100000           CONT_RD   EQU     $100000                           ; Continuous readout implemented
255    
256                        ; Special address for two words for the DSP to bootstrap code from the EEPROM
257                                  IF      @SCP("HOST","ROM")
264                                  ENDIF
265    
266                                  IF      @SCP("HOST","HOST")
267       P:000000 P:000000                   ORG     P:0,P:0
268       P:000000 P:000000 0C0190            JMP     <INIT
269       P:000001 P:000001 000000            NOP
270                                           ENDIF
271    
272                                 ;  This ISR receives serial words a byte at a time over the asynchronous
273                                 ;    serial link (SCI) and squashes them into a single 24-bit word
274       P:000002 P:000002 602400  SCI_RCV   MOVE              R0,X:<SAVE_R0           ; Save R0
275       P:000003 P:000003 052139            MOVEC             SR,X:<SAVE_SR           ; Save Status Register
276       P:000004 P:000004 60A700            MOVE              X:<SCI_R0,R0            ; Restore R0 = pointer to SCI receive regist
er
277       P:000005 P:000005 542300            MOVE              A1,X:<SAVE_A1           ; Save A1
278       P:000006 P:000006 452200            MOVE              X1,X:<SAVE_X1           ; Save X1
279       P:000007 P:000007 54A600            MOVE              X:<SCI_A1,A1            ; Get SRX value of accumulator contents
280       P:000008 P:000008 45E000            MOVE              X:(R0),X1               ; Get the SCI byte
281       P:000009 P:000009 0AD041            BCLR    #1,R0                             ; Test for the address being $FFF6 = last by
te
282       P:00000A P:00000A 000000            NOP
283       P:00000B P:00000B 000000            NOP
284       P:00000C P:00000C 000000            NOP
285       P:00000D P:00000D 205862            OR      X1,A      (R0)+                   ; Add the byte into the 24-bit word
286       P:00000E P:00000E 0E0013            JCC     <MID_BYT                          ; Not the last byte => only restore register
s
287       P:00000F P:00000F 545C00  END_BYT   MOVE              A1,X:(R4)+              ; Put the 24-bit word into the SCI buffer
288       P:000010 P:000010 60F400            MOVE              #SRXL,R0                ; Re-establish first address of SCI interfac
e
                            FFFF98
289       P:000012 P:000012 2C0000            MOVE              #0,A1                   ; For zeroing out SCI_A1
290       P:000013 P:000013 602700  MID_BYT   MOVE              R0,X:<SCI_R0            ; Save the SCI receiver address
291       P:000014 P:000014 542600            MOVE              A1,X:<SCI_A1            ; Save A1 for next interrupt
292       P:000015 P:000015 05A139            MOVEC             X:<SAVE_SR,SR           ; Restore Status Register
293       P:000016 P:000016 54A300            MOVE              X:<SAVE_A1,A1           ; Restore A1
294       P:000017 P:000017 45A200            MOVE              X:<SAVE_X1,X1           ; Restore X1
295       P:000018 P:000018 60A400            MOVE              X:<SAVE_R0,R0           ; Restore R0
296       P:000019 P:000019 000004            RTI                                       ; Return from interrupt service
297    
298                                 ; Clear error condition and interrupt on SCI receiver
299       P:00001A P:00001A 077013  CLR_ERR   MOVEP             X:SSR,X:RCV_ERR         ; Read SCI status register
                            000025
300       P:00001C P:00001C 077018            MOVEP             X:SRXL,X:RCV_ERR        ; This clears any error
                            000025
301       P:00001E P:00001E 000004            RTI
302    
303       P:00001F P:00001F                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
304       P:000030 P:000030                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
305       P:000040 P:000040                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
306    
307                                 ; Tune the table so the following instruction is at P:$50 exactly.
308       P:000050 P:000050 0D0002            JSR     SCI_RCV                           ; SCI receive data interrupt
309       P:000051 P:000051 000000            NOP
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 6



310       P:000052 P:000052 0D001A            JSR     CLR_ERR                           ; SCI receive error interrupt
311       P:000053 P:000053 000000            NOP
312    
313                                 ; *******************  Command Processing  ******************
314    
315                                 ; Read the header and check it for self-consistency
316       P:000054 P:000054 609F00  START     MOVE              X:<IDL_ADR,R0
317       P:000055 P:000055 018FA0            JSET    #TIM_BIT,X:TCSR0,EXPOSING         ; If exposing go check the timer
                            00005A
318       P:000057 P:000057 0A00A4            JSET    #ST_RDC,X:<STATUS,CONTINUE_READING
                            00005A
319       P:000059 P:000059 0AE080            JMP     (R0)
320    
321       P:00005A P:00005A 330700  TST_RCV   MOVE              #<COM_BUF,R3
322       P:00005B P:00005B 0D00A5            JSR     <GET_RCV
323       P:00005C P:00005C 0E005B            JCC     *-1
324    
325                                 ; Check the header and read all the remaining words in the command
326       P:00005D P:00005D 0C00FF  PRC_RCV   JMP     <CHK_HDR                          ; Update HEADER and NWORDS
327       P:00005E P:00005E 578600  PR_RCV    MOVE              X:<NWORDS,B             ; Read this many words total in the command
328       P:00005F P:00005F 000000            NOP
329       P:000060 P:000060 01418C            SUB     #1,B                              ; We've already read the header
330       P:000061 P:000061 000000            NOP
331       P:000062 P:000062 06CF00            DO      B,RD_COM
                            00006A
332       P:000064 P:000064 205B00            MOVE              (R3)+                   ; Increment past what's been read already
333       P:000065 P:000065 0B0080  GET_WRD   JSCLR   #ST_RCV,X:STATUS,CHK_FO
                            0000A9
334       P:000067 P:000067 0B00A0            JSSET   #ST_RCV,X:STATUS,CHK_SCI
                            0000D5
335       P:000069 P:000069 0E0065            JCC     <GET_WRD
336       P:00006A P:00006A 000000            NOP
337       P:00006B P:00006B 330700  RD_COM    MOVE              #<COM_BUF,R3            ; Restore R3 = beginning of the command
338    
339                                 ; Is this command for the timing board?
340       P:00006C P:00006C 448500            MOVE              X:<HEADER,X0
341       P:00006D P:00006D 579B00            MOVE              X:<DMASK,B
342       P:00006E P:00006E 459A4E            AND     X0,B      X:<TIM_DRB,X1           ; Extract destination byte
343       P:00006F P:00006F 20006D            CMP     X1,B                              ; Does header = timing board number?
344       P:000070 P:000070 0EA080            JEQ     <COMMAND                          ; Yes, process it here
345       P:000071 P:000071 0E909D            JLT     <FO_XMT                           ; Send it to fiber optic transmitter
346    
347                                 ; Transmit the command to the utility board over the SCI port
348       P:000072 P:000072 060600            DO      X:<NWORDS,DON_XMT                 ; Transmit NWORDS
                            00007E
349       P:000074 P:000074 60F400            MOVE              #STXL,R0                ; SCI first byte address
                            FFFF95
350       P:000076 P:000076 44DB00            MOVE              X:(R3)+,X0              ; Get the 24-bit word to transmit
351       P:000077 P:000077 060380            DO      #3,SCI_SPT
                            00007D
352       P:000079 P:000079 019381            JCLR    #TDRE,X:SSR,*                     ; Continue ONLY if SCI XMT is empty
                            000079
353       P:00007B P:00007B 445800            MOVE              X0,X:(R0)+              ; Write to SCI, byte pointer + 1
354       P:00007C P:00007C 000000            NOP                                       ; Delay for the status flag to be set
355       P:00007D P:00007D 000000            NOP
356                                 SCI_SPT
357       P:00007E P:00007E 000000            NOP
358                                 DON_XMT
359       P:00007F P:00007F 0C0054            JMP     <START
360    
361                                 ; Process the receiver entry - is it in the command table ?
362       P:000080 P:000080 0203DF  COMMAND   MOVE              X:(R3+1),B              ; Get the command
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 7



363       P:000081 P:000081 205B00            MOVE              (R3)+
364       P:000082 P:000082 205B00            MOVE              (R3)+                   ; Point R3 to the first argument
365       P:000083 P:000083 302800            MOVE              #<COM_TBL,R0            ; Get the command table starting address
366       P:000084 P:000084 062180            DO      #NUM_COM,END_COM                  ; Loop over the command table
                            00008B
367       P:000086 P:000086 47D800            MOVE              X:(R0)+,Y1              ; Get the command table entry
368       P:000087 P:000087 62E07D            CMP     Y1,B      X:(R0),R2               ; Does receiver = table entries address?
369       P:000088 P:000088 0E208B            JNE     <NOT_COM                          ; No, keep looping
370       P:000089 P:000089 00008C            ENDDO                                     ; Restore the DO loop system registers
371       P:00008A P:00008A 0AE280            JMP     (R2)                              ; Jump execution to the command
372       P:00008B P:00008B 205800  NOT_COM   MOVE              (R0)+                   ; Increment the register past the table addr
ess
373                                 END_COM
374       P:00008C P:00008C 0C008D            JMP     <ERROR                            ; The command is not in the table
375    
376                                 ; It's not in the command table - send an error message
377       P:00008D P:00008D 479D00  ERROR     MOVE              X:<ERR,Y1               ; Send the message - there was an error
378       P:00008E P:00008E 0C0090            JMP     <FINISH1                          ; This protects against unknown commands
379    
380                                 ; Send a reply packet - header and reply
381       P:00008F P:00008F 479800  FINISH    MOVE              X:<DONE,Y1              ; Send 'DON' as the reply
382       P:000090 P:000090 578500  FINISH1   MOVE              X:<HEADER,B             ; Get header of incoming command
383       P:000091 P:000091 469C00            MOVE              X:<SMASK,Y0             ; This was the source byte, and is to
384       P:000092 P:000092 330700            MOVE              #<COM_BUF,R3            ;     become the destination byte
385       P:000093 P:000093 46935E            AND     Y0,B      X:<TWO,Y0
386       P:000094 P:000094 0C1ED1            LSR     #8,B                              ; Shift right eight bytes, add it to the
387       P:000095 P:000095 460600            MOVE              Y0,X:<NWORDS            ;     header, and put 2 as the number
388       P:000096 P:000096 469958            ADD     Y0,B      X:<SBRD,Y0              ;     of words in the string
389       P:000097 P:000097 200058            ADD     Y0,B                              ; Add source board's header, set Y1 for abov
e
390       P:000098 P:000098 000000            NOP
391       P:000099 P:000099 575B00            MOVE              B,X:(R3)+               ; Put the new header on the transmitter stac
k
392       P:00009A P:00009A 475B00            MOVE              Y1,X:(R3)+              ; Put the argument on the transmitter stack
393       P:00009B P:00009B 570500            MOVE              B,X:<HEADER
394       P:00009C P:00009C 0C006B            JMP     <RD_COM                           ; Decide where to send the reply, and do it
395    
396                                 ; Transmit words to the host computer over the fiber optics link
397       P:00009D P:00009D 63F400  FO_XMT    MOVE              #COM_BUF,R3
                            000007
398       P:00009F P:00009F 060600            DO      X:<NWORDS,DON_FFO                 ; Transmit all the words in the command
                            0000A3
399       P:0000A1 P:0000A1 57DB00            MOVE              X:(R3)+,B
400       P:0000A2 P:0000A2 0D00EB            JSR     <XMT_WRD
401       P:0000A3 P:0000A3 000000            NOP
402       P:0000A4 P:0000A4 0C0054  DON_FFO   JMP     <START
403    
404                                 ; Check for commands from the fiber optic FIFO and the utility board (SCI)
405       P:0000A5 P:0000A5 0D00A9  GET_RCV   JSR     <CHK_FO                           ; Check for fiber optic command from FIFO
406       P:0000A6 P:0000A6 0E80A8            JCS     <RCV_RTS                          ; If there's a command, check the header
407       P:0000A7 P:0000A7 0D00D5            JSR     <CHK_SCI                          ; Check for an SCI command
408       P:0000A8 P:0000A8 00000C  RCV_RTS   RTS
409    
410                                 ; Because of FIFO metastability require that EF be stable for two tests
411       P:0000A9 P:0000A9 0A8989  CHK_FO    JCLR    #EF,X:HDR,TST2                    ; EF = Low,  Low  => CLR SR, return
                            0000AC
412       P:0000AB P:0000AB 0C00AF            JMP     <TST3                             ;      High, Low  => try again
413       P:0000AC P:0000AC 0A8989  TST2      JCLR    #EF,X:HDR,CLR_CC                  ;      Low,  High => try again
                            0000D1
414       P:0000AE P:0000AE 0C00A9            JMP     <CHK_FO                           ;      High, High => read FIFO
415       P:0000AF P:0000AF 0A8989  TST3      JCLR    #EF,X:HDR,CHK_FO
                            0000A9
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 8



416    
417       P:0000B1 P:0000B1 08F4BB            MOVEP             #$028FE2,X:BCR          ; Slow down RDFO access
                            028FE2
418       P:0000B3 P:0000B3 000000            NOP
419       P:0000B4 P:0000B4 000000            NOP
420       P:0000B5 P:0000B5 5FF000            MOVE                          Y:RDFO,B
                            FFFFF1
421       P:0000B7 P:0000B7 2B0000            MOVE              #0,B2
422       P:0000B8 P:0000B8 0140CE            AND     #$FF,B
                            0000FF
423       P:0000BA P:0000BA 0140CD            CMP     #>$AC,B                           ; It must be $AC to be a valid word
                            0000AC
424       P:0000BC P:0000BC 0E20D1            JNE     <CLR_CC
425       P:0000BD P:0000BD 4EF000            MOVE                          Y:RDFO,Y0   ; Read the MS byte
                            FFFFF1
426       P:0000BF P:0000BF 0C1951            INSERT  #$008010,Y0,B
                            008010
427       P:0000C1 P:0000C1 4EF000            MOVE                          Y:RDFO,Y0   ; Read the middle byte
                            FFFFF1
428       P:0000C3 P:0000C3 0C1951            INSERT  #$008008,Y0,B
                            008008
429       P:0000C5 P:0000C5 4EF000            MOVE                          Y:RDFO,Y0   ; Read the LS byte
                            FFFFF1
430       P:0000C7 P:0000C7 0C1951            INSERT  #$008000,Y0,B
                            008000
431       P:0000C9 P:0000C9 000000            NOP
432       P:0000CA P:0000CA 516300            MOVE              B0,X:(R3)               ; Put the word into COM_BUF
433       P:0000CB P:0000CB 0A0000            BCLR    #ST_RCV,X:<STATUS                 ; Its a command from the host computer
434       P:0000CC P:0000CC 000000  SET_CC    NOP
435       P:0000CD P:0000CD 0AF960            BSET    #0,SR                             ; Valid word => SR carry bit = 1
436       P:0000CE P:0000CE 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
437       P:0000D0 P:0000D0 00000C            RTS
438       P:0000D1 P:0000D1 0AF940  CLR_CC    BCLR    #0,SR                             ; Not valid word => SR carry bit = 0
439       P:0000D2 P:0000D2 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
440       P:0000D4 P:0000D4 00000C            RTS
441    
442                                 ; Test the SCI (= synchronous communications interface) for new words
443       P:0000D5 P:0000D5 44F000  CHK_SCI   MOVE              X:(SCI_TABLE+33),X0
                            000421
444       P:0000D7 P:0000D7 228E00            MOVE              R4,A
445       P:0000D8 P:0000D8 209000            MOVE              X0,R0
446       P:0000D9 P:0000D9 200045            CMP     X0,A
447       P:0000DA P:0000DA 0EA0D1            JEQ     <CLR_CC                           ; There is no new SCI word
448       P:0000DB P:0000DB 44D800            MOVE              X:(R0)+,X0
449       P:0000DC P:0000DC 446300            MOVE              X0,X:(R3)
450       P:0000DD P:0000DD 220E00            MOVE              R0,A
451       P:0000DE P:0000DE 0140C5            CMP     #(SCI_TABLE+32),A                 ; Wrap it around the circular
                            000420
452       P:0000E0 P:0000E0 0EA0E4            JEQ     <INIT_PROCESSED_SCI               ;   buffer boundary
453       P:0000E1 P:0000E1 547000            MOVE              A1,X:(SCI_TABLE+33)
                            000421
454       P:0000E3 P:0000E3 0C00E9            JMP     <SCI_END
455                                 INIT_PROCESSED_SCI
456       P:0000E4 P:0000E4 56F400            MOVE              #SCI_TABLE,A
                            000400
457       P:0000E6 P:0000E6 000000            NOP
458       P:0000E7 P:0000E7 567000            MOVE              A,X:(SCI_TABLE+33)
                            000421
459       P:0000E9 P:0000E9 0A0020  SCI_END   BSET    #ST_RCV,X:<STATUS                 ; Its a utility board (SCI) word
460       P:0000EA P:0000EA 0C00CC            JMP     <SET_CC
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 9



461    
462                                 ; Transmit the word in B1 to the host computer over the fiber optic data link
463                                 XMT_WRD
464       P:0000EB P:0000EB 08F4BB            MOVEP             #$028FE2,X:BCR          ; Slow down RDFO access
                            028FE2
465       P:0000ED P:0000ED 60F400            MOVE              #FO_HDR+1,R0
                            000002
466       P:0000EF P:0000EF 060380            DO      #3,XMT_WRD1
                            0000F3
467       P:0000F1 P:0000F1 0C1D91            ASL     #8,B,B
468       P:0000F2 P:0000F2 000000            NOP
469       P:0000F3 P:0000F3 535800            MOVE              B2,X:(R0)+
470                                 XMT_WRD1
471       P:0000F4 P:0000F4 60F400            MOVE              #FO_HDR,R0
                            000001
472       P:0000F6 P:0000F6 61F400            MOVE              #WRFO,R1
                            FFFFF2
473       P:0000F8 P:0000F8 060480            DO      #4,XMT_WRD2
                            0000FB
474       P:0000FA P:0000FA 46D800            MOVE              X:(R0)+,Y0              ; Should be MOVEP  X:(R0)+,Y:WRFO
475       P:0000FB P:0000FB 4E6100            MOVE                          Y0,Y:(R1)
476                                 XMT_WRD2
477       P:0000FC P:0000FC 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
478       P:0000FE P:0000FE 00000C            RTS
479    
480                                 ; Check the command or reply header in X:(R3) for self-consistency
481       P:0000FF P:0000FF 46E300  CHK_HDR   MOVE              X:(R3),Y0
482       P:000100 P:000100 579600            MOVE              X:<MASK1,B              ; Test for S.LE.3 and D.LE.3 and N.LE.7
483       P:000101 P:000101 20005E            AND     Y0,B
484       P:000102 P:000102 0E208D            JNE     <ERROR                            ; Test failed
485       P:000103 P:000103 579700            MOVE              X:<MASK2,B              ; Test for either S.NE.0 or D.NE.0
486       P:000104 P:000104 20005E            AND     Y0,B
487       P:000105 P:000105 0EA08D            JEQ     <ERROR                            ; Test failed
488       P:000106 P:000106 579500            MOVE              X:<SEVEN,B
489       P:000107 P:000107 20005E            AND     Y0,B                              ; Extract NWORDS, must be > 0
490       P:000108 P:000108 0EA08D            JEQ     <ERROR
491       P:000109 P:000109 44E300            MOVE              X:(R3),X0
492       P:00010A P:00010A 440500            MOVE              X0,X:<HEADER            ; Its a correct header
493       P:00010B P:00010B 550600            MOVE              B1,X:<NWORDS            ; Number of words in the command
494       P:00010C P:00010C 0C005E            JMP     <PR_RCV
495    
496                                 ;  *****************  Boot Commands  *******************
497    
498                                 ; Test Data Link - simply return value received after 'TDL'
499       P:00010D P:00010D 47DB00  TDL       MOVE              X:(R3)+,Y1              ; Get the data value
500       P:00010E P:00010E 0C0090            JMP     <FINISH1                          ; Return from executing TDL command
501    
502                                 ; Read DSP or EEPROM memory ('RDM' address): read memory, reply with value
503       P:00010F P:00010F 47DB00  RDMEM     MOVE              X:(R3)+,Y1
504       P:000110 P:000110 20EF00            MOVE              Y1,B
505       P:000111 P:000111 0140CE            AND     #$0FFFFF,B                        ; Bits 23-20 need to be zeroed
                            0FFFFF
506       P:000113 P:000113 21B000            MOVE              B1,R0                   ; Need the address in an address register
507       P:000114 P:000114 20EF00            MOVE              Y1,B
508       P:000115 P:000115 000000            NOP
509       P:000116 P:000116 0ACF14            JCLR    #20,B,RDX                         ; Test address bit for Program memory
                            00011A
510       P:000118 P:000118 07E087            MOVE              P:(R0),Y1               ; Read from Program Memory
511       P:000119 P:000119 0C0090            JMP     <FINISH1                          ; Send out a header with the value
512       P:00011A P:00011A 0ACF15  RDX       JCLR    #21,B,RDY                         ; Test address bit for X: memory
                            00011E
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 10



513       P:00011C P:00011C 47E000            MOVE              X:(R0),Y1               ; Write to X data memory
514       P:00011D P:00011D 0C0090            JMP     <FINISH1                          ; Send out a header with the value
515       P:00011E P:00011E 0ACF16  RDY       JCLR    #22,B,RDR                         ; Test address bit for Y: memory
                            000122
516       P:000120 P:000120 4FE000            MOVE                          Y:(R0),Y1   ; Read from Y data memory
517       P:000121 P:000121 0C0090            JMP     <FINISH1                          ; Send out a header with the value
518       P:000122 P:000122 0ACF17  RDR       JCLR    #23,B,ERROR                       ; Test address bit for read from EEPROM memo
ry
                            00008D
519       P:000124 P:000124 479400            MOVE              X:<THREE,Y1             ; Convert to word address to a byte address
520       P:000125 P:000125 220600            MOVE              R0,Y0                   ; Get 16-bit address in a data register
521       P:000126 P:000126 2000B8            MPY     Y0,Y1,B                           ; Multiply
522       P:000127 P:000127 20002A            ASR     B                                 ; Eliminate zero fill of fractional multiply
523       P:000128 P:000128 213000            MOVE              B0,R0                   ; Need to address memory
524       P:000129 P:000129 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
525       P:00012A P:00012A 0D0178            JSR     <RD_WORD                          ; Read word from EEPROM
526       P:00012B P:00012B 21A700            MOVE              B1,Y1                   ; FINISH1 transmits Y1 as its reply
527       P:00012C P:00012C 0C0090            JMP     <FINISH1
528    
529                                 ; Program WRMEM ('WRM' address datum): write to memory, reply 'DON'.
530       P:00012D P:00012D 47DB00  WRMEM     MOVE              X:(R3)+,Y1              ; Get the address to be written to
531       P:00012E P:00012E 20EF00            MOVE              Y1,B
532       P:00012F P:00012F 0140CE            AND     #$0FFFFF,B                        ; Bits 23-20 need to be zeroed
                            0FFFFF
533       P:000131 P:000131 21B000            MOVE              B1,R0                   ; Need the address in an address register
534       P:000132 P:000132 20EF00            MOVE              Y1,B
535       P:000133 P:000133 46DB00            MOVE              X:(R3)+,Y0              ; Get datum into Y0 so MOVE works easily
536       P:000134 P:000134 0ACF14            JCLR    #20,B,WRX                         ; Test address bit for Program memory
                            000138
537       P:000136 P:000136 076086            MOVE              Y0,P:(R0)               ; Write to Program memory
538       P:000137 P:000137 0C008F            JMP     <FINISH
539       P:000138 P:000138 0ACF15  WRX       JCLR    #21,B,WRY                         ; Test address bit for X: memory
                            00013C
540       P:00013A P:00013A 466000            MOVE              Y0,X:(R0)               ; Write to X: memory
541       P:00013B P:00013B 0C008F            JMP     <FINISH
542       P:00013C P:00013C 0ACF16  WRY       JCLR    #22,B,WRR                         ; Test address bit for Y: memory
                            000140
543       P:00013E P:00013E 4E6000            MOVE                          Y0,Y:(R0)   ; Write to Y: memory
544       P:00013F P:00013F 0C008F            JMP     <FINISH
545       P:000140 P:000140 0ACF17  WRR       JCLR    #23,B,ERROR                       ; Test address bit for write to EEPROM
                            00008D
546       P:000142 P:000142 013D02            BCLR    #WRENA,X:PDRC                     ; WR_ENA* = 0 to enable EEPROM writing
547       P:000143 P:000143 460E00            MOVE              Y0,X:<SV_A1             ; Save the datum to be written
548       P:000144 P:000144 479400            MOVE              X:<THREE,Y1             ; Convert word address to a byte address
549       P:000145 P:000145 220600            MOVE              R0,Y0                   ; Get 16-bit address in a data register
550       P:000146 P:000146 2000B8            MPY     Y1,Y0,B                           ; Multiply
551       P:000147 P:000147 20002A            ASR     B                                 ; Eliminate zero fill of fractional multiply
552       P:000148 P:000148 213000            MOVE              B0,R0                   ; Need to address memory
553       P:000149 P:000149 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
554       P:00014A P:00014A 558E00            MOVE              X:<SV_A1,B1             ; Get the datum to be written
555       P:00014B P:00014B 060380            DO      #3,L1WRR                          ; Loop over three bytes of the word
                            000154
556       P:00014D P:00014D 07588D            MOVE              B1,P:(R0)+              ; Write each EEPROM byte
557       P:00014E P:00014E 0C1C91            ASR     #8,B,B
558       P:00014F P:00014F 469E00            MOVE              X:<C100K,Y0             ; Move right one byte, enter delay = 1 msec
559       P:000150 P:000150 06C600            DO      Y0,L2WRR                          ; Delay by 12 milliseconds for EEPROM write
                            000153
560       P:000152 P:000152 060CA0            REP     #12                               ; Assume 100 MHz DSP56303
561       P:000153 P:000153 000000            NOP
562                                 L2WRR
563       P:000154 P:000154 000000            NOP                                       ; DO loop nesting restriction
564                                 L1WRR
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 11



565       P:000155 P:000155 013D22            BSET    #WRENA,X:PDRC                     ; WR_ENA* = 1 to disable EEPROM writing
566       P:000156 P:000156 0C008F            JMP     <FINISH
567    
568                                 ; Load application code from P: memory into its proper locations
569       P:000157 P:000157 47DB00  LDAPPL    MOVE              X:(R3)+,Y1              ; Application number, not used yet
570       P:000158 P:000158 0D015A            JSR     <LOAD_APPLICATION
571       P:000159 P:000159 0C008F            JMP     <FINISH
572    
573                                 LOAD_APPLICATION
574       P:00015A P:00015A 60F400            MOVE              #$8000,R0               ; Starting EEPROM address
                            008000
575       P:00015C P:00015C 0D0178            JSR     <RD_WORD                          ; Number of words in boot code
576       P:00015D P:00015D 21A600            MOVE              B1,Y0
577       P:00015E P:00015E 479400            MOVE              X:<THREE,Y1
578       P:00015F P:00015F 2000B8            MPY     Y0,Y1,B
579       P:000160 P:000160 20002A            ASR     B
580       P:000161 P:000161 213000            MOVE              B0,R0                   ; EEPROM address of start of P: application
581       P:000162 P:000162 0AD06F            BSET    #15,R0                            ; To access EEPROM
582       P:000163 P:000163 0D0178            JSR     <RD_WORD                          ; Read number of words in application P:
583       P:000164 P:000164 61F400            MOVE              #(X_BOOT_START+1),R1    ; End of boot P: code that needs keeping
                            00022B
584       P:000166 P:000166 06CD00            DO      B1,RD_APPL_P
                            000169
585       P:000168 P:000168 0D0178            JSR     <RD_WORD
586       P:000169 P:000169 07598D            MOVE              B1,P:(R1)+
587                                 RD_APPL_P
588       P:00016A P:00016A 0D0178            JSR     <RD_WORD                          ; Read number of words in application X:
589       P:00016B P:00016B 61F400            MOVE              #END_COMMAND_TABLE,R1
                            000036
590       P:00016D P:00016D 06CD00            DO      B1,RD_APPL_X
                            000170
591       P:00016F P:00016F 0D0178            JSR     <RD_WORD
592       P:000170 P:000170 555900            MOVE              B1,X:(R1)+
593                                 RD_APPL_X
594       P:000171 P:000171 0D0178            JSR     <RD_WORD                          ; Read number of words in application Y:
595       P:000172 P:000172 310100            MOVE              #1,R1                   ; There is no Y: memory in the boot code
596       P:000173 P:000173 06CD00            DO      B1,RD_APPL_Y
                            000176
597       P:000175 P:000175 0D0178            JSR     <RD_WORD
598       P:000176 P:000176 5D5900            MOVE                          B1,Y:(R1)+
599                                 RD_APPL_Y
600       P:000177 P:000177 00000C            RTS
601    
602                                 ; Read one word from EEPROM location R0 into accumulator B1
603       P:000178 P:000178 060380  RD_WORD   DO      #3,L_RDBYTE
                            00017B
604       P:00017A P:00017A 07D88B            MOVE              P:(R0)+,B2
605       P:00017B P:00017B 0C1C91            ASR     #8,B,B
606                                 L_RDBYTE
607       P:00017C P:00017C 00000C            RTS
608    
609                                 ; Come to here on a 'STP' command so 'DON' can be sent
610                                 STOP_IDLE_CLOCKING
611       P:00017D P:00017D 305A00            MOVE              #<TST_RCV,R0            ; Execution address when idle => when not
612       P:00017E P:00017E 601F00            MOVE              R0,X:<IDL_ADR           ;   processing commands or reading out
613       P:00017F P:00017F 0A0002            BCLR    #IDLMODE,X:<STATUS                ; Don't idle after readout
614       P:000180 P:000180 0C008F            JMP     <FINISH
615    
616                                 ; Routines executed after the DSP boots and initializes
617       P:000181 P:000181 305A00  STARTUP   MOVE              #<TST_RCV,R0            ; Execution address when idle => when not
618       P:000182 P:000182 601F00            MOVE              R0,X:<IDL_ADR           ;   processing commands or reading out
619       P:000183 P:000183 44F400            MOVE              #50000,X0               ; Delay by 500 milliseconds
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 12



                            00C350
620       P:000185 P:000185 06C400            DO      X0,L_DELAY
                            000188
621       P:000187 P:000187 06E8A3            REP     #1000
622       P:000188 P:000188 000000            NOP
623                                 L_DELAY
624       P:000189 P:000189 57F400            MOVE              #$020002,B              ; Normal reply after booting is 'SYR'
                            020002
625       P:00018B P:00018B 0D00EB            JSR     <XMT_WRD
626       P:00018C P:00018C 57F400            MOVE              #'SYR',B
                            535952
627       P:00018E P:00018E 0D00EB            JSR     <XMT_WRD
628    
629       P:00018F P:00018F 0C0054            JMP     <START                            ; Start normal command processing
630    
631                                 ; *******************  DSP  INITIALIZATION  CODE  **********************
632                                 ; This code initializes the DSP right after booting, and is overwritten
633                                 ;   by application code
634       P:000190 P:000190 08F4BD  INIT      MOVEP             #PLL_INIT,X:PCTL        ; Initialize PLL to 100 MHz
                            050003
635       P:000192 P:000192 000000            NOP
636    
637                                 ; Set operation mode register OMR to normal expanded
638       P:000193 P:000193 0500BA            MOVEC             #$0000,OMR              ; Operating Mode Register = Normal Expanded
639       P:000194 P:000194 0500BB            MOVEC             #0,SP                   ; Reset the Stack Pointer SP
640    
641                                 ; Program the AA = address attribute pins
642       P:000195 P:000195 08F4B9            MOVEP             #$FFFC21,X:AAR0         ; Y = $FFF000 to $FFFFFF asserts commands
                            FFFC21
643       P:000197 P:000197 08F4B8            MOVEP             #$008909,X:AAR1         ; P = $008000 to $00FFFF accesses the EEPROM
                            008909
644       P:000199 P:000199 08F4B7            MOVEP             #$010C11,X:AAR2         ; X = $010000 to $010FFF reads A/D values
                            010C11
645       P:00019B P:00019B 08F4B6            MOVEP             #$080621,X:AAR3         ; Y = $080000 to $0BFFFF R/W from SRAM
                            080621
646    
647       P:00019D P:00019D 0A0F00            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
648       P:00019E P:00019E 0A0F02            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
649       P:00019F P:00019F 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                            00000F
650    
651                                 ; Program the DRAM memory access and addressing
652       P:0001A1 P:0001A1 08F4BB            MOVEP             #$028FE1,X:BCR          ; Bus Control Register
                            028FE1
653    
654                                 ; Program the Host port B for parallel I/O
655       P:0001A3 P:0001A3 08F484            MOVEP             #>1,X:HPCR              ; All pins enabled as GPIO
                            000001
656       P:0001A5 P:0001A5 08F489            MOVEP             #$810C,X:HDR
                            00810C
657       P:0001A7 P:0001A7 08F488            MOVEP             #$B10E,X:HDDR           ; Data Direction Register
                            00B10E
658                                                                                     ;  (1 for Output, 0 for Input)
659    
660                                 ; Port B conversion from software bits to schematic labels
661                                 ;       PB0 = PWROK             PB08 = PRSFIFO*
662                                 ;       PB1 = LED1              PB09 = EF*
663                                 ;       PB2 = LVEN              PB10 = EXT-IN0
664                                 ;       PB3 = HVEN              PB11 = EXT-IN1
665                                 ;       PB4 = STATUS0           PB12 = EXT-OUT0
666                                 ;       PB5 = STATUS1           PB13 = EXT-OUT1
667                                 ;       PB6 = STATUS2           PB14 = SSFHF*
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 13



668                                 ;       PB7 = STATUS3           PB15 = SELSCI
669    
670                                 ; Program the serial port ESSI0 = Port C for serial communication with
671                                 ;   the utility board
672       P:0001A9 P:0001A9 07F43F            MOVEP             #>0,X:PCRC              ; Software reset of ESSI0
                            000000
673       P:0001AB P:0001AB 07F435            MOVEP             #$180809,X:CRA0         ; Divide 100 MHz by 20 to get 5.0 MHz
                            180809
674                                                                                     ; DC[4:0] = 0 for non-network operation
675                                                                                     ; WL0-WL2 = 3 for 24-bit data words
676                                                                                     ; SSC1 = 0 for SC1 not used
677       P:0001AD P:0001AD 07F436            MOVEP             #$020020,X:CRB0         ; SCKD = 1 for internally generated clock
                            020020
678                                                                                     ; SCD2 = 0 so frame sync SC2 is an output
679                                                                                     ; SHFD = 0 for MSB shifted first
680                                                                                     ; FSL = 0, frame sync length not used
681                                                                                     ; CKP = 0 for rising clock edge transitions
682                                                                                     ; SYN = 0 for asynchronous
683                                                                                     ; TE0 = 1 to enable transmitter #0
684                                                                                     ; MOD = 0 for normal, non-networked mode
685                                                                                     ; TE0 = 0 to NOT enable transmitter #0 yet
686                                                                                     ; RE = 1 to enable receiver
687       P:0001AF P:0001AF 07F43F            MOVEP             #%111001,X:PCRC         ; Control Register (0 for GPIO, 1 for ESSI)
                            000039
688       P:0001B1 P:0001B1 07F43E            MOVEP             #%000110,X:PRRC         ; Data Direction Register (0 for In, 1 for O
ut)
                            000006
689       P:0001B3 P:0001B3 07F43D            MOVEP             #%000100,X:PDRC         ; Data Register - WR_ENA* = 1
                            000004
690    
691                                 ; Port C version = Analog boards
692                                 ;       MOVEP   #$000809,X:CRA0 ; Divide 100 MHz by 20 to get 5.0 MHz
693                                 ;       MOVEP   #$000030,X:CRB0 ; SCKD = 1 for internally generated clock
694                                 ;       MOVEP   #%100000,X:PCRC ; Control Register (0 for GPIO, 1 for ESSI)
695                                 ;       MOVEP   #%000100,X:PRRC ; Data Direction Register (0 for In, 1 for Out)
696                                 ;       MOVEP   #%000000,X:PDRC ; Data Register: 'not used' = 0 outputs
697    
698       P:0001B5 P:0001B5 07F43C            MOVEP             #0,X:TX00               ; Initialize the transmitter to zero
                            000000
699       P:0001B7 P:0001B7 000000            NOP
700       P:0001B8 P:0001B8 000000            NOP
701       P:0001B9 P:0001B9 013630            BSET    #TE,X:CRB0                        ; Enable the SSI transmitter
702    
703                                 ; Conversion from software bits to schematic labels for Port C
704                                 ;       PC0 = SC00 = UTL-T-SCK
705                                 ;       PC1 = SC01 = 2_XMT = SYNC on prototype
706                                 ;       PC2 = SC02 = WR_ENA*
707                                 ;       PC3 = SCK0 = TIM-U-SCK
708                                 ;       PC4 = SRD0 = UTL-T-STD
709                                 ;       PC5 = STD0 = TIM-U-STD
710    
711                                 ; Program the serial port ESSI1 = Port D for serial transmission to
712                                 ;   the analog boards and two parallel I/O input pins
713       P:0001BA P:0001BA 07F42F            MOVEP             #>0,X:PCRD              ; Software reset of ESSI0
                            000000
714       P:0001BC P:0001BC 07F425            MOVEP             #$000809,X:CRA1         ; Divide 100 MHz by 20 to get 5.0 MHz
                            000809
715                                                                                     ; DC[4:0] = 0
716                                                                                     ; WL[2:0] = ALC = 0 for 8-bit data words
717                                                                                     ; SSC1 = 0 for SC1 not used
718       P:0001BE P:0001BE 07F426            MOVEP             #$000030,X:CRB1         ; SCKD = 1 for internally generated clock
                            000030
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 14



719                                                                                     ; SCD2 = 1 so frame sync SC2 is an output
720                                                                                     ; SHFD = 0 for MSB shifted first
721                                                                                     ; CKP = 0 for rising clock edge transitions
722                                                                                     ; TE0 = 0 to NOT enable transmitter #0 yet
723                                                                                     ; MOD = 0 so its not networked mode
724       P:0001C0 P:0001C0 07F42F            MOVEP             #%100000,X:PCRD         ; Control Register (0 for GPIO, 1 for ESSI)
                            000020
725                                                                                     ; PD3 = SCK1, PD5 = STD1 for ESSI
726       P:0001C2 P:0001C2 07F42E            MOVEP             #%000100,X:PRRD         ; Data Direction Register (0 for In, 1 for O
ut)
                            000004
727       P:0001C4 P:0001C4 07F42D            MOVEP             #%000100,X:PDRD         ; Data Register: 'not used' = 0 outputs
                            000004
728       P:0001C6 P:0001C6 07F42C            MOVEP             #0,X:TX10               ; Initialize the transmitter to zero
                            000000
729       P:0001C8 P:0001C8 000000            NOP
730       P:0001C9 P:0001C9 000000            NOP
731       P:0001CA P:0001CA 012630            BSET    #TE,X:CRB1                        ; Enable the SSI transmitter
732    
733                                 ; Conversion from software bits to schematic labels for Port D
734                                 ; PD0 = SC10 = 2_XMT_? input
735                                 ; PD1 = SC11 = SSFEF* input
736                                 ; PD2 = SC12 = PWR_EN
737                                 ; PD3 = SCK1 = TIM-A-SCK
738                                 ; PD4 = SRD1 = PWRRST
739                                 ; PD5 = STD1 = TIM-A-STD
740    
741                                 ; Program the SCI port to communicate with the utility board
742       P:0001CB P:0001CB 07F41C            MOVEP             #$0B04,X:SCR            ; SCI programming: 11-bit asynchronous
                            000B04
743                                                                                     ;   protocol (1 start, 8 data, 1 even parity
,
744                                                                                     ;   1 stop); LSB before MSB; enable receiver
745                                                                                     ;   and its interrupts; transmitter interrup
ts
746                                                                                     ;   disabled.
747       P:0001CD P:0001CD 07F41B            MOVEP             #$0003,X:SCCR           ; SCI clock: utility board data rate =
                            000003
748                                                                                     ;   (390,625 kbits/sec); internal clock.
749       P:0001CF P:0001CF 07F41F            MOVEP             #%011,X:PCRE            ; Port Control Register = RXD, TXD enabled
                            000003
750       P:0001D1 P:0001D1 07F41E            MOVEP             #%000,X:PRRE            ; Port Direction Register (0 = Input)
                            000000
751    
752                                 ;       PE0 = RXD
753                                 ;       PE1 = TXD
754                                 ;       PE2 = SCLK
755    
756                                 ; Program one of the three timers as an exposure timer
757       P:0001D3 P:0001D3 07F403            MOVEP             #$C34F,X:TPLR           ; Prescaler to generate millisecond timer,
                            00C34F
758                                                                                     ;  counting from the system clock / 2 = 50 M
Hz
759       P:0001D5 P:0001D5 07F40F            MOVEP             #$208200,X:TCSR0        ; Clear timer complete bit and enable presca
ler
                            208200
760       P:0001D7 P:0001D7 07F40E            MOVEP             #0,X:TLR0               ; Timer load register
                            000000
761    
762                                 ; Enable interrupts for the SCI port only
763       P:0001D9 P:0001D9 08F4BF            MOVEP             #$000000,X:IPRC         ; No interrupts allowed
                            000000
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 15



764       P:0001DB P:0001DB 08F4BE            MOVEP             #>$80,X:IPRP            ; Enable SCI interrupt only, IPR = 1
                            000080
765       P:0001DD P:0001DD 00FCB8            ANDI    #$FC,MR                           ; Unmask all interrupt levels
766    
767                                 ; Initialize the fiber optic serial receiver circuitry
768       P:0001DE P:0001DE 061480            DO      #20,L_FO_INIT
                            0001E3
769       P:0001E0 P:0001E0 5FF000            MOVE                          Y:RDFO,B
                            FFFFF1
770       P:0001E2 P:0001E2 0605A0            REP     #5
771       P:0001E3 P:0001E3 000000            NOP
772                                 L_FO_INIT
773    
774                                 ; Pulse PRSFIFO* low to revive the CMDRST* instruction and reset the FIFO
775       P:0001E4 P:0001E4 44F400            MOVE              #1000000,X0             ; Delay by 10 milliseconds
                            0F4240
776       P:0001E6 P:0001E6 06C400            DO      X0,*+3
                            0001E8
777       P:0001E8 P:0001E8 000000            NOP
778       P:0001E9 P:0001E9 0A8908            BCLR    #8,X:HDR
779       P:0001EA P:0001EA 0614A0            REP     #20
780       P:0001EB P:0001EB 000000            NOP
781       P:0001EC P:0001EC 0A8928            BSET    #8,X:HDR
782    
783                                 ; Reset the utility board
784       P:0001ED P:0001ED 0A0F05            BCLR    #5,X:<LATCH
785       P:0001EE P:0001EE 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Clear reset utility board bit
                            00000F
786       P:0001F0 P:0001F0 06C8A0            REP     #200                              ; Delay by RESET* low time
787       P:0001F1 P:0001F1 000000            NOP
788       P:0001F2 P:0001F2 0A0F25            BSET    #5,X:<LATCH
789       P:0001F3 P:0001F3 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Clear reset utility board bit
                            00000F
790       P:0001F5 P:0001F5 56F400            MOVE              #200000,A               ; Delay 2 msec for utility boot
                            030D40
791       P:0001F7 P:0001F7 06CE00            DO      A,*+3
                            0001F9
792       P:0001F9 P:0001F9 000000            NOP
793    
794                                 ; Put all the analog switch inputs to low so they draw minimum current
795       P:0001FA P:0001FA 012F23            BSET    #3,X:PCRD                         ; Turn the serial clock on
796       P:0001FB P:0001FB 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                            0C3000
797       P:0001FD P:0001FD 20001B            CLR     B
798       P:0001FE P:0001FE 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC write
s
799       P:0001FF P:0001FF 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writ
es
                            001000
800       P:000201 P:000201 060F80            DO      #15,L_ANALOG                      ; Fifteen video processor boards maximum
                            000209
801       P:000203 P:000203 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
802       P:000204 P:000204 200040            ADD     X0,A
803       P:000205 P:000205 5F7000            MOVE                          B,Y:WRSS    ; This is for the fast analog switches
                            FFFFF3
804       P:000207 P:000207 0620A3            REP     #800                              ; Delay for the serial data transmission
805       P:000208 P:000208 000000            NOP
806       P:000209 P:000209 200068            ADD     X1,B                              ; Increment the video and clock driver numbe
rs
807                                 L_ANALOG
808       P:00020A P:00020A 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
809       P:00020B P:00020B 0C0223            JMP     <SKIP
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 16



810    
811                                 ; Transmit contents of accumulator A1 over the synchronous serial transmitter
812                                 XMIT_A_WORD
813       P:00020C P:00020C 07F42C            MOVEP             #0,X:TX10               ; This helps, don't know why
                            000000
814       P:00020E P:00020E 547000            MOVE              A1,X:SV_A1
                            00000E
815       P:000210 P:000210 000000            NOP
816       P:000211 P:000211 01A786            JCLR    #TDE,X:SSISR1,*                   ; Start bit
                            000211
817       P:000213 P:000213 07F42C            MOVEP             #$010000,X:TX10
                            010000
818       P:000215 P:000215 060380            DO      #3,L_X
                            00021B
819       P:000217 P:000217 01A786            JCLR    #TDE,X:SSISR1,*                   ; Three data bytes
                            000217
820       P:000219 P:000219 04CCCC            MOVEP             A1,X:TX10
821       P:00021A P:00021A 0C1E90            LSL     #8,A
822       P:00021B P:00021B 000000            NOP
823                                 L_X
824       P:00021C P:00021C 01A786            JCLR    #TDE,X:SSISR1,*                   ; Zeroes to bring transmitter low
                            00021C
825       P:00021E P:00021E 07F42C            MOVEP             #0,X:TX10
                            000000
826       P:000220 P:000220 54F000            MOVE              X:SV_A1,A1
                            00000E
827       P:000222 P:000222 00000C            RTS
828    
829                                 SKIP
830    
831                                 ; Set up the circular SCI buffer, 32 words in size
832       P:000223 P:000223 64F400            MOVE              #SCI_TABLE,R4
                            000400
833       P:000225 P:000225 051FA4            MOVE              #31,M4
834       P:000226 P:000226 647000            MOVE              R4,X:(SCI_TABLE+33)
                            000421
835    
836                                           IF      @SCP("HOST","ROM")
844                                           ENDIF
845    
846       P:000228 P:000228 44F400            MOVE              #>$AC,X0
                            0000AC
847       P:00022A P:00022A 440100            MOVE              X0,X:<FO_HDR
848    
849       P:00022B P:00022B 0C0181            JMP     <STARTUP
850    
851                                 ;  ****************  X: Memory tables  ********************
852    
853                                 ; Define the address in P: space where the table of constants begins
854    
855                                  X_BOOT_START
856       00022A                              EQU     @LCV(L)-2
857    
858                                           IF      @SCP("HOST","ROM")
860                                           ENDIF
861                                           IF      @SCP("HOST","HOST")
862       X:000000 X:000000                   ORG     X:0,X:0
863                                           ENDIF
864    
865                                 ; Special storage area - initialization constants and scratch space
866       X:000000 X:000000         STATUS    DC      $40004                            ; Controller status bits
867    
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 17



868       000001                    FO_HDR    EQU     STATUS+1                          ; Fiber optic write bytes
869       000005                    HEADER    EQU     FO_HDR+4                          ; Command header
870       000006                    NWORDS    EQU     HEADER+1                          ; Number of words in the command
871       000007                    COM_BUF   EQU     NWORDS+1                          ; Command buffer
872       00000E                    SV_A1     EQU     COM_BUF+7                         ; Save accumulator A1
873    
874                                           IF      @SCP("HOST","ROM")
879                                           ENDIF
880    
881                                           IF      @SCP("HOST","HOST")
882       X:00000F X:00000F                   ORG     X:$F,X:$F
883                                           ENDIF
884    
885                                 ; Parameter table in P: space to be copied into X: space during
886                                 ;   initialization, and is copied from ROM by the DSP boot
887       X:00000F X:00000F         LATCH     DC      $3A                               ; Starting value in latch chip U25
888                                  EXPOSURE_TIME
889       X:000010 X:000010                   DC      0                                 ; Exposure time in milliseconds
890                                  ELAPSED_TIME
891       X:000011 X:000011                   DC      0                                 ; Time elapsed so far in the exposure
892       X:000012 X:000012         ONE       DC      1                                 ; One
893       X:000013 X:000013         TWO       DC      2                                 ; Two
894       X:000014 X:000014         THREE     DC      3                                 ; Three
895       X:000015 X:000015         SEVEN     DC      7                                 ; Seven
896       X:000016 X:000016         MASK1     DC      $FCFCF8                           ; Mask for checking header
897       X:000017 X:000017         MASK2     DC      $030300                           ; Mask for checking header
898       X:000018 X:000018         DONE      DC      'DON'                             ; Standard reply
899       X:000019 X:000019         SBRD      DC      $020000                           ; Source Identification number
900       X:00001A X:00001A         TIM_DRB   DC      $000200                           ; Destination = timing board number
901       X:00001B X:00001B         DMASK     DC      $00FF00                           ; Mask to get destination board number
902       X:00001C X:00001C         SMASK     DC      $FF0000                           ; Mask to get source board number
903       X:00001D X:00001D         ERR       DC      'ERR'                             ; An error occurred
904       X:00001E X:00001E         C100K     DC      100000                            ; Delay for WRROM = 1 millisec
905       X:00001F X:00001F         IDL_ADR   DC      TST_RCV                           ; Address of idling routine
906       X:000020 X:000020         EXP_ADR   DC      0                                 ; Jump to this address during exposures
907    
908                                 ; Places for saving register values
909       X:000021 X:000021         SAVE_SR   DC      0                                 ; Status Register
910       X:000022 X:000022         SAVE_X1   DC      0
911       X:000023 X:000023         SAVE_A1   DC      0
912       X:000024 X:000024         SAVE_R0   DC      0
913       X:000025 X:000025         RCV_ERR   DC      0
914       X:000026 X:000026         SCI_A1    DC      0                                 ; Contents of accumulator A1 in RCV ISR
915       X:000027 X:000027         SCI_R0    DC      SRXL
916    
917                                 ; Command table
918       000028                    COM_TBL_R EQU     @LCV(R)
919       X:000028 X:000028         COM_TBL   DC      'TDL',TDL                         ; Test Data Link
920       X:00002A X:00002A                   DC      'RDM',RDMEM                       ; Read from DSP or EEPROM memory
921       X:00002C X:00002C                   DC      'WRM',WRMEM                       ; Write to DSP memory
922       X:00002E X:00002E                   DC      'LDA',LDAPPL                      ; Load application from EEPROM to DSP
923       X:000030 X:000030                   DC      'STP',STOP_IDLE_CLOCKING
924       X:000032 X:000032                   DC      'DON',START                       ; Nothing special
925       X:000034 X:000034                   DC      'ERR',START                       ; Nothing special
926    
927                                  END_COMMAND_TABLE
928       000036                              EQU     @LCV(R)
929    
930                                 ; The table at SCI_TABLE is for words received from the utility board, written by
931                                 ;   the interrupt service routine SCI_RCV. Note that it is 32 words long,
932                                 ;   hard coded, and the 33rd location contains the pointer to words that have
933                                 ;   been processed by moving them from the SCI_TABLE to the COM_BUF.
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timboot.s  Page 18



934    
935                                           IF      @SCP("HOST","ROM")
937                                           ENDIF
938    
939       000036                    END_ADR   EQU     @LCV(L)                           ; End address of P: code written to ROM
940                                           INCLUDE "timhdr.s"
941                                        COMMENT *
942    
943                                 This is a header file that has some HIPO-specific stuff in it.  It is
944                                 vastly stripped down compared to the original since most of the things in it
945                                 are now in timboot.asm.
946    
947                                 I believe that all the following stuff can be zapped out.  Comment out for now.
948    
949                                         PAGE    132     ; Printronix page width - 132 columns
950    
951                                 ; Some basic structural definitions
952                                 APL_ADR EQU     $130    ; P: memory location where application code begins
953                                 APL_LEN EQU     $200-APL_ADR ; Maximum length of application program
954    
955                                 ; CHANGING MISC_LEN FROM 0X280 TO A LARGER NUMBER BREAKS THE ROM COPY APPROACH!
956                                 ; However if all you do is download there is a lot more memory available.
957                                 MISC_LEN EQU    $450    ; Maximum length of "miscellanous" code
958                                 ;MISC_LEN EQU   $3F0    ; Maximum length of "miscellanous" code
959                                 ; MISC_LEN EQU  $280    ; Maximum length of "miscellanous" code
960    
961                                 COM_LEN EQU     $40     ; Length of memory for application commands
962                                 TIM_ISR EQU     $3C     ; DSP timer interrupt service routine address
963                                 PGM_CON EQU     $3E     ; Program continues on here
964                                 COM_TBL EQU     $80     ; Starting address of command table in X: memory
965                                 N_W_APL EQU     $500    ; Number of words in each application
966                                 NUM_COM EQU     40      ; Number of entries in command table
967    
968                                 RST_ISR EQU     $00     ; Hardware reset interrupt
969                                 ROM_ID  EQU     $06     ; Location of program Identification = SWI interrupt
970                                 START   EQU     $08     ; Starting address of program
971                                 RCV_BUF EQU     $60     ; Starting address of receiver buffer in X:
972                                 TBL_ADR EQU     $0F     ; (IR) Waveform tables starting address
973    
974                                 ROM_OFF EQU     $4000   ; Boot program offset address in EEPROM
975                                 LD_X    EQU     $4200   ; Assembler loads X: starting at this EEPROM address
976                                 RD_X    EQU     $C600   ; DSP reads X: from this EEPROM address
977    
978                                 ; Define DSP port addresses
979                                 WRSS    EQU     $FF80   ; Write clock driver and VP switch states
980                                 RDFO    EQU     $FFC0   ; Read serial receiver fiber optic contents
981                                 WRFO    EQU     $FFC0   ; Write to fiber optic serial transmitter
982                                 RDAD    EQU     $FFA0   ; Read A/D datum into DSP
983                                 RDAD0   EQU     $FFA0   ; Address for reading A/D #0
984                                 RDAD1   EQU     $FFA1   ; Address for reading A/D #1
985                                 WRLATCH EQU     $FFC1   ; Write to timing board latch
986                                 RSTWDT  EQU     $6000   ; Address to reset the timing board watchdog timer
987                                 BCR     EQU     $FFFE   ; Bus (=Port A) Control Register -> Wait States
988                                 PBC     EQU     $FFE0   ; Port B Control Register
989                                 PBDDR   EQU     $FFE2   ; Port B Data Direction Register
990                                 PBD     EQU     $FFE4   ; Port B Data Register
991                                 PCC     EQU     $FFE1   ; Port C Control Register
992                                 PCDDR   EQU     $FFE3   ; PortC Data Direction Register
993                                 PCD     EQU     $FFE5   ; Port C Data Register
994                                 IPR     EQU     $FFFF   ; Interrupt Priority Register
995                                 SSITX   EQU     $FFEF   ; SSI Transmit and Receive data register
996                                 SSIRX   EQU     $FFEF   ; SSI Transmit and Receive data register
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timhdr.s  Page 19



997                                 SSISR   EQU     $FFEE   ; SSI Status Register
998                                 CRA     EQU     $FFEC   ; SSI Control Register A
999                                 CRB     EQU     $FFED   ; SSI Control Regsiter B
1000                                TCSR    EQU     $FFDE   ; Timer control and status register
1001                                TCR     EQU     $FFDF   ; Timer count register
1002   
1003                                ; Hardware bit definitions all over the place
1004                                SSI_TDE EQU     6       ; SSI Transmitter data register empty
1005                                SSI_RDF EQU     7       ; SSI Receiver data register full
1006                                LVEN    EQU     2       ; Low voltage enable (+/-15 volt nominal)
1007                                HVEN    EQU     3       ; Enable high voltage (+32V nominal)
1008                                TIM_U_RST EQU   5       ; Timing to utility board reset bit number in U25
1009                                PWRST   EQU     13      ; Power control board reset
1010                                RST_FIFO EQU    7       ; Reset FIFO bit number in control latch U25
1011                                EF      EQU     9       ; FIFO empty flag, low true
1012                                TIM_BIT EQU     0       ; Timer status bit
1013                                WW      EQU     1       ; Word width = 1 for 16-bit image data, 0 for 24-bit
1014                                CDAC    EQU     0       ; Bit number in U25 for clearing DACs
1015                                ENCK    EQU     2       ; Bit number in U25 for enabling analog switches
1016                                DUALCLK EQU     1       ; Set to clock two halves of clock driver board together
1017   
1018                                ; Software status bits, defined at X:<STATUS = X:0
1019                                ST_RCV  EQU     0       ; Set if FO, cleared if SSI
1020                                TST_IMG EQU     10      ; Set if controller is to generate a test image
1021                                SHUT    EQU     11      ; Set if opening shutter at beginning of exposure
1022   
1023                                IDLMODE EQU     2       ; Set if need to idle after readout
1024                                ST_SHUT EQU     3       ; Set to indicate shutter is closed, clear for open
1025                                ST_RDC  EQU     4       ; Set if executing 'RDC' command - reading out
1026                                SPLIT_S EQU     5       ; Set if split serial
1027                                SPLIT_P EQU     6       ; Set if split parallel
1028                                MPP     EQU     7       ; Set if parallels are in MPP mode
1029   
1030                                END OF COMMENT HERE
1031                                        *
1032                                ; additional X:<STATUS bits
1033                                ; NOTE
1034                                ; NOTE
1035                                ; the SPLIT_P, and MPP X:<STATUS bits are pre-empted.
1036                                ; the SHUT X:<STATUS bit, and all other >= 8 are not used
1037                                ; assumption is that a GWAVES class camera will never use a shutter.
1038      000006                    ST_ABRT   EQU     6                                 ; Set if an abort (readout or exp) in progre
ss
1039      000007                    ST_EXP    EQU     7                                 ; Set if presently in EXPOSE or waiting for 
trigger
1040   
1041   
1042                                ; move IMGVAR down to $80 as per Confluence July 1 #1
1043                                ;IMGVAR_ADR EQU $100            ;  Special Image Mode variables Starting Address in X:
1044      000080                    IMGVAR_ADR EQU    $80                               ;  Special Image Mode variables Starting Add
ress in X:
1045   
1046                                ; Additional software status bit, defined at X:<STATUS = X:0
1047      000008                    TRIGGER   EQU     8                                 ; Set if a Hardware triggered exposure
1048   
1049                                ; add these HDR (port B) bits for thermo cool statuses
1050      000004                    STS0      EQU     4                                 ; STATUS 0, thermocool
1051      000005                    STS1      EQU     5                                 ; STATUS 1, thermocool
1052   
1053                                ; Image mode bits, defined at X:<IMAGE_MODE
1054   
1055      000000                    FDOTS     EQU     0                                 ; Fast Dots
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timhdr.s  Page 20



1056      000001                    FIND      EQU     1                                 ; Find
1057      000002                    SDOTS     EQU     2                                 ; Slow Dots
1058      000003                    SERIES    EQU     3                                 ; Series
1059      000004                    SINGLE    EQU     4                                 ; Single
1060      000005                    STRIP     EQU     5                                 ; Stripscan
1061      000006                    F_OCC     EQU     6                                 ; Fast occultation, keep as 6 for compatibil
ity
1062      000007                    B_OCC     EQU     7                                 ; Basic occultation
1063      000008                    P_OCC     EQU     8                                 ; Pipelined occultation
1064   
1065                                ; Image Status, define at X:<ISTATUS
1066      000000                    NO_SKIP   EQU     0                                 ; Set for slow dots, fast and pipelined occu
ltation mode
1067                                                                                    ; to avoid parallel skipping to the subframe
 boundary.
1068      000001                    OPEN_CLOSE EQU    1                                 ; Set if shutter opens/closes each image
1069                                                                                    ; Clear if shutter stays open for many image
s
1070      000002                    STORAGE   EQU     2                                 ; Set if storage area is to be clocked
1071                                          INCLUDE "infospec.s"
1072                                ; General DSP info field specifications.
1073                                ; These values are 'addresses' and used as the argument for the INF command.
1074   
1075                                 GET_VERSION
1076      000000                              EQU     0                                 ; IVERSION field
1077      000001                    GET_FLAVOR EQU    1                                 ; IFLAVOR field
1078      000002                    GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
1079      000003                    GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
1080      000004                    GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if availabl
e)
1081                                 GET_TEMP2STS
1082      000005                              EQU     5                                 ; two bits of thermo cool status for GWAVES
1083   
1084                                          INCLUDE "timinfospec.s"
1085                                ; TIM DSP info field specifications.
1086                                ; These values are 'addresses' and used as the argument for the INF command.
1087   
1088                                 GET_CAPABLE
1089      000100                              EQU     $100                              ; ICAPABLE field (what dsp supports).
1090                                 GET_INT_TIM
1091      000101                              EQU     $101                              ; Integration time per pixel in leach units
1092                                 GET_R_DELAY
1093      000102                              EQU     $102                              ; Serial overlap in leach units
1094                                 GET_SI_DELAY
1095      000103                              EQU     $103                              ; Parallel overlap in leach units
1096   
1097                                          INCLUDE "timinfo.s"
1098                                ; DSP Version
1099      04507F                    IVERSION  EQU     282751                            ; 1.5/1
1100   
1101      612020                    IFLAVOR   EQU     'a  '                             ; a
1102   
1103      000DAA                    ITIME0    EQU     3498                              ; lo order time: 2018 2 22  0:24:10 GMT
1104   
1105      005A8E                    ITIME1    EQU     23182                             ; hi order time: 2018 2 22  0:24:10 GMT
1106   
1107      000000                    ISVNREV   EQU     0                                 ; most recent code svn rev
1108   
1109                                ; this need to be defined externally due to a problem in timboot.s
1110                                ; as per Confluence, July 6, #1
1111      00005A                    EXPOSING  EQU     TST_RCV                           ; Address if exposing
1112                                 CONTINUE_READING
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  tim.s  Page 21



1113      00005A                              EQU     TST_RCV                           ; Address if reading out
1114   
1115                                ; tim capability definitions
1116                                 FINDCAPABLE
1117      000001                              EQU     1                                 ; Find exposure mode
1118                                 SNGLCAPABLE
1119      000002                              EQU     2                                 ; Single exposure mode
1120                                 SERICAPABLE
1121      000004                              EQU     4                                 ; Series exposure mode
1122                                 BASCCAPABLE
1123      000008                              EQU     8                                 ; Basic occ exposure mode
1124                                 FASTCAPABLE
1125      000010                              EQU     16                                ; Fast occ exposure mode
1126                                 PIPECAPABLE
1127      000020                              EQU     32                                ; Pipeline occ exposure mode
1128                                 FDOTCAPABLE
1129      000040                              EQU     64                                ; Fast dots exposure mode
1130                                 SDOTCAPABLE
1131      000080                              EQU     128                               ; Slow dots exposure mode
1132                                 STRPCAPABLE
1133      000100                              EQU     256                               ; Slow dots exposure mode
1134      0001FB                    TIMCAPABLE EQU    FINDCAPABLE+SNGLCAPABLE+STRPCAPABLE+BASCCAPABLE+FASTCAPABLE+PIPECAPABLE+FDOTCA
PABLE+SDOTCAPABLE
1135   
1136      P:00022C P:00022C                   ORG     P:,P:
1137   
1138                                ; Remove SHUTTER_CC advertisement as per Confluence July 4 #3
1139                                ;CC     EQU     ARC22+ARC47+SHUTTER_CC+SPLIT_SERIAL+SUBARRAY+BINNING
1140      001C17                    CC        EQU     ARC22+ARC47+SPLIT_SERIAL+SUBARRAY+BINNING
1141   
1142                                ; Put number of words of application in P: for loading application from EEPROM
1143      P:00022C P:00022C                   DC      TIMBOOT_X_MEMORY-@LCV(L)-1
1144   
1145                                ;**************************************************************************
1146                                ;                                                                         *
1147                                ;    Permanent address register assignments                               *
1148                                ;        R1 - Address of SSI receiver contents                            *
1149                                ;        R2 - Address of SCI receiver contents                            *
1150                                ;        R3 - Pointer to current top of command buffer                    *
1151                                ;        R4 - Pointer to processed contents of command buffer             *
1152                                ;        R5 - Temporary register for processing SSI and SCI contents      *
1153                                ;        R6 - CCD clock driver address for CCD #0 = $FF80                 *
1154                                ;                It is also the A/D address of analog board #0            *
1155                                ;        R6 CURRENTLY UNUSED (geniii)
1156                                ;                                                                         *
1157                                ;    Other registers                                                      *
1158                                ;        R0, R7 - Temporary registers used all over the place.            *
1159                                ;        R5 - Can be used as a temporary register but is circular,        *
1160                                ;               modulo 32.                                                *
1161                                ;**************************************************************************
1162   
1163                                ;  ***********************   CCD  READOUT   ***********************
1164                                ; RDCCD is now a subroutine
1165                                ; Adding several CLOCK_WAITs as per Jun 29 #8.
1166   
1167                                RDCCD
1168      P:00022D P:00022D 0A20A2            JSET    #STORAGE,X:ISTATUS,RCCD1
                            000233
1169                                ; Do the frame transfer if STORAGE==0, else skip it.
1170      P:00022F P:00022F 4DBB00            MOVE                          Y:<S_SIZE,X1
1171      P:000230 P:000230 0D0556            JSR     <CLOCK_WAIT
1172      P:000231 P:000231 0BF080            JSR     ISHIFT                            ; Do the frame transfer
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  tim.s  Page 22



                            00052F
1173   
1174                                ; Calculate some readout parameters.
1175                                ; This is also an alternative entry point for skipping the frame transfer
1176                                ; STORAGE also selects ganged or storage only parallels during readout
1177                                ; NO_SKIP skips over the section that parallel skips to the subframe start
1178   
1179      P:000233 P:000233 5E9900  RCCD1     MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1180      P:000234 P:000234 200003            TST     A
1181      P:000235 P:000235 0E2240            JNE     <SUB_IMG
1182      P:000236 P:000236 5C1600            MOVE                          A1,Y:<NP_SKIP ; Zero these all out.  Full frame
1183      P:000237 P:000237 5C1700            MOVE                          A1,Y:<NS_SKP1
1184      P:000238 P:000238 5C1800            MOVE                          A1,Y:<NS_SKP2
1185      P:000239 P:000239 5E8100            MOVE                          Y:<NSR,A    ; NSERIALS_READ = NSR
1186      P:00023A P:00023A 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            00023D
1187      P:00023C P:00023C 200022            ASR     A                                 ; Split serials require / 2
1188      P:00023D P:00023D 000000            NOP
1189      P:00023E P:00023E 5E1000            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1190      P:00023F P:00023F 0C0250            JMP     <SETUP
1191   
1192                                ; Loop over the required number of subimage boxes if NBOXES > 0
1193      P:000240 P:000240 67F400  SUB_IMG   MOVE              #READ_TABLE,R7          ; Parameter table for subimage readout
                            00001D
1194      P:000242 P:000242 061940            DO      Y:<NBOXES,L_NBOXES                ; Loop over number of boxes
                            0002D6
1195      P:000244 P:000244 4CDF00            MOVE                          Y:(R7)+,X0
1196      P:000245 P:000245 4C1600            MOVE                          X0,Y:<NP_SKIP
1197      P:000246 P:000246 4CDF00            MOVE                          Y:(R7)+,X0
1198      P:000247 P:000247 4C1700            MOVE                          X0,Y:<NS_SKP1
1199      P:000248 P:000248 4CDF00            MOVE                          Y:(R7)+,X0
1200      P:000249 P:000249 4C1800            MOVE                          X0,Y:<NS_SKP2
1201      P:00024A P:00024A 5E9B00            MOVE                          Y:<NS_READ,A
1202      P:00024B P:00024B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                            00024E
1203      P:00024D P:00024D 200022            ASR     A
1204      P:00024E P:00024E 000000            NOP
1205      P:00024F P:00024F 5E1000            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1206   
1207                                ; Calculate the fast readout parameters
1208      P:000250 P:000250 0D0404  SETUP     JSR     <SETUP_SUBROUTINE
1209      P:000251 P:000251 0D0556            JSR     <CLOCK_WAIT
1210   
1211                                ; Skip over the required number of rows for subimage readout
1212                                ; If #NO_SKIP == 0 skip rows up to first subframe, storage clocks only
1213      P:000252 P:000252 0A20A0            JSET    #NO_SKIP,X:ISTATUS,CLR_SR
                            00025C
1214      P:000254 P:000254 5E9600            MOVE                          Y:<NP_SKIP,A ; Number of rows NP_SKIP to skip
1215      P:000255 P:000255 200003            TST     A
1216      P:000256 P:000256 0EA25C            JEQ     <CLR_SR                           ; If zero, skip this shift
1217      P:000257 P:000257 061640            DO      Y:<NP_SKIP,L_SKIP1                ; Clock number of rows to skip
                            00025B
1218      P:000259 P:000259 305200            MOVE              #<S_CLEAR,R0            ; SR kept clear with DG
1219      P:00025A P:00025A 0D02E0            JSR     <CLOCK
1220      P:00025B P:00025B 000000            NOP
1221                                L_SKIP1
1222   
1223                                ; Clear out the accumulated charge from the serial shift register
1224                                ; Leave this commented-out code in until we can test it with a subframe
1225                                ; CLR_SR MOVE   #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1226                                ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1227                                ;       NOP
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  tim.s  Page 23



1228                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1229                                ;       DO      Y:<NSCLR,*+3            ; Number of waveform entries total
1230                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1231                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1232   
1233      P:00025C P:00025C 60F400  CLR_SR    MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel skip
                            00007A
1234      P:00025E P:00025E 0D02E0            JSR     <CLOCK
1235   
1236                                ; Parallel shift the image into the serial shift register
1237      P:00025F P:00025F 4C8200            MOVE                          Y:<NPR,X0   ; Number of rows set by host computer
1238      P:000260 P:000260 5E9900            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1239      P:000261 P:000261 200003            TST     A
1240      P:000262 P:000262 0EA264            JEQ     *+2
1241      P:000263 P:000263 4C9C00            MOVE                          Y:<NP_READ,X0 ; If NBOXES .NE. 0 use subimage table
1242   
1243                                ; Main loop over each line to be read out
1244                                ; If split parallels have to divide NPR by two to be loop counter
1245                                ; Subimages implicitly assumes that parallels are not split
1246      P:000264 P:000264 0A0086            JCLR    #SPLIT_P,X:STATUS,PLOOP           ; skip this if not split parallels
                            00026B
1247      P:000266 P:000266 5EF000            MOVE                          Y:NPR,A     ; Get NPR
                            000002
1248      P:000268 P:000268 200022            ASR     A                                 ; Divide by 2
1249      P:000269 P:000269 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1250      P:00026A P:00026A 21C400            MOVE              A,X0                    ; Overwrite loop counter in X0
1251   
1252                                ; Finally start the row loop
1253      P:00026B P:00026B 06C400  PLOOP     DO      X0,LPR                            ; Number of rows to read out
                            0002D5
1254   
1255                                ; Check for a command once per line. Only the ABORT command is allowed
1256                                ;       JSR     <GET_RCV                ; Was a command received?
1257                                ;       JCC     <CONTINUE_RD            ; If no, continue reading out
1258                                ; as per Confluence July 5 #7
1259                                ;       JMP     <PRC_RCV                ; If yes, go process it
1260      P:00026D P:00026D 0C0275            JMP     <CONTINUE_RD
1261   
1262                                ; Abort the readout currently underway
1263                                ABR_RDC
1264      P:00026E P:00026E 200013            CLR     A
1265      P:00026F P:00026F 5EBF00            MOVE                          Y:<TESTLOC1,A
1266      P:000270 P:000270 014180            ADD     #1,A
1267      P:000271 P:000271 0A0026            BSET    #ST_ABRT,X:<STATUS
1268      P:000272 P:000272 5C3F00            MOVE                          A1,Y:<TESTLOC1
1269   
1270      P:000273 P:000273 0A0084            JCLR    #ST_RDC,X:<STATUS,ABORT_EXPOSURE
                            00057B
1271                                ; already in readout- so just fall thru and continue,
1272                                ; having set the ST_ABRT flag.
1273                                ; currently we just let this readout segment run to the end and
1274                                ; handle the abort in the outer xxx_PROC code- this has
1275                                ; the advantage of ending the overall exposure on a frame boundary
1276                                ; in the case of 3-d images.
1277                                ; A more abrupt ending of the RDCCD code could be arranged if needed.
1278   
1279                                ;       ENDDO                           ; Properly terminate row loop
1280                                ;       MOVE    Y:<NBOXES,A             ; NBOXES = 0 => full image readout
1281                                ;       TST     A
1282                                ;       JEQ     *+2
1283                                ;       ENDDO                           ; Properly terminate box loop
1284                                ;       NOP
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  tim.s  Page 24



1285                                ;       CLR     A
1286                                ;       INC     A
1287                                ;       NOP
1288                                ;       MOVE    A0,Y:<IFLPCNT
1289                                ;       RTS                             ; Return early from subroutine
1290   
1291                                ; Move the row into the serial register.
1292                                 CONTINUE_RD
1293      P:000275 P:000275 060640            DO      Y:<NPBIN,LPR_I                    ; Transfer # of rows, with binning
                            00027C
1294      P:000277 P:000277 305B00            MOVE              #<IS_PARALLEL,R0
1295      P:000278 P:000278 0A20A2            JSET    #STORAGE,X:ISTATUS,GANGED         ; if STORAGE == 1 ganged parallels
                            00027B
1296      P:00027A P:00027A 304000            MOVE              #<S_PARALLEL,R0         ; if STORAGE == 0 store clocks only
1297      P:00027B P:00027B 0D02E0  GANGED    JSR     <CLOCK                            ; Parallel clocking
1298      P:00027C P:00027C 000000            NOP
1299                                LPR_I
1300   
1301                                ; Skip over NS_SKP1 columns for subimage readout
1302                                ;       MOVE    Y:<NS_SKP1,A            ; Number of columns to skip
1303      P:00027D P:00027D 5E9200            MOVE                          Y:<NSKIP1,A ; Number of waveforms for skip
1304      P:00027E P:00027E 200003            TST     A
1305      P:00027F P:00027F 0EA284            JEQ     <L_READ
1306      P:000280 P:000280 0505A1            MOVE              #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1307   
1308                                ;       Fix for new interface CLOCKCT
1309                                ;       June 30 bottom "questions and comments" #2,3
1310      P:000281 P:000281 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1311      P:000282 P:000282 218400            MOVE              A1,X0                   ; how many
1312      P:000283 P:000283 0D02E6            JSR     <CLOCKCT
1313                                ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1314                                ;       NOP
1315                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1316                                ;       DO      Y:<NSKIP1,LS_SKIP1      ; Number of waveform entries total
1317                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1318                                ;LS_SKIP1
1319                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1320   
1321                                ; Finally read some real pixels - this is the serial binning routine
1322      P:000284 P:000284 200013  L_READ    CLR     A
1323      P:000285 P:000285 20001B            CLR     B
1324      P:000286 P:000286 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1325      P:000287 P:000287 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                            000006
1326      P:000289 P:000289 200005            CMP     B,A                               ; else do special waveforms via NO_BIN
1327      P:00028A P:00028A 0E729C            JGT     <NO_BIN                           ; Skip over general serial binning software
1328      P:00028B P:00028B 00000B            DEC     B                                 ; serial binning factor minus 1
1329      P:00028C P:00028C 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1330      P:00028D P:00028D 212700            MOVE              B0,Y1
1331      P:00028E P:00028E 061040            DO      Y:<NSERIALS_READ,LSR_BIN          ; Number of pixels to read out
                            00029A
1332      P:000290 P:000290 688E00            MOVE                          Y:<INITIAL_CLOCK,R0 ; (already /2 if split serials)
1333      P:000291 P:000291 0D02E0            JSR     <CLOCK
1334                                ;       DO      Y:<NSBIN,LSR_I          ; Bin serially NSBIN times
1335      P:000292 P:000292 06C700            DO      Y1,LSR_I                          ; Bin serially NSBIN times
                            000296
1336      P:000294 P:000294 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1337      P:000295 P:000295 0D02E0            JSR     <CLOCK                            ;   shift register
1338      P:000296 P:000296 000000            NOP
1339                                LSR_I
1340      P:000297 P:000297 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                            0000B3
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  tim.s  Page 25



1341      P:000299 P:000299 0D02E0            JSR     <CLOCK
1342                                ;       MOVE    Y1,Y:<INTERVAL          ; HACK.  Use for debugging
1343      P:00029A P:00029A 000000            NOP
1344                                LSR_BIN
1345      P:00029B P:00029B 0C02A2            JMP     <OVER_RD                          ; All done binning
1346   
1347                                ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1348      P:00029C P:00029C 588C00  NO_BIN    MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1349      P:00029D P:00029D 00000A            DEC     A                                 ; waveform - 1 into M1
1350      P:00029E P:00029E 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1351      P:00029F P:00029F 04C8A1            MOVE              A0,M1                   ; Modularity
1352                                ;       Fix for new interface CLOCKCT
1353                                ;       June 30 bottom "questions and comments" #2,3
1354      P:0002A0 P:0002A0 4C9300            MOVE                          Y:<NREAD,X0 ; how many
1355      P:0002A1 P:0002A1 0D02E6            JSR     <CLOCKCT
1356                                ;       NOP
1357                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1358                                ;       DO      Y:<NREAD,LSR            ; Number of waveform entries total
1359                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1360                                ;LSR
1361                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1362   
1363                                ; If NR_BIAS=0 clobber SR with DG and skip to end of row loop
1364      P:0002A2 P:0002A2 5E9A00  OVER_RD   MOVE                          Y:<NR_BIAS,A ; Is NR_BIAS zero?
1365      P:0002A3 P:0002A3 200003            TST     A
1366      P:0002A4 P:0002A4 0E22AA            JNE     <OVR_RD1                          ; no, go to the NS_SKP2 section
1367      P:0002A5 P:0002A5 60F400            MOVE              #DUMP_SERIAL,R0         ; yes, clobber SR with DG
                            00007A
1368      P:0002A7 P:0002A7 0D02E0            JSR     <CLOCK
1369      P:0002A8 P:0002A8 0AF080            JMP     END_ROW                           ; and go to the end of the row loop
                            0002D5
1370                                ; Skip over NS_SKP2 columns for subimage readout to get to overscan region
1371      P:0002AA P:0002AA 5E9800  OVR_RD1   MOVE                          Y:<NS_SKP2,A ; Number of columns to skip
1372      P:0002AB P:0002AB 200003            TST     A
1373      P:0002AC P:0002AC 0EA2B1            JEQ     <L_BIAS
1374      P:0002AD P:0002AD 0505A1            MOVE              #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1375      P:0002AE P:0002AE 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1376                                ;       Fix for new interface CLOCKCT
1377                                ;       June 30 bottom "questions and comments" #2,3
1378      P:0002AF P:0002AF 4C9400            MOVE                          Y:<NSKIP2,X0 ; how many
1379      P:0002B0 P:0002B0 0D02E6            JSR     <CLOCKCT
1380                                ;       NOP
1381                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1382                                ;       DO      Y:<NSKIP2,LS_SKIP2      ; Number of waveform entries total
1383                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1384                                ;LS_SKIP2
1385                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1386   
1387                                ; And read the bias pixels if in subimage readout mode
1388                                ; I think this means that if NBOXES==0 you have to have NSR include bias px.
1389      P:0002B1 P:0002B1 5E9900  L_BIAS    MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1390      P:0002B2 P:0002B2 200003            TST     A
1391      P:0002B3 P:0002B3 0EA2D5            JEQ     <END_ROW
1392   
1393                                ; Finally read some real bias pixels
1394      P:0002B4 P:0002B4 200013            CLR     A
1395      P:0002B5 P:0002B5 20001B            CLR     B
1396      P:0002B6 P:0002B6 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1397      P:0002B7 P:0002B7 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                            000006
1398      P:0002B9 P:0002B9 200005            CMP     B,A                               ; else do special waveforms via NO_BIN_BIAS
1399      P:0002BA P:0002BA 0E72CF            JGT     <NO_BIN_BIAS                      ; Skip over general serial binning software
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  tim.s  Page 26



1400      P:0002BB P:0002BB 00000B            DEC     B                                 ; serial binning factor minus 1
1401      P:0002BC P:0002BC 5E9A00            MOVE                          Y:<NR_BIAS,A
1402      P:0002BD P:0002BD 200022            ASR     A                                 ; Split serials require / 2
1403      P:0002BE P:0002BE 212700            MOVE              B0,Y1
1404      P:0002BF P:0002BF 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            0002C2
1405      P:0002C1 P:0002C1 06CE00            DO      A,LBIAS_BIN                       ; Number of pixels to read out
                            0002CD
1406      P:0002C3 P:0002C3 688E00            MOVE                          Y:<INITIAL_CLOCK,R0
1407      P:0002C4 P:0002C4 0D02E0            JSR     <CLOCK
1408      P:0002C5 P:0002C5 06C700            DO      Y1,LBIAS_I                        ; Bin serially NSBIN times
                            0002C9
1409                                ;       DO      Y:<NSBIN,LBIAS_I        ; Bin serially NSBIN times
1410      P:0002C7 P:0002C7 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1411      P:0002C8 P:0002C8 0D02E0            JSR     <CLOCK                            ;   shift register
1412      P:0002C9 P:0002C9 000000            NOP
1413                                LBIAS_I
1414      P:0002CA P:0002CA 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                            0000B3
1415      P:0002CC P:0002CC 0D02E0            JSR     <CLOCK
1416      P:0002CD P:0002CD 000000            NOP
1417                                LBIAS_BIN
1418      P:0002CE P:0002CE 0C02D5            JMP     <END_ROW                          ; All done binning
1419   
1420                                ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1421                                ; NBIAS is already divided by 2 in SETUP_SUBROUTINE if split serials.
1422                                NO_BIN_BIAS
1423      P:0002CF P:0002CF 588C00            MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1424      P:0002D0 P:0002D0 00000A            DEC     A                                 ; waveform - 1 into M1
1425      P:0002D1 P:0002D1 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1426      P:0002D2 P:0002D2 04C8A1            MOVE              A0,M1                   ; Modularity
1427                                ;       Fix for new interface CLOCKCT
1428                                ;       June 30 bottom "questions and comments" #2,3
1429      P:0002D3 P:0002D3 4C9500            MOVE                          Y:<NBIAS,X0 ; how many
1430      P:0002D4 P:0002D4 0D02E6            JSR     <CLOCKCT
1431                                ;       NOP
1432                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1433                                ;       DO      Y:<NBIAS,*+3            ; Number of waveform entries total
1434                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1435                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1436      P:0002D5 P:0002D5 000000  END_ROW   NOP
1437      P:0002D6 P:0002D6 000000  LPR       NOP                                       ; End of parallel loop
1438      P:0002D7 P:0002D7 000000  L_NBOXES  NOP                                       ; End of subimage boxes loop
1439      P:0002D8 P:0002D8 000000            NOP
1440      P:0002D9 P:0002D9 307800            MOVE              #<DCRST_LAST,R0         ; get DC Restore going
1441      P:0002DA P:0002DA 0D02E0            JSR     <CLOCK
1442      P:0002DB P:0002DB 0D0556            JSR     <CLOCK_WAIT
1443      P:0002DC P:0002DC 307600            MOVE              #<IMO_LAST_CLOCK,R0     ; set clocks to 0
1444      P:0002DD P:0002DD 0D02E0            JSR     <CLOCK
1445      P:0002DE P:0002DE 0D0556            JSR     <CLOCK_WAIT
1446      P:0002DF P:0002DF 00000C            RTS
1447   
1448                                ; ***************** END OF CCD READOUT SUBROUTINE  ************
1449   
1450                                ; Core subroutine for clocking out CCD charge
1451                                ; Must keep in tim.s to insure that it is in fast P memory
1452                                ; Modified for FIFO magement and new processor as per
1453                                ; June 30 bottom "questions and comments" #2,3
1454   
1455                                ; CLOCK assumes waveform in R0, which begins with a count field
1456                                ; NOTE: in geniii, this count is 1 larger than genii because it
1457                                ; is a straight count of the # of points in the wave- gen-ii
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  tim.s  Page 27



1458                                ; needed a count 1 smaller since there was a pipeline that was
1459                                ; primed with a starter pixel.
1460                                CLOCK
1461      P:0002E0 P:0002E0 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002E0
1462      P:0002E2 P:0002E2 065860            REP     Y:(R0)+
1463      P:0002E3 P:0002E3 09D8F3            MOVEP             Y:(R0)+,Y:WRSS          ; next piece of the waveform
1464      P:0002E4 P:0002E4 000000            NOP                                       ; just in case
1465      P:0002E5 P:0002E5 00000C            RTS
1466   
1467                                ; CLOCKCT assumes waveform in R1, without a count field, and the
1468                                ; count in X0, and modulus counter in M1.
1469                                ; In order to manage the FIFO (SSFHF) we copy the wave out in a block of 16 pts
1470                                ; at a time. The SSFHF check happens at the start of each block.
1471                                ; Note that count in X0 is again a straight count requiring a fix to FASTSKP
1472                                ; CLOCKCT trashes A
1473                                CLOCKCT
1474      P:0002E6 P:0002E6 200013            CLR     A
1475      P:0002E7 P:0002E7 208E00            MOVE              X0,A
1476                                CLKBLKFULL
1477                                                                                    ; see if we can do a full block in the wavef
orm.
1478      P:0002E8 P:0002E8 015085            CMP     #16,A
1479      P:0002E9 P:0002E9 0E92F0            JLT     <CLKBLKREM
1480                                                                                    ; 16 or more points remain
1481      P:0002EA P:0002EA 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002EA
1482      P:0002EC P:0002EC 0610A0            REP     #16
1483      P:0002ED P:0002ED 09D9F3            MOVEP             Y:(R1)+,Y:WRSS          ; next modulo piece of the waveform
1484      P:0002EE P:0002EE 015084            SUB     #16,A
1485      P:0002EF P:0002EF 0C02E8            JMP     <CLKBLKFULL
1486                                CLKBLKREM
1487                                                                                    ; last little bit..
1488      P:0002F0 P:0002F0 200003            TST     A
1489      P:0002F1 P:0002F1 0EF2F7            JLE     <CLOCK1                           ; no it divided evenly so all done--
1490                                                                                    ; do the remainder of 1 to 15 pts.
1491      P:0002F2 P:0002F2 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002F2
1492      P:0002F4 P:0002F4 06CE00            DO      A,CLOCK1
                            0002F6
1493      P:0002F6 P:0002F6 09D9F3            MOVEP             Y:(R1)+,Y:WRSS          ; next modulo piece of the waveform
1494                                CLOCK1
1495      P:0002F7 P:0002F7 000000            NOP                                       ; just in case
1496      P:0002F8 P:0002F8 00000C            RTS
1497   
1498                                ;CLOCK   MOVE    Y:(R0)+,X0             ; # of waveform entries
1499                                ;        MOVE    Y:(R0)+,A              ; Start the pipeline
1500                                ;        DO      X0,CLK1                 ; Repeat X0 times
1501                                ;        MOVE    A,X:(R6) Y:(R0)+,A      ; Send out the waveform
1502                                ;CLK1
1503                                ;        MOVE    A,X:(R6)               ; Flush out the pipeline
1504                                ;        RTS                            ; Return from subroutine
1505   
1506                                ; Include miscellaneous timing commands
1507                                          INCLUDE "timmisc.s"                       ; Custom
1508                                ; This file is for utilities that are in common to all the timing board
1509                                ;   programs, located starting at P:$200 in external SRAM
1510   
1511                                          IF      @SCP("10","50")
1513                                          ENDIF
1514                                          IF      @SCP("10","200")
1516                                          ENDIF
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 28



1517                                          IF      @SCP("10","10")
1518      00000A                    SDELAY    EQU     10
1519                                          ENDIF
1520   
1521   
1522                                ;  ****************  PROGRAM CODE IN SRAM PROGRAM SPACE    *******************
1523                                ; Put all the following code in SRAM, starting at P:$200.
1524                                          IF      @SCP("HOST","HOST")
1525                                ; as per Confluence, July 9
1526                                ;       ORG     P:$200,P:$200   ; Download address
1527      P:0002F9 P:0002F9                   ORG     P:,P:                             ; Download address
1528                                          ELSE
1530                                          ENDIF
1531   
1532                                ; Fast clear of CCD, executed as a command
1533      P:0002F9 P:0002F9 0D02FB  CLEAR     JSR     <CLR_CCD
1534      P:0002FA P:0002FA 0C008F            JMP     <FINISH
1535   
1536                                ; Fast clear image before each exposure, executed as a subroutine.  Uses DG
1537      P:0002FB P:0002FB 060440  CLR_CCD   DO      Y:<NPCLR,LPCLR                    ; Loop over number of lines in image
                            000300
1538      P:0002FD P:0002FD 60F400            MOVE              #IS_CLEAR,R0            ; Address of parallel transfer waveform
                            000065
1539      P:0002FF P:0002FF 0D02E0            JSR     <CLOCK                            ; Go clock out the CCD charge
1540      P:000300 P:000300 000000            NOP                                       ; Do loop restriction
1541                                LPCLR
1542      P:000301 P:000301 60F400            MOVE              #DUMP_SERIAL,R0
                            00007A
1543      P:000303 P:000303 0D02E0            JSR     <CLOCK                            ; and wipe out the dregs in the SR
1544      P:000304 P:000304 307600            MOVE              #<IMO_LAST_CLOCK,R0     ; set clocks to 0
1545      P:000305 P:000305 0D02E0            JSR     <CLOCK
1546      P:000306 P:000306 245A00            MOVE              #TST_RCV,X0             ; Wait for commands during exposure
1547      P:000307 P:000307 441F00            MOVE              X0,X:<IDL_ADR           ;  instead of idling
1548      P:000308 P:000308 00000C            RTS
1549   
1550                                ; Keep the CCD idling when not reading out
1551      P:000309 P:000309 060140  IDLE      DO      Y:<NSR,IDL1                       ; Loop over number of pixels per line
                            000312
1552      P:00030B P:00030B 308000            MOVE              #<SERIAL_IDLE,R0        ; Serial transfer on pixel
1553      P:00030C P:00030C 0D02E0            JSR     <CLOCK                            ; Go to it
1554      P:00030D P:00030D 330700            MOVE              #COM_BUF,R3
1555      P:00030E P:00030E 0D00A5            JSR     <GET_RCV                          ; Check for FO or SSI commands
1556      P:00030F P:00030F 0E0312            JCC     <NO_COM                           ; Continue IDLE if no commands received
1557      P:000310 P:000310 00008C            ENDDO
1558      P:000311 P:000311 0C005D            JMP     <PRC_RCV                          ; Go process header and command
1559      P:000312 P:000312 000000  NO_COM    NOP
1560                                IDL1
1561      P:000313 P:000313 306500            MOVE              #<IS_CLEAR,R0           ; Address of parallel clocking waveform
1562      P:000314 P:000314 0D02E0            JSR     <CLOCK                            ; Go clock out the CCD charge
1563      P:000315 P:000315 0C0309            JMP     <IDLE
1564   
1565                                ; Start the exposure timer and monitor its progress
1566      P:000316 P:000316 07F40E  EXPOSE    MOVEP             #0,X:TLR0               ; Load 0 into counter timer
                            000000
1567      P:000318 P:000318 240000            MOVE              #0,X0
1568      P:000319 P:000319 441100            MOVE              X0,X:<ELAPSED_TIME      ; Set elapsed exposure time to zero
1569                                ;       CLR     B                       ; possibly fix bug as per
1570      P:00031A P:00031A 579000            MOVE              X:<EXPOSURE_TIME,B
1571      P:00031B P:00031B 20000B            TST     B                                 ; Special test for zero exposure time
1572      P:00031C P:00031C 0EA328            JEQ     <END_EXP                          ; Don't even start an exposure
1573      P:00031D P:00031D 01418C            SUB     #1,B                              ; Timer counts from X:TCPR0+1 to zero
1574      P:00031E P:00031E 010F20            BSET    #TIM_BIT,X:TCSR0                  ; Enable the timer #0
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 29



1575      P:00031F P:00031F 577000            MOVE              B,X:TCPR0
                            FFFF8D
1576      P:000321 P:000321 0A8989  CHK_RCV   JCLR    #EF,X:HDR,CHK_TIM                 ; Simple test for fast execution
                            000326
1577      P:000323 P:000323 330700            MOVE              #COM_BUF,R3             ; The beginning of the command buffer
1578      P:000324 P:000324 0D00A5            JSR     <GET_RCV                          ; Check for an incoming command
1579      P:000325 P:000325 0E805D            JCS     <PRC_RCV                          ; If command is received, go check it
1580      P:000326 P:000326 018F95  CHK_TIM   JCLR    #TCF,X:TCSR0,CHK_RCV              ; Wait for timer to equal compare value
                            000321
1581      P:000328 P:000328 010F00  END_EXP   BCLR    #TIM_BIT,X:TCSR0                  ; Disable the timer
1582      P:000329 P:000329 0AE780            JMP     (R7)                              ; This contains the return address
1583   
1584                                ; Select which readouts to process
1585                                ;   'SOS'  Amplifier_name
1586                                ;       Amplifier_name = '__L', '__R', '_LR'
1587                                ;       Correct command ptr to R3 as per "Four Points" #2
1588   
1589      P:00032A P:00032A 44DB00  SEL_OS    MOVE              X:(R3)+,X0              ; Get amplifier(s) name
1590      P:00032B P:00032B 0D032D            JSR     <SELECT_OUTPUT_SOURCE
1591      P:00032C P:00032C 0C0090            JMP     <FINISH1
1592   
1593                                ; A massive subroutine for setting all the addresses depending on the
1594                                ; output source(s) selection and binning parameter.  Most of the
1595                                ; waveforms are in fast Y memory (< 0xFF) but there isn't enough
1596                                ; space for the fast serial binning waveforms for binning factors
1597                                ; 1 through 5.  These are in high Y memory and have to be copied in.
1598   
1599                                SELECT_OUTPUT_SOURCE
1600                                ; Set all the waveform addresses depending on which readout/binning mode
1601      P:00032D P:00032D 56F400            MOVE              #'__L',A                ; LEFT Amplifier = readout #0
                            5F5F4C
1602      P:00032F P:00032F 200045            CMP     X0,A
1603      P:000330 P:000330 0E237B            JNE     <CMP_R
1604      P:000331 P:000331 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1605      P:000332 P:000332 46F400            MOVE              #SERIAL_SKIP_LEFT,Y0
                            0000E8
1606      P:000334 P:000334 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            00000B
1607      P:000336 P:000336 46F400            MOVE              #INITIAL_CLOCK_LEFT,Y0
                            000099
1608      P:000338 P:000338 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000E
1609      P:00033A P:00033A 46F400            MOVE              #SERIAL_CLOCK_LEFT,Y0
                            0000AC
1610      P:00033C P:00033C 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000D
1611      P:00033E P:00033E 46F400            MOVE              #(CLK2+$030000+000+000+000+000+H2L+H2R+000+000),Y0
                            032210
1612      P:000340 P:000340 4E7000            MOVE                          Y0,Y:CCLK_1
                            0000B4
1613      P:000342 P:000342 0A0005            BCLR    #SPLIT_S,X:STATUS
1614                                ; Now go through copying in the serial read waveform if binning more than 5.
1615      P:000343 P:000343 200013            CLR     A
1616      P:000344 P:000344 20001B            CLR     B
1617      P:000345 P:000345 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 6 or greater
                            00001E
1618      P:000347 P:000347 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
1619      P:000348 P:000348 50F400            MOVE              #>5,A0
                            000005
1620      P:00034A P:00034A 200005            CMP     B,A
1621      P:00034B P:00034B 0E93CC            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
1622      P:00034C P:00034C 0D03D9            JSR     <SET_BINBIT                       ; else set BINBIT
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 30



1623      P:00034D P:00034D 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1624      P:00034E P:00034E 0A1E81  TRY_1_L   JCLR    #1,X:BINBIT,TRY_2_L
                            000357
1625                                ;       MOVE    #1,A0                   ; HACK
1626                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1627      P:000350 P:000350 51F400            MOVE              #(END_SERIAL_READ_LEFT_1-SERIAL_READ_LEFT_1),B0
                            00000C
1628      P:000352 P:000352 60F400            MOVE              #SERIAL_READ_LEFT_1,R0  ; Here if left amp, bin by 1
                            000165
1629      P:000354 P:000354 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1630      P:000355 P:000355 0D03D2            JSR     <WAVECPY                          ; Copy the waveform
1631      P:000356 P:000356 0C03CC            JMP     <CMP_END
1632      P:000357 P:000357 0A1E82  TRY_2_L   JCLR    #2,X:BINBIT,TRY_3_L
                            000360
1633      P:000359 P:000359 51F400            MOVE              #(END_SERIAL_READ_LEFT_2-SERIAL_READ_LEFT_2),B0
                            000013
1634      P:00035B P:00035B 60F400            MOVE              #SERIAL_READ_LEFT_2,R0  ; Here if left amp, bin by 2
                            00018B
1635      P:00035D P:00035D 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1636      P:00035E P:00035E 0D03D2            JSR     <WAVECPY                          ; Copy the waveform
1637      P:00035F P:00035F 0C03CC            JMP     <CMP_END
1638      P:000360 P:000360 0A1E83  TRY_3_L   JCLR    #3,X:<BINBIT,TRY_4_L
                            000369
1639      P:000362 P:000362 51F400            MOVE              #(END_SERIAL_READ_LEFT_3-SERIAL_READ_LEFT_3),B0
                            000019
1640      P:000364 P:000364 60F400            MOVE              #SERIAL_READ_LEFT_3,R0  ; Here if left amp, bin by 3
                            0001C4
1641      P:000366 P:000366 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1642      P:000367 P:000367 0D03D2            JSR     <WAVECPY                          ; Copy the waveform
1643      P:000368 P:000368 0C03CC            JMP     <CMP_END
1644      P:000369 P:000369 0A1E84  TRY_4_L   JCLR    #4,X:BINBIT,TRY_5_L
                            000372
1645      P:00036B P:00036B 51F400            MOVE              #(END_SERIAL_READ_LEFT_4-SERIAL_READ_LEFT_4),B0
                            00001F
1646      P:00036D P:00036D 60F400            MOVE              #SERIAL_READ_LEFT_4,R0  ; Here if left amp, bin by 4
                            00020F
1647      P:00036F P:00036F 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1648      P:000370 P:000370 0D03D2            JSR     <WAVECPY                          ; Copy the waveform
1649      P:000371 P:000371 0C03CC            JMP     <CMP_END
1650      P:000372 P:000372 0A1E85  TRY_5_L   JCLR    #5,X:BINBIT,CMP_END
                            0003CC
1651      P:000374 P:000374 51F400            MOVE              #(END_SERIAL_READ_LEFT_5-SERIAL_READ_LEFT_5),B0
                            000025
1652      P:000376 P:000376 60F400            MOVE              #SERIAL_READ_LEFT_5,R0  ; Here if left amp, bin by 5
                            00026C
1653      P:000378 P:000378 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1654      P:000379 P:000379 0D03D2            JSR     <WAVECPY                          ; Copy the waveform
1655      P:00037A P:00037A 0C03CC            JMP     <CMP_END
1656   
1657      P:00037B P:00037B 56F400  CMP_R     MOVE              #'__R',A                ; RIGHT Amplifier = readout #1
                            5F5F52
1658      P:00037D P:00037D 200045            CMP     X0,A
1659      P:00037E P:00037E 0E23C9            JNE     <CMP_LR
1660      P:00037F P:00037F 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1661      P:000380 P:000380 46F400            MOVE              #SERIAL_SKIP_RIGHT,Y0
                            0000F0
1662      P:000382 P:000382 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            00000B
1663      P:000384 P:000384 46F400            MOVE              #INITIAL_CLOCK_RIGHT,Y0
                            00008D
1664      P:000386 P:000386 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 31



                            00000E
1665      P:000388 P:000388 46F400            MOVE              #SERIAL_CLOCK_RIGHT,Y0
                            0000A5
1666      P:00038A P:00038A 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000D
1667      P:00038C P:00038C 46F400            MOVE              #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),Y0
                            032120
1668      P:00038E P:00038E 4E7000            MOVE                          Y0,Y:CCLK_1
                            0000B4
1669      P:000390 P:000390 0A0005            BCLR    #SPLIT_S,X:STATUS
1670                                ; Now go through copying in the serial read waveform if binning more than 5.
1671      P:000391 P:000391 200013            CLR     A
1672      P:000392 P:000392 20001B            CLR     B
1673      P:000393 P:000393 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 6 or greater
                            00001E
1674      P:000395 P:000395 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
1675      P:000396 P:000396 50F400            MOVE              #>5,A0
                            000005
1676      P:000398 P:000398 200005            CMP     B,A
1677      P:000399 P:000399 0E93CC            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
1678      P:00039A P:00039A 0D03D9            JSR     <SET_BINBIT                       ; else set BINBIT
1679      P:00039B P:00039B 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1680      P:00039C P:00039C 0A1E81  TRY_1_R   JCLR    #1,X:BINBIT,TRY_2_R
                            0003A5
1681                                ;       MOVE    #2,A0                   ; HACK
1682                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1683      P:00039E P:00039E 51F400            MOVE              #(END_SERIAL_READ_RIGHT_1-SERIAL_READ_RIGHT_1),B0
                            00000D
1684      P:0003A0 P:0003A0 60F400            MOVE              #SERIAL_READ_RIGHT_1,R0 ; Here if right amp, bin by 1
                            000171
1685      P:0003A2 P:0003A2 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1686      P:0003A3 P:0003A3 0D03D2            JSR     <WAVECPY                          ; Copy the waveform
1687      P:0003A4 P:0003A4 0C03CC            JMP     <CMP_END
1688      P:0003A5 P:0003A5 0A1E82  TRY_2_R   JCLR    #2,X:BINBIT,TRY_3_R
                            0003AE
1689      P:0003A7 P:0003A7 51F400            MOVE              #(END_SERIAL_READ_RIGHT_2-SERIAL_READ_RIGHT_2),B0
                            000013
1690      P:0003A9 P:0003A9 60F400            MOVE              #SERIAL_READ_RIGHT_2,R0 ; Here if right amp, bin by 2
                            00019E
1691      P:0003AB P:0003AB 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1692      P:0003AC P:0003AC 0D03D2            JSR     <WAVECPY                          ; Copy the waveform
1693      P:0003AD P:0003AD 0C03CC            JMP     <CMP_END
1694      P:0003AE P:0003AE 0A1E83  TRY_3_R   JCLR    #3,X:BINBIT,TRY_4_R
                            0003B7
1695      P:0003B0 P:0003B0 51F400            MOVE              #(END_SERIAL_READ_RIGHT_3-SERIAL_READ_RIGHT_3),B0
                            000019
1696      P:0003B2 P:0003B2 60F400            MOVE              #SERIAL_READ_RIGHT_3,R0 ; Here if right amp, bin by 3
                            0001DD
1697      P:0003B4 P:0003B4 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1698      P:0003B5 P:0003B5 0D03D2            JSR     <WAVECPY                          ; Copy the waveform
1699      P:0003B6 P:0003B6 0C03CC            JMP     <CMP_END
1700      P:0003B7 P:0003B7 0A1E84  TRY_4_R   JCLR    #4,X:BINBIT,TRY_5_R
                            0003C0
1701      P:0003B9 P:0003B9 51F400            MOVE              #(END_SERIAL_READ_RIGHT_4-SERIAL_READ_RIGHT_4),B0
                            00001F
1702      P:0003BB P:0003BB 60F400            MOVE              #SERIAL_READ_RIGHT_4,R0 ; Here if right amp, bin by 4
                            00022E
1703      P:0003BD P:0003BD 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1704      P:0003BE P:0003BE 0D03D2            JSR     <WAVECPY                          ; Copy the waveform
1705      P:0003BF P:0003BF 0C03CC            JMP     <CMP_END
1706      P:0003C0 P:0003C0 0A1E85  TRY_5_R   JCLR    #5,X:BINBIT,CMP_END
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 32



                            0003CC
1707      P:0003C2 P:0003C2 51F400            MOVE              #(END_SERIAL_READ_RIGHT_5-SERIAL_READ_RIGHT_5),B0
                            000025
1708      P:0003C4 P:0003C4 60F400            MOVE              #SERIAL_READ_RIGHT_5,R0 ; Here if right amp, bin by 5
                            000291
1709      P:0003C6 P:0003C6 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1710      P:0003C7 P:0003C7 0D03D2            JSR     <WAVECPY                          ; Copy the waveform
1711      P:0003C8 P:0003C8 0C03CC            JMP     <CMP_END
1712   
1713      P:0003C9 P:0003C9 56F400  CMP_LR    MOVE              #'_LR',A                ; LEFT and RIGHT = readouts #0 and #1
                            5F4C52
1714                                          IF      @SCP("ENABLESPLITS","ON")
1771                                          ELSE
1772      P:0003CB P:0003CB 0C03CF            JMP     <CMP_ERROR
1773                                          ENDIF
1774   
1775                                ;       returns modified as per "Four points", #1
1776      P:0003CC P:0003CC 47F400  CMP_END   MOVE              #'DON',Y1
                            444F4E
1777      P:0003CE P:0003CE 00000C            RTS
1778                                CMP_ERROR
1779      P:0003CF P:0003CF 47F400            MOVE              #'ERR',Y1
                            455252
1780      P:0003D1 P:0003D1 00000C            RTS
1781   
1782                                ; Short function to copy in waveforms from high Y to fast Y memory.
1783                                ; R0 is the source address, R7 the destination, and X0 is intermediary reg.
1784                                WAVECPY
1785      P:0003D2 P:0003D2 06C900            DO      B0,WAVELP                         ; Copy the waveform; B0 is SERWAVLEN already
                            0003D6
1786      P:0003D4 P:0003D4 4CD800            MOVE                          Y:(R0)+,X0
1787      P:0003D5 P:0003D5 4C5F00            MOVE                          X0,Y:(R7)+
1788      P:0003D6 P:0003D6 000000            NOP
1789                                WAVELP
1790      P:0003D7 P:0003D7 000000            NOP
1791      P:0003D8 P:0003D8 00000C            RTS
1792   
1793                                ; Short function to set the correct bit in BINBIT based on NSBIN
1794                                ; Called only if NSBIN is less than 6.
1795   
1796                                SET_BINBIT
1797                                ;       MOVE    Y:<TESTLOC1,A0                  ; HACK - test if this code is executed
1798                                ;       INC     A                               ; HACK
1799                                ;       MOVE    A0,Y:<TESTLOC1                  ; HACK
1800      P:0003D9 P:0003D9 50F400            MOVE              #>1,A0                  ; Put a bit in A and shift to right spot
                            000001
1801      P:0003DB P:0003DB 060540            DO      Y:<NSBIN,BINLOOP                  ; Bit zero position not used, 1-5 used
                            0003DD
1802      P:0003DD P:0003DD 200032            ASL     A
1803                                BINLOOP
1804      P:0003DE P:0003DE 507000            MOVE              A0,X:BINBIT             ; set bit 1-5 for SELECT_OUTPUT_SOURCE jump 
table
                            00001E
1805      P:0003E0 P:0003E0 00000C            RTS
1806   
1807   
1808                                ; Set the number of rows and columns and binning factors
1809                                ;       Correct command ptr to R3 as per "Four Points" #2
1810                                SET_ROWS_COLUMNS
1811      P:0003E1 P:0003E1 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NSR = NAXIS1
1812      P:0003E2 P:0003E2 4C7000            MOVE                          X0,Y:NSR
                            000001
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 33



1813      P:0003E4 P:0003E4 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NPR = NAXIS2
1814      P:0003E5 P:0003E5 4C7000            MOVE                          X0,Y:NPR
                            000002
1815      P:0003E7 P:0003E7 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NSBIN
1816      P:0003E8 P:0003E8 4C7000            MOVE                          X0,Y:NSBIN
                            000005
1817      P:0003EA P:0003EA 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NPBIN
1818      P:0003EB P:0003EB 4C7000            MOVE                          X0,Y:NPBIN
                            000006
1819      P:0003ED P:0003ED 4CBD00            MOVE                          Y:<AMPVAL,X0 ; Get ampval in X0 for SOS call
1820      P:0003EE P:0003EE 0D032D            JSR     <SELECT_OUTPUT_SOURCE             ; Update serial read waveform in case binnin
g changed
1821      P:0003EF P:0003EF 0C008F            JMP     <FINISH                           ; no error return possible
1822   
1823                                ; Set the variables for the time-resolved modes
1824                                ;       Correct command ptr to R3 as per "Four Points" #2
1825                                SET_IMAGE_PARAM
1826      P:0003F0 P:0003F0 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Image mode
1827      P:0003F1 P:0003F1 447000            MOVE              X0,X:IMAGE_MODE
                            000080
1828      P:0003F3 P:0003F3 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Iframes = NAXIS3
1829      P:0003F4 P:0003F4 4C7000            MOVE                          X0,Y:IFRAMES
                            00003A
1830      P:0003F6 P:0003F6 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Srows
1831      P:0003F7 P:0003F7 4C7000            MOVE                          X0,Y:SROWS
                            000038
1832      P:0003F9 P:0003F9 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Interval
1833                                ;       MOVE    X0,Y:INTERVAL           ; HACK - Using Interval as a test location
1834      P:0003FA P:0003FA 0C008F            JMP     <FINISH
1835   
1836   
1837                                ; Set the hardware trigger bit, executed as a command
1838                                ;       Correct command ptr to R3 as per "Four Points" #2
1839                                ; Disable h/w trigger and return error (for now) as per June 30, #8
1840                                SET_TRIGGER
1841      P:0003FB P:0003FB 44DB00            MOVE              X:(R3)+,X0              ; Get the trigger value
1842      P:0003FC P:0003FC 56F400            MOVE              #'_ON',A
                            5F4F4E
1843      P:0003FE P:0003FE 200045            CMP     X0,A
1844      P:0003FF P:0003FF 0AF0A2            JNE     NO_TRIGGER
                            000402
1845                                ;       JSET    #11,X:PBD,TRIG_CLR      ; Is Trigger running?
1846      P:000401 P:000401 0C008D            JMP     <ERROR                            ; Yes! report Error!  Why do this?
1847                                ;TRIG_CLR
1848                                ;       BSET    #TRIGGER,X:<STATUS      ; Set status bit, hardware trigger
1849                                ;       JMP     <FINISH
1850                                NO_TRIGGER
1851      P:000402 P:000402 0A0008            BCLR    #TRIGGER,X:<STATUS                ; Clear Status bit, software timing
1852      P:000403 P:000403 0C008F            JMP     <FINISH
1853   
1854                                ; Calculate the fast read parameters for each readout box
1855                                SETUP_SUBROUTINE
1856      P:000404 P:000404 4C8C00            MOVE                          Y:<SERWAVLEN,X0 ; # of waveforms
1857      P:000405 P:000405 4D9000            MOVE                          Y:<NSERIALS_READ,X1 ; Number of pixels to read
1858      P:000406 P:000406 0D0561            JSR     <FASTSKP                          ; Compute number of clocks required
1859      P:000407 P:000407 4D1300            MOVE                          X1,Y:<NREAD ; Number of waveforms per line
1860      P:000408 P:000408 5E9A00            MOVE                          Y:<NR_BIAS,A ; Number of pixels to read
1861      P:000409 P:000409 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                            00040C
1862      P:00040B P:00040B 200022            ASR     A
1863      P:00040C P:00040C 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1864      P:00040D P:00040D 21C500            MOVE              A,X1                    ; Number of waveforms per line
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 34



1865      P:00040E P:00040E 0D0561            JSR     <FASTSKP                          ; Compute number of clocks required
1866      P:00040F P:00040F 4D1500            MOVE                          X1,Y:<NBIAS ; Number of waveforms per line
1867      P:000410 P:000410 44F400            MOVE              #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT),X0 ; # of waveforms
                            000006
1868      P:000412 P:000412 4D8300            MOVE                          Y:<NS_CLR,X1 ; Number of pixels to skip
1869      P:000413 P:000413 0D0561            JSR     <FASTSKP                          ; Compute number of clocks required
1870      P:000414 P:000414 4D1100            MOVE                          X1,Y:<NSCLR ; Number of waveforms per line
1871      P:000415 P:000415 4D9700            MOVE                          Y:<NS_SKP1,X1 ; Number of pixels to skip
1872      P:000416 P:000416 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
1873      P:000417 P:000417 2000F0            MPY     Y1,X1,A
1874      P:000418 P:000418 200022            ASR     A
1875      P:000419 P:000419 210500            MOVE              A0,X1
1876      P:00041A P:00041A 0D0561            JSR     <FASTSKP                          ; Compute number of clocks required
1877      P:00041B P:00041B 4D1200            MOVE                          X1,Y:<NSKIP1 ; Number of waveforms per line
1878      P:00041C P:00041C 4D9800            MOVE                          Y:<NS_SKP2,X1 ; Number of pixels to skip
1879      P:00041D P:00041D 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
1880      P:00041E P:00041E 2000F0            MPY     Y1,X1,A
1881      P:00041F P:00041F 200022            ASR     A
1882      P:000420 P:000420 210500            MOVE              A0,X1
1883      P:000421 P:000421 0D0561            JSR     <FASTSKP                          ; Compute number of clocks required
1884      P:000422 P:000422 4D1400            MOVE                          X1,Y:<NSKIP2 ; Number of waveforms per line
1885      P:000423 P:000423 4D9600            MOVE                          Y:<NP_SKIP,X1
1886      P:000424 P:000424 4F8600            MOVE                          Y:<NPBIN,Y1
1887      P:000425 P:000425 2000F0            MPY     X1,Y1,A
1888      P:000426 P:000426 200022            ASR     A
1889      P:000427 P:000427 581600            MOVE                          A0,Y:<NP_SKIP
1890      P:000428 P:000428 00000C            RTS
1891   
1892                                ; Returns immediately if hardware triggering is not being used
1893                                ; Blocks until the trigger is found to be high twice in a row.
1894                                ; Waits until the trigger goes high
1895                                WAIT_UNTIL_TRIGGER
1896      P:000429 P:000429 0A0088            JCLR    #TRIGGER,X:STATUS,UNTIL_TRIGGER_RETURN
                            00042E
1897      P:00042B P:00042B 000000            NOP
1898                                ;       JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER       ; Is Trigger Low?
1899      P:00042C P:00042C 000000            NOP                                       ; Pause
1900                                ;       JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER       ; Is Trigger still Low?
1901      P:00042D P:00042D 000000            NOP
1902                                UNTIL_TRIGGER_RETURN
1903      P:00042E P:00042E 00000C            RTS
1904   
1905                                ; Returns immediately if hardware triggering is not being used
1906                                ; Blocks until the trigger is found to be low twice in a row.
1907                                ; Waits while the trigger is high
1908                                WAIT_WHILE_TRIGGER
1909      P:00042F P:00042F 0A0088            JCLR    #TRIGGER,X:STATUS,WHILE_TRIGGER_RETURN
                            000434
1910      P:000431 P:000431 000000            NOP
1911                                ;       JSET    #11,X:PBD,WAIT_WHILE_TRIGGER       ; Is Trigger High?
1912      P:000432 P:000432 000000            NOP                                       ; Pause
1913                                ;       JSET    #11,X:PBD,WAIT_WHILE_TRIGGER       ; Is Trigger still High?
1914      P:000433 P:000433 000000            NOP
1915                                WHILE_TRIGGER_RETURN
1916      P:000434 P:000434 00000C            RTS
1917   
1918                                ; Like WAIT_WHILE_TRIGGER but clears the CCD while waiting
1919                                ; Pro:  Clears CCD while waiting.  Con: timing rattiness of 1 parallel time
1920                                ; Returns immediately if hardware triggering is not being used
1921                                ; Blocks until the trigger is found to be low twice in a row.
1922                                ; Waits while the trigger is high
1923                                CLEAR_WHILE_TRIGGER
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 35



1924      P:000435 P:000435 0A0088            JCLR    #TRIGGER,X:STATUS,CLEAR_TRIG_RETURN
                            00043C
1925      P:000437 P:000437 60F400            MOVE              #IS_CLEAR,R0            ; Address of parallel transfer waveform
                            000065
1926      P:000439 P:000439 0D02E0            JSR     <CLOCK                            ; Go clock out the CCD charge
1927                                ;       JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER       ; Is Trigger High?
1928      P:00043A P:00043A 000000            NOP                                       ; Pause
1929                                ;       JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER      ; Is Trigger still High?
1930      P:00043B P:00043B 000000            NOP
1931                                CLEAR_TRIG_RETURN
1932      P:00043C P:00043C 00000C            RTS
1933   
1934                                ; Subroutine to compute SROWS in unbinned pixels and store in UBSROWS
1935   
1936                                UB_CONV
1937      P:00043D P:00043D 4CB800            MOVE                          Y:<SROWS,X0
1938      P:00043E P:00043E 4D8600            MOVE                          Y:<NPBIN,X1 ; Adjust for for parallel binning factor
1939      P:00043F P:00043F 2000A0            MPY     X0,X1,A
1940      P:000440 P:000440 200022            ASR     A
1941      P:000441 P:000441 583900            MOVE                          A0,Y:<UBSROWS ; Put unbinned number in UBSROWS
1942      P:000442 P:000442 00000C            RTS
1943   
1944                                ; Key code segments for the HIPO modes.
1945                                ; Jump table to the various modes - see also timhdr.s
1946                                START_FT_EXPOSURE
1947      P:000443 P:000443 0A0006            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of lingering abort flag
1948      P:000444 P:000444 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
1949      P:000446 P:000446 0AC421            JSET    #FIND,X0,SINGLE_PROC
                            00047F
1950      P:000448 P:000448 0AC424            JSET    #SINGLE,X0,SINGLE_PROC
                            00047F
1951                                ;       JSET    #SERIES,X0,SERIES_PROC        ; defunct.  Use basic occ.
1952      P:00044A P:00044A 0AC420            JSET    #FDOTS,X0,FDOT_PROC
                            000459
1953      P:00044C P:00044C 0AC422            JSET    #SDOTS,X0,SDOT_PROC               ; slow dots & strips use sdot_proc
                            0004B6
1954      P:00044E P:00044E 0AC425            JSET    #STRIP,X0,SDOT_PROC
                            0004B6
1955      P:000450 P:000450 0AC427            JSET    #B_OCC,X0,SINGLE_PROC             ; basic occ uses single_proc
                            00047F
1956      P:000452 P:000452 0AC426            JSET    #F_OCC,X0,FPO_PROC                ; fast & pipelined occ use occ_proc
                            0004E0
1957      P:000454 P:000454 0AC428            JSET    #P_OCC,X0,FPO_PROC
                            0004E0
1958      P:000456 P:000456 44F400            MOVE              #'ERR',X0               ; error if not a valid mode
                            455252
1959      P:000458 P:000458 0C008D            JMP     <ERROR
1960   
1961                                FDOT_PROC                                           ; used by fdots only
1962                                ; Start by replacing SROWS (binned rows) with unbinned rows.  Will get rewritten on next SEX com
mand
1963                                ; Leave the DO loop in here - no reason to change it - won't exceed 65535 dots, for sure!
1964      P:000459 P:000459 0D043D            JSR     UB_CONV                           ; Fill in unbinned SROWS
1965      P:00045A P:00045A 4C8200            MOVE                          Y:<NPR,X0
1966      P:00045B P:00045B 4C1C00            MOVE                          X0,Y:<NP_READ ; Make sure that NP_READ=NPR in case of su
bframe
1967      P:00045C P:00045C 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
1968      P:00045D P:00045D 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for FDOTS
1969      P:00045E P:00045E 0A2020            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe bou
ndary
1970      P:00045F P:00045F 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 36



                            00051C
1971      P:000461 P:000461 0D02FB            JSR     <CLR_CCD                          ; Clear out the CCD
1972      P:000462 P:000462 0D042F            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
1973                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
1974      P:000463 P:000463 0D0570            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
1975      P:000464 P:000464 063A40            DO      Y:<IFRAMES,FDOT_LOOP              ; Loop over the number of FDOTS
                            000475
1976      P:000466 P:000466 0A00A8            JSET    #TRIGGER,X:STATUS,FDX_END         ; If no triggering jump to expose image func
tion
                            00046C
1977      P:000468 P:000468 67F400            MOVE              #FDX_END,R7             ; Store the Address into R7
                            00046C
1978      P:00046A P:00046A 0A0027            BSET    #ST_EXP,X:<STATUS
1979      P:00046B P:00046B 0C0316            JMP     <EXPOSE                           ; Delay for specified exposure time
1980                                FDX_END
1981      P:00046C P:00046C 0A0007            BCLR    #ST_EXP,X:<STATUS
1982      P:00046D P:00046D 0A0086            JCLR    #ST_ABRT,X:<STATUS,FDX_NXT        ; got abort underway?
                            000471
1983      P:00046F P:00046F 00008C            ENDDO
1984      P:000470 P:000470 0C047D            JMP     <FDOT_FINI
1985                                FDX_NXT
1986      P:000471 P:000471 0D0429            JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
1987      P:000472 P:000472 4DB900            MOVE                          Y:<UBSROWS,X1 ; Number of unbinned rows per shift
1988      P:000473 P:000473 0D052F            JSR     <ISHIFT                           ; Clock out the waveforms
1989      P:000474 P:000474 0D042F            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
1990      P:000475 P:000475 000000            NOP
1991                                FDOT_LOOP
1992      P:000476 P:000476 0D0571            JSR     <C_CSHUT                          ; Conditionally close shutter
1993      P:000477 P:000477 063A40            DO      Y:<IFRAMES,FDOT_LP1               ; Loop over the number of FDOTS during reado
ut
                            00047C
1994      P:000479 P:000479 0A0024            BSET    #ST_RDC,X:<STATUS
1995      P:00047A P:00047A 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD
1996      P:00047B P:00047B 0A0004            BCLR    #ST_RDC,X:<STATUS
1997      P:00047C P:00047C 000000            NOP
1998                                FDOT_LP1
1999                                FDOT_FINI
2000                                ;       CLOSE SHUTTER if abt??
2001                                ;       JSR     <WAIT_UNTIL_TRIGGER             ; If taking more than one set of dots sync. trig
ger.  Vestigial?
2002      P:00047D P:00047D 0AF080            JMP     CLEANUP                           ; clean up after command.
                            000524
2003   
2004                                SINGLE_PROC                                         ; Used by find, single, and basic occ
2005      P:00047F P:00047F 0A2001            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for find & basic occ
2006      P:000480 P:000480 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2007      P:000482 P:000482 0AC404            JCLR    #SINGLE,X0,*+3                    ; But if single mode,
                            000485
2008      P:000484 P:000484 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
2009      P:000485 P:000485 0A2002            BCLR    #STORAGE,X:<ISTATUS               ; Do the FT, no storage clocks only during r
eadout
2010      P:000486 P:000486 0A2000            BCLR    #NO_SKIP,X:<ISTATUS               ; Do parallel skip up to the subframe bounda
ry
2011                                          IF      @SCP("10","0")
2012                                          ELSE
2013      P:000487 P:000487 060A80            DO      #SDELAY,SNGL_DELAY1
                            00048E
2014      P:000489 P:000489 44F400            MOVE              #25000,X0
                            0061A8
2015      P:00048B P:00048B 06C400            DO      X0,SNGL_DELAY0
                            00048D
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 37



2016      P:00048D P:00048D 000000            NOP
2017                                 SNGL_DELAY0
2018      P:00048E P:00048E 000000            NOP
2019                                 SNGL_DELAY1
2020      P:00048F P:00048F 000000            NOP
2021                                          ENDIF
2022   
2023      P:000490 P:000490 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            00051C
2024      P:000492 P:000492 0D02FB            JSR     <CLR_CCD                          ; Clear out the CCD
2025      P:000493 P:000493 0D042F            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2026                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2027      P:000494 P:000494 4CBA00            MOVE                          Y:<IFRAMES,X0
2028      P:000495 P:000495 4C3E00            MOVE                          X0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
2029      P:000496 P:000496 0D0570  SN_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2030      P:000497 P:000497 67F400            MOVE              #SNX_END,R7             ; Store the Address into R7
                            00049B
2031      P:000499 P:000499 0A0027            BSET    #ST_EXP,X:<STATUS
2032                                ;       JSET    #TRIGGER,X:STATUS,SNX_END       ; If no triggering jump to expose image function
2033      P:00049A P:00049A 0C0316            JMP     <EXPOSE                           ; Delay for specified exposure time
2034                                SNX_END
2035      P:00049B P:00049B 0A0007            BCLR    #ST_EXP,X:<STATUS
2036      P:00049C P:00049C 0A00A6            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                            0004AD
2037   
2038      P:00049E P:00049E 0D0429            JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2039      P:00049F P:00049F 0D0571            JSR     <C_CSHUT                          ; Close shutter if open-close bit is set
2040      P:0004A0 P:0004A0 0A0024            BSET    #ST_RDC,X:<STATUS
2041      P:0004A1 P:0004A1 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD
2042      P:0004A2 P:0004A2 0A0004            BCLR    #ST_RDC,X:<STATUS
2043      P:0004A3 P:0004A3 0D042F            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2044      P:0004A4 P:0004A4 0A00A6            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                            0004AD
2045      P:0004A6 P:0004A6 200013            CLR     A
2046      P:0004A7 P:0004A7 58BE00            MOVE                          Y:<IFLPCNT,A0
2047      P:0004A8 P:0004A8 00000A            DEC     A                                 ; Get loop count, decrement, and loop till z
ero
2048      P:0004A9 P:0004A9 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2049      P:0004AA P:0004AA 583E00            MOVE                          A0,Y:<IFLPCNT
2050      P:0004AB P:0004AB 200003            TST     A
2051      P:0004AC P:0004AC 0E2496            JNE     SN_LP                             ; End of IFRAMES loop
2052                                SNX_FINI
2053      P:0004AD P:0004AD 0A0964            BSET    #4,Y:<SH_DEL
2054      P:0004AE P:0004AE 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2055      P:0004B0 P:0004B0 0AC421            JSET    #FIND,X0,*+3
                            0004B3
2056      P:0004B2 P:0004B2 0D0573            JSR     <CSHUT                            ; Close the shutter unless in find mode
2057      P:0004B3 P:0004B3 0A0965            BSET    #5,Y:<SH_DEL
2058      P:0004B4 P:0004B4 0AF080            JMP     CLEANUP                           ; clean up after command.
                            000524
2059   
2060                                SDOT_PROC                                           ; Used by slow dots and strips
2061      P:0004B6 P:0004B6 4CB800            MOVE                          Y:<SROWS,X0
2062      P:0004B7 P:0004B7 4C1C00            MOVE                          X0,Y:<NP_READ ; Make sure that NP_READ=SROWS
2063      P:0004B8 P:0004B8 0A2001            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for strips
2064      P:0004B9 P:0004B9 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2065      P:0004BB P:0004BB 0AC402            JCLR    #SDOTS,X0,*+3                     ; But if sdots mode,
                            0004BE
2066      P:0004BD P:0004BD 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
2067      P:0004BE P:0004BE 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for SDOTS an
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 38



d strips
2068      P:0004BF P:0004BF 0A2020            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe bou
ndary
2069      P:0004C0 P:0004C0 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            00051C
2070      P:0004C2 P:0004C2 0D02FB            JSR     <CLR_CCD                          ; Clear out the CCD
2071      P:0004C3 P:0004C3 0D042F            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2072                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2073      P:0004C4 P:0004C4 4CBA00            MOVE                          Y:<IFRAMES,X0
2074      P:0004C5 P:0004C5 4C3E00            MOVE                          X0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
2075      P:0004C6 P:0004C6 0D0570  SD_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2076      P:0004C7 P:0004C7 0A00A8            JSET    #TRIGGER,X:STATUS,SDX_END         ; If no triggering jump to expose image func
tion
                            0004D0
2077      P:0004C9 P:0004C9 67F400            MOVE              #SDX_END,R7             ; Store the Address into R7
                            0004D0
2078      P:0004CB P:0004CB 0A0027            BSET    #ST_EXP,X:<STATUS
2079      P:0004CC P:0004CC 0C0316            JMP     <EXPOSE                           ; Delay for specified exposure time
2080      P:0004CD P:0004CD 0A0007            BCLR    #ST_EXP,X:<STATUS
2081      P:0004CE P:0004CE 0A00A6            JSET    #ST_ABRT,X:<STATUS,SDX_FINI       ; got abort underway?
                            0004DD
2082      P:0004D0 P:0004D0 0D0429  SDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2083      P:0004D1 P:0004D1 0D0571            JSR     <C_CSHUT                          ; Close shutter if open-close is set
2084      P:0004D2 P:0004D2 0A0024            BSET    #ST_RDC,X:<STATUS
2085      P:0004D3 P:0004D3 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD.
2086      P:0004D4 P:0004D4 0A0004            BCLR    #ST_RDC,X:<STATUS
2087                                                                                    ; No FT or parallel skip since STORAGE=1
2088      P:0004D5 P:0004D5 0D042F            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2089      P:0004D6 P:0004D6 200013            CLR     A
2090      P:0004D7 P:0004D7 58BE00            MOVE                          Y:<IFLPCNT,A0
2091      P:0004D8 P:0004D8 00000A            DEC     A                                 ; Get loop count, decrement, and loop till z
ero
2092      P:0004D9 P:0004D9 000000            NOP
2093      P:0004DA P:0004DA 583E00            MOVE                          A0,Y:<IFLPCNT
2094      P:0004DB P:0004DB 200003            TST     A
2095      P:0004DC P:0004DC 0E24C6            JNE     SD_LP                             ; End of IFRAMES loop
2096                                SDX_FINI
2097      P:0004DD P:0004DD 0D0573            JSR     <CSHUT                            ; Unconditionally close shutter
2098      P:0004DE P:0004DE 0AF080            JMP     CLEANUP                           ; clean up after command.
                            000524
2099   
2100                                FPO_PROC                                            ; Used by fast and pipelined occultation mod
es
2101      P:0004E0 P:0004E0 4C9C00            MOVE                          Y:<NP_READ,X0
2102      P:0004E1 P:0004E1 4C3800            MOVE                          X0,Y:<SROWS ; Make sure that SROWS=NP_READ
2103      P:0004E2 P:0004E2 0D043D            JSR     UB_CONV                           ; Fill in unbinned SROWS in UBSROWS
2104      P:0004E3 P:0004E3 0A2001            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for both of these modes
2105      P:0004E4 P:0004E4 0A2002            BCLR    #STORAGE,X:<ISTATUS               ; Storage clocks only during readout
2106      P:0004E5 P:0004E5 0A2020            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe bou
ndary
2107      P:0004E6 P:0004E6 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            00051C
2108      P:0004E8 P:0004E8 0D02FB            JSR     <CLR_CCD                          ; Clear out the CCD
2109      P:0004E9 P:0004E9 0D042F            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2110                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2111      P:0004EA P:0004EA 0D0570            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2112      P:0004EB P:0004EB 4CBA00            MOVE                          Y:<IFRAMES,X0
2113      P:0004EC P:0004EC 4C3E00            MOVE                          X0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
2114      P:0004ED P:0004ED 0A00A8  FP_LP     JSET    #TRIGGER,X:STATUS,FPO_END         ; If no triggering jump to expose image func
tion
                            0004F6
2115      P:0004EF P:0004EF 67F400            MOVE              #FPO_END,R7             ; Store the Address into R7
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 39



                            0004F6
2116      P:0004F1 P:0004F1 0A0027            BSET    #ST_EXP,X:<STATUS
2117      P:0004F2 P:0004F2 0C0316            JMP     <EXPOSE                           ; Delay for specified exposure time
2118      P:0004F3 P:0004F3 0A0007            BCLR    #ST_EXP,X:<STATUS
2119      P:0004F4 P:0004F4 0A00A6            JSET    #ST_ABRT,X:<STATUS,FPO_FINI       ; got abort underway?
                            000519
2120      P:0004F6 P:0004F6 0D0429  FPO_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2121      P:0004F7 P:0004F7 4DB900            MOVE                          Y:<UBSROWS,X1 ; Shift down UBSROWS unbinned rows
2122      P:0004F8 P:0004F8 0BF080            JSR     ISHIFT                            ; Clock down subframe height
                            00052F
2123      P:0004FA P:0004FA 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2124      P:0004FC P:0004FC 0AC428            JSET    #P_OCC,X0,FPO_RD                  ; Shift the rest of the way for F_OCC
                            000508
2125                                                                                    ; Go straight to readout if P_OCC
2126      P:0004FE P:0004FE 4CF000            MOVE                          Y:S_SIZE,X0
                            00003B
2127      P:000500 P:000500 208E00            MOVE              X0,A                    ; Get only least significant 24 bits
2128      P:000501 P:000501 4CB900            MOVE                          Y:<UBSROWS,X0
2129      P:000502 P:000502 200044            SUB     X0,A                              ;
2130      P:000503 P:000503 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2131      P:000504 P:000504 21C500            MOVE              A,X1                    ; X1 = S_SIZE - UBSROWS
2132      P:000505 P:000505 0BF080            JSR     SSHIFT                            ; Clock storage the rest of the way
                            00053D
2133      P:000507 P:000507 0A0024            BSET    #ST_RDC,X:<STATUS
2134      P:000508 P:000508 0D0233  FPO_RD    JSR     <RCCD1                            ; Finally, read out the CCD.  Skip the FT
2135      P:000509 P:000509 0A0004            BCLR    #ST_RDC,X:<STATUS
2136      P:00050A P:00050A 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2137      P:00050C P:00050C 0AC426            JSET    #F_OCC,X0,FPO_SK                  ; Shift back up by UBSROWS if P_OCC
                            000511
2138      P:00050E P:00050E 4DB900            MOVE                          Y:<UBSROWS,X1 ; Shift UBSROWS unbinned rows back up
2139      P:00050F P:00050F 0BF080            JSR     RSHIFT                            ; Clock subframe height back up
                            000549
2140      P:000511 P:000511 0D042F  FPO_SK    JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2141      P:000512 P:000512 200013            CLR     A
2142      P:000513 P:000513 58BE00            MOVE                          Y:<IFLPCNT,A0
2143      P:000514 P:000514 00000A            DEC     A                                 ; Get loop count, decrement, and loop till z
ero
2144      P:000515 P:000515 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2145      P:000516 P:000516 583E00            MOVE                          A0,Y:<IFLPCNT
2146      P:000517 P:000517 200003            TST     A
2147      P:000518 P:000518 0E24ED            JNE     FP_LP                             ; End of IFRAMES loop
2148                                FPO_FINI
2149      P:000519 P:000519 0D0573            JSR     <CSHUT                            ; Unconditionally close shutter
2150      P:00051A P:00051A 0AF080            JMP     CLEANUP                           ; clean up after command.
                            000524
2151   
2152                                ; Support subroutines and code fragments used in the various mode code
2153                                ; IMG_INI, CLEANUP, ISHIFT, SSHIFT, RSHIFT
2154                                ;  Image initialization subroutine.  Sets up status bits & PCI card
2155                                ; Correct XMT_FO to XMT_WRD in timboot.s and change the input arg to B1
2156                                ; as per "Four Points" #3
2157   
2158      P:00051C P:00051C 55F400  IMG_INI   MOVE              #$020102,B1             ; Transmit header word
                            020102
2159      P:00051E P:00051E 0D00EB            JSR     <XMT_WRD
2160      P:00051F P:00051F 55F400            MOVE              #'IIA',B1               ; Initialize Image Address
                            494941
2161      P:000521 P:000521 0D00EB            JSR     <XMT_WRD
2162                                ;        BSET    #ST_RDC,X:<STATUS       ; Set status to reading out
2163      P:000522 P:000522 0D06E5            JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 40



2164      P:000523 P:000523 00000C            RTS
2165   
2166                                ; Cleanup code fragment (not a subroutine) for the end all modes.  JMP to it.
2167                                ; remove WW mode reference and also do a CLOCK wait.
2168                                ; support no idling mode as per MLO code.
2169                                ; all as per July 4 confluence #1
2170   
2171                                ;CLEANUP BCLR    #WW,X:PBD               ; Clear WW to 0 for 32-bit commands
2172                                CLEANUP
2173   
2174                                ; Restore the controller to non-image data transfer and idling if necessary
2175      P:000524 P:000524 0A0082            JCLR    #IDLMODE,X:<STATUS,NO_IDL         ; Don't idle after readout
                            000529
2176      P:000526 P:000526 60F400            MOVE              #IDLE,R0
                            000309
2177      P:000528 P:000528 0C052A            JMP     <CLEAN1
2178      P:000529 P:000529 305A00  NO_IDL    MOVE              #TST_RCV,R0
2179                                CLEAN1
2180      P:00052A P:00052A 0BF080            JSR     CLOCK_WAIT                        ; so everything is transferred
                            000556
2181      P:00052C P:00052C 601F00            MOVE              R0,X:<IDL_ADR
2182   
2183                                ;        BCLR    #ST_RDC,X:<STATUS       ; Clear status to NOT reading out
2184      P:00052D P:00052D 0A0006            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of any abort flag
2185      P:00052E P:00052E 0C0054            JMP     <START                            ; Wait for a new command
2186   
2187                                ; Shift image and storage areas down by the number of rows in X1
2188                                ISHIFT
2189                                          IF      @SCP("IMO","IMO")
2190      P:00052F P:00052F 306E00            MOVE              #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2191      P:000530 P:000530 0D02E0            JSR     <CLOCK                            ; IMO
2192      P:000531 P:000531 000000            NOP                                       ; IMO
2193                                          ENDIF
2194      P:000532 P:000532 06C500            DO      X1,ISH_LOOP                       ; Number of rows to shift is in X1
                            000536
2195      P:000534 P:000534 306500            MOVE              #<IS_CLEAR,R0           ; Ganged clocks with DG running
2196      P:000535 P:000535 0D02E0            JSR     <CLOCK                            ; Parallel clocking
2197      P:000536 P:000536 000000            NOP
2198                                ISH_LOOP
2199      P:000537 P:000537 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                            00007A
2200      P:000539 P:000539 0D02E0            JSR     <CLOCK
2201      P:00053A P:00053A 307600            MOVE              #<IMO_LAST_CLOCK,R0     ; set clocks to 0
2202      P:00053B P:00053B 0D02E0            JSR     <CLOCK
2203      P:00053C P:00053C 00000C            RTS                                       ; End of ISHIFT
2204   
2205                                ; Shift storage area only down by the number of rows in X1
2206                                SSHIFT
2207                                          IF      @SCP("IMO","IMO")
2208      P:00053D P:00053D 306E00            MOVE              #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2209      P:00053E P:00053E 0D02E0            JSR     <CLOCK                            ; IMO
2210      P:00053F P:00053F 000000            NOP                                       ; IMO
2211                                          ENDIF
2212      P:000540 P:000540 06C500            DO      X1,SSH_LOOP                       ; Number of rows to shift is in X1
                            000544
2213      P:000542 P:000542 305200            MOVE              #<S_CLEAR,R0            ; Storage clocks only with DG running
2214      P:000543 P:000543 0D02E0            JSR     <CLOCK                            ; Parallel clocking
2215      P:000544 P:000544 000000            NOP
2216                                SSH_LOOP
2217      P:000545 P:000545 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                            00007A
2218      P:000547 P:000547 0D02E0            JSR     <CLOCK
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timmisc.s  Page 41



2219      P:000548 P:000548 00000C            RTS                                       ; End of SSHIFT
2220   
2221                                ; Used by pipelined occultation mode to move the storage area back up to
2222                                ; the seam following read of a subframe
2223                                RSHIFT
2224                                          IF      @SCP("IMO","IMO")
2225      P:000549 P:000549 306E00            MOVE              #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2226      P:00054A P:00054A 0D02E0            JSR     <CLOCK                            ; IMO
2227      P:00054B P:00054B 000000            NOP                                       ; IMO
2228                                          ENDIF
2229      P:00054C P:00054C 06C500            DO      X1,RVS_SHIFT                      ; Number of rows to read out
                            000550
2230      P:00054E P:00054E 304A00            MOVE              #<R_S_PARALLEL,R0       ; Reverse parallel waveform
2231      P:00054F P:00054F 0D02E0            JSR     <CLOCK                            ; Parallel clocking
2232      P:000550 P:000550 000000            NOP
2233                                RVS_SHIFT
2234      P:000551 P:000551 00000C            RTS                                       ; End of RSHIFT
2235                                          INCLUDE "timCCDmisc.s"                    ; Generic
2236                                ; This file is for utilities that are in common to all the timing board
2237                                ;   programs, located starting at P:$200 in external SRAM
2238   
2239                                        COMMENT *
2240   
2241                                The following commands are supported in this "timmisc.s" file
2242                                PAL_DLY                 Subroutine to delay by about 8 microseconds
2243                                SET_DAC                 Transfer DAC values in (R0) table to the DACs
2244                                FASTSKP                 Compute number of waveform table entries in a readout
2245                                                                for fast clocking
2246                                OSHUT                   Subroutine call for opening the shutter
2247                                CSHUT                   Subroutine call for closing the shutter
2248                                OPEN_SHUTTER            Command for opening the shutter
2249                                CLOSE_SHUTTER           Command for closing the shutter
2250                                SET_EXP_TIME            Write desired exposure time to timing board variable
2251                                RD_EXP_TIME             Read elapsed exposure time
2252                                START_EXPOSURE          Start an exposure - 'DON' reply, clear FPA, open
2253                                                        shutter, expose, close shutter, delay Y:SH_DLY, readout
2254                                PAUSE_EXPOSURE          Close shutter, stop exposure timer
2255                                RESUME_EXPOSURE         Open shutter if necessary, resume exposure timer
2256                                ABORT_EXPOSURE          Close shutter, stop exposure timer
2257                                INF                     Return version and timing information
2258                                IDL                     Put FPA to clocking when not processing commands or
2259                                                        reading out
2260                                READ_CONTROLLER_CONFIGURATION
2261   
2262                                PWR_OFF                 Turn off ananlog power supply voltages to backplane
2263                                PWR_ON                  Turn on analog power supply voltages to backplane
2264                                SETBIAS                 Command to call SET_BIASES and reply 'DON'
2265                                SET_BIASES              Subroutine to turn on all bias and clock voltages
2266                                                        by reading them from the waveform tables and writing
2267                                                        them to the DACs
2268                                SER_ANA                 Direct the timing board DSP's synchronous serial
2269                                                        transmitter to the analog boards (clock driver, video)
2270                                SER_UTL                 Direct the timing board DSP's synchronous serial
2271                                                        transmitter to the utility board
2272                                CLR_SWS                 Clear the analog switches in the clock driver and
2273                                                        video boards to lower their power consumption, as a
2274                                                        command with a 'DON' reply
2275                                CLEAR_SWITCHES          A subroutine call for CLR_WSW
2276                                ST_GAIN                 Set the video processor gain to one of four values
2277                                WR_CNTRL
2278                                SET_DC
2279                                SET_BIAS_NUMBER
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timCCDmisc.s  Page 42



2280                                SET_MUX
2281   
2282                                        *
2283   
2284                                ; These become a single line macros, as per June 30 #12
2285                                ; Enable serial communication to the analog boards
2286                                SER_ANA   MACRO
2287 m                                        BSET    #3,X:PCRD                         ; Turn on the serial clock
2288 m                                        ENDM
2289                                ; Enable serial communication to the utility board
2290                                SER_UTL   MACRO
2291 m                                        BCLR    #3,X:PCRD                         ; Turn off the serial clock
2292 m                                        ENDM
2293   
2294   
2295                                ; Delay for serial writes to the PALs and DACs by 8 microsec
2296                                ; Conformed to gen-iii MLO as per CCDmisc comments June 30 #1
2297      P:000552 P:000552 062083  PAL_DLY   DO      #800,*+3                          ; Wait 8 usec for serial data transmission
                            000554
2298      P:000554 P:000554 000000            NOP
2299      P:000555 P:000555 00000C            RTS
2300   
2301                                ; Wait for clocking to be complete before proceeding
2302                                ; Code added as per June 29 #5
2303                                CLOCK_WAIT
2304      P:000556 P:000556 01ADA1            JSET    #SSFEF,X:PDRD,*                   ; Wait for the SS FIFO to be empty
                            000556
2305      P:000558 P:000558 00000C            RTS
2306   
2307   
2308   
2309                                ;  Update the DACs
2310                                ; Remove cruft as per June 30 #2
2311      P:000559 P:000559 4CD800  SET_DAC   MOVE                          Y:(R0)+,X0  ; Get the number of table entries
2312      P:00055A P:00055A 06C400            DO      X0,SET_L0                         ; Repeat X0 times
                            00055F
2313      P:00055C P:00055C 5ED800            MOVE                          Y:(R0)+,A   ; Send out the waveform
2314      P:00055D P:00055D 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
2315      P:00055E P:00055E 0D0552            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
2316      P:00055F P:00055F 000000            NOP                                       ; Do loop restriction
2317                                SET_L0
2318      P:000560 P:000560 00000C            RTS                                       ; Return from subroutine
2319   
2320                                ; Subroutine for computing number of fast clocks needed
2321                                ; remove the offset for gen-iii, as per June 30 general comment #3
2322      P:000561 P:000561 2000A8  FASTSKP   MPY     X0,X1,B                           ; X1 = number of pixels to skip,
2323                                                                                    ; X0 = number of waveform table entries
2324      P:000562 P:000562 20002A            ASR     B                                 ; Correct for multiplication left shift
2325      P:000563 P:000563 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2326      P:000564 P:000564 212500            MOVE              B0,X1                   ; Get only least significant 24 bits
2327                                ;       MOVE    X:<ONE,X1
2328                                ;       SUB     X1,A            ; Subtract 1
2329                                ;       MOVE    A,X1            ; X1 = X0 * X1 - 1
2330      P:000565 P:000565 00000C            RTS
2331   
2332                                ; this becomes a no-op for gwaves which has no shutter.
2333                                ; as per Confluence July 4 #2
2334                                SET_SHUTTER_STATE
2335                                ;       MOVE    X:LATCH,A
2336                                ;       AND     #$FFEF,A
2337                                ;       OR      X0,A
2338                                ;       NOP
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timCCDmisc.s  Page 43



2339                                ;       MOVE    A1,X:LATCH
2340                                ;       MOVEP   A1,Y:WRLATCH
2341      P:000566 P:000566 00000C            RTS
2342   
2343                                ; Open the shutter from the timing board, executed as a command
2344                                OPEN_SHUTTER
2345      P:000567 P:000567 0A0023            BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
2346      P:000568 P:000568 240000            MOVE              #0,X0
2347      P:000569 P:000569 0D0566            JSR     <SET_SHUTTER_STATE
2348      P:00056A P:00056A 0C008F            JMP     <FINISH
2349   
2350                                ; Close the shutter from the timing board, executed as a command
2351                                CLOSE_SHUTTER
2352      P:00056B P:00056B 0A0003            BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
2353      P:00056C P:00056C 44F400            MOVE              #>$10,X0
                            000010
2354      P:00056E P:00056E 0D0566            JSR     <SET_SHUTTER_STATE
2355      P:00056F P:00056F 0C008F            JMP     <FINISH
2356   
2357                                ; Subroutine with two entry points.  C_OSHUT is conditional on SHUT
2358                                ; Open the shutter conditionally based on the shutter status bit
2359                                ; Open the shutter by setting the backplane bit TIM-LATCH0
2360                                ; NOTE this code is a no-op for gwaves
2361                                C_OSHUT
2362                                ;       JCLR    #SHUT,X:STATUS,OSH_RTN
2363                                OSHUT
2364                                                                                    ;BSET    #ST_SHUT,X:<STATUS     ; Set status
 bit to mean shutter open
2365                                                                                    ;MOVE   #0,X0
2366                                                                                    ;JSR    <SET_SHUTTER_STATE
2367      P:000570 P:000570 00000C  OSH_RTN   RTS
2368   
2369                                ; Subroutine with two entry points.  C_CSHUT is conditional on OPEN_CLOSE
2370                                ; Close the shutter conditionally based on the open-close ISTATUS bit
2371                                ; Close the shutter by clearing the backplane bit TIM-LATCH0
2372      P:000571 P:000571 0A2081  C_CSHUT   JCLR    #OPEN_CLOSE,X:ISTATUS,CSH_RTN     ; Don't close if always open
                            000577
2373      P:000573 P:000573 0A0003  CSHUT     BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
2374      P:000574 P:000574 44F400            MOVE              #>$10,X0
                            000010
2375      P:000576 P:000576 0D0566            JSR     <SET_SHUTTER_STATE
2376      P:000577 P:000577 00000C  CSH_RTN   RTS
2377   
2378                                ; Set the desired exposure time
2379                                ;       Correct command ptr to R3 as per "Four Points" #2
2380                                ;       Modify exposure time var name as per June 30 #5
2381                                SET_EXP_TIME
2382      P:000578 P:000578 44DB00            MOVE              X:(R3)+,X0
2383      P:000579 P:000579 441000            MOVE              X0,X:<EXPOSURE_TIME
2384                                ;       MOVE    X0,X:<TGT_TIM
2385      P:00057A P:00057A 0C008F            JMP     <FINISH
2386   
2387   
2388                                ; Abort exposure - close the shutter, stop the timer and resume idle mode
2389                                ; Modified to match gen-iii MLO code- as per June 30 #6
2390                                ABORT_EXPOSURE
2391      P:00057B P:00057B 0A00A7            JSET    #ST_EXP,X:<STATUS,DO_ABEXP
                            00057E
2392                                ; assume we got here via the idle rcv loop
2393      P:00057D P:00057D 0C008F            JMP     <FINISH
2394                                DO_ABEXP
2395      P:00057E P:00057E 20001B            CLR     B
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timCCDmisc.s  Page 44



2396      P:00057F P:00057F 5FBF00            MOVE                          Y:<TESTLOC1,B
2397      P:000580 P:000580 0140C8            ADD     #128,B
                            000080
2398   
2399                                ;       JSR     <CSHUT                  ; Close the shutter
2400      P:000582 P:000582 010F00            BCLR    #TIM_BIT,X:TCSR0                  ; Disable the DSP exposure timer
2401      P:000583 P:000583 5F3F00            MOVE                          B,Y:<TESTLOC1
2402                                ;
2403                                ; The place to return must be in R7-
2404      P:000584 P:000584 0AE780            JMP     (R7)                              ; 'return' from EXPOSE
2405   
2406   
2407                                ;       JCLR    #IDLMODE,X:<STATUS,NO_IDL2 ; Check whether to idle after readout
2408                                ;       MOVE    #IDLE,X0                ; Idle after readout
2409                                ;       JMP     RDC_E2
2410                                ;NO_IDL2
2411                                ;       MOVE    #TST_RCV,X0             ; Idle after readout
2412                                ;RDC_E2
2413                                ;       MOVE    X0,X:<IDL_ADR
2414                                ;       JSR     <CLOCK_WAIT
2415                                ;       BCLR    #ST_RDC,X:<STATUS       ; Set status to not reading out
2416                                ;        DO      #4000,*+3               ; Wait 40 microsec for the fiber
2417                                ;        NOP                             ;  optic to clear out
2418                                ;       JMP     <FINISH
2419   
2420                                ;       Process INF according to the single addressing parameter
2421                                ;       Correct FINISH1 datum as per "Four Points" #1
2422                                ;       Correct command ptr to R3 as per "Four Points" #2
2423                                GET_INFO
2424      P:000585 P:000585 56DB00            MOVE              X:(R3)+,A               ; 0-4 is generic, >= 0x100 tim specific
2425                                ; Remove for gen-iii per June 6 #2
2426      P:000586 P:000586 47F400            MOVE              #IVERSION,Y1
                            04507F
2427      P:000588 P:000588 46F400            MOVE              #>GET_VERSION,Y0
                            000000
2428      P:00058A P:00058A 200055            CMP     Y0,A
2429      P:00058B P:00058B 0EA090            JEQ     <FINISH1
2430                                ; Remove for gen-iii per June 6 #2
2431      P:00058C P:00058C 47F400            MOVE              #IFLAVOR,Y1
                            612020
2432      P:00058E P:00058E 46F400            MOVE              #>GET_FLAVOR,Y0
                            000001
2433      P:000590 P:000590 200055            CMP     Y0,A
2434      P:000591 P:000591 0EA090            JEQ     <FINISH1
2435      P:000592 P:000592 47F400            MOVE              #ITIME0,Y1
                            000DAA
2436      P:000594 P:000594 46F400            MOVE              #>GET_TIME0,Y0
                            000002
2437      P:000596 P:000596 200055            CMP     Y0,A
2438      P:000597 P:000597 0EA090            JEQ     <FINISH1                          ; Is it Time0?
2439      P:000598 P:000598 47F400            MOVE              #ITIME1,Y1
                            005A8E
2440      P:00059A P:00059A 46F400            MOVE              #>GET_TIME1,Y0
                            000003
2441      P:00059C P:00059C 200055            CMP     Y0,A
2442      P:00059D P:00059D 0EA090            JEQ     <FINISH1                          ; Is it Time1?
2443      P:00059E P:00059E 270000            MOVE              #ISVNREV,Y1
2444      P:00059F P:00059F 46F400            MOVE              #>GET_SVNREV,Y0
                            000004
2445      P:0005A1 P:0005A1 200055            CMP     Y0,A
2446      P:0005A2 P:0005A2 0EA090            JEQ     <FINISH1                          ; Is it Svn rev?
2447      P:0005A3 P:0005A3 47F400            MOVE              #TIMCAPABLE,Y1
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timCCDmisc.s  Page 45



                            0001FB
2448      P:0005A5 P:0005A5 46F400            MOVE              #>GET_CAPABLE,Y0
                            000100
2449      P:0005A7 P:0005A7 200055            CMP     Y0,A
2450      P:0005A8 P:0005A8 0EA090            JEQ     <FINISH1                          ; Is it Tim Capabilities?
2451      P:0005A9 P:0005A9 47F400            MOVE              #INT_TIM,Y1
                            040000
2452      P:0005AB P:0005AB 46F400            MOVE              #>GET_INT_TIM,Y0
                            000101
2453      P:0005AD P:0005AD 200055            CMP     Y0,A
2454      P:0005AE P:0005AE 0EA090            JEQ     <FINISH1                          ; Is it Integration time?
2455      P:0005AF P:0005AF 47F400            MOVE              #R_DELAY,Y1
                            000000
2456      P:0005B1 P:0005B1 46F400            MOVE              #>GET_R_DELAY,Y0
                            000102
2457      P:0005B3 P:0005B3 200055            CMP     Y0,A
2458      P:0005B4 P:0005B4 0EA090            JEQ     <FINISH1                          ; Is it Serial time?
2459      P:0005B5 P:0005B5 47F400            MOVE              #SI_DELAY,Y1
                            8C0000
2460      P:0005B7 P:0005B7 46F400            MOVE              #>GET_SI_DELAY,Y0
                            000103
2461      P:0005B9 P:0005B9 200055            CMP     Y0,A
2462      P:0005BA P:0005BA 0EA090            JEQ     <FINISH1                          ; Is it Parallel time?
2463   
2464      P:0005BB P:0005BB 46F400            MOVE              #>GET_TEMP2STS,Y0       ; Is it 2 bit temp status
                            000005
2465      P:0005BD P:0005BD 200055            CMP     Y0,A
2466      P:0005BE P:0005BE 0E208D            JNE     <ERROR
2467      P:0005BF P:0005BF 200013            CLR     A
2468      P:0005C0 P:0005C0 0A89A5            JSET    #STS1,X:HDR,GET_STS0
                            0005C3
2469      P:0005C2 P:0005C2 014280            ADD     #<2,A
2470                                GET_STS0
2471      P:0005C3 P:0005C3 0A89A4            JSET    #STS0,X:HDR,RES_TEMPS
                            0005C6
2472      P:0005C5 P:0005C5 014180            ADD     #<1,A
2473                                RES_TEMPS
2474      P:0005C6 P:0005C6 000000            NOP
2475      P:0005C7 P:0005C7 218700            MOVE              A1,Y1
2476      P:0005C8 P:0005C8 0C0090            JMP     <FINISH1
2477   
2478   
2479                                ; Set software to IDLE mode
2480      P:0005C9 P:0005C9 44F400  IDL       MOVE              #IDLE,X0                ; Exercise clocks when idling
                            000309
2481      P:0005CB P:0005CB 441F00            MOVE              X0,X:<IDL_ADR
2482      P:0005CC P:0005CC 0A0022            BSET    #IDLMODE,X:<STATUS                ; Idle after readout
2483      P:0005CD P:0005CD 0C008F            JMP     <FINISH                           ; Need to send header and 'DON'
2484   
2485                                ; Come to here on a 'STP' command so 'DON' can be sent
2486                                ; Remove for gen-iii since it is in timboot as per June 30 #9
2487                                ;STP     MOVE   #TST_RCV,X0             ; Wait for commands during exposure
2488                                ;       MOVE    X0,X:<IDL_ADR           ;  instead of exercising clocks
2489                                ;       BCLR    #IDLMODE,X:<STATUS      ; Don't idle after readout
2490                                ;       JMP     <FINISH
2491   
2492                                ; Let the host computer read the controller configuration
2493                                ;       Correct FINISH1 datum as per "Four Points" #1
2494                                READ_CONTROLLER_CONFIGURATION
2495      P:0005CE P:0005CE 4F8A00            MOVE                          Y:<CONFIG,Y1 ; Just transmit the configuration
2496      P:0005CF P:0005CF 0C0090            JMP     <FINISH1
2497   
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timCCDmisc.s  Page 46



2498                                ; Power off
2499      P:0005D0 P:0005D0 0D0624  PWR_OFF   JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
2500      P:0005D1 P:0005D1 0A8922            BSET    #LVEN,X:HDR
2501      P:0005D2 P:0005D2 0A8923            BSET    #HVEN,X:HDR
2502      P:0005D3 P:0005D3 0C008F            JMP     <FINISH
2503   
2504                                ; Start power-on cycle
2505                                PWR_ON
2506      P:0005D4 P:0005D4 0D0624            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
2507      P:0005D5 P:0005D5 0D05E6            JSR     <PON                              ; Turn on the power control board
2508      P:0005D6 P:0005D6 0A8980            JCLR    #PWROK,X:HDR,PWR_ERR              ; Test if the power turned on properly
                            0005E3
2509      P:0005D8 P:0005D8 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                            000100
2510      P:0005DA P:0005DA 0D060E            JSR     <SET_BIASES                       ; Turn on the DC bias supplies
2511      P:0005DB P:0005DB 60F400            MOVE              #IDLE,R0                ; Put controller in IDLE state
                            000309
2512      P:0005DD P:0005DD 601F00            MOVE              R0,X:<IDL_ADR
2513                                ;       MOVE    #$41064,X0
2514                                ;       as per Confluence July 4 #5
2515      P:0005DE P:0005DE 312400            MOVE              #$24,R1
2516      P:0005DF P:0005DF 610000            MOVE              R1,X:<STATUS
2517                                ;       as per Confluence July 4 #4 and July 22 note
2518      P:0005E0 P:0005E0 4CBD00            MOVE                          Y:<AMPVAL,X0
2519      P:0005E1 P:0005E1 0D032D            JSR     <SELECT_OUTPUT_SOURCE
2520      P:0005E2 P:0005E2 0C008F            JMP     <FINISH
2521   
2522                                ; The power failed to turn on because of an error on the power control board
2523      P:0005E3 P:0005E3 0A8922  PWR_ERR   BSET    #LVEN,X:HDR                       ; Turn off the low voltage emable line
2524      P:0005E4 P:0005E4 0A8923            BSET    #HVEN,X:HDR                       ; Turn off the high voltage emable line
2525      P:0005E5 P:0005E5 0C008D            JMP     <ERROR
2526   
2527                                ; As a subroutine, turn on the low voltages (+/- 6.5V, +/- 16.5V) and delay
2528      P:0005E6 P:0005E6 0A8902  PON       BCLR    #LVEN,X:HDR                       ; Set these signals to DSP outputs
2529      P:0005E7 P:0005E7 44F400            MOVE              #2000000,X0
                            1E8480
2530      P:0005E9 P:0005E9 06C400            DO      X0,*+3                            ; Wait 20 millisec for settling
                            0005EB
2531      P:0005EB P:0005EB 000000            NOP
2532   
2533                                ; Turn on the high +36 volt power line and then delay
2534      P:0005EC P:0005EC 0A8903            BCLR    #HVEN,X:HDR                       ; HVEN = Low => Turn on +36V
2535      P:0005ED P:0005ED 44F400            MOVE              #2000000,X0
                            1E8480
2536      P:0005EF P:0005EF 06C400            DO      X0,*+3                            ; Wait 20 millisec for settling
                            0005F1
2537      P:0005F1 P:0005F1 000000            NOP
2538      P:0005F2 P:0005F2 00000C            RTS
2539   
2540                                ;prototype code- to set leds on gwaves
2541                                SETVRDS
2542      P:0005F3 P:0005F3 44DB00            MOVE              X:(R3)+,X0
2543      P:0005F4 P:0005F4 200013            CLR     A
2544      P:0005F5 P:0005F5 208E00            MOVE              X0,A
2545      P:0005F6 P:0005F6 0140C6            AND     #$3FFF,A
                            003FFF
2546      P:0005F8 P:0005F8 0140C0            ADD     #VID0+DAC_RegD,A
                            0FC000
2547      P:0005FA P:0005FA 44DB00            MOVE              X:(R3)+,X0
2548      P:0005FB P:0005FB 5C7000            MOVE                          A1,Y:VRD2_V
                            0002DD
2549      P:0005FD P:0005FD 208E00            MOVE              X0,A
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timCCDmisc.s  Page 47



2550      P:0005FE P:0005FE 0140C6            AND     #$3FFF,A
                            003FFF
2551      P:000600 P:000600 0140C0            ADD     #VID0+DAC_RegD,A
                            0FC000
2552      P:000602 P:000602 60F400            MOVE              #SET_VRD2_3,R0
                            0002DB
2553      P:000604 P:000604 5C7000            MOVE                          A1,Y:VRD3_V
                            0002DF
2554      P:000606 P:000606 0D060E            JSR     <SET_BIASES
2555      P:000607 P:000607 0C008F            JMP     <FINISH
2556   
2557                                SETBIAS
2558      P:000608 P:000608 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                            000100
2559      P:00060A P:00060A 0D060E            JSR     <SET_BIASES
2560      P:00060B P:00060B 0C008F            JMP     <FINISH
2561   
2562                                ; Set all the DC bias voltages and video processor offset values, reading
2563      P:00060C P:00060C 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                            000100
2564                                ;   them from the 'DACS' table
2565                                SET_BIASES
2566                                          SER_ANA
2568      P:00060F P:00060F 0A0F01            BCLR    #1,X:<LATCH                       ; Separate updates of clock driver
2569      P:000610 P:000610 0A0F20            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
2570      P:000611 P:000611 0A0F22            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
2571      P:000612 P:000612 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                            00000F
2572      P:000614 P:000614 0D0552            JSR     <PAL_DLY                          ; Delay for all this to happen
2573   
2574                                ; Read DAC values from a table, and write them to the DACs
2575      P:000615 P:000615 000000            NOP
2576      P:000616 P:000616 065840            DO      Y:(R0)+,L_DAC                     ; Repeat Y:(R0)+ times
                            00061A
2577      P:000618 P:000618 5ED800            MOVE                          Y:(R0)+,A   ; Read the table entry
2578      P:000619 P:000619 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
2579      P:00061A P:00061A 000000            NOP
2580                                L_DAC
2581   
2582                                ; Let the DAC voltages all ramp up before exiting
2583      P:00061B P:00061B 44F400            MOVE              #400000,X0
                            061A80
2584      P:00061D P:00061D 06C400            DO      X0,*+3                            ; 4 millisec delay
                            00061F
2585      P:00061F P:00061F 000000            NOP
2586                                          SER_UTL
2588      P:000621 P:000621 00000C            RTS
2589   
2590                                ; Enable serial communication to the analog boards
2591                                ; This becomes a single line macro above, as per June 30 #12
2592   
2593                                ;SER_ANA        BSET    #0,X:PBD                ; Set H0 for analog boards SSI
2594                                ;       MOVEP   #$0000,X:PCC            ; Software reset of SSI
2595                                ;       BCLR    #10,X:CRB               ; SSI -> continuous clock for analog
2596                                ;       MOVEP   #$0160,X:PCC            ; Re-enable the SSI
2597                                ;       RTS
2598   
2599                                ; Enable serial communication to the utility board
2600                                ; This becomes a single line macro above, as per June 30 #12
2601   
2602                                ;SER_UTL        MOVEP   #$0000,X:PCC            ; Software reset of SSI
2603                                ;       BSET    #10,X:CRB               ; SSI -> gated clock for util board
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timCCDmisc.s  Page 48



2604                                ;       MOVEP   #$0160,X:PCC            ; Enable the SSI
2605                                ;       BCLR    #0,X:PBD                ; Clear H0 for utility board SSI
2606                                ;       RTS
2607   
2608      P:000622 P:000622 0D0624  CLR_SWS   JSR     <CLEAR_SWITCHES
2609      P:000623 P:000623 0C008F            JMP     <FINISH
2610   
2611                                ; Clear all video processor analog switches to lower their power dissipation
2612                                CLEAR_SWITCHES
2613                                          SER_ANA
2615      P:000625 P:000625 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                            0C3000
2616      P:000627 P:000627 20001B            CLR     B
2617      P:000628 P:000628 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC write
s
2618      P:000629 P:000629 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writ
es
                            001000
2619      P:00062B P:00062B 060F80            DO      #15,L_VIDEO                       ; Fifteen video processor boards maximum
                            000632
2620      P:00062D P:00062D 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
2621      P:00062E P:00062E 200040            ADD     X0,A
2622      P:00062F P:00062F 5F7000            MOVE                          B,Y:WRSS
                            FFFFF3
2623      P:000631 P:000631 0D0552            JSR     <PAL_DLY                          ; Delay for the serial data transmission
2624      P:000632 P:000632 200068            ADD     X1,B
2625                                L_VIDEO
2626      P:000633 P:000633 0A0F00            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
2627      P:000634 P:000634 0A0F02            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
2628      P:000635 P:000635 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                            00000F
2629                                          SER_UTL
2631      P:000638 P:000638 00000C            RTS
2632   
2633                                ; Specify the MUX value to be output on the clock driver board
2634                                ; This is copied in from the NIHTS DSP per correspondence with Bob Leach in
2635                                ; early November 2015. The most important change is in the 5th line where the
2636                                ; bits to select the mux used to be $0030000 and are now $001000.
2637                                ; Command syntax is  SMX  #clock_driver_board #MUX1 #MUX2
2638                                ;                               #clock_driver_board from 0 to 15
2639                                ;                               #MUX1, #MUX2 from 0 to 23
2640   
2641                                SET_MUX
2642      P:000639 P:000639 012F23            BSET    #3,X:PCRD                         ; Turn on the serial clock
2643      P:00063A P:00063A 56DB00            MOVE              X:(R3)+,A               ; Clock driver board number
2644      P:00063B P:00063B 0614A0            REP     #20
2645      P:00063C P:00063C 200033            LSL     A
2646      P:00063D P:00063D 44F400            MOVE              #$001000,X0             ; Bits to select MUX on ARC32 board
                            001000
2647      P:00063F P:00063F 200042            OR      X0,A
2648      P:000640 P:000640 000000            NOP
2649      P:000641 P:000641 218500            MOVE              A1,X1                   ; Move here for later use
2650   
2651                                ; Get the first MUX number
2652      P:000642 P:000642 56DB00            MOVE              X:(R3)+,A               ; Get the first MUX number
2653      P:000643 P:000643 200003            TST     A
2654      P:000644 P:000644 0E9689            JLT     <ERR_SM1
2655      P:000645 P:000645 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                            000018
2656      P:000647 P:000647 200045            CMP     X0,A
2657      P:000648 P:000648 0E1689            JGE     <ERR_SM1
2658      P:000649 P:000649 21CF00            MOVE              A,B
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timCCDmisc.s  Page 49



2659      P:00064A P:00064A 44F400            MOVE              #>7,X0
                            000007
2660      P:00064C P:00064C 20004E            AND     X0,B
2661      P:00064D P:00064D 44F400            MOVE              #>$18,X0
                            000018
2662      P:00064F P:00064F 200046            AND     X0,A
2663      P:000650 P:000650 0E2653            JNE     <SMX_1                            ; Test for 0 <= MUX number <= 7
2664      P:000651 P:000651 0ACD63            BSET    #3,B1
2665      P:000652 P:000652 0C065E            JMP     <SMX_A
2666      P:000653 P:000653 44F400  SMX_1     MOVE              #>$08,X0
                            000008
2667      P:000655 P:000655 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
2668      P:000656 P:000656 0E2659            JNE     <SMX_2
2669      P:000657 P:000657 0ACD64            BSET    #4,B1
2670      P:000658 P:000658 0C065E            JMP     <SMX_A
2671      P:000659 P:000659 44F400  SMX_2     MOVE              #>$10,X0
                            000010
2672      P:00065B P:00065B 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
2673      P:00065C P:00065C 0E2689            JNE     <ERR_SM1
2674      P:00065D P:00065D 0ACD65            BSET    #5,B1
2675      P:00065E P:00065E 20006A  SMX_A     OR      X1,B1                             ; Add prefix to MUX numbers
2676      P:00065F P:00065F 000000            NOP
2677      P:000660 P:000660 21A700            MOVE              B1,Y1
2678   
2679                                ; Add on the second MUX number
2680      P:000661 P:000661 56DB00            MOVE              X:(R3)+,A               ; Get the next MUX number
2681      P:000662 P:000662 200003            TST     A
2682      P:000663 P:000663 0E968A            JLT     <ERR_SM2
2683      P:000664 P:000664 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                            000018
2684      P:000666 P:000666 200045            CMP     X0,A
2685      P:000667 P:000667 0E168A            JGE     <ERR_SM2
2686      P:000668 P:000668 0606A0            REP     #6
2687      P:000669 P:000669 200033            LSL     A
2688      P:00066A P:00066A 000000            NOP
2689      P:00066B P:00066B 21CF00            MOVE              A,B
2690      P:00066C P:00066C 44F400            MOVE              #$1C0,X0
                            0001C0
2691      P:00066E P:00066E 20004E            AND     X0,B
2692      P:00066F P:00066F 44F400            MOVE              #>$600,X0
                            000600
2693      P:000671 P:000671 200046            AND     X0,A
2694      P:000672 P:000672 0E2675            JNE     <SMX_3                            ; Test for 0 <= MUX number <= 7
2695      P:000673 P:000673 0ACD69            BSET    #9,B1
2696      P:000674 P:000674 0C0680            JMP     <SMX_B
2697      P:000675 P:000675 44F400  SMX_3     MOVE              #>$200,X0
                            000200
2698      P:000677 P:000677 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
2699      P:000678 P:000678 0E267B            JNE     <SMX_4
2700      P:000679 P:000679 0ACD6A            BSET    #10,B1
2701      P:00067A P:00067A 0C0680            JMP     <SMX_B
2702      P:00067B P:00067B 44F400  SMX_4     MOVE              #>$400,X0
                            000400
2703      P:00067D P:00067D 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
2704      P:00067E P:00067E 0E268A            JNE     <ERR_SM2
2705      P:00067F P:00067F 0ACD6B            BSET    #11,B1
2706      P:000680 P:000680 200078  SMX_B     ADD     Y1,B                              ; Add prefix to MUX numbers
2707      P:000681 P:000681 000000            NOP
2708      P:000682 P:000682 21AE00            MOVE              B1,A
2709      P:000683 P:000683 0140C6            AND     #$F01FFF,A                        ; Just to be sure
                            F01FFF
2710      P:000685 P:000685 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timCCDmisc.s  Page 50



2711      P:000686 P:000686 0D0552            JSR     <PAL_DLY                          ; Delay for all this to happen
2712      P:000687 P:000687 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
2713      P:000688 P:000688 0C008F            JMP     <FINISH
2714      P:000689 P:000689 56DB00  ERR_SM1   MOVE              X:(R3)+,A               ; Throw off the last argument
2715      P:00068A P:00068A 012F03  ERR_SM2   BCLR    #3,X:PCRD                         ; Turn the serial clock off
2716      P:00068B P:00068B 0C008D            JMP     <ERROR
2717   
2718                                ; Set the video processor gain and integrator speed for all video boards
2719                                ;  Command syntax is  SGN  #GAIN  #SPEED, #GAIN = 1, 2, 5 or 10
2720                                ;                                         #SPEED = 0 for slow, 1 for fast
2721                                ;       Correct command ptr to R3 as per "Four Points" #2
2722                                ;  fixes to match gen-iii as per June 30, #15
2723                                ST_GAIN
2724                                ;       SER_ANA ; Set SSI to analog board communication
2725      P:00068C P:00068C 56DB00            MOVE              X:(R3)+,A               ; Gain value (1,2,5 or 10)
2726                                ; making this a no-op for now
2727      P:00068D P:00068D 56DB00            MOVE              X:(R3)+,A               ; Gain value (1,2,5 or 10)
2728      P:00068E P:00068E 0C008F            JMP     <FINISH
2729      P:00068F P:00068F 44F400            MOVE              #>1,X0
                            000001
2730      P:000691 P:000691 200045            CMP     X0,A                              ; Check for gain = x1
2731      P:000692 P:000692 0E2696            JNE     <STG2
2732      P:000693 P:000693 57F400            MOVE              #>$77,B
                            000077
2733      P:000695 P:000695 0C06AA            JMP     <STG_A
2734      P:000696 P:000696 44F400  STG2      MOVE              #>2,X0                  ; Check for gain = x2
                            000002
2735      P:000698 P:000698 200045            CMP     X0,A
2736      P:000699 P:000699 0E269D            JNE     <STG5
2737      P:00069A P:00069A 57F400            MOVE              #>$BB,B
                            0000BB
2738      P:00069C P:00069C 0C06AA            JMP     <STG_A
2739      P:00069D P:00069D 44F400  STG5      MOVE              #>5,X0                  ; Check for gain = x5
                            000005
2740      P:00069F P:00069F 200045            CMP     X0,A
2741      P:0006A0 P:0006A0 0E26A4            JNE     <STG10
2742      P:0006A1 P:0006A1 57F400            MOVE              #>$DD,B
                            0000DD
2743      P:0006A3 P:0006A3 0C06AA            JMP     <STG_A
2744      P:0006A4 P:0006A4 44F400  STG10     MOVE              #>10,X0                 ; Check for gain = x10
                            00000A
2745      P:0006A6 P:0006A6 200045            CMP     X0,A
2746      P:0006A7 P:0006A7 0E208D            JNE     <ERROR
2747      P:0006A8 P:0006A8 57F400            MOVE              #>$EE,B
                            0000EE
2748   
2749      P:0006AA P:0006AA 56DB00  STG_A     MOVE              X:(R3)+,A               ; Integrator Speed (0 for slow, 1 for fast)
2750      P:0006AB P:0006AB 000000            NOP
2751      P:0006AC P:0006AC 0ACC00            JCLR    #0,A1,STG_B
                            0006B1
2752      P:0006AE P:0006AE 0ACD68            BSET    #8,B1
2753      P:0006AF P:0006AF 000000            NOP
2754      P:0006B0 P:0006B0 0ACD69            BSET    #9,B1
2755      P:0006B1 P:0006B1 44F400  STG_B     MOVE              #$0C3C00,X0
                            0C3C00
2756      P:0006B3 P:0006B3 20004A            OR      X0,B
2757      P:0006B4 P:0006B4 000000            NOP
2758      P:0006B5 P:0006B5 5F0000            MOVE                          B,Y:<GAIN   ; Store the GAIN value for later us
2759   
2760                                ; Send this same value to 15 video processor boards whether they exist or not
2761      P:0006B6 P:0006B6 241000            MOVE              #$100000,X0             ; Increment value
2762      P:0006B7 P:0006B7 060F80            DO      #15,STG_LOOP
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timCCDmisc.s  Page 51



                            0006BD
2763      P:0006B9 P:0006B9 21AC00            MOVE              B1,A1
2764      P:0006BA P:0006BA 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
2765   
2766                                ;       MOVE    B,X:SSITX       ; Transmit the SSI word
2767      P:0006BB P:0006BB 0D0552            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
2768      P:0006BC P:0006BC 200048            ADD     X0,B                              ; Increment the video processor board number
2769      P:0006BD P:0006BD 000000            NOP
2770                                STG_LOOP
2771   
2772                                          SER_UTL                                   ; Return SSI to utility board communication
2774      P:0006BF P:0006BF 0C008F            JMP     <FINISH
2775                                ; Remove cruft as per June 30 #16
2776                                ;ERR_SGN        MOVE    X:(R4)+,A
2777                                ;       JSR     <SER_UTL        ; Return SSI to utility board communication
2778                                ;       JMP     <ERROR
2779   
2780                                ; Write an arbitrary control word over the SSI link to any register, any board
2781                                ; Command syntax is  WRC number, number is 24-bit number to be sent to any board
2782                                ;WR_CNTRL
2783                                ;       JSR     <SER_ANA        ; Set SSI to analog board communication
2784                                ;       JSR     <PAL_DLY        ; Wait for the number to be sent
2785                                ;        MOVEP  X:(R4)+,X:SSITX ; Send out the waveform
2786                                ;       JSR     <PAL_DLY        ; Wait for SSI and PAL to be empty
2787                                ;       JSR     <SER_UTL        ; Return SSI to utility board communication
2788                                ;       JMP     <FINISH
2789   
2790   
2791   
2792                                ; Specify subarray readout coordinates, one rectangle only
2793                                ; Call this subroutine BEFORE SET_SUBARRAY_POSITIONS since it
2794                                ; initializes NBOXES
2795                                ;       Correct command ptr to R3 as per "Four Points" #2
2796                                SET_SUBARRAY_SIZES
2797      P:0006C0 P:0006C0 200013            CLR     A
2798      P:0006C1 P:0006C1 44DB00            MOVE              X:(R3)+,X0
2799      P:0006C2 P:0006C2 5E1900            MOVE                          A,Y:<NBOXES ; Number of subimage boxes = 0 to start
2800      P:0006C3 P:0006C3 4C1A00            MOVE                          X0,Y:<NR_BIAS ; Number of bias pixels to read
2801      P:0006C4 P:0006C4 44DB00            MOVE              X:(R3)+,X0
2802      P:0006C5 P:0006C5 4C1B00            MOVE                          X0,Y:<NS_READ ; Number of columns in subimage read
2803      P:0006C6 P:0006C6 44DB00            MOVE              X:(R3)+,X0
2804      P:0006C7 P:0006C7 4C1C00            MOVE                          X0,Y:<NP_READ ; Number of rows in subimage read
2805      P:0006C8 P:0006C8 0C008F            JMP     <FINISH
2806   
2807                                ; Call this routine once for every subarray to be added to the table
2808                                ; Note that the way the variables are arranged the subframes all are the
2809                                ; same dimensions.  They also cannot overlap in the row direction.
2810                                ; SET_SUBARRAY_SIZES must be called first to initialize NBOXES
2811                                SET_SUBARRAY_POSITIONS
2812      P:0006C9 P:0006C9 4C9900            MOVE                          Y:<NBOXES,X0 ; Next available slot
2813      P:0006CA P:0006CA 459400            MOVE              X:<THREE,X1
2814      P:0006CB P:0006CB 2000A0            MPY     X0,X1,A
2815      P:0006CC P:0006CC 200022            ASR     A
2816      P:0006CD P:0006CD 210C00            MOVE              A0,A1
2817      P:0006CE P:0006CE 44F400            MOVE              #>24,X0
                            000018
2818      P:0006D0 P:0006D0 200045            CMP     X0,A
2819      P:0006D1 P:0006D1 0E708D            JGT     <ERROR                            ; Error if number of boxes > 9
2820      P:0006D2 P:0006D2 44F400            MOVE              #READ_TABLE,X0
                            00001D
2821      P:0006D4 P:0006D4 200040            ADD     X0,A
2822      P:0006D5 P:0006D5 44DB00            MOVE              X:(R3)+,X0
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  timCCDmisc.s  Page 52



2823      P:0006D6 P:0006D6 219700            MOVE              A1,R7
2824      P:0006D7 P:0006D7 000000            NOP
2825      P:0006D8 P:0006D8 000000            NOP
2826      P:0006D9 P:0006D9 000000            NOP
2827      P:0006DA P:0006DA 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of rows (parallels) to clear
2828      P:0006DB P:0006DB 44DB00            MOVE              X:(R3)+,X0
2829      P:0006DC P:0006DC 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears before
2830      P:0006DD P:0006DD 44DB00            MOVE              X:(R3)+,X0              ;  the box readout
2831      P:0006DE P:0006DE 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears after
2832      P:0006DF P:0006DF 5E9900            MOVE                          Y:<NBOXES,A ;  the box readout
2833      P:0006E0 P:0006E0 449200            MOVE              X:<ONE,X0
2834      P:0006E1 P:0006E1 200040            ADD     X0,A                              ; Update the next available slot position
2835      P:0006E2 P:0006E2 000000            NOP
2836      P:0006E3 P:0006E3 5E1900            MOVE                          A,Y:<NBOXES
2837      P:0006E4 P:0006E4 0C008F            JMP     <FINISH
2838   
2839                                ; Alert the PCI interface board that images are coming soon
2840                                ; This tells the PCI card how many pixels to expect for each SEX command
2841                                ; This is fairly complex.  The first value sent is NSR*NPR (NAXIS1*NAXIS2).
2842                                ; The second value is IFRAMES, but if NBOXES > 0, it is IFRAMES*NBOXES
2843                                ; Correct XMT_FO to XMT_WRD in timboot.s and change the input arg to B1
2844                                ; as per "Four Points" #3
2845                                PCI_READ_IMAGE
2846      P:0006E5 P:0006E5 55F400            MOVE              #$020104,B1             ; Send header word to the FO transmitter
                            020104
2847      P:0006E7 P:0006E7 0D00EB            JSR     <XMT_WRD
2848      P:0006E8 P:0006E8 55F400            MOVE              #'RDA',B1
                            524441
2849      P:0006EA P:0006EA 0D00EB            JSR     <XMT_WRD
2850      P:0006EB P:0006EB 4CF000            MOVE                          Y:NSR,X0    ; NSR = NAXIS1
                            000001
2851      P:0006ED P:0006ED 4DF000            MOVE                          Y:NPR,X1    ; NPR = NAXIS2
                            000002
2852      P:0006EF P:0006EF 2000A8            MPY     X0,X1,B
2853      P:0006F0 P:0006F0 20002A            ASR     B                                 ; Correct for multiplication left shift
2854      P:0006F1 P:0006F1 212D00            MOVE              B0,B1
2855      P:0006F2 P:0006F2 0D00EB            JSR     <XMT_WRD                          ; Send NSR*NPR to PCI card
2856      P:0006F3 P:0006F3 4CF000            MOVE                          Y:IFRAMES,X0 ; IFRAMES = NAXIS3
                            00003A
2857      P:0006F5 P:0006F5 5E9900            MOVE                          Y:<NBOXES,A ; If NBOXES = 0, transmit that to PCI
2858      P:0006F6 P:0006F6 208D00            MOVE              X0,B1
2859      P:0006F7 P:0006F7 200003            TST     A
2860      P:0006F8 P:0006F8 0AF0AA            JEQ     XMT
                            0006FE
2861      P:0006FA P:0006FA 4D9900            MOVE                          Y:<NBOXES,X1 ; If NBOXES = 0, transmit that to PCI
2862      P:0006FB P:0006FB 2000A8            MPY     X0,X1,B                           ; If not, multiply by NBOXES, then send
2863      P:0006FC P:0006FC 20002A            ASR     B                                 ; Correct for multiplication left shift
2864      P:0006FD P:0006FD 212D00            MOVE              B0,B1                   ; Get only least significant 24 bits
2865      P:0006FE P:0006FE 000000  XMT       NOP
2866      P:0006FF P:0006FF 0D00EB            JSR     <XMT_WRD
2867      P:000700 P:000700 00000C            RTS
2868                                ; superfluous- June 30 #20
2869                                ;XMT_FO MOVEP   X0,Y:WRFO
2870                                ;       REP     #15
2871                                ;       NOP
2872                                ;       RTS
2873   
2874                                 TIMBOOT_X_MEMORY
2875      000701                              EQU     @LCV(L)
2876   
2877                                ;  ****************  Setup memory tables in X: space ********************
2878   
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  tim.s  Page 53



2879                                ; Define the address in P: space where the table of constants begins
2880   
2881                                          IF      @SCP("HOST","HOST")
2882      X:000036 X:000036                   ORG     X:END_COMMAND_TABLE,X:END_COMMAND_TABLE
2883                                          ENDIF
2884   
2885                                          IF      @SCP("HOST","ROM")
2887                                          ENDIF
2888   
2889      X:000036 X:000036                   DC      'IDL',IDL                         ; Put CCD in IDLE mode
2890                                ; Remove for gen-iii since it is in timboot as per June 30 #9
2891                                ;       DC      'STP',STP               ; Exit IDLE mode
2892      X:000038 X:000038                   DC      'SVR',SETVRDS                     ; set VRD2,3
2893      X:00003A X:00003A                   DC      'SBV',SETBIAS                     ; Set DC bias supply voltages
2894      X:00003C X:00003C                   DC      'RDC',RDCCD                       ; Begin CCD readout
2895      X:00003E X:00003E                   DC      'CLR',CLEAR                       ; Fast clear the CCD
2896      X:000040 X:000040                   DC      'SGN',ST_GAIN                     ; Set video processor gain
2897      X:000042 X:000042                   DC      'SMX',SET_MUX                     ; Set clock driver MUX output
2898   
2899      X:000044 X:000044                   DC      'ABR',ABR_RDC                     ; Abort readout
2900      X:000046 X:000046                   DC      'CRD',CONT_RD                     ; Continue reading out
2901      X:000048 X:000048                   DC      'CSW',CLR_SWS                     ; Clear analog switches to lower power
2902      X:00004A X:00004A                   DC      'SOS',SEL_OS                      ; Select output source
2903      X:00004C X:00004C                   DC      'RCC',READ_CONTROLLER_CONFIGURATION
2904      X:00004E X:00004E                   DC      'SSS',SET_SUBARRAY_SIZES
2905      X:000050 X:000050                   DC      'SSP',SET_SUBARRAY_POSITIONS
2906      X:000052 X:000052                   DC      'DON',START                       ; Nothing special
2907      X:000054 X:000054                   DC      'OSH',OPEN_SHUTTER
2908      X:000056 X:000056                   DC      'CSH',CLOSE_SHUTTER
2909      X:000058 X:000058                   DC      'PON',PWR_ON                      ; Turn on all camera biases and clocks
2910      X:00005A X:00005A                   DC      'POF',PWR_OFF                     ; Turn +/- 15V power supplies off
2911      X:00005C X:00005C                   DC      'SET',SET_EXP_TIME                ; Set exposure time
2912      X:00005E X:00005E                   DC      'SEX',START_FT_EXPOSURE           ; Goes to mode-dependent jump table
2913      X:000060 X:000060                   DC      'AEX',ABORT_EXPOSURE
2914      X:000062 X:000062                   DC      'STG',SET_TRIGGER                 ;  Set Trigger Mode on or off
2915      X:000064 X:000064                   DC      'SIP',SET_IMAGE_PARAM
2916      X:000066 X:000066                   DC      'SRC',SET_ROWS_COLUMNS            ; Set NSR, NPR, and binning
2917      X:000068 X:000068                   DC      'INF',GET_INFO                    ; info command for versioning and more
2918   
2919                                 END_APPLICATON_COMMAND_TABLE
2920      00006A                              EQU     @LCV(L)
2921   
2922                                          IF      @SCP("HOST","HOST")
2923      000021                    NUM_COM   EQU     (@LCV(R)-COM_TBL_R)/2             ; No. of boot & application commands
2924                                ;EXPOSING                EQU     CHK_TIM                 ; Address if exposing
2925                                ;CONTINUE_READING        EQU     RDCCD                   ; Address if reading out
2926                                          ENDIF
2927   
2928                                ; ***********  DATA AREAS - READOUT PARAMETERS AND WAVEFORMS  ************
2929                                          IF      @SCP("HOST","HOST")
2930      X:000080 X:000080                   ORG     X:IMGVAR_ADR,X:IMGVAR_ADR
2931      X:000080 X:000080         IMAGE_MODE DC     0
2932                                ; ISTATUS                       DC              0
2933                                ; bum an unused location in low X: for ISTATUS so JSETs work
2934                                ; as per Confluence July 5 #3
2935      000020                    ISTATUS   EQU     EXP_ADR                           ; dangerous!
2936   
2937                                ; some X: variables removed as per Confluence July 1 #4
2938                                ;DSP_VERS       DC      VERSION ; code version must stay in loc,n 102!!
2939                                ;DSP_FLAV       DC      FLAVOR ;  type of dsp support must stay in loc,n 103!!
2940                                ; The next three locations are for tracking the readout timing for gain
2941                                ; calculation, exp-int calculation, and greed factor calculation
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  tim.s  Page 54



2942                                ; They are locations 0x104, 105, and 106
2943                                ;INTTIM         DC      INT_TIM ; per-pixel integration in Leach units
2944                                ;RDELAY         DC      R_DELAY ; serial overlap in Leach units
2945                                ;SIDELAY                DC      SI_DELAY ; parallel overlap in Leach units
2946   
2947                                ;BINBIT         DC      2       ; Bit representation of bin factor, bits 1-5
2948                                                                                    ; 2 = bit 1 set. Bit zero not used.
2949                                ; bum a rarely used location in low X: for BINBIT so JSETs work
2950                                ; as per Confluence July 5 #5
2951      00001E                    BINBIT    EQU     C100K                             ; dangerous!
2952                                                                                    ; Bit representation of bin factor, bits 1-5
2953                                                                                    ; 2 = bit 1 set. Bit zero not used.
2954                                 END_APPLICATION_X_MEMORY
2955      000081                              EQU     @LCV(L)
2956                                          ENDIF
2957   
2958                                          IF      @SCP("HOST","HOST")
2959      Y:000000 Y:000000                   ORG     Y:0,Y:0                           ; Download address
2960                                          ELSE
2962                                          ENDIF
2963   
2964                                ; NSR, NPR, NSBIN, and NPBIN are set by SET_ROWS_COLUMNS
2965      Y:000000 Y:000000         GAIN      DC      0                                 ; Video processor gain and integrator speed
2966      Y:000001 Y:000001         NSR       DC      528                               ; Number Serial Read, prescan + image + bias
2967      Y:000002 Y:000002         NPR       DC      536                               ; Number Parallel Read
2968      Y:000003 Y:000003         NS_CLR    DC      1056                              ; To clear serial register, twice
2969      Y:000004 Y:000004         NPCLR     DC      1072                              ; To clear parallel register, twice
2970      Y:000005 Y:000005         NSBIN     DC      1                                 ; Serial binning parameter
2971      Y:000006 Y:000006         NPBIN     DC      1                                 ; Parallel binning parameter
2972      Y:000007 Y:000007         NROWS     DC      536                               ; Number of physical rows in CCD
2973      Y:000008 Y:000008         NCOLS     DC      528                               ; Number of physical columns in CCD
2974   
2975                                ; Miscellaneous definitions
2976                                ; Delete TST_DAT since it isn't used.  Need the space so S_SIZE doesn't barf.
2977                                ; TST_DAT       DC      0               ; Temporary definition for test images
2978      Y:000009 Y:000009         SH_DEL    DC      3                                 ; Delay in milliseconds between shutter clos
ing
2979                                                                                    ;   and image readout.  Actual delay is 1.5x
2980                                                                                    ;   as long as advertised, e.g. 4.5 ms for 3
.
2981      Y:00000A Y:00000A         CONFIG    DC      CC                                ; Controller configuration
2982                                ; Readout peculiarity parameters
2983                                 SERIAL_SKIP
2984      Y:00000B Y:00000B                   DC      SERIAL_SKIP_LEFT                  ; Serial skipping waveforms
2985      Y:00000C Y:00000C         SERWAVLEN DC      5                                 ; Serial read waveform table length
2986                                 SERIAL_CLOCK
2987      Y:00000D Y:00000D                   DC      SERIAL_CLOCK_LEFT                 ; Serial waveform table
2988                                 INITIAL_CLOCK
2989      Y:00000E Y:00000E                   DC      INITIAL_CLOCK_LEFT                ; Serial waveform table
2990                                 PARALLEL_CLOCK
2991      Y:00000F Y:00000F                   DC      IS_PARALLEL                       ; Addr. of parallel clocking
2992   
2993                                 NSERIALS_READ
2994      Y:000010 Y:000010                   DC      0                                 ; Number of serials to read
2995      Y:000011 Y:000011         NSCLR     DC      0                                 ; Number of waveforms in fast mode
2996      Y:000012 Y:000012         NSKIP1    DC      0                                 ; Number of waveforms in fast mode
2997      Y:000013 Y:000013         NREAD     DC      0                                 ; Number of waveforms in fast mode
2998      Y:000014 Y:000014         NSKIP2    DC      0                                 ; Number of waveforms in fast mode
2999      Y:000015 Y:000015         NBIAS     DC      0                                 ; Number of waveforms in fast mode
3000   
3001                                ; These three parameters are read from the READ_TABLE when needed by the
3002                                ;   RDCCD routine as it loops through the required number of boxes
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  tim.s  Page 55



3003      Y:000016 Y:000016         NP_SKIP   DC      0                                 ; Number of rows to skip
3004      Y:000017 Y:000017         NS_SKP1   DC      0                                 ; Number of serials to clear before read
3005      Y:000018 Y:000018         NS_SKP2   DC      0                                 ; Number of serials to clear after read
3006   
3007                                ; Subimage readout parameters. Ten subimage boxes maximum.
3008                                ; All subimage boxes are the same size, NS_READ x NP_READ
3009                                ; NR_BIAS, NS_READ, and NP_READ are set by SET_SUBARRAY_SIZES
3010                                ; The READ_TABLE entries and implicitly NBOXES are set by SET_SUBARRAY_POSITIONS
3011      Y:000019 Y:000019         NBOXES    DC      0                                 ; Number of boxes to read
3012      Y:00001A Y:00001A         NR_BIAS   DC      0                                 ; Number of bias pixels to read
3013      Y:00001B Y:00001B         NS_READ   DC      0                                 ; Number of columns per box
3014      Y:00001C Y:00001C         NP_READ   DC      0                                 ; Number of rows per box
3015      Y:00001D Y:00001D         READ_TABLE DC     0,0,0                             ; #1 = Number of rows to clear,
3016      Y:000020 Y:000020                   DC      0,0,0                             ; #2 = Number of columns to skip before
3017      Y:000023 Y:000023                   DC      0,0,0                             ;   subimage read
3018      Y:000026 Y:000026                   DC      0,0,0                             ; #3 = Number of columns to clear after
3019      Y:000029 Y:000029                   DC      0,0,0                             ;   subimage read to get to overscan area
3020      Y:00002C Y:00002C                   DC      0,0,0
3021      Y:00002F Y:00002F                   DC      0,0,0
3022      Y:000032 Y:000032                   DC      0,0,0
3023      Y:000035 Y:000035                   DC      0,0,0
3024   
3025                                ; IMAGE_MODE, SROWS, IFRAMES, and INTERVAL are set by SET_IMAGE_PARAM
3026                                ; UBSROWS is set later on by UB_CONV.  S_SIZE is hardwired.
3027      Y:000038 Y:000038         SROWS     DC      1                                 ; Number of Storage image rows to Loop over
3028      Y:000039 Y:000039         UBSROWS   DC      1                                 ; SROWS in unbinned pixels.  Set by UB_CONV
3029      Y:00003A Y:00003A         IFRAMES   DC      1                                 ; Number of Series frames to Loop over
3030      Y:00003B Y:00003B         S_SIZE    DC      528                               ; Number of rows in the Storage Array
3031                                                                                    ; NOTE: Not equal to # rows in image area!
3032      Y:00003C Y:00003C         INTERVAL  DC      7                                 ; Interval to pause for soft trigger
3033      Y:00003D Y:00003D         AMPVAL    DC      0                                 ; Amplifier selected
3034      Y:00003E Y:00003E         IFLPCNT   DC      0                                 ; 24-bit IFRAMES loop counter for timmisc.s
3035      Y:00003F Y:00003F         TESTLOC1  DC      0                                 ; Test location
3036                                ; NOTE:  TESTLOC1 is address 63 in the Y memory.  There are addressing problems
3037                                ; starting at the next address (64).
3038   
3039                                ; Include the waveform table
3040                                          IF      @SCP("IMO","IMO")
3041                                          INCLUDE "GWAVES.waveforms.IMO.s"          ; Readout and clocking waveforms
3042                                ; Waveform tables and definitions for the e2v CCD67 256 sq. frame 
3043                                ; transfer CCD for GWAVES.  This uses the ARC22 timing, ARC32 clock
3044                                ; driver and ARC47 4-channel video board.  
3045                                ;
3046                                ; This file is a modified version of the Gen II HIPO waveforms file.
3047                                ; 
3048   
3049                                ; CCD clock voltage definitions
3050      000000                    VIDEO     EQU     $000000                           ; Video processor board select = 0
3051      002000                    CLK2      EQU     $002000                           ; Clock driver board select = 2
3052      003000                    CLK3      EQU     $003000                           ; Clock driver board select = 3 
3053      200000                    CLKV      EQU     $200000                           ; Clock driver board DAC voltage selection a
ddress 
3054      000000                    VID0      EQU     $000000                           ; Address of video board DACS
3055      0E0000                    DAC_ADDR  EQU     $0E0000                           ; DAC Channel Address
3056      0F4000                    DAC_RegM  EQU     $0F4000                           ; DAC m Register
3057      0F8000                    DAC_RegC  EQU     $0F8000                           ; DAC c Register
3058      0FC000                    DAC_RegD  EQU     $0FC000                           ; DAC X1 Register
3059      1.300000E+001             Vmax      EQU     13.0                              ; Maximum clock driver voltage
3060      0.000000E+000             ZERO      EQU     0.0                               ; Unused pins
3061   
3062                                ; INT_TIM, controlled by Makefile def'n INTTIM_SETTING
3063                                ; as per Confluence July 1 end commentary
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 56



3064                                          IF      @SCP("04","04")
3065                                ; 04 setting, noted for its languid "04"-ness
3066      040000                    INT_TIM   EQU     $040000
3067                                          ENDIF
3068                                          IF      @SCP("04","02")
3071                                          ENDIF
3072                                          IF      @SCP("04","08")
3075                                          ENDIF
3076                                          IF      @SCP("04","0C")
3079                                          ENDIF
3080   
3081   
3082                                ;INT_TIM        EQU     $040000 ; 0.85 us/px - use gain 4.75, experimental
3083                                ;INT_TIM        EQU     $080000 ; 1.0 us/px - use gain 4.75, doesn't clip
3084                                ;INT_TIM        EQU     $080000 ; 1.0 us/px - use gain 9.5, clips @ PRAM
3085                                ;INT_TIM        EQU     $150000 ; 1.5 us/px - use gain 9.5, clips @ ADC
3086                                ;INT_TIM                EQU     $1D0000 ; 1.8 us/px - use gain 4.75, best overall
3087                                ;INT_TIM        EQU     $470000 ; 3.5 us/px - use gain 2, slower & quieter
3088                                ;INT_TIM        EQU     $920000 ; 6.5 us/px - use gain 1, slower & quieter
3089                                ;INT_TIM        EQU     $6D0000 ; 5.0 us/px - use gain 2 or 4.75, clips @ ADC
3090   
3091                                ;ADC_TIM                EQU     $0C0000 ; Slow ADC TIME
3092      000000                    ADC_TIM   EQU     $000000                           ; Fast ADC TIME
3093   
3094                                ; Delay numbers in clocking
3095   
3096                                ; SI_DELAY, controlled by Makefile def'n SIDELAY_SETTING
3097                                ; as per Confluence July 1 end commentary
3098                                          IF      @SCP("8C","86")
3101                                          ENDIF
3102                                          IF      @SCP("8C","8C")
3103                                ; 8C setting, noted for its languid "8C"-ness
3104      8C0000                    SI_DELAY  EQU     $8C0000                           ; Fast Storage/Image Delay
3105                                          ENDIF
3106                                          IF      @SCP("8C","92")
3109                                          ENDIF
3110                                          IF      @SCP("8C","9B")
3113                                          ENDIF
3114   
3115                                ;SI_DELAY       EQU     $C00000 ; Started with 0x36 Parallel clock delay
3116                                ;SI_DELAY       EQU     $860000 ; Fast Storage/Image Delay
3117                                ;SI_DELAY       EQU     $860000 ; Slower Storage/Image Delay
3118   
3119                                ; R_DELAY, controlled by Makefile def'n RDELAY_SETTING
3120                                ; as per Confluence July 1 end commentary
3121                                          IF      @SCP("00","00")
3122                                ; 00 setting, noted for its bustling "00"-ness
3123      000000                    R_DELAY   EQU     $000000                           ; Fast serial regisiter transfer delay
3124                                          ENDIF
3125   
3126                                ;R_DELAY                EQU     $080000 ; Serial register transfer delay
3127                                ;R_DELAY                EQU     $000000 ; Fast serial regisiter transfer delay
3128   
3129   
3130      000000                    SKIP_DELAY EQU    $000000                           ; Serial register skipping delay
3131   
3132   
3133                                ; bitwise symbols for integrator manipulation from LMI waveforms file.
3134                                ; Video processor bit definition
3135                                ;             6     5    4     3      2        1         0
3136                                ;            xfer, A/D, integ, Pol-, fixed 0, DCrestore, rst (1 => switch open)
3137                                ; for the ARC-47 1C (incl. all of gen-ii) it was
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 57



3138                                ;            xfer, A/D, integ, Pol+, Pol-,    DCrestore, rst (1 => switch open)
3139   
3140                                ; goes with VIDEO
3141      000078                    INT_INIT  EQU     %1111000                          ; Change nearly everything
3142                                ; goes with VIDEO
3143      00007B                    INT_RSTOFF EQU    %1111011                          ; Stop resetting integrator
3144                                ; goes with VIDEO and INT_TIM
3145      00000B                    INT_MINUS EQU     %0001011                          ; Integrate reset level
3146                                ; goes with VIDEO
3147      000013                    INT_STOP  EQU     %0010011                          ; Stop Integrate
3148                                ; goes with VIDEO and INT_TIM
3149      000003                    INT_PLUS  EQU     %0000011                          ; Integrate signal level
3150                                ; goes with VIDEO and ADC_TIM
3151      000013                    INT_SMPL  EQU     %0010011                          ; Stop integrate, A/D is sampling
3152                                ; goes with VIDEO
3153      000010                    INT_DCR   EQU     %0010000                          ; Reset integ. and DC restore
3154   
3155                                ; Clock voltages in volts 
3156      3.000000E+000             RG_HI     EQU     +3.0                              ; Reset
3157      -9.000000E+000            RG_LO     EQU     -9.0                              ; 
3158      1.000000E+000             R_HI      EQU     +1.0                              ; Serials
3159      -8.000000E+000            R_LO      EQU     -8.0                              ; 
3160      3.000000E+000             SI_HI     EQU     +3.0                              ; Parallels
3161      -9.000000E+000            SI_LO     EQU     -9.0                              ;
3162      3.000000E+000             DG_HI     EQU     +3.0                              ; Dump Gate
3163      -9.000000E+000            DG_LO     EQU     -9.0                              ;
3164   
3165                                ; DC Bias voltages in volts             
3166                                          IF      @SCP("20.0","21.0")
3168                                          ENDIF
3169                                          IF      @SCP("20.0","20.0")
3170      2.000000E+001             VOD       EQU     20.0                              ; Output Drain
3171                                          ENDIF
3172                                          IF      @SCP("20.0","19.0")
3174                                          ENDIF
3175      9.000000E+000             VRD       EQU     9.00                              ; Reset Drain
3176      -6.000000E+000            VOG       EQU     -6.0                              ; Output Gate
3177      -6.000000E+000            VABG      EQU     -6.0                              ; Anti-blooming gate
3178      1.900000E+001             VDD       EQU     19.0                              ; Dump Drain - xxx Not used, keep as placeho
lder
3179      6.000000E+000             PWR       EQU     +6.0                              ; Preamp power - xxx Not used, keep as place
holder
3180   
3181      002E00                    OFFSET    EQU     $2E00                             ; xxx These need to be tweaked
3182                                ;OFFSET0        EQU     $2E00   ; Left Side Of Frame
3183                                ;OFFSET1        EQU     $2E00   ; Right Side Of Frame  
3184      001F00                    OFFSET0   EQU     $1F00                             ; Left Side Of Frame
3185      001E00                    OFFSET1   EQU     $1E00                             ; Right Side Of Frame  
3186      002E00                    OFFSET2   EQU     OFFSET                            ; Channels 2 and 3 not used
3187      002E00                    OFFSET3   EQU     OFFSET
3188   
3189                                ; Define switch state bits for the lower CCD clock driver bank CLK2
3190                                ;XXX    EQU     1       ; Unused, Pin 1 - clock 0
3191                                ;XXX    EQU     2       ; Unused, Pin 2 - clock 1
3192      000004                    RGL       EQU     4                                 ; Reset Gate Left, Pin 3 - clock 2
3193      000008                    H3L       EQU     8                                 ; Serial #3 Left, Pin 4 - clock 3
3194      000010                    H2L       EQU     $10                               ; Serial #2 Left, Pin 5 - clock 4
3195      000020                    H1L       EQU     $20                               ; Serial #1 Left, Pin 6 - clock 5
3196                                ;XXX    EQU     $40     ; Unused, Pin 7 - clock 6
3197                                ;XXX    EQU     $80     ; Unused, Pin 8 - clock 7
3198      000100                    H1R       EQU     $100                              ; Serial #1 Right, Pin 9 - clock 8
3199      000200                    H2R       EQU     $200                              ; Serial #2 Right, Pin 10 - clock 9
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 58



3200      000400                    H3R       EQU     $400                              ; Serial #3 Right, Pin 11 - clock 10
3201      000800                    RGR       EQU     $800                              ; Reset Gate Right, Pin 12 - clock 11
3202   
3203                                ; Define switch state bits for the upper CCD clock driver bank CLK3
3204      000001                    I1        EQU     1                                 ; Image, phase #1, Pin 13 - clock 12
3205      000002                    I2        EQU     2                                 ; Image, phase #2, Pin 14 - clock 13
3206      000004                    I3        EQU     4                                 ; Image, phase #3, Pin 15 - clock 14
3207                                ;XX     EQU     8       ; Unused, Pin 16 - clock 15
3208      000010                    DG        EQU     $10                               ; Dump Gate, Pin 17 - clock 16
3209                                ;XX     EQU     $20     ; Unused, Pin 18 - clock 17
3210                                ;XX     EQU     $40     ; Unused, Pin 19 - clock 18
3211                                ;XX     EQU     $80     ; Unused, Pin 33 - clock 19
3212      000100                    S3        EQU     $100                              ; Storage, phase #3, Pin 34 - clock 20
3213      000200                    S2        EQU     $200                              ; Storage, phase #2, Pin 35 - clock 21
3214      000400                    S1        EQU     $400                              ; Storage, phase #1, Pin 36 - clock 22
3215                                ;XX     EQU     $800    ; Unused, Pin 37 - clock 23
3216   
3217                                ;  ***  Definitions for Y: memory waveform tables  *****
3218                                ; Clock only the Storage clocks : S1->S2->S3
3219                                S_PARALLEL
3220      Y:000040 Y:000040                   DC      END_S_PARALLEL-S_PARALLEL-1
3221      Y:000041 Y:000041                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
3222      Y:000042 Y:000042                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3223                                ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
3224      Y:000043 Y:000043                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00
3225      Y:000044 Y:000044                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00
3226      Y:000045 Y:000045                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3
3227      Y:000046 Y:000046                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3
3228      Y:000047 Y:000047                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3
3229      Y:000048 Y:000048                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
3230      Y:000049 Y:000049                   DC      CLK3+SI_DELAY+00+00+00+00+00+00   ; IMO line
3231                                END_S_PARALLEL
3232   
3233                                ; Reverse clock only the Storage clocks : S1->S3->S2->S1
3234                                ; Use in pipelined occultation mode
3235                                R_S_PARALLEL
3236      Y:00004A Y:00004A                   DC      END_R_S_PARALLEL-R_S_PARALLEL-1
3237      Y:00004B Y:00004B                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3238      Y:00004C Y:00004C                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3
3239      Y:00004D Y:00004D                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3
3240      Y:00004E Y:00004E                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3
3241      Y:00004F Y:00004F                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00
3242      Y:000050 Y:000050                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00
3243      Y:000051 Y:000051                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
3244                                ;       DC      CLK3+SI_DELAY+00+00+00+00+00+00 ; IMO line
3245                                END_R_S_PARALLEL
3246   
3247                                ; Clock only the Storage clocks : S1->S2->S3 with DG
3248                                S_CLEAR
3249      Y:000052 Y:000052                   DC      END_S_CLEAR-S_CLEAR-1
3250      Y:000053 Y:000053                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
3251      Y:000054 Y:000054                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3252                                ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
3253      Y:000055 Y:000055                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00+DG
3254      Y:000056 Y:000056                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00+DG
3255      Y:000057 Y:000057                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3+DG
3256      Y:000058 Y:000058                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3+DG
3257      Y:000059 Y:000059                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3+DG
3258      Y:00005A Y:00005A                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
3259                                ;       DC      CLK3+SI_DELAY+00+00+00+00+00+00 ; IMO line
3260                                END_S_CLEAR
3261                                ; 2 microsecond delay before readout starts may be needed here
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 59



3262                                ;       DC      CLK3+$600000+I1+00+00+S1+00+0000
3263   
3264                                ; Clock both the Storage and Image clocks : I1->I2->I3 and S1->S2->S3
3265                                IS_PARALLEL
3266      Y:00005B Y:00005B                   DC      END_IS_PARALLEL-IS_PARALLEL-1
3267      Y:00005C Y:00005C                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
3268      Y:00005D Y:00005D                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3269                                ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
3270      Y:00005E Y:00005E                   DC      CLK3+SI_DELAY+I1+I2+00+S1+S2+00
3271      Y:00005F Y:00005F                   DC      CLK3+SI_DELAY+00+I2+00+00+S2+00
3272      Y:000060 Y:000060                   DC      CLK3+SI_DELAY+00+I2+I3+00+S2+S3
3273      Y:000061 Y:000061                   DC      CLK3+SI_DELAY+00+00+I3+00+00+S3
3274      Y:000062 Y:000062                   DC      CLK3+SI_DELAY+I1+00+I3+S1+00+S3
3275      Y:000063 Y:000063                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
3276      Y:000064 Y:000064                   DC      CLK3+SI_DELAY+00+00+00+00+00+00   ; IMO line
3277                                END_IS_PARALLEL
3278   
3279                                ; Clock both the Storage and Image clocks : I1->I2->I3 and S1->S2->S3
3280                                IS_CLEAR
3281      Y:000065 Y:000065                   DC      IS_CLEAR_END-IS_CLEAR-1
3282      Y:000066 Y:000066                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
3283      Y:000067 Y:000067                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3284                                ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+00 ; Probably not needed
3285      Y:000068 Y:000068                   DC      CLK3+SI_DELAY+I1+I2+00+S1+S2+00+DG
3286      Y:000069 Y:000069                   DC      CLK3+SI_DELAY+00+I2+00+00+S2+00+DG
3287      Y:00006A Y:00006A                   DC      CLK3+SI_DELAY+00+I2+I3+00+S2+S3+DG
3288      Y:00006B Y:00006B                   DC      CLK3+SI_DELAY+00+00+I3+00+00+S3+DG
3289      Y:00006C Y:00006C                   DC      CLK3+SI_DELAY+I1+00+I3+S1+00+S3+DG
3290      Y:00006D Y:00006D                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
3291                                ;       DC      CLK3+SI_DELAY+00+00+00+00+00+00 ; IMO line
3292                                IS_CLEAR_END
3293   
3294                                ; Special IMO waveform for long initial clock after integration
3295                                ; Initial IMO clock duration is 142.8 microseconds.
3296                                IMO_FIRST_CLOCK
3297      Y:00006E Y:00006E                   DC      IMO_FIRST_CLOCK_END-IMO_FIRST_CLOCK-1
3298      Y:00006F Y:00006F                   DC      CLK3+$FF0000+I1+00+00+S1+00+00    ; Max delay, 20.4 us, IMO
3299      Y:000070 Y:000070                   DC      CLK3+$FF0000+I1+00+00+S1+00+00    ; Max delay, 20.4 us, IMO
3300      Y:000071 Y:000071                   DC      CLK3+$FF0000+I1+00+00+S1+00+00    ; Max delay, 20.4 us, IMO
3301      Y:000072 Y:000072                   DC      CLK3+$FF0000+I1+00+00+S1+00+00    ; Max delay, 20.4 us, IMO
3302      Y:000073 Y:000073                   DC      CLK3+$FF0000+I1+00+00+S1+00+00    ; Max delay, 20.4 us, IMO
3303      Y:000074 Y:000074                   DC      CLK3+$FF0000+I1+00+00+S1+00+00    ; Max delay, 20.4 us, IMO
3304      Y:000075 Y:000075                   DC      CLK3+$FF0000+I1+00+00+S1+00+00    ; Max delay, 20.4 us, IMO
3305                                IMO_FIRST_CLOCK_END
3306   
3307                                IMO_LAST_CLOCK
3308      Y:000076 Y:000076                   DC      IMO_LAST_CLOCK_END-IMO_LAST_CLOCK-1
3309      Y:000077 Y:000077                   DC      CLK3+SI_DELAY+00+00+00+00+00+00   ; IMO line
3310                                IMO_LAST_CLOCK_END
3311   
3312                                DCRST_LAST
3313      Y:000078 Y:000078                   DC      DCRST_LAST_END-DCRST_LAST-1
3314      Y:000079 Y:000079                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
3315                                DCRST_LAST_END
3316   
3317                                DUMP_SERIAL
3318      Y:00007A Y:00007A                   DC      END_DUMP_SERIAL-DUMP_SERIAL-1
3319      Y:00007B Y:00007B                   DC      CLK2+SI_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3320      Y:00007C Y:00007C                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
3321      Y:00007D Y:00007D                   DC      CLK2+SI_DELAY+RGL+RGR+000+000+000+000+000+000
3322      Y:00007E Y:00007E                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+00
3323      Y:00007F Y:00007F                   DC      CLK2+SI_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 60



3324                                END_DUMP_SERIAL
3325                                        COMMENT *
3326                                ; Michigan AIMO clocking - this is vestigial and commented out
3327                                PARALLEL DC     PARALLEL_CLEAR-PARALLEL-1
3328                                        DC      CLK2+$000000+RGL+RGR+H1L+H1R+H2L+H2R+00+000+000+00
3329                                        DC      CLK3+P_DELAY+00+00+I3
3330                                        DC      CLK3+P_DELAY+00+00+I3
3331                                        DC      CLK3+P_DELAY+I1+00+I3
3332                                        DC      CLK3+P_DELAY+I1+00+00
3333                                        DC      CLK3+P_DELAY+I1+I2+00
3334                                        DC      CLK3+P_DELAY+00+I2+00
3335                                        DC      CLK3+P_DELAY+00+I2+I3
3336                                        DC      CLK3+P_DELAY+00+00+I3
3337                                        DC      CLK3+P_DELAY+00+00+I3
3338                                        DC      CLK3+P_DELAY+00+00+00
3339                                        *
3340   
3341                                ; For serial clocking we know that the serial registers are laid out as
3342                                ; follows for a backside part per communication with Paul Jorden:       
3343   
3344                                ;          Right Side               Left Side
3345                                ;       OG  3  2  1  3 .........  3  2  1  3  OG
3346   
3347                                ; Left amp is   2 -> 1 -> 3
3348                                ; Right amp is  1 -> 2 -> 3
3349   
3350                                ; For a frontside part the left and right are reversed.
3351                                ; Parallel phase 3 dumps into serial 1 and 2.
3352   
3353                                ; Between serial clock code lumps the serials are left as follows:
3354                                ; LEFT  Phase 2 L and R both high
3355                                ; RIGHT Phase 1 L and R both high
3356                                ; SPLIT H1R and H2L are high
3357   
3358                                ; Video processor bit definition
3359                                ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3360   
3361                                SERIAL_IDLE                                         ; Split serial
3362      Y:000080 Y:000080                   DC      END_SERIAL_IDLE-SERIAL_IDLE-1
3363      Y:000081 Y:000081                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3364      Y:000082 Y:000082                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3365      Y:000083 Y:000083                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3366      Y:000084 Y:000084                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3367      Y:000085 Y:000085                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3368      Y:000086 Y:000086                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3369      Y:000087 Y:000087                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3370      Y:000088 Y:000088                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3371      Y:000089 Y:000089                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
3372      Y:00008A Y:00008A                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
3373      Y:00008B Y:00008B                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3374      Y:00008C Y:00008C                   DC      VIDEO+$000000+INT_SMPL            ; Stop integrate, A/D is sampling
3375                                ; Not needed, so comment out
3376                                ;       DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3377                                END_SERIAL_IDLE
3378   
3379                                ; The following waveforms are for binned operation.  This is tricky with the
3380                                ; CCD47 because it doesn't have a summing well.  The reset level integration
3381                                ; has to happen before serial 3 drops for the first time and the data level
3382                                ; integration has to happen after it drops for the last time.  The initial
3383                                ; clocks go through the reset integration, the serial clocks are the 
3384                                ; intervening clocks for additional pixels binned with the first one, and
3385                                ; the video process is left to do the last clock and data integration.
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 61



3386   
3387                                          IF      @SCP("ENABLESPLITS","ON")
3403                                          ENDIF
3404   
3405                                INITIAL_CLOCK_RIGHT                                 ; Serial right, Swap S1L and S2L
3406      Y:00008D Y:00008D                   DC      END_INITIAL_CLOCK_RIGHT-INITIAL_CLOCK_RIGHT-1
3407      Y:00008E Y:00008E                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3408      Y:00008F Y:00008F                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3409      Y:000090 Y:000090                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3410      Y:000091 Y:000091                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3411      Y:000092 Y:000092                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3412      Y:000093 Y:000093                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3413      Y:000094 Y:000094                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3414                                ;       DC      $00F021                 ; Transmit A/D data to host
3415      Y:000095 Y:000095                   DC      $00F041                           ; Transmit A/D data to host
3416      Y:000096 Y:000096                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3417      Y:000097 Y:000097                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3418      Y:000098 Y:000098                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
3419                                END_INITIAL_CLOCK_RIGHT
3420   
3421                                INITIAL_CLOCK_LEFT                                  ; Serial left, Swap S1R and S2R
3422      Y:000099 Y:000099                   DC      END_INITIAL_CLOCK_LEFT-INITIAL_CLOCK_LEFT-1
3423      Y:00009A Y:00009A                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3424      Y:00009B Y:00009B                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3425      Y:00009C Y:00009C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3426      Y:00009D Y:00009D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3427      Y:00009E Y:00009E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3428      Y:00009F Y:00009F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3429      Y:0000A0 Y:0000A0                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3430      Y:0000A1 Y:0000A1                   DC      $00F000                           ; Transmit A/D data to host
3431      Y:0000A2 Y:0000A2                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3432      Y:0000A3 Y:0000A3                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3433      Y:0000A4 Y:0000A4                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
3434                                END_INITIAL_CLOCK_LEFT
3435   
3436                                          IF      @SCP("ENABLESPLITS","ON")
3446                                          ENDIF
3447   
3448                                SERIAL_CLOCK_RIGHT                                  ; Serial right, Swap S1L and S2L
3449      Y:0000A5 Y:0000A5                   DC      END_SERIAL_CLOCK_RIGHT-SERIAL_CLOCK_RIGHT-1
3450      Y:0000A6 Y:0000A6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3451      Y:0000A7 Y:0000A7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3452      Y:0000A8 Y:0000A8                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3453      Y:0000A9 Y:0000A9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3454      Y:0000AA Y:0000AA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3455      Y:0000AB Y:0000AB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3456                                END_SERIAL_CLOCK_RIGHT
3457   
3458                                SERIAL_CLOCK_LEFT                                   ; Serial left, Swap S1R and S2R
3459      Y:0000AC Y:0000AC                   DC      END_SERIAL_CLOCK_LEFT-SERIAL_CLOCK_LEFT-1
3460      Y:0000AD Y:0000AD                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3461      Y:0000AE Y:0000AE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3462      Y:0000AF Y:0000AF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3463      Y:0000B0 Y:0000B0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3464      Y:0000B1 Y:0000B1                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3465      Y:0000B2 Y:0000B2                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3466                                END_SERIAL_CLOCK_LEFT
3467   
3468                                VIDEO_PROCESS
3469      Y:0000B3 Y:0000B3                   DC      END_VIDEO_PROCESS-VIDEO_PROCESS-1
3470                                CCLK_1                                              ; The following line is overwritten by timmi
sc.s
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 62



3471      Y:0000B4 Y:0000B4                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
3472      Y:0000B5 Y:0000B5                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3473      Y:0000B6 Y:0000B6                   DC      VIDEO+$000000+INT_SMPL            ; Stop integrate, A/D is sampling
3474                                CCLK_2                                              ; The following line is overwritten by timmi
sc.s, but is correct as is.
3475                                ; Actually it shouldn't be needed so comment it out.
3476                                ;       DC      CLK2+S_DLY+S1R+S2R+000+S1L+S2L+000+000+000+000+000
3477                                END_VIDEO_PROCESS
3478   
3479                                ; Starting Y: address of circular waveforms for no-overhead access
3480      0000C0                    STRT_CIR  EQU     $C0
3481                                ;ROM_DISP       EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+STRT_CIR
3482                                ;DAC_DISP       EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+$100
3483   
3484                                ; Check for Y: data memory overflow
3485                                          IF      @CVS(N,*)>STRT_CIR
3487                                          ENDIF                                     ;  will not overflow
3488   
3489                                ; The fast serial code with the circulating address register must start 
3490                                ;   on a boundary that is a multiple of the address register modulus.
3491   
3492                                          IF      @SCP("HOST","HOST")
3493      Y:0000C0 Y:0000C0                   ORG     Y:STRT_CIR,Y:STRT_CIR             ; Download address
3494                                ;       ELSE
3495                                ;       ORG     Y:STRT_CIR,P:ROM_DISP
3496                                          ENDIF
3497   
3498                                ; This is an area to copy in the serial fast binned waveforms from high Y memory
3499                                ; It is 0x28 = 40 locations long, enough to put in a binned-by-five waveform
3500                                ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3501                                SERIAL_READ
3502      Y:0000C0 Y:0000C0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3503      Y:0000C1 Y:0000C1                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3504      Y:0000C2 Y:0000C2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3505      Y:0000C3 Y:0000C3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3506      Y:0000C4 Y:0000C4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3507      Y:0000C5 Y:0000C5                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
3508                                SXMIT
3509      Y:0000C6 Y:0000C6                   DC      $00F000                           ; Transmit A/D data to host
3510      Y:0000C7 Y:0000C7                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3511      Y:0000C8 Y:0000C8                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3512      Y:0000C9 Y:0000C9                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
3513      Y:0000CA Y:0000CA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3514      Y:0000CB Y:0000CB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3515      Y:0000CC Y:0000CC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3516      Y:0000CD Y:0000CD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3517      Y:0000CE Y:0000CE                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3518      Y:0000CF Y:0000CF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3519      Y:0000D0 Y:0000D0                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3520      Y:0000D1 Y:0000D1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3521      Y:0000D2 Y:0000D2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3522      Y:0000D3 Y:0000D3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3523      Y:0000D4 Y:0000D4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3524      Y:0000D5 Y:0000D5                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3525      Y:0000D6 Y:0000D6                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3526      Y:0000D7 Y:0000D7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3527      Y:0000D8 Y:0000D8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3528      Y:0000D9 Y:0000D9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3529      Y:0000DA Y:0000DA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3530      Y:0000DB Y:0000DB                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3531      Y:0000DC Y:0000DC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3532      Y:0000DD Y:0000DD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 63



3533      Y:0000DE Y:0000DE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3534      Y:0000DF Y:0000DF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3535      Y:0000E0 Y:0000E0                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3536      Y:0000E1 Y:0000E1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3537      Y:0000E2 Y:0000E2                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
3538      Y:0000E3 Y:0000E3                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3539      Y:0000E4 Y:0000E4                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
3540                                END_SERIAL
3541   
3542                                ; Serial clocking waveform for skipping
3543                                          IF      @SCP("HOST","HOST")
3544      Y:0000E8 Y:0000E8                   ORG     Y:STRT_CIR+$28,Y:STRT_CIR+$28     ; Download address
3545                                ;       ELSE
3546                                ;       ORG     Y:STRT_CIR+$28,P:ROM_DISP+$28
3547                                          ENDIF
3548   
3549                                ; There are three serial skip waveforms that must all be the same length
3550                                SERIAL_SKIP_LEFT
3551                                ;       DC      END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1
3552      Y:0000E8 Y:0000E8                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3553      Y:0000E9 Y:0000E9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3554      Y:0000EA Y:0000EA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3555      Y:0000EB Y:0000EB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3556      Y:0000EC Y:0000EC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3557      Y:0000ED Y:0000ED                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3558                                END_SERIAL_SKIP_LEFT
3559   
3560                                          IF      @SCP("HOST","HOST")
3561      Y:0000F0 Y:0000F0                   ORG     Y:STRT_CIR+$30,Y:STRT_CIR+$30     ; Download address
3562                                ;       ELSE
3563                                ;       ORG     Y:STRT_CIR+$30,P:ROM_DISP+$30
3564                                          ENDIF
3565   
3566                                SERIAL_SKIP_RIGHT
3567                                ;       DC      END_SERIAL_SKIP_RIGHT-SERIAL_SKIP_RIGHT-1
3568      Y:0000F0 Y:0000F0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3569      Y:0000F1 Y:0000F1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3570      Y:0000F2 Y:0000F2                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3571      Y:0000F3 Y:0000F3                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3572      Y:0000F4 Y:0000F4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3573      Y:0000F5 Y:0000F5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3574                                END_SERIAL_SKIP_RIGHT
3575   
3576                                          IF      @SCP("HOST","HOST")
3577      Y:0000F8 Y:0000F8                   ORG     Y:STRT_CIR+$38,Y:STRT_CIR+$38     ; Download address
3578                                ;       ELSE
3579                                ;       ORG     Y:STRT_CIR+$38,P:ROM_DISP+$38
3580                                          ENDIF
3581   
3582                                          IF      @SCP("ENABLESPLITS","ON")
3592                                          ENDIF
3593   
3594                                ; Put all the following code in SRAM.
3595                                          IF      @SCP("HOST","HOST")
3596      Y:000100 Y:000100                   ORG     Y:$100,Y:$100                     ; Download address
3597                                ;       ELSE
3598                                ;       ORG     Y:$100,P:DAC_DISP
3599                                          ENDIF
3600   
3601                                ; Initialization of clock driver and video processor DACs and switches
3602                                ; This is for the ARC 47 4-channel video board
3603      Y:000100 Y:000100         DACS      DC      END_DACS-DACS-1
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 64



3604      Y:000101 Y:000101                   DC      CLKV+$0A0080                      ; DAC = unbuffered mode
3605      Y:000102 Y:000102                   DC      CLKV+$000100+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #1, Unused
3606      Y:000103 Y:000103                   DC      CLKV+$000200+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3607      Y:000104 Y:000104                   DC      CLKV+$000400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #2, Unused
3608      Y:000105 Y:000105                   DC      CLKV+$000800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3609      Y:000106 Y:000106                   DC      CLKV+$002000+@CVI((RG_HI+Vmax)/(2*Vmax)*255) ; Pin #3, RG Left
3610      Y:000107 Y:000107                   DC      CLKV+$004000+@CVI((RG_LO+Vmax)/(2*Vmax)*255)
3611      Y:000108 Y:000108                   DC      CLKV+$008000+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #4, S3 Left
3612      Y:000109 Y:000109                   DC      CLKV+$010000+@CVI((R_LO+Vmax)/(2*Vmax)*255)
3613      Y:00010A Y:00010A                   DC      CLKV+$020100+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #5, S2 Left
3614      Y:00010B Y:00010B                   DC      CLKV+$020200+@CVI((R_LO+Vmax)/(2*Vmax)*255)
3615      Y:00010C Y:00010C                   DC      CLKV+$020400+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #6, S1 Left
3616      Y:00010D Y:00010D                   DC      CLKV+$020800+@CVI((R_LO+Vmax)/(2*Vmax)*255)
3617      Y:00010E Y:00010E                   DC      CLKV+$022000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #7, Unused
3618      Y:00010F Y:00010F                   DC      CLKV+$024000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3619      Y:000110 Y:000110                   DC      CLKV+$028000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #8, Unused
3620      Y:000111 Y:000111                   DC      CLKV+$030000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3621      Y:000112 Y:000112                   DC      CLKV+$040100+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #9, S1 Right
3622      Y:000113 Y:000113                   DC      CLKV+$040200+@CVI((R_LO+Vmax)/(2*Vmax)*255)
3623      Y:000114 Y:000114                   DC      CLKV+$040400+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #10, S2 Right
3624      Y:000115 Y:000115                   DC      CLKV+$040800+@CVI((R_LO+Vmax)/(2*Vmax)*255)
3625      Y:000116 Y:000116                   DC      CLKV+$042000+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #11, S3 Right
3626      Y:000117 Y:000117                   DC      CLKV+$044000+@CVI((R_LO+Vmax)/(2*Vmax)*255)
3627      Y:000118 Y:000118                   DC      CLKV+$048000+@CVI((RG_HI+Vmax)/(2*Vmax)*255) ; Pin #12, RG Right
3628      Y:000119 Y:000119                   DC      CLKV+$050000+@CVI((RG_LO+Vmax)/(2*Vmax)*255)
3629   
3630      Y:00011A Y:00011A                   DC      CLKV+$060100+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #13, I1
3631      Y:00011B Y:00011B                   DC      CLKV+$060200+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3632      Y:00011C Y:00011C                   DC      CLKV+$060400+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #14, I2
3633      Y:00011D Y:00011D                   DC      CLKV+$060800+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3634      Y:00011E Y:00011E                   DC      CLKV+$062000+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #15, I3
3635      Y:00011F Y:00011F                   DC      CLKV+$064000+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3636      Y:000120 Y:000120                   DC      CLKV+$068000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #16, Unused
3637      Y:000121 Y:000121                   DC      CLKV+$070000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3638      Y:000122 Y:000122                   DC      CLKV+$080100+@CVI((DG_HI+Vmax)/(2*Vmax)*255) ; Pin #17, DG
3639      Y:000123 Y:000123                   DC      CLKV+$080200+@CVI((DG_LO+Vmax)/(2*Vmax)*255)
3640      Y:000124 Y:000124                   DC      CLKV+$080400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #18, Unused
3641      Y:000125 Y:000125                   DC      CLKV+$080800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3642      Y:000126 Y:000126                   DC      CLKV+$082000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #19, Unused
3643      Y:000127 Y:000127                   DC      CLKV+$084000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3644      Y:000128 Y:000128                   DC      CLKV+$088000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #33, Unused
3645      Y:000129 Y:000129                   DC      CLKV+$090000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3646      Y:00012A Y:00012A                   DC      CLKV+$0A0100+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #34, S3
3647      Y:00012B Y:00012B                   DC      CLKV+$0A0200+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3648      Y:00012C Y:00012C                   DC      CLKV+$0A0400+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #35, S2
3649      Y:00012D Y:00012D                   DC      CLKV+$0A0800+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3650      Y:00012E Y:00012E                   DC      CLKV+$0A2000+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #36, S1
3651      Y:00012F Y:00012F                   DC      CLKV+$0A4000+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3652      Y:000130 Y:000130                   DC      CLKV+$0A8000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #37, Unused
3653      Y:000131 Y:000131                   DC      CLKV+$0B0000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3654   
3655                                ; Commands for the ARC-47 video board 
3656      Y:000132 Y:000132                   DC      VID0+$0C0000                      ; Normal Image data D17-D2
3657   
3658                                ; Gain : $0D000g, g = 0 to %1111, Gain = 4.75 to 1.0 in steps of 0.25
3659                                ; xxx I don't understand this PRAM arrangement.
3660                                ;       DC      VID0+$0D000F
3661      Y:000133 Y:000133                   DC      VID0+$0D0000                      ; fix for arc-47 gen-iii default gain 1
3662      Y:000134 Y:000134                   DC      VID0+$0C0180                      ; integrator parameter for 0.5 us
3663   
3664      3.045000E+001             VOD_MAX   EQU     30.45
3665      1.990000E+001             VRD_MAX   EQU     19.90
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 65



3666      8.700000E+000             VOG_MAX   EQU     8.70
3667      002A08                    DAC_VOD   EQU     @CVI((VOD/VOD_MAX)*16384-1)       ; Unipolar
3668      001CF0                    DAC_VRD   EQU     @CVI((VRD/VRD_MAX)*16384-1)       ; Unipolar
3669      0009ED                    DAC_VOG   EQU     @CVI(((VOG+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3670      0009ED                    DAC_VABG  EQU     @CVI(((VABG+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3671      0027EE                    DAC_VDD   EQU     @CVI((VDD/VOD_MAX)*16384-1)       ; Unipolar
3672      003610                    DAC_PWR   EQU     @CVI(((PWR+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
3673      001FFF                    DAC_ZERO  EQU     $1FFF                             ; Bipolar
3674   
3675                                ; Initialize the ARC-47 DAC For DC_BIAS
3676                                ; xxx These need to be revisited with Rich - which is which?
3677      Y:000135 Y:000135                   DC      VID0+DAC_ADDR+$000000             ; Vod0, pin 52
3678      Y:000136 Y:000136                   DC      VID0+DAC_RegD+DAC_VOD
3679      Y:000137 Y:000137                   DC      VID0+DAC_ADDR+$000004             ; Vrd0, pin 13
3680      Y:000138 Y:000138                   DC      VID0+DAC_RegD+DAC_VRD
3681      Y:000139 Y:000139                   DC      VID0+DAC_ADDR+$000008             ; Vog0, pin 29
3682      Y:00013A Y:00013A                   DC      VID0+DAC_RegD+DAC_VOG
3683      Y:00013B Y:00013B                   DC      VID0+DAC_ADDR+$00000C             ; Vabg, pin 5, NC
3684      Y:00013C Y:00013C                   DC      VID0+DAC_RegD+DAC_ZERO
3685   
3686      Y:00013D Y:00013D                   DC      VID0+DAC_ADDR+$000001             ; Vod1, pin 32
3687      Y:00013E Y:00013E                   DC      VID0+DAC_RegD+DAC_VOD
3688      Y:00013F Y:00013F                   DC      VID0+DAC_ADDR+$000005             ; Vrd1, pin 55
3689      Y:000140 Y:000140                   DC      VID0+DAC_RegD+DAC_VRD
3690      Y:000141 Y:000141                   DC      VID0+DAC_ADDR+$000009             ; Vabg, pin 8
3691      Y:000142 Y:000142                   DC      VID0+DAC_RegD+DAC_VABG
3692      Y:000143 Y:000143                   DC      VID0+DAC_ADDR+$00000D             ; Vrsv1, pin 47, NC
3693      Y:000144 Y:000144                   DC      VID0+DAC_RegD+DAC_ZERO
3694   
3695      Y:000145 Y:000145                   DC      VID0+DAC_ADDR+$000002             ; Vod2, pin 11
3696      Y:000146 Y:000146                   DC      VID0+DAC_RegD+DAC_VOD
3697      Y:000147 Y:000147                   DC      VID0+DAC_ADDR+$000006             ; Vrd2, pin 35
3698      Y:000148 Y:000148                   DC      VID0+DAC_RegD+0
3699      Y:000149 Y:000149                   DC      VID0+DAC_ADDR+$00000A             ; Vog2, pin 50
3700      Y:00014A Y:00014A                   DC      VID0+DAC_RegD+DAC_VOG
3701      Y:00014B Y:00014B                   DC      VID0+DAC_ADDR+$00000E             ; Vrsv2, pin 27
3702      Y:00014C Y:00014C                   DC      VID0+DAC_RegD+DAC_ZERO
3703   
3704      Y:00014D Y:00014D                   DC      VID0+DAC_ADDR+$000003             ; Vod3, pin 53
3705      Y:00014E Y:00014E                   DC      VID0+DAC_RegD+DAC_VOD
3706      Y:00014F Y:00014F                   DC      VID0+DAC_ADDR+$000007             ; Vrd3, pin 14
3707      Y:000150 Y:000150                   DC      VID0+DAC_RegD+0
3708      Y:000151 Y:000151                   DC      VID0+DAC_ADDR+$00000B             ; Vog3, pin 30
3709      Y:000152 Y:000152                   DC      VID0+DAC_RegD+DAC_VOG
3710      Y:000153 Y:000153                   DC      VID0+DAC_ADDR+$00000F             ; Vrsv3, pin 6
3711      Y:000154 Y:000154                   DC      VID0+DAC_RegD+DAC_ZERO
3712   
3713      Y:000155 Y:000155                   DC      VID0+DAC_ADDR+$000010             ; Vod4, pin 33
3714      Y:000156 Y:000156                   DC      VID0+DAC_RegD+DAC_VDD
3715      Y:000157 Y:000157                   DC      VID0+DAC_ADDR+$000011             ; Vrd4, pin 56
3716      Y:000158 Y:000158                   DC      VID0+DAC_RegD+DAC_PWR
3717      Y:000159 Y:000159                   DC      VID0+DAC_ADDR+$000012             ; Vog4, pin 9
3718      Y:00015A Y:00015A                   DC      VID0+DAC_RegD+DAC_ZERO
3719      Y:00015B Y:00015B                   DC      VID0+DAC_ADDR+$000013             ; Vrsv4,pin 48
3720      Y:00015C Y:00015C                   DC      VID0+DAC_RegD+DAC_ZERO
3721   
3722                                ; Initialize the ARC-47 DAC For Video Offsets
3723      Y:00015D Y:00015D                   DC      VID0+DAC_ADDR+$000014
3724      Y:00015E Y:00015E                   DC      VID0+DAC_RegD+OFFSET0
3725      Y:00015F Y:00015F                   DC      VID0+DAC_ADDR+$000015
3726      Y:000160 Y:000160                   DC      VID0+DAC_RegD+OFFSET1
3727      Y:000161 Y:000161                   DC      VID0+DAC_ADDR+$000016
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 66



3728      Y:000162 Y:000162                   DC      VID0+DAC_RegD+OFFSET2
3729      Y:000163 Y:000163                   DC      VID0+DAC_ADDR+$000017
3730      Y:000164 Y:000164                   DC      VID0+DAC_RegD+OFFSET3
3731   
3732                                END_DACS
3733   
3734                                ;       These are the 15 fast serial read waveforms for left, right, 
3735                                ;       and split reads for serial binning factors from 1 to 5.
3736   
3737                                ;       Unbinned waveforms
3738                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3739                                SERIAL_READ_LEFT_1
3740      Y:000165 Y:000165                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3741      Y:000166 Y:000166                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3742      Y:000167 Y:000167                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3743      Y:000168 Y:000168                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3744      Y:000169 Y:000169                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3745      Y:00016A Y:00016A                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
3746                                SXMIT_LEFT_1
3747      Y:00016B Y:00016B                   DC      $00F000                           ; Transmit A/D data to host
3748      Y:00016C Y:00016C                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3749      Y:00016D Y:00016D                   DC      VIDEO+$000000+INT_STOP            ; Stop integrating
3750      Y:00016E Y:00016E                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
3751      Y:00016F Y:00016F                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3752      Y:000170 Y:000170                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
3753                                END_SERIAL_READ_LEFT_1
3754   
3755                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3756                                SERIAL_READ_RIGHT_1
3757      Y:000171 Y:000171                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3758      Y:000172 Y:000172                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3759      Y:000173 Y:000173                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3760      Y:000174 Y:000174                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3761      Y:000175 Y:000175                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3762      Y:000176 Y:000176                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
3763                                SXMIT_RIGHT_1
3764                                ;       DC      $00F021                 ; Transmit A/D data to host
3765      Y:000177 Y:000177                   DC      $00F041                           ; Transmit A/D data to host
3766      Y:000178 Y:000178                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3767      Y:000179 Y:000179                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3768      Y:00017A Y:00017A                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
3769      Y:00017B Y:00017B                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
3770      Y:00017C Y:00017C                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3771      Y:00017D Y:00017D                   DC      VIDEO+$000000+INT_SMPL            ; Stop integrate, A/D is sampling
3772                                END_SERIAL_READ_RIGHT_1
3773   
3774                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3775                                SERIAL_READ_SPLIT_1
3776      Y:00017E Y:00017E                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3777      Y:00017F Y:00017F                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3778      Y:000180 Y:000180                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3779      Y:000181 Y:000181                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3780      Y:000182 Y:000182                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3781      Y:000183 Y:000183                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3782                                SXMIT_SPLIT_1
3783                                ;       DC      $00F020                 ; Transmit A/D data to host
3784      Y:000184 Y:000184                   DC      $00F040                           ; Transmit A/D data to host
3785      Y:000185 Y:000185                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3786      Y:000186 Y:000186                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3787      Y:000187 Y:000187                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
3788      Y:000188 Y:000188                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
3789      Y:000189 Y:000189                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 67



3790      Y:00018A Y:00018A                   DC      VIDEO+$000000+INT_SMPL            ; Stop integrate, A/D is sampling
3791                                END_SERIAL_READ_SPLIT_1
3792   
3793                                ; Bin by 2 waveforms
3794                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3795                                SERIAL_READ_LEFT_2
3796      Y:00018B Y:00018B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3797      Y:00018C Y:00018C                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3798      Y:00018D Y:00018D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3799      Y:00018E Y:00018E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3800      Y:00018F Y:00018F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3801      Y:000190 Y:000190                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
3802                                SXMIT_LEFT_2
3803      Y:000191 Y:000191                   DC      $00F000                           ; Transmit A/D data to host
3804      Y:000192 Y:000192                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3805      Y:000193 Y:000193                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3806      Y:000194 Y:000194                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
3807      Y:000195 Y:000195                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3808      Y:000196 Y:000196                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3809      Y:000197 Y:000197                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3810      Y:000198 Y:000198                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3811      Y:000199 Y:000199                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3812      Y:00019A Y:00019A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3813      Y:00019B Y:00019B                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
3814      Y:00019C Y:00019C                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3815      Y:00019D Y:00019D                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
3816                                END_SERIAL_READ_LEFT_2
3817   
3818                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3819                                SERIAL_READ_RIGHT_2
3820      Y:00019E Y:00019E                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3821      Y:00019F Y:00019F                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3822      Y:0001A0 Y:0001A0                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3823      Y:0001A1 Y:0001A1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3824      Y:0001A2 Y:0001A2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3825      Y:0001A3 Y:0001A3                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
3826                                SXMIT_RIGHT_2
3827                                ;       DC      $00F021                 ; Transmit A/D data to host
3828      Y:0001A4 Y:0001A4                   DC      $00F041                           ; Transmit A/D data to host
3829      Y:0001A5 Y:0001A5                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3830      Y:0001A6 Y:0001A6                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3831      Y:0001A7 Y:0001A7                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
3832      Y:0001A8 Y:0001A8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3833      Y:0001A9 Y:0001A9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3834      Y:0001AA Y:0001AA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3835      Y:0001AB Y:0001AB                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3836      Y:0001AC Y:0001AC                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3837      Y:0001AD Y:0001AD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3838      Y:0001AE Y:0001AE                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
3839      Y:0001AF Y:0001AF                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3840      Y:0001B0 Y:0001B0                   DC      VIDEO+$000000+INT_SMPL            ; Stop integrate, A/D is sampling
3841                                END_SERIAL_READ_RIGHT_2
3842   
3843                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3844                                SERIAL_READ_SPLIT_2
3845      Y:0001B1 Y:0001B1                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3846      Y:0001B2 Y:0001B2                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3847      Y:0001B3 Y:0001B3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3848      Y:0001B4 Y:0001B4                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3849      Y:0001B5 Y:0001B5                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3850      Y:0001B6 Y:0001B6                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3851                                SXMIT_SPLIT_2
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 68



3852                                ;       DC      $00F020                 ; Transmit A/D data to host
3853      Y:0001B7 Y:0001B7                   DC      $00F040                           ; Transmit A/D data to host
3854      Y:0001B8 Y:0001B8                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3855      Y:0001B9 Y:0001B9                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3856      Y:0001BA Y:0001BA                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
3857      Y:0001BB Y:0001BB                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
3858      Y:0001BC Y:0001BC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3859      Y:0001BD Y:0001BD                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3860      Y:0001BE Y:0001BE                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3861      Y:0001BF Y:0001BF                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3862      Y:0001C0 Y:0001C0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3863      Y:0001C1 Y:0001C1                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
3864      Y:0001C2 Y:0001C2                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3865      Y:0001C3 Y:0001C3                   DC      VIDEO+$000000+INT_SMPL            ; Stop integrate, A/D is sampling
3866                                END_SERIAL_READ_SPLIT_2
3867   
3868   
3869                                ;       Binned by 3 waveforms
3870                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3871                                SERIAL_READ_LEFT_3
3872      Y:0001C4 Y:0001C4                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3873      Y:0001C5 Y:0001C5                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3874      Y:0001C6 Y:0001C6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3875      Y:0001C7 Y:0001C7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3876      Y:0001C8 Y:0001C8                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3877      Y:0001C9 Y:0001C9                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
3878                                SXMIT_LEFT_3
3879      Y:0001CA Y:0001CA                   DC      $00F000                           ; Transmit A/D data to host
3880      Y:0001CB Y:0001CB                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3881      Y:0001CC Y:0001CC                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3882      Y:0001CD Y:0001CD                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
3883      Y:0001CE Y:0001CE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3884      Y:0001CF Y:0001CF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3885      Y:0001D0 Y:0001D0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3886      Y:0001D1 Y:0001D1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3887      Y:0001D2 Y:0001D2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3888      Y:0001D3 Y:0001D3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3889      Y:0001D4 Y:0001D4                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3890      Y:0001D5 Y:0001D5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3891      Y:0001D6 Y:0001D6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3892      Y:0001D7 Y:0001D7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3893      Y:0001D8 Y:0001D8                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3894      Y:0001D9 Y:0001D9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3895      Y:0001DA Y:0001DA                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
3896      Y:0001DB Y:0001DB                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3897      Y:0001DC Y:0001DC                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
3898                                END_SERIAL_READ_LEFT_3
3899   
3900                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3901                                SERIAL_READ_RIGHT_3
3902      Y:0001DD Y:0001DD                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3903      Y:0001DE Y:0001DE                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3904      Y:0001DF Y:0001DF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3905      Y:0001E0 Y:0001E0                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3906      Y:0001E1 Y:0001E1                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3907      Y:0001E2 Y:0001E2                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
3908                                SXMIT_RIGHT_3
3909                                ;       DC      $00F021                 ; Transmit A/D data to host
3910      Y:0001E3 Y:0001E3                   DC      $00F041                           ; Transmit A/D data to host
3911      Y:0001E4 Y:0001E4                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3912      Y:0001E5 Y:0001E5                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3913      Y:0001E6 Y:0001E6                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 69



3914      Y:0001E7 Y:0001E7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3915      Y:0001E8 Y:0001E8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3916      Y:0001E9 Y:0001E9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3917      Y:0001EA Y:0001EA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3918      Y:0001EB Y:0001EB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3919      Y:0001EC Y:0001EC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3920      Y:0001ED Y:0001ED                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3921      Y:0001EE Y:0001EE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3922      Y:0001EF Y:0001EF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3923      Y:0001F0 Y:0001F0                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3924      Y:0001F1 Y:0001F1                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3925      Y:0001F2 Y:0001F2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3926      Y:0001F3 Y:0001F3                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
3927      Y:0001F4 Y:0001F4                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3928      Y:0001F5 Y:0001F5                   DC      VIDEO+$000000+INT_SMPL            ; Stop integrate, A/D is sampling
3929                                END_SERIAL_READ_RIGHT_3
3930   
3931                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3932                                SERIAL_READ_SPLIT_3
3933      Y:0001F6 Y:0001F6                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3934      Y:0001F7 Y:0001F7                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3935      Y:0001F8 Y:0001F8                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3936      Y:0001F9 Y:0001F9                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3937      Y:0001FA Y:0001FA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3938      Y:0001FB Y:0001FB                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3939                                SXMIT_SPLIT_3
3940                                ;       DC      $00F020                 ; Transmit A/D data to host
3941      Y:0001FC Y:0001FC                   DC      $00F040                           ; Transmit A/D data to host
3942      Y:0001FD Y:0001FD                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3943      Y:0001FE Y:0001FE                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3944      Y:0001FF Y:0001FF                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
3945      Y:000200 Y:000200                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
3946      Y:000201 Y:000201                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3947      Y:000202 Y:000202                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3948      Y:000203 Y:000203                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3949      Y:000204 Y:000204                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3950      Y:000205 Y:000205                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3951      Y:000206 Y:000206                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
3952      Y:000207 Y:000207                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3953      Y:000208 Y:000208                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3954      Y:000209 Y:000209                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3955      Y:00020A Y:00020A                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3956      Y:00020B Y:00020B                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3957      Y:00020C Y:00020C                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
3958      Y:00020D Y:00020D                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3959      Y:00020E Y:00020E                   DC      VIDEO+$000000+INT_SMPL            ; Stop integrate, A/D is sampling
3960                                END_SERIAL_READ_SPLIT_3
3961   
3962                                ;       Binned by 4 waveforms
3963                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3964                                SERIAL_READ_LEFT_4
3965      Y:00020F Y:00020F                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3966      Y:000210 Y:000210                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
3967      Y:000211 Y:000211                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3968      Y:000212 Y:000212                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3969      Y:000213 Y:000213                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3970      Y:000214 Y:000214                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
3971                                SXMIT_LEFT_4
3972      Y:000215 Y:000215                   DC      $00F000                           ; Transmit A/D data to host
3973      Y:000216 Y:000216                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
3974      Y:000217 Y:000217                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3975      Y:000218 Y:000218                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 70



3976      Y:000219 Y:000219                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3977      Y:00021A Y:00021A                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3978      Y:00021B Y:00021B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3979      Y:00021C Y:00021C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3980      Y:00021D Y:00021D                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3981      Y:00021E Y:00021E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3982      Y:00021F Y:00021F                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3983      Y:000220 Y:000220                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3984      Y:000221 Y:000221                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3985      Y:000222 Y:000222                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3986      Y:000223 Y:000223                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3987      Y:000224 Y:000224                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3988      Y:000225 Y:000225                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3989      Y:000226 Y:000226                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3990      Y:000227 Y:000227                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3991      Y:000228 Y:000228                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3992      Y:000229 Y:000229                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3993      Y:00022A Y:00022A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3994      Y:00022B Y:00022B                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
3995      Y:00022C Y:00022C                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3996      Y:00022D Y:00022D                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
3997                                END_SERIAL_READ_LEFT_4
3998   
3999                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4000                                SERIAL_READ_RIGHT_4
4001      Y:00022E Y:00022E                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
4002      Y:00022F Y:00022F                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
4003      Y:000230 Y:000230                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
4004      Y:000231 Y:000231                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4005      Y:000232 Y:000232                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4006      Y:000233 Y:000233                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
4007                                SXMIT_RIGHT_4
4008                                ;       DC      $00F021                 ; Transmit A/D data to host
4009      Y:000234 Y:000234                   DC      $00F041                           ; Transmit A/D data to host
4010      Y:000235 Y:000235                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
4011      Y:000236 Y:000236                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4012      Y:000237 Y:000237                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
4013      Y:000238 Y:000238                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
4014      Y:000239 Y:000239                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4015      Y:00023A Y:00023A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
4016      Y:00023B Y:00023B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4017      Y:00023C Y:00023C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4018      Y:00023D Y:00023D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
4019      Y:00023E Y:00023E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
4020      Y:00023F Y:00023F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4021      Y:000240 Y:000240                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
4022      Y:000241 Y:000241                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4023      Y:000242 Y:000242                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4024      Y:000243 Y:000243                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
4025      Y:000244 Y:000244                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
4026      Y:000245 Y:000245                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4027      Y:000246 Y:000246                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
4028      Y:000247 Y:000247                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4029      Y:000248 Y:000248                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4030      Y:000249 Y:000249                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
4031      Y:00024A Y:00024A                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
4032      Y:00024B Y:00024B                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4033      Y:00024C Y:00024C                   DC      VIDEO+$000000+INT_SMPL            ; Stop integrate, A/D is sampling
4034                                END_SERIAL_READ_RIGHT_4
4035   
4036                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4037                                SERIAL_READ_SPLIT_4
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 71



4038      Y:00024D Y:00024D                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
4039      Y:00024E Y:00024E                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
4040      Y:00024F Y:00024F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
4041      Y:000250 Y:000250                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
4042      Y:000251 Y:000251                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4043      Y:000252 Y:000252                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
4044                                SXMIT_SPLIT_4
4045                                ;       DC      $00F020                 ; Transmit A/D data to host
4046      Y:000253 Y:000253                   DC      $00F040                           ; Transmit A/D data to host
4047      Y:000254 Y:000254                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
4048      Y:000255 Y:000255                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4049      Y:000256 Y:000256                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
4050      Y:000257 Y:000257                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
4051      Y:000258 Y:000258                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4052      Y:000259 Y:000259                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
4053      Y:00025A Y:00025A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
4054      Y:00025B Y:00025B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4055      Y:00025C Y:00025C                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
4056      Y:00025D Y:00025D                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
4057      Y:00025E Y:00025E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4058      Y:00025F Y:00025F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
4059      Y:000260 Y:000260                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
4060      Y:000261 Y:000261                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4061      Y:000262 Y:000262                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
4062      Y:000263 Y:000263                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
4063      Y:000264 Y:000264                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4064      Y:000265 Y:000265                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
4065      Y:000266 Y:000266                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
4066      Y:000267 Y:000267                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4067      Y:000268 Y:000268                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
4068      Y:000269 Y:000269                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
4069      Y:00026A Y:00026A                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4070      Y:00026B Y:00026B                   DC      VIDEO+$000000+INT_SMPL            ; Stop integrate, A/D is sampling
4071                                END_SERIAL_READ_SPLIT_4
4072   
4073                                ;       Binned by 5 waveforms
4074                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4075                                SERIAL_READ_LEFT_5
4076      Y:00026C Y:00026C                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
4077      Y:00026D Y:00026D                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
4078      Y:00026E Y:00026E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
4079      Y:00026F Y:00026F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
4080      Y:000270 Y:000270                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4081      Y:000271 Y:000271                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
4082                                SXMIT_LEFT_5
4083      Y:000272 Y:000272                   DC      $00F000                           ; Transmit A/D data to host
4084      Y:000273 Y:000273                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
4085      Y:000274 Y:000274                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4086      Y:000275 Y:000275                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
4087      Y:000276 Y:000276                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
4088      Y:000277 Y:000277                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4089      Y:000278 Y:000278                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
4090      Y:000279 Y:000279                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
4091      Y:00027A Y:00027A                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4092      Y:00027B Y:00027B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4093      Y:00027C Y:00027C                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
4094      Y:00027D Y:00027D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4095      Y:00027E Y:00027E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
4096      Y:00027F Y:00027F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
4097      Y:000280 Y:000280                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4098      Y:000281 Y:000281                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4099      Y:000282 Y:000282                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 72



4100      Y:000283 Y:000283                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4101      Y:000284 Y:000284                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
4102      Y:000285 Y:000285                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
4103      Y:000286 Y:000286                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4104      Y:000287 Y:000287                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4105      Y:000288 Y:000288                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
4106      Y:000289 Y:000289                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4107      Y:00028A Y:00028A                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
4108      Y:00028B Y:00028B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
4109      Y:00028C Y:00028C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4110      Y:00028D Y:00028D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4111      Y:00028E Y:00028E                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
4112      Y:00028F Y:00028F                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4113      Y:000290 Y:000290                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4114                                END_SERIAL_READ_LEFT_5
4115   
4116                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4117                                SERIAL_READ_RIGHT_5
4118      Y:000291 Y:000291                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
4119      Y:000292 Y:000292                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
4120      Y:000293 Y:000293                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
4121      Y:000294 Y:000294                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4122      Y:000295 Y:000295                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4123      Y:000296 Y:000296                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
4124                                SXMIT_RIGHT_5
4125                                ;       DC      $00F021                 ; Transmit A/D data to host
4126      Y:000297 Y:000297                   DC      $00F041                           ; Transmit A/D data to host
4127      Y:000298 Y:000298                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
4128      Y:000299 Y:000299                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4129      Y:00029A Y:00029A                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
4130      Y:00029B Y:00029B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
4131      Y:00029C Y:00029C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4132      Y:00029D Y:00029D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
4133      Y:00029E Y:00029E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4134      Y:00029F Y:00029F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4135      Y:0002A0 Y:0002A0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
4136      Y:0002A1 Y:0002A1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
4137      Y:0002A2 Y:0002A2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4138      Y:0002A3 Y:0002A3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
4139      Y:0002A4 Y:0002A4                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4140      Y:0002A5 Y:0002A5                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4141      Y:0002A6 Y:0002A6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
4142      Y:0002A7 Y:0002A7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
4143      Y:0002A8 Y:0002A8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4144      Y:0002A9 Y:0002A9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
4145      Y:0002AA Y:0002AA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4146      Y:0002AB Y:0002AB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4147      Y:0002AC Y:0002AC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
4148      Y:0002AD Y:0002AD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
4149      Y:0002AE Y:0002AE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4150      Y:0002AF Y:0002AF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
4151      Y:0002B0 Y:0002B0                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
4152      Y:0002B1 Y:0002B1                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4153      Y:0002B2 Y:0002B2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
4154      Y:0002B3 Y:0002B3                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
4155      Y:0002B4 Y:0002B4                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4156      Y:0002B5 Y:0002B5                   DC      VIDEO+$000000+INT_SMPL            ; Stop integrate, A/D is sampling
4157                                END_SERIAL_READ_RIGHT_5
4158   
4159                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4160                                SERIAL_READ_SPLIT_5
4161      Y:0002B6 Y:0002B6                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  GWAVES.waveforms.IMO.s  Page 73



4162      Y:0002B7 Y:0002B7                   DC      VIDEO+$000000+INT_INIT            ; Change nearly everything
4163      Y:0002B8 Y:0002B8                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
4164      Y:0002B9 Y:0002B9                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
4165      Y:0002BA Y:0002BA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4166      Y:0002BB Y:0002BB                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
4167                                SXMIT_SPLIT_5
4168                                ;       DC      $00F020                 ; Transmit A/D data to host
4169      Y:0002BC Y:0002BC                   DC      $00F040                           ; Transmit A/D data to host
4170      Y:0002BD Y:0002BD                   DC      VIDEO+$000000+INT_RSTOFF          ; Stop resetting integrator
4171      Y:0002BE Y:0002BE                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4172      Y:0002BF Y:0002BF                   DC      VIDEO+$000000+INT_STOP            ; Stop Integrate
4173      Y:0002C0 Y:0002C0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
4174      Y:0002C1 Y:0002C1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4175      Y:0002C2 Y:0002C2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
4176      Y:0002C3 Y:0002C3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
4177      Y:0002C4 Y:0002C4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4178      Y:0002C5 Y:0002C5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
4179      Y:0002C6 Y:0002C6                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
4180      Y:0002C7 Y:0002C7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4181      Y:0002C8 Y:0002C8                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
4182      Y:0002C9 Y:0002C9                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
4183      Y:0002CA Y:0002CA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4184      Y:0002CB Y:0002CB                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
4185      Y:0002CC Y:0002CC                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
4186      Y:0002CD Y:0002CD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4187      Y:0002CE Y:0002CE                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
4188      Y:0002CF Y:0002CF                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
4189      Y:0002D0 Y:0002D0                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4190      Y:0002D1 Y:0002D1                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
4191      Y:0002D2 Y:0002D2                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
4192      Y:0002D3 Y:0002D3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
4193      Y:0002D4 Y:0002D4                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
4194      Y:0002D5 Y:0002D5                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
4195      Y:0002D6 Y:0002D6                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
4196      Y:0002D7 Y:0002D7                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
4197      Y:0002D8 Y:0002D8                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
4198      Y:0002D9 Y:0002D9                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4199      Y:0002DA Y:0002DA                   DC      VIDEO+$000000+INT_SMPL            ; Stop integrate, A/D is sampling
4200                                END_SERIAL_READ_SPLIT_5
4201   
4202                                ; this small table is for writing the 2 dacs to control
4203                                ; the GWAVES SH and retro leds.
4204                                ; The values will be filled in via VRD2_V and VRD3_V
4205                                SET_VRD2_3
4206      Y:0002DB Y:0002DB                   DC      ENDSET_VRD2_3-SET_VRD2_3-1
4207      Y:0002DC Y:0002DC                   DC      VID0+DAC_ADDR+$000006             ; Vrd2, pin 35
4208      Y:0002DD Y:0002DD         VRD2_V    DC      VID0+DAC_RegD+0
4209      Y:0002DE Y:0002DE                   DC      VID0+DAC_ADDR+$000007             ; Vrd3, pin 14
4210      Y:0002DF Y:0002DF         VRD3_V    DC      VID0+DAC_RegD+0
4211                                ENDSET_VRD2_3
4212   
4213   
4214   
4215                                          ELSE
4217                                          ENDIF
4218   
4219                                 END_APPLICATON_Y_MEMORY
4220      0002E0                              EQU     @LCV(L)
4221   
4222                                ;  End of program
4223                                          END

Motorola DSP56300 Assembler  Version 6.2.23   118-02-21  17:24:12  tim.s  Page 74



0    Errors
0    Warnings


