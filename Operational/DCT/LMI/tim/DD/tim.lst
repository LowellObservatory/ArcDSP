Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  tim.s  Page 1



1                          ; This file is used to generate DSP code for the Gen III ARC-22/32/47
2                          ;    board set.
3                          ;
4                          ; This file contains two subroutines and X and Y data areas.  The two
5                          ; subroutines are RDCCD (with secondary entry point RCCD1) and CLOCK.
6                          ; These need to be in fast P memory.  The boot code and tim.s are there.
7                          ; tim.s includes timmisc.s, timCCDmisc.s and the waveforms file at the
8                          ; end.
9      
10                                   PAGE    132                               ; Printronix page width - 132 columns
11     
12                         ; Include a header file that defines global parameters
13     
14                                   INCLUDE "timboot.s"
15                         ;  This file is used to generate boot DSP code for the Gen III 250 MHz fiber
16                         ;       optic timing board = ARC22 using a DSP56303 as its main processor.
17     
18                         ; Various addressing control registers
19        FFFFFB           BCR       EQU     $FFFFFB                           ; Bus Control Register
20        FFFFF9           AAR0      EQU     $FFFFF9                           ; Address Attribute Register, channel 0
21        FFFFF8           AAR1      EQU     $FFFFF8                           ; Address Attribute Register, channel 1
22        FFFFF7           AAR2      EQU     $FFFFF7                           ; Address Attribute Register, channel 2
23        FFFFF6           AAR3      EQU     $FFFFF6                           ; Address Attribute Register, channel 3
24        FFFFFD           PCTL      EQU     $FFFFFD                           ; PLL control register
25        FFFFFE           IPRP      EQU     $FFFFFE                           ; Interrupt Priority register - Peripheral
26        FFFFFF           IPRC      EQU     $FFFFFF                           ; Interrupt Priority register - Core
27     
28                         ; Port E is the Synchronous Communications Interface (SCI) port
29        FFFF9F           PCRE      EQU     $FFFF9F                           ; Port Control Register
30        FFFF9E           PRRE      EQU     $FFFF9E                           ; Port Direction Register
31        FFFF9D           PDRE      EQU     $FFFF9D                           ; Port Data Register
32        FFFF9C           SCR       EQU     $FFFF9C                           ; SCI Control Register
33        FFFF9B           SCCR      EQU     $FFFF9B                           ; SCI Clock Control Register
34     
35        FFFF9A           SRXH      EQU     $FFFF9A                           ; SCI Receive Data Register, High byte
36        FFFF99           SRXM      EQU     $FFFF99                           ; SCI Receive Data Register, Middle byte
37        FFFF98           SRXL      EQU     $FFFF98                           ; SCI Receive Data Register, Low byte
38     
39        FFFF97           STXH      EQU     $FFFF97                           ; SCI Transmit Data register, High byte
40        FFFF96           STXM      EQU     $FFFF96                           ; SCI Transmit Data register, Middle byte
41        FFFF95           STXL      EQU     $FFFF95                           ; SCI Transmit Data register, Low byte
42     
43        FFFF94           STXA      EQU     $FFFF94                           ; SCI Transmit Address Register
44        FFFF93           SSR       EQU     $FFFF93                           ; SCI Status Register
45     
46        000009           SCITE     EQU     9                                 ; X:SCR bit set to enable the SCI transmitter
47        000008           SCIRE     EQU     8                                 ; X:SCR bit set to enable the SCI receiver
48        000000           TRNE      EQU     0                                 ; This is set in X:SSR when the transmitter
49                                                                             ;  shift and data registers are both empty
50        000001           TDRE      EQU     1                                 ; This is set in X:SSR when the transmitter
51                                                                             ;  data register is empty
52        000002           RDRF      EQU     2                                 ; X:SSR bit set when receiver register is full
53        00000F           SELSCI    EQU     15                                ; 1 for SCI to backplane, 0 to front connector
54     
55     
56                         ; ESSI Flags
57        000006           TDE       EQU     6                                 ; Set when transmitter data register is empty
58        000007           RDF       EQU     7                                 ; Set when receiver is full of data
59        000010           TE        EQU     16                                ; Transmitter enable
60     
61                         ; Phase Locked Loop initialization
62        050003           PLL_INIT  EQU     $050003                           ; PLL = 25 MHz x 2 = 100 MHz
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 2



63     
64                         ; Port B general purpose I/O
65        FFFFC4           HPCR      EQU     $FFFFC4                           ; Control register (bits 1-6 cleared for GPIO)
66        FFFFC9           HDR       EQU     $FFFFC9                           ; Data register
67        FFFFC8           HDDR      EQU     $FFFFC8                           ; Data Direction Register bits (=1 for output)
68     
69                         ; Port C is Enhanced Synchronous Serial Port 0 = ESSI0
70        FFFFBF           PCRC      EQU     $FFFFBF                           ; Port C Control Register
71        FFFFBE           PRRC      EQU     $FFFFBE                           ; Port C Data direction Register
72        FFFFBD           PDRC      EQU     $FFFFBD                           ; Port C GPIO Data Register
73        FFFFBC           TX00      EQU     $FFFFBC                           ; Transmit Data Register #0
74        FFFFB8           RX0       EQU     $FFFFB8                           ; Receive data register
75        FFFFB7           SSISR0    EQU     $FFFFB7                           ; Status Register
76        FFFFB6           CRB0      EQU     $FFFFB6                           ; Control Register B
77        FFFFB5           CRA0      EQU     $FFFFB5                           ; Control Register A
78     
79                         ; Port D is Enhanced Synchronous Serial Port 1 = ESSI1
80        FFFFAF           PCRD      EQU     $FFFFAF                           ; Port D Control Register
81        FFFFAE           PRRD      EQU     $FFFFAE                           ; Port D Data direction Register
82        FFFFAD           PDRD      EQU     $FFFFAD                           ; Port D GPIO Data Register
83        FFFFAC           TX10      EQU     $FFFFAC                           ; Transmit Data Register 0
84        FFFFA7           SSISR1    EQU     $FFFFA7                           ; Status Register
85        FFFFA6           CRB1      EQU     $FFFFA6                           ; Control Register B
86        FFFFA5           CRA1      EQU     $FFFFA5                           ; Control Register A
87     
88                         ; Timer module addresses
89        FFFF8F           TCSR0     EQU     $FFFF8F                           ; Timer control and status register
90        FFFF8E           TLR0      EQU     $FFFF8E                           ; Timer load register = 0
91        FFFF8D           TCPR0     EQU     $FFFF8D                           ; Timer compare register = exposure time
92        FFFF8C           TCR0      EQU     $FFFF8C                           ; Timer count register = elapsed time
93        FFFF83           TPLR      EQU     $FFFF83                           ; Timer prescaler load register => milliseconds
94        FFFF82           TPCR      EQU     $FFFF82                           ; Timer prescaler count register
95        000000           TIM_BIT   EQU     0                                 ; Set to enable the timer
96        000009           TRM       EQU     9                                 ; Set to enable the timer preloading
97        000015           TCF       EQU     21                                ; Set when timer counter = compare register
98     
99                         ; Board specific addresses and constants
100       FFFFF1           RDFO      EQU     $FFFFF1                           ; Read incoming fiber optic data byte
101       FFFFF2           WRFO      EQU     $FFFFF2                           ; Write fiber optic data replies
102       FFFFF3           WRSS      EQU     $FFFFF3                           ; Write switch state
103       FFFFF5           WRLATCH   EQU     $FFFFF5                           ; Write to a latch
104       010000           RDAD      EQU     $010000                           ; Read A/D values into the DSP
105       000009           EF        EQU     9                                 ; Serial receiver empty flag
106    
107                        ; DSP port A bit equates
108       000000           PWROK     EQU     0                                 ; Power control board says power is OK
109       000001           LED1      EQU     1                                 ; Control one of two LEDs
110       000002           LVEN      EQU     2                                 ; Low voltage power enable
111       000003           HVEN      EQU     3                                 ; High voltage power enable
112       00000E           SSFHF     EQU     14                                ; Switch state FIFO half full flag
113       00000A           EXT_IN0   EQU     10                                ; External digital I/O to the timing board
114       00000B           EXT_IN1   EQU     11
115       00000C           EXT_OUT0  EQU     12
116       00000D           EXT_OUT1  EQU     13
117    
118                        ; Port D equate
119       000001           SSFEF     EQU     1                                 ; Switch state FIFO empty flag
120    
121                        ; Other equates
122       000002           WRENA     EQU     2                                 ; Enable writing to the EEPROM
123    
124                        ; Latch U25 bit equates
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 3



125       000000           CDAC      EQU     0                                 ; Clear the analog board DACs
126       000002           ENCK      EQU     2                                 ; Enable the clock outputs
127       000004           SHUTTER   EQU     4                                 ; Control the shutter
128       000005           TIM_U_RST EQU     5                                 ; Reset the utility board
129    
130                        ; Software status bits, defined at X:<STATUS = X:0
131       000000           ST_RCV    EQU     0                                 ; Set to indicate word is from SCI = utility board
132       000002           IDLMODE   EQU     2                                 ; Set if need to idle after readout
133       000003           ST_SHUT   EQU     3                                 ; Set to indicate shutter is closed, clear for open
134       000004           ST_RDC    EQU     4                                 ; Set if executing 'RDC' command - reading out
135       000005           SPLIT_S   EQU     5                                 ; Set if split serial
136       000006           SPLIT_P   EQU     6                                 ; Set if split parallel
137       000007           MPP       EQU     7                                 ; Set if parallels are in MPP mode
138       000008           NOT_CLR   EQU     8                                 ; Set if not to clear CCD before exposure
139       00000A           TST_IMG   EQU     10                                ; Set if controller is to generate a test image
140       00000B           SHUT      EQU     11                                ; Set if opening shutter at beginning of exposure
141       00000C           ST_DITH   EQU     12                                ; Set if to dither during exposure
142       00000D           ST_SYNC   EQU     13                                ; Set if starting exposure on SYNC = high signal
143       00000E           ST_CNRD   EQU     14                                ; Set if in continous readout mode
144       00000F           ST_DIRTY  EQU     15                                ; Set if waveform tables need to be updated
145       000010           ST_SA     EQU     16                                ; Set if in subarray readout mode
146    
147                        ; Address for the table containing the incoming SCI words
148       000400           SCI_TABLE EQU     $400
149    
150    
151                        ; Specify controller configuration bits of the X:STATUS word
152                        ;   to describe the software capabilities of this application file
153                        ; The bit is set (=1) if the capability is supported by the controller
154    
155    
156                                COMMENT *
157    
158                        BIT #'s         FUNCTION
159                        2,1,0           Video Processor
160                                                000     ARC41, CCD Rev. 3
161                                                001     CCD Gen I
162                                                010     ARC42, dual readout CCD
163                                                011     ARC44, 4-readout IR coadder
164                                                100     ARC45. dual readout CCD
165                                                101     ARC46 = 8-channel IR
166                                                110     ARC48 = 8 channel CCD
167                                                111     ARC47 = 4-channel CCD
168    
169                        4,3             Timing Board
170                                                00      ARC20, Rev. 4, Gen II
171                                                01      Gen I
172                                                10      ARC22, Gen III, 250 MHz
173    
174                        6,5             Utility Board
175                                                00      No utility board
176                                                01      ARC50
177    
178                        7               Shutter
179                                                0       No shutter support
180                                                1       Yes shutter support
181    
182                        9,8             Temperature readout
183                                                00      No temperature readout
184                                                01      Polynomial Diode calibration
185                                                10      Linear temperature sensor calibration
186    
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 4



187                        10              Subarray readout
188                                                0       Not supported
189                                                1       Yes supported
190    
191                        11              Binning
192                                                0       Not supported
193                                                1       Yes supported
194    
195                        12              Split-Serial readout
196                                                0       Not supported
197                                                1       Yes supported
198    
199                        13              Split-Parallel readout
200                                                0       Not supported
201                                                1       Yes supported
202    
203                        14              MPP = Inverted parallel clocks
204                                                0       Not supported
205                                                1       Yes supported
206    
207                        16,15           Clock Driver Board
208                                                00      ARC30 or ARC31
209                                                01      ARC32, CCD and IR
210                                                11      No clock driver board (Gen I)
211    
212                        19,18,17                Special implementations
213                                                000     Somewhere else
214                                                001     Mount Laguna Observatory
215                                                010     NGST Aladdin
216                                                xxx     Other
217                                *
218    
219                        CCDVIDREV3B
220       000000                     EQU     $000000                           ; CCD Video Processor Rev. 3
221       000000           ARC41     EQU     $000000
222       000001           VIDGENI   EQU     $000001                           ; CCD Video Processor Gen I
223       000002           IRREV4    EQU     $000002                           ; IR Video Processor Rev. 4
224       000002           ARC42     EQU     $000002
225       000003           COADDER   EQU     $000003                           ; IR Coadder
226       000003           ARC44     EQU     $000003
227       000004           CCDVIDREV5 EQU    $000004                           ; Differential input CCD video Rev. 5
228       000004           ARC45     EQU     $000004
229       000005           ARC46     EQU     $000005                           ; 8-channel IR video board
230       000006           ARC48     EQU     $000006                           ; 8-channel CCD video board
231       000007           ARC47     EQU     $000007                           ; 4-channel CCD video board
232       000000           TIMREV4   EQU     $000000                           ; Timing Revision 4 = 50 MHz
233       000000           ARC20     EQU     $000000
234       000008           TIMGENI   EQU     $000008                           ; Timing Gen I = 40 MHz
235       000010           TIMREV5   EQU     $000010                           ; Timing Revision 5 = 250 MHz
236       000010           ARC22     EQU     $000010
237       008000           ARC32     EQU     $008000                           ; CCD & IR clock driver board
238       000020           UTILREV3  EQU     $000020                           ; Utility Rev. 3 supported
239       000020           ARC50     EQU     $000020
240       000080           SHUTTER_CC EQU    $000080                           ; Shutter supported
241       000100           TEMP_POLY EQU     $000100                           ; Polynomial calibration
242                        TEMP_LINEAR
243       000200                     EQU     $000200                           ; Linear calibration
244       000400           SUBARRAY  EQU     $000400                           ; Subarray readout supported
245       000800           BINNING   EQU     $000800                           ; Binning supported
246                        SPLIT_SERIAL
247       001000                     EQU     $001000                           ; Split serial supported
248                        SPLIT_PARALLEL
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 5



249       002000                     EQU     $002000                           ; Split parallel supported
250       004000           MPP_CC    EQU     $004000                           ; Inverted clocks supported
251       018000           CLKDRVGENI EQU    $018000                           ; No clock driver board - Gen I
252       020000           MLO       EQU     $020000                           ; Set if Mount Laguna Observatory
253       040000           NGST      EQU     $040000                           ; NGST Aladdin implementation
254       100000           CONT_RD   EQU     $100000                           ; Continuous readout implemented
255    
256                        ; Special address for two words for the DSP to bootstrap code from the EEPROM
257                                  IF      @SCP("HOST","ROM")
264                                  ENDIF
265    
266                                  IF      @SCP("HOST","HOST")
267       P:000000 P:000000                   ORG     P:0,P:0
268       P:000000 P:000000 0C0190            JMP     <INIT
269       P:000001 P:000001 000000            NOP
270                                           ENDIF
271    
272                                 ;  This ISR receives serial words a byte at a time over the asynchronous
273                                 ;    serial link (SCI) and squashes them into a single 24-bit word
274       P:000002 P:000002 602400  SCI_RCV   MOVE              R0,X:<SAVE_R0           ; Save R0
275       P:000003 P:000003 052139            MOVEC             SR,X:<SAVE_SR           ; Save Status Register
276       P:000004 P:000004 60A700            MOVE              X:<SCI_R0,R0            ; Restore R0 = pointer to SCI receive regist
er
277       P:000005 P:000005 542300            MOVE              A1,X:<SAVE_A1           ; Save A1
278       P:000006 P:000006 452200            MOVE              X1,X:<SAVE_X1           ; Save X1
279       P:000007 P:000007 54A600            MOVE              X:<SCI_A1,A1            ; Get SRX value of accumulator contents
280       P:000008 P:000008 45E000            MOVE              X:(R0),X1               ; Get the SCI byte
281       P:000009 P:000009 0AD041            BCLR    #1,R0                             ; Test for the address being $FFF6 = last by
te
282       P:00000A P:00000A 000000            NOP
283       P:00000B P:00000B 000000            NOP
284       P:00000C P:00000C 000000            NOP
285       P:00000D P:00000D 205862            OR      X1,A      (R0)+                   ; Add the byte into the 24-bit word
286       P:00000E P:00000E 0E0013            JCC     <MID_BYT                          ; Not the last byte => only restore register
s
287       P:00000F P:00000F 545C00  END_BYT   MOVE              A1,X:(R4)+              ; Put the 24-bit word into the SCI buffer
288       P:000010 P:000010 60F400            MOVE              #SRXL,R0                ; Re-establish first address of SCI interfac
e
                            FFFF98
289       P:000012 P:000012 2C0000            MOVE              #0,A1                   ; For zeroing out SCI_A1
290       P:000013 P:000013 602700  MID_BYT   MOVE              R0,X:<SCI_R0            ; Save the SCI receiver address
291       P:000014 P:000014 542600            MOVE              A1,X:<SCI_A1            ; Save A1 for next interrupt
292       P:000015 P:000015 05A139            MOVEC             X:<SAVE_SR,SR           ; Restore Status Register
293       P:000016 P:000016 54A300            MOVE              X:<SAVE_A1,A1           ; Restore A1
294       P:000017 P:000017 45A200            MOVE              X:<SAVE_X1,X1           ; Restore X1
295       P:000018 P:000018 60A400            MOVE              X:<SAVE_R0,R0           ; Restore R0
296       P:000019 P:000019 000004            RTI                                       ; Return from interrupt service
297    
298                                 ; Clear error condition and interrupt on SCI receiver
299       P:00001A P:00001A 077013  CLR_ERR   MOVEP             X:SSR,X:RCV_ERR         ; Read SCI status register
                            000025
300       P:00001C P:00001C 077018            MOVEP             X:SRXL,X:RCV_ERR        ; This clears any error
                            000025
301       P:00001E P:00001E 000004            RTI
302    
303       P:00001F P:00001F                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
304       P:000030 P:000030                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
305       P:000040 P:000040                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
306    
307                                 ; Tune the table so the following instruction is at P:$50 exactly.
308       P:000050 P:000050 0D0002            JSR     SCI_RCV                           ; SCI receive data interrupt
309       P:000051 P:000051 000000            NOP
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 6



310       P:000052 P:000052 0D001A            JSR     CLR_ERR                           ; SCI receive error interrupt
311       P:000053 P:000053 000000            NOP
312    
313                                 ; *******************  Command Processing  ******************
314    
315                                 ; Read the header and check it for self-consistency
316       P:000054 P:000054 609F00  START     MOVE              X:<IDL_ADR,R0
317       P:000055 P:000055 018FA0            JSET    #TIM_BIT,X:TCSR0,EXPOSING         ; If exposing go check the timer
                            00005A
318       P:000057 P:000057 0A00A4            JSET    #ST_RDC,X:<STATUS,CONTINUE_READING
                            00005A
319       P:000059 P:000059 0AE080            JMP     (R0)
320    
321       P:00005A P:00005A 330700  TST_RCV   MOVE              #<COM_BUF,R3
322       P:00005B P:00005B 0D00A5            JSR     <GET_RCV
323       P:00005C P:00005C 0E005B            JCC     *-1
324    
325                                 ; Check the header and read all the remaining words in the command
326       P:00005D P:00005D 0C00FF  PRC_RCV   JMP     <CHK_HDR                          ; Update HEADER and NWORDS
327       P:00005E P:00005E 578600  PR_RCV    MOVE              X:<NWORDS,B             ; Read this many words total in the command
328       P:00005F P:00005F 000000            NOP
329       P:000060 P:000060 01418C            SUB     #1,B                              ; We've already read the header
330       P:000061 P:000061 000000            NOP
331       P:000062 P:000062 06CF00            DO      B,RD_COM
                            00006A
332       P:000064 P:000064 205B00            MOVE              (R3)+                   ; Increment past what's been read already
333       P:000065 P:000065 0B0080  GET_WRD   JSCLR   #ST_RCV,X:STATUS,CHK_FO
                            0000A9
334       P:000067 P:000067 0B00A0            JSSET   #ST_RCV,X:STATUS,CHK_SCI
                            0000D5
335       P:000069 P:000069 0E0065            JCC     <GET_WRD
336       P:00006A P:00006A 000000            NOP
337       P:00006B P:00006B 330700  RD_COM    MOVE              #<COM_BUF,R3            ; Restore R3 = beginning of the command
338    
339                                 ; Is this command for the timing board?
340       P:00006C P:00006C 448500            MOVE              X:<HEADER,X0
341       P:00006D P:00006D 579B00            MOVE              X:<DMASK,B
342       P:00006E P:00006E 459A4E            AND     X0,B      X:<TIM_DRB,X1           ; Extract destination byte
343       P:00006F P:00006F 20006D            CMP     X1,B                              ; Does header = timing board number?
344       P:000070 P:000070 0EA080            JEQ     <COMMAND                          ; Yes, process it here
345       P:000071 P:000071 0E909D            JLT     <FO_XMT                           ; Send it to fiber optic transmitter
346    
347                                 ; Transmit the command to the utility board over the SCI port
348       P:000072 P:000072 060600            DO      X:<NWORDS,DON_XMT                 ; Transmit NWORDS
                            00007E
349       P:000074 P:000074 60F400            MOVE              #STXL,R0                ; SCI first byte address
                            FFFF95
350       P:000076 P:000076 44DB00            MOVE              X:(R3)+,X0              ; Get the 24-bit word to transmit
351       P:000077 P:000077 060380            DO      #3,SCI_SPT
                            00007D
352       P:000079 P:000079 019381            JCLR    #TDRE,X:SSR,*                     ; Continue ONLY if SCI XMT is empty
                            000079
353       P:00007B P:00007B 445800            MOVE              X0,X:(R0)+              ; Write to SCI, byte pointer + 1
354       P:00007C P:00007C 000000            NOP                                       ; Delay for the status flag to be set
355       P:00007D P:00007D 000000            NOP
356                                 SCI_SPT
357       P:00007E P:00007E 000000            NOP
358                                 DON_XMT
359       P:00007F P:00007F 0C0054            JMP     <START
360    
361                                 ; Process the receiver entry - is it in the command table ?
362       P:000080 P:000080 0203DF  COMMAND   MOVE              X:(R3+1),B              ; Get the command
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 7



363       P:000081 P:000081 205B00            MOVE              (R3)+
364       P:000082 P:000082 205B00            MOVE              (R3)+                   ; Point R3 to the first argument
365       P:000083 P:000083 302800            MOVE              #<COM_TBL,R0            ; Get the command table starting address
366       P:000084 P:000084 062080            DO      #NUM_COM,END_COM                  ; Loop over the command table
                            00008B
367       P:000086 P:000086 47D800            MOVE              X:(R0)+,Y1              ; Get the command table entry
368       P:000087 P:000087 62E07D            CMP     Y1,B      X:(R0),R2               ; Does receiver = table entries address?
369       P:000088 P:000088 0E208B            JNE     <NOT_COM                          ; No, keep looping
370       P:000089 P:000089 00008C            ENDDO                                     ; Restore the DO loop system registers
371       P:00008A P:00008A 0AE280            JMP     (R2)                              ; Jump execution to the command
372       P:00008B P:00008B 205800  NOT_COM   MOVE              (R0)+                   ; Increment the register past the table addr
ess
373                                 END_COM
374       P:00008C P:00008C 0C008D            JMP     <ERROR                            ; The command is not in the table
375    
376                                 ; It's not in the command table - send an error message
377       P:00008D P:00008D 479D00  ERROR     MOVE              X:<ERR,Y1               ; Send the message - there was an error
378       P:00008E P:00008E 0C0090            JMP     <FINISH1                          ; This protects against unknown commands
379    
380                                 ; Send a reply packet - header and reply
381       P:00008F P:00008F 479800  FINISH    MOVE              X:<DONE,Y1              ; Send 'DON' as the reply
382       P:000090 P:000090 578500  FINISH1   MOVE              X:<HEADER,B             ; Get header of incoming command
383       P:000091 P:000091 469C00            MOVE              X:<SMASK,Y0             ; This was the source byte, and is to
384       P:000092 P:000092 330700            MOVE              #<COM_BUF,R3            ;     become the destination byte
385       P:000093 P:000093 46935E            AND     Y0,B      X:<TWO,Y0
386       P:000094 P:000094 0C1ED1            LSR     #8,B                              ; Shift right eight bytes, add it to the
387       P:000095 P:000095 460600            MOVE              Y0,X:<NWORDS            ;     header, and put 2 as the number
388       P:000096 P:000096 469958            ADD     Y0,B      X:<SBRD,Y0              ;     of words in the string
389       P:000097 P:000097 200058            ADD     Y0,B                              ; Add source board's header, set Y1 for abov
e
390       P:000098 P:000098 000000            NOP
391       P:000099 P:000099 575B00            MOVE              B,X:(R3)+               ; Put the new header on the transmitter stac
k
392       P:00009A P:00009A 475B00            MOVE              Y1,X:(R3)+              ; Put the argument on the transmitter stack
393       P:00009B P:00009B 570500            MOVE              B,X:<HEADER
394       P:00009C P:00009C 0C006B            JMP     <RD_COM                           ; Decide where to send the reply, and do it
395    
396                                 ; Transmit words to the host computer over the fiber optics link
397       P:00009D P:00009D 63F400  FO_XMT    MOVE              #COM_BUF,R3
                            000007
398       P:00009F P:00009F 060600            DO      X:<NWORDS,DON_FFO                 ; Transmit all the words in the command
                            0000A3
399       P:0000A1 P:0000A1 57DB00            MOVE              X:(R3)+,B
400       P:0000A2 P:0000A2 0D00EB            JSR     <XMT_WRD
401       P:0000A3 P:0000A3 000000            NOP
402       P:0000A4 P:0000A4 0C0054  DON_FFO   JMP     <START
403    
404                                 ; Check for commands from the fiber optic FIFO and the utility board (SCI)
405       P:0000A5 P:0000A5 0D00A9  GET_RCV   JSR     <CHK_FO                           ; Check for fiber optic command from FIFO
406       P:0000A6 P:0000A6 0E80A8            JCS     <RCV_RTS                          ; If there's a command, check the header
407       P:0000A7 P:0000A7 0D00D5            JSR     <CHK_SCI                          ; Check for an SCI command
408       P:0000A8 P:0000A8 00000C  RCV_RTS   RTS
409    
410                                 ; Because of FIFO metastability require that EF be stable for two tests
411       P:0000A9 P:0000A9 0A8989  CHK_FO    JCLR    #EF,X:HDR,TST2                    ; EF = Low,  Low  => CLR SR, return
                            0000AC
412       P:0000AB P:0000AB 0C00AF            JMP     <TST3                             ;      High, Low  => try again
413       P:0000AC P:0000AC 0A8989  TST2      JCLR    #EF,X:HDR,CLR_CC                  ;      Low,  High => try again
                            0000D1
414       P:0000AE P:0000AE 0C00A9            JMP     <CHK_FO                           ;      High, High => read FIFO
415       P:0000AF P:0000AF 0A8989  TST3      JCLR    #EF,X:HDR,CHK_FO
                            0000A9
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 8



416    
417       P:0000B1 P:0000B1 08F4BB            MOVEP             #$028FE2,X:BCR          ; Slow down RDFO access
                            028FE2
418       P:0000B3 P:0000B3 000000            NOP
419       P:0000B4 P:0000B4 000000            NOP
420       P:0000B5 P:0000B5 5FF000            MOVE                          Y:RDFO,B
                            FFFFF1
421       P:0000B7 P:0000B7 2B0000            MOVE              #0,B2
422       P:0000B8 P:0000B8 0140CE            AND     #$FF,B
                            0000FF
423       P:0000BA P:0000BA 0140CD            CMP     #>$AC,B                           ; It must be $AC to be a valid word
                            0000AC
424       P:0000BC P:0000BC 0E20D1            JNE     <CLR_CC
425       P:0000BD P:0000BD 4EF000            MOVE                          Y:RDFO,Y0   ; Read the MS byte
                            FFFFF1
426       P:0000BF P:0000BF 0C1951            INSERT  #$008010,Y0,B
                            008010
427       P:0000C1 P:0000C1 4EF000            MOVE                          Y:RDFO,Y0   ; Read the middle byte
                            FFFFF1
428       P:0000C3 P:0000C3 0C1951            INSERT  #$008008,Y0,B
                            008008
429       P:0000C5 P:0000C5 4EF000            MOVE                          Y:RDFO,Y0   ; Read the LS byte
                            FFFFF1
430       P:0000C7 P:0000C7 0C1951            INSERT  #$008000,Y0,B
                            008000
431       P:0000C9 P:0000C9 000000            NOP
432       P:0000CA P:0000CA 516300            MOVE              B0,X:(R3)               ; Put the word into COM_BUF
433       P:0000CB P:0000CB 0A0000            BCLR    #ST_RCV,X:<STATUS                 ; Its a command from the host computer
434       P:0000CC P:0000CC 000000  SET_CC    NOP
435       P:0000CD P:0000CD 0AF960            BSET    #0,SR                             ; Valid word => SR carry bit = 1
436       P:0000CE P:0000CE 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
437       P:0000D0 P:0000D0 00000C            RTS
438       P:0000D1 P:0000D1 0AF940  CLR_CC    BCLR    #0,SR                             ; Not valid word => SR carry bit = 0
439       P:0000D2 P:0000D2 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
440       P:0000D4 P:0000D4 00000C            RTS
441    
442                                 ; Test the SCI (= synchronous communications interface) for new words
443       P:0000D5 P:0000D5 44F000  CHK_SCI   MOVE              X:(SCI_TABLE+33),X0
                            000421
444       P:0000D7 P:0000D7 228E00            MOVE              R4,A
445       P:0000D8 P:0000D8 209000            MOVE              X0,R0
446       P:0000D9 P:0000D9 200045            CMP     X0,A
447       P:0000DA P:0000DA 0EA0D1            JEQ     <CLR_CC                           ; There is no new SCI word
448       P:0000DB P:0000DB 44D800            MOVE              X:(R0)+,X0
449       P:0000DC P:0000DC 446300            MOVE              X0,X:(R3)
450       P:0000DD P:0000DD 220E00            MOVE              R0,A
451       P:0000DE P:0000DE 0140C5            CMP     #(SCI_TABLE+32),A                 ; Wrap it around the circular
                            000420
452       P:0000E0 P:0000E0 0EA0E4            JEQ     <INIT_PROCESSED_SCI               ;   buffer boundary
453       P:0000E1 P:0000E1 547000            MOVE              A1,X:(SCI_TABLE+33)
                            000421
454       P:0000E3 P:0000E3 0C00E9            JMP     <SCI_END
455                                 INIT_PROCESSED_SCI
456       P:0000E4 P:0000E4 56F400            MOVE              #SCI_TABLE,A
                            000400
457       P:0000E6 P:0000E6 000000            NOP
458       P:0000E7 P:0000E7 567000            MOVE              A,X:(SCI_TABLE+33)
                            000421
459       P:0000E9 P:0000E9 0A0020  SCI_END   BSET    #ST_RCV,X:<STATUS                 ; Its a utility board (SCI) word
460       P:0000EA P:0000EA 0C00CC            JMP     <SET_CC
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 9



461    
462                                 ; Transmit the word in B1 to the host computer over the fiber optic data link
463                                 XMT_WRD
464       P:0000EB P:0000EB 08F4BB            MOVEP             #$028FE2,X:BCR          ; Slow down RDFO access
                            028FE2
465       P:0000ED P:0000ED 60F400            MOVE              #FO_HDR+1,R0
                            000002
466       P:0000EF P:0000EF 060380            DO      #3,XMT_WRD1
                            0000F3
467       P:0000F1 P:0000F1 0C1D91            ASL     #8,B,B
468       P:0000F2 P:0000F2 000000            NOP
469       P:0000F3 P:0000F3 535800            MOVE              B2,X:(R0)+
470                                 XMT_WRD1
471       P:0000F4 P:0000F4 60F400            MOVE              #FO_HDR,R0
                            000001
472       P:0000F6 P:0000F6 61F400            MOVE              #WRFO,R1
                            FFFFF2
473       P:0000F8 P:0000F8 060480            DO      #4,XMT_WRD2
                            0000FB
474       P:0000FA P:0000FA 46D800            MOVE              X:(R0)+,Y0              ; Should be MOVEP  X:(R0)+,Y:WRFO
475       P:0000FB P:0000FB 4E6100            MOVE                          Y0,Y:(R1)
476                                 XMT_WRD2
477       P:0000FC P:0000FC 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
478       P:0000FE P:0000FE 00000C            RTS
479    
480                                 ; Check the command or reply header in X:(R3) for self-consistency
481       P:0000FF P:0000FF 46E300  CHK_HDR   MOVE              X:(R3),Y0
482       P:000100 P:000100 579600            MOVE              X:<MASK1,B              ; Test for S.LE.3 and D.LE.3 and N.LE.7
483       P:000101 P:000101 20005E            AND     Y0,B
484       P:000102 P:000102 0E208D            JNE     <ERROR                            ; Test failed
485       P:000103 P:000103 579700            MOVE              X:<MASK2,B              ; Test for either S.NE.0 or D.NE.0
486       P:000104 P:000104 20005E            AND     Y0,B
487       P:000105 P:000105 0EA08D            JEQ     <ERROR                            ; Test failed
488       P:000106 P:000106 579500            MOVE              X:<SEVEN,B
489       P:000107 P:000107 20005E            AND     Y0,B                              ; Extract NWORDS, must be > 0
490       P:000108 P:000108 0EA08D            JEQ     <ERROR
491       P:000109 P:000109 44E300            MOVE              X:(R3),X0
492       P:00010A P:00010A 440500            MOVE              X0,X:<HEADER            ; Its a correct header
493       P:00010B P:00010B 550600            MOVE              B1,X:<NWORDS            ; Number of words in the command
494       P:00010C P:00010C 0C005E            JMP     <PR_RCV
495    
496                                 ;  *****************  Boot Commands  *******************
497    
498                                 ; Test Data Link - simply return value received after 'TDL'
499       P:00010D P:00010D 47DB00  TDL       MOVE              X:(R3)+,Y1              ; Get the data value
500       P:00010E P:00010E 0C0090            JMP     <FINISH1                          ; Return from executing TDL command
501    
502                                 ; Read DSP or EEPROM memory ('RDM' address): read memory, reply with value
503       P:00010F P:00010F 47DB00  RDMEM     MOVE              X:(R3)+,Y1
504       P:000110 P:000110 20EF00            MOVE              Y1,B
505       P:000111 P:000111 0140CE            AND     #$0FFFFF,B                        ; Bits 23-20 need to be zeroed
                            0FFFFF
506       P:000113 P:000113 21B000            MOVE              B1,R0                   ; Need the address in an address register
507       P:000114 P:000114 20EF00            MOVE              Y1,B
508       P:000115 P:000115 000000            NOP
509       P:000116 P:000116 0ACF14            JCLR    #20,B,RDX                         ; Test address bit for Program memory
                            00011A
510       P:000118 P:000118 07E087            MOVE              P:(R0),Y1               ; Read from Program Memory
511       P:000119 P:000119 0C0090            JMP     <FINISH1                          ; Send out a header with the value
512       P:00011A P:00011A 0ACF15  RDX       JCLR    #21,B,RDY                         ; Test address bit for X: memory
                            00011E
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 10



513       P:00011C P:00011C 47E000            MOVE              X:(R0),Y1               ; Write to X data memory
514       P:00011D P:00011D 0C0090            JMP     <FINISH1                          ; Send out a header with the value
515       P:00011E P:00011E 0ACF16  RDY       JCLR    #22,B,RDR                         ; Test address bit for Y: memory
                            000122
516       P:000120 P:000120 4FE000            MOVE                          Y:(R0),Y1   ; Read from Y data memory
517       P:000121 P:000121 0C0090            JMP     <FINISH1                          ; Send out a header with the value
518       P:000122 P:000122 0ACF17  RDR       JCLR    #23,B,ERROR                       ; Test address bit for read from EEPROM memo
ry
                            00008D
519       P:000124 P:000124 479400            MOVE              X:<THREE,Y1             ; Convert to word address to a byte address
520       P:000125 P:000125 220600            MOVE              R0,Y0                   ; Get 16-bit address in a data register
521       P:000126 P:000126 2000B8            MPY     Y0,Y1,B                           ; Multiply
522       P:000127 P:000127 20002A            ASR     B                                 ; Eliminate zero fill of fractional multiply
523       P:000128 P:000128 213000            MOVE              B0,R0                   ; Need to address memory
524       P:000129 P:000129 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
525       P:00012A P:00012A 0D0178            JSR     <RD_WORD                          ; Read word from EEPROM
526       P:00012B P:00012B 21A700            MOVE              B1,Y1                   ; FINISH1 transmits Y1 as its reply
527       P:00012C P:00012C 0C0090            JMP     <FINISH1
528    
529                                 ; Program WRMEM ('WRM' address datum): write to memory, reply 'DON'.
530       P:00012D P:00012D 47DB00  WRMEM     MOVE              X:(R3)+,Y1              ; Get the address to be written to
531       P:00012E P:00012E 20EF00            MOVE              Y1,B
532       P:00012F P:00012F 0140CE            AND     #$0FFFFF,B                        ; Bits 23-20 need to be zeroed
                            0FFFFF
533       P:000131 P:000131 21B000            MOVE              B1,R0                   ; Need the address in an address register
534       P:000132 P:000132 20EF00            MOVE              Y1,B
535       P:000133 P:000133 46DB00            MOVE              X:(R3)+,Y0              ; Get datum into Y0 so MOVE works easily
536       P:000134 P:000134 0ACF14            JCLR    #20,B,WRX                         ; Test address bit for Program memory
                            000138
537       P:000136 P:000136 076086            MOVE              Y0,P:(R0)               ; Write to Program memory
538       P:000137 P:000137 0C008F            JMP     <FINISH
539       P:000138 P:000138 0ACF15  WRX       JCLR    #21,B,WRY                         ; Test address bit for X: memory
                            00013C
540       P:00013A P:00013A 466000            MOVE              Y0,X:(R0)               ; Write to X: memory
541       P:00013B P:00013B 0C008F            JMP     <FINISH
542       P:00013C P:00013C 0ACF16  WRY       JCLR    #22,B,WRR                         ; Test address bit for Y: memory
                            000140
543       P:00013E P:00013E 4E6000            MOVE                          Y0,Y:(R0)   ; Write to Y: memory
544       P:00013F P:00013F 0C008F            JMP     <FINISH
545       P:000140 P:000140 0ACF17  WRR       JCLR    #23,B,ERROR                       ; Test address bit for write to EEPROM
                            00008D
546       P:000142 P:000142 013D02            BCLR    #WRENA,X:PDRC                     ; WR_ENA* = 0 to enable EEPROM writing
547       P:000143 P:000143 460E00            MOVE              Y0,X:<SV_A1             ; Save the datum to be written
548       P:000144 P:000144 479400            MOVE              X:<THREE,Y1             ; Convert word address to a byte address
549       P:000145 P:000145 220600            MOVE              R0,Y0                   ; Get 16-bit address in a data register
550       P:000146 P:000146 2000B8            MPY     Y1,Y0,B                           ; Multiply
551       P:000147 P:000147 20002A            ASR     B                                 ; Eliminate zero fill of fractional multiply
552       P:000148 P:000148 213000            MOVE              B0,R0                   ; Need to address memory
553       P:000149 P:000149 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
554       P:00014A P:00014A 558E00            MOVE              X:<SV_A1,B1             ; Get the datum to be written
555       P:00014B P:00014B 060380            DO      #3,L1WRR                          ; Loop over three bytes of the word
                            000154
556       P:00014D P:00014D 07588D            MOVE              B1,P:(R0)+              ; Write each EEPROM byte
557       P:00014E P:00014E 0C1C91            ASR     #8,B,B
558       P:00014F P:00014F 469E00            MOVE              X:<C100K,Y0             ; Move right one byte, enter delay = 1 msec
559       P:000150 P:000150 06C600            DO      Y0,L2WRR                          ; Delay by 12 milliseconds for EEPROM write
                            000153
560       P:000152 P:000152 060CA0            REP     #12                               ; Assume 100 MHz DSP56303
561       P:000153 P:000153 000000            NOP
562                                 L2WRR
563       P:000154 P:000154 000000            NOP                                       ; DO loop nesting restriction
564                                 L1WRR
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 11



565       P:000155 P:000155 013D22            BSET    #WRENA,X:PDRC                     ; WR_ENA* = 1 to disable EEPROM writing
566       P:000156 P:000156 0C008F            JMP     <FINISH
567    
568                                 ; Load application code from P: memory into its proper locations
569       P:000157 P:000157 47DB00  LDAPPL    MOVE              X:(R3)+,Y1              ; Application number, not used yet
570       P:000158 P:000158 0D015A            JSR     <LOAD_APPLICATION
571       P:000159 P:000159 0C008F            JMP     <FINISH
572    
573                                 LOAD_APPLICATION
574       P:00015A P:00015A 60F400            MOVE              #$8000,R0               ; Starting EEPROM address
                            008000
575       P:00015C P:00015C 0D0178            JSR     <RD_WORD                          ; Number of words in boot code
576       P:00015D P:00015D 21A600            MOVE              B1,Y0
577       P:00015E P:00015E 479400            MOVE              X:<THREE,Y1
578       P:00015F P:00015F 2000B8            MPY     Y0,Y1,B
579       P:000160 P:000160 20002A            ASR     B
580       P:000161 P:000161 213000            MOVE              B0,R0                   ; EEPROM address of start of P: application
581       P:000162 P:000162 0AD06F            BSET    #15,R0                            ; To access EEPROM
582       P:000163 P:000163 0D0178            JSR     <RD_WORD                          ; Read number of words in application P:
583       P:000164 P:000164 61F400            MOVE              #(X_BOOT_START+1),R1    ; End of boot P: code that needs keeping
                            00022B
584       P:000166 P:000166 06CD00            DO      B1,RD_APPL_P
                            000169
585       P:000168 P:000168 0D0178            JSR     <RD_WORD
586       P:000169 P:000169 07598D            MOVE              B1,P:(R1)+
587                                 RD_APPL_P
588       P:00016A P:00016A 0D0178            JSR     <RD_WORD                          ; Read number of words in application X:
589       P:00016B P:00016B 61F400            MOVE              #END_COMMAND_TABLE,R1
                            000036
590       P:00016D P:00016D 06CD00            DO      B1,RD_APPL_X
                            000170
591       P:00016F P:00016F 0D0178            JSR     <RD_WORD
592       P:000170 P:000170 555900            MOVE              B1,X:(R1)+
593                                 RD_APPL_X
594       P:000171 P:000171 0D0178            JSR     <RD_WORD                          ; Read number of words in application Y:
595       P:000172 P:000172 310100            MOVE              #1,R1                   ; There is no Y: memory in the boot code
596       P:000173 P:000173 06CD00            DO      B1,RD_APPL_Y
                            000176
597       P:000175 P:000175 0D0178            JSR     <RD_WORD
598       P:000176 P:000176 5D5900            MOVE                          B1,Y:(R1)+
599                                 RD_APPL_Y
600       P:000177 P:000177 00000C            RTS
601    
602                                 ; Read one word from EEPROM location R0 into accumulator B1
603       P:000178 P:000178 060380  RD_WORD   DO      #3,L_RDBYTE
                            00017B
604       P:00017A P:00017A 07D88B            MOVE              P:(R0)+,B2
605       P:00017B P:00017B 0C1C91            ASR     #8,B,B
606                                 L_RDBYTE
607       P:00017C P:00017C 00000C            RTS
608    
609                                 ; Come to here on a 'STP' command so 'DON' can be sent
610                                 STOP_IDLE_CLOCKING
611       P:00017D P:00017D 305A00            MOVE              #<TST_RCV,R0            ; Execution address when idle => when not
612       P:00017E P:00017E 601F00            MOVE              R0,X:<IDL_ADR           ;   processing commands or reading out
613       P:00017F P:00017F 0A0002            BCLR    #IDLMODE,X:<STATUS                ; Don't idle after readout
614       P:000180 P:000180 0C008F            JMP     <FINISH
615    
616                                 ; Routines executed after the DSP boots and initializes
617       P:000181 P:000181 305A00  STARTUP   MOVE              #<TST_RCV,R0            ; Execution address when idle => when not
618       P:000182 P:000182 601F00            MOVE              R0,X:<IDL_ADR           ;   processing commands or reading out
619       P:000183 P:000183 44F400            MOVE              #50000,X0               ; Delay by 500 milliseconds
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 12



                            00C350
620       P:000185 P:000185 06C400            DO      X0,L_DELAY
                            000188
621       P:000187 P:000187 06E8A3            REP     #1000
622       P:000188 P:000188 000000            NOP
623                                 L_DELAY
624       P:000189 P:000189 57F400            MOVE              #$020002,B              ; Normal reply after booting is 'SYR'
                            020002
625       P:00018B P:00018B 0D00EB            JSR     <XMT_WRD
626       P:00018C P:00018C 57F400            MOVE              #'SYR',B
                            535952
627       P:00018E P:00018E 0D00EB            JSR     <XMT_WRD
628    
629       P:00018F P:00018F 0C0054            JMP     <START                            ; Start normal command processing
630    
631                                 ; *******************  DSP  INITIALIZATION  CODE  **********************
632                                 ; This code initializes the DSP right after booting, and is overwritten
633                                 ;   by application code
634       P:000190 P:000190 08F4BD  INIT      MOVEP             #PLL_INIT,X:PCTL        ; Initialize PLL to 100 MHz
                            050003
635       P:000192 P:000192 000000            NOP
636    
637                                 ; Set operation mode register OMR to normal expanded
638       P:000193 P:000193 0500BA            MOVEC             #$0000,OMR              ; Operating Mode Register = Normal Expanded
639       P:000194 P:000194 0500BB            MOVEC             #0,SP                   ; Reset the Stack Pointer SP
640    
641                                 ; Program the AA = address attribute pins
642       P:000195 P:000195 08F4B9            MOVEP             #$FFFC21,X:AAR0         ; Y = $FFF000 to $FFFFFF asserts commands
                            FFFC21
643       P:000197 P:000197 08F4B8            MOVEP             #$008909,X:AAR1         ; P = $008000 to $00FFFF accesses the EEPROM
                            008909
644       P:000199 P:000199 08F4B7            MOVEP             #$010C11,X:AAR2         ; X = $010000 to $010FFF reads A/D values
                            010C11
645       P:00019B P:00019B 08F4B6            MOVEP             #$080621,X:AAR3         ; Y = $080000 to $0BFFFF R/W from SRAM
                            080621
646    
647       P:00019D P:00019D 0A0F00            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
648       P:00019E P:00019E 0A0F02            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
649       P:00019F P:00019F 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                            00000F
650    
651                                 ; Program the DRAM memory access and addressing
652       P:0001A1 P:0001A1 08F4BB            MOVEP             #$028FE1,X:BCR          ; Bus Control Register
                            028FE1
653    
654                                 ; Program the Host port B for parallel I/O
655       P:0001A3 P:0001A3 08F484            MOVEP             #>1,X:HPCR              ; All pins enabled as GPIO
                            000001
656       P:0001A5 P:0001A5 08F489            MOVEP             #$810C,X:HDR
                            00810C
657       P:0001A7 P:0001A7 08F488            MOVEP             #$B10E,X:HDDR           ; Data Direction Register
                            00B10E
658                                                                                     ;  (1 for Output, 0 for Input)
659    
660                                 ; Port B conversion from software bits to schematic labels
661                                 ;       PB0 = PWROK             PB08 = PRSFIFO*
662                                 ;       PB1 = LED1              PB09 = EF*
663                                 ;       PB2 = LVEN              PB10 = EXT-IN0
664                                 ;       PB3 = HVEN              PB11 = EXT-IN1
665                                 ;       PB4 = STATUS0           PB12 = EXT-OUT0
666                                 ;       PB5 = STATUS1           PB13 = EXT-OUT1
667                                 ;       PB6 = STATUS2           PB14 = SSFHF*
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 13



668                                 ;       PB7 = STATUS3           PB15 = SELSCI
669    
670                                 ; Program the serial port ESSI0 = Port C for serial communication with
671                                 ;   the utility board
672       P:0001A9 P:0001A9 07F43F            MOVEP             #>0,X:PCRC              ; Software reset of ESSI0
                            000000
673       P:0001AB P:0001AB 07F435            MOVEP             #$180809,X:CRA0         ; Divide 100 MHz by 20 to get 5.0 MHz
                            180809
674                                                                                     ; DC[4:0] = 0 for non-network operation
675                                                                                     ; WL0-WL2 = 3 for 24-bit data words
676                                                                                     ; SSC1 = 0 for SC1 not used
677       P:0001AD P:0001AD 07F436            MOVEP             #$020020,X:CRB0         ; SCKD = 1 for internally generated clock
                            020020
678                                                                                     ; SCD2 = 0 so frame sync SC2 is an output
679                                                                                     ; SHFD = 0 for MSB shifted first
680                                                                                     ; FSL = 0, frame sync length not used
681                                                                                     ; CKP = 0 for rising clock edge transitions
682                                                                                     ; SYN = 0 for asynchronous
683                                                                                     ; TE0 = 1 to enable transmitter #0
684                                                                                     ; MOD = 0 for normal, non-networked mode
685                                                                                     ; TE0 = 0 to NOT enable transmitter #0 yet
686                                                                                     ; RE = 1 to enable receiver
687       P:0001AF P:0001AF 07F43F            MOVEP             #%111001,X:PCRC         ; Control Register (0 for GPIO, 1 for ESSI)
                            000039
688       P:0001B1 P:0001B1 07F43E            MOVEP             #%000110,X:PRRC         ; Data Direction Register (0 for In, 1 for O
ut)
                            000006
689       P:0001B3 P:0001B3 07F43D            MOVEP             #%000100,X:PDRC         ; Data Register - WR_ENA* = 1
                            000004
690    
691                                 ; Port C version = Analog boards
692                                 ;       MOVEP   #$000809,X:CRA0 ; Divide 100 MHz by 20 to get 5.0 MHz
693                                 ;       MOVEP   #$000030,X:CRB0 ; SCKD = 1 for internally generated clock
694                                 ;       MOVEP   #%100000,X:PCRC ; Control Register (0 for GPIO, 1 for ESSI)
695                                 ;       MOVEP   #%000100,X:PRRC ; Data Direction Register (0 for In, 1 for Out)
696                                 ;       MOVEP   #%000000,X:PDRC ; Data Register: 'not used' = 0 outputs
697    
698       P:0001B5 P:0001B5 07F43C            MOVEP             #0,X:TX00               ; Initialize the transmitter to zero
                            000000
699       P:0001B7 P:0001B7 000000            NOP
700       P:0001B8 P:0001B8 000000            NOP
701       P:0001B9 P:0001B9 013630            BSET    #TE,X:CRB0                        ; Enable the SSI transmitter
702    
703                                 ; Conversion from software bits to schematic labels for Port C
704                                 ;       PC0 = SC00 = UTL-T-SCK
705                                 ;       PC1 = SC01 = 2_XMT = SYNC on prototype
706                                 ;       PC2 = SC02 = WR_ENA*
707                                 ;       PC3 = SCK0 = TIM-U-SCK
708                                 ;       PC4 = SRD0 = UTL-T-STD
709                                 ;       PC5 = STD0 = TIM-U-STD
710    
711                                 ; Program the serial port ESSI1 = Port D for serial transmission to
712                                 ;   the analog boards and two parallel I/O input pins
713       P:0001BA P:0001BA 07F42F            MOVEP             #>0,X:PCRD              ; Software reset of ESSI0
                            000000
714       P:0001BC P:0001BC 07F425            MOVEP             #$000809,X:CRA1         ; Divide 100 MHz by 20 to get 5.0 MHz
                            000809
715                                                                                     ; DC[4:0] = 0
716                                                                                     ; WL[2:0] = ALC = 0 for 8-bit data words
717                                                                                     ; SSC1 = 0 for SC1 not used
718       P:0001BE P:0001BE 07F426            MOVEP             #$000030,X:CRB1         ; SCKD = 1 for internally generated clock
                            000030
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 14



719                                                                                     ; SCD2 = 1 so frame sync SC2 is an output
720                                                                                     ; SHFD = 0 for MSB shifted first
721                                                                                     ; CKP = 0 for rising clock edge transitions
722                                                                                     ; TE0 = 0 to NOT enable transmitter #0 yet
723                                                                                     ; MOD = 0 so its not networked mode
724       P:0001C0 P:0001C0 07F42F            MOVEP             #%100000,X:PCRD         ; Control Register (0 for GPIO, 1 for ESSI)
                            000020
725                                                                                     ; PD3 = SCK1, PD5 = STD1 for ESSI
726       P:0001C2 P:0001C2 07F42E            MOVEP             #%000100,X:PRRD         ; Data Direction Register (0 for In, 1 for O
ut)
                            000004
727       P:0001C4 P:0001C4 07F42D            MOVEP             #%000100,X:PDRD         ; Data Register: 'not used' = 0 outputs
                            000004
728       P:0001C6 P:0001C6 07F42C            MOVEP             #0,X:TX10               ; Initialize the transmitter to zero
                            000000
729       P:0001C8 P:0001C8 000000            NOP
730       P:0001C9 P:0001C9 000000            NOP
731       P:0001CA P:0001CA 012630            BSET    #TE,X:CRB1                        ; Enable the SSI transmitter
732    
733                                 ; Conversion from software bits to schematic labels for Port D
734                                 ; PD0 = SC10 = 2_XMT_? input
735                                 ; PD1 = SC11 = SSFEF* input
736                                 ; PD2 = SC12 = PWR_EN
737                                 ; PD3 = SCK1 = TIM-A-SCK
738                                 ; PD4 = SRD1 = PWRRST
739                                 ; PD5 = STD1 = TIM-A-STD
740    
741                                 ; Program the SCI port to communicate with the utility board
742       P:0001CB P:0001CB 07F41C            MOVEP             #$0B04,X:SCR            ; SCI programming: 11-bit asynchronous
                            000B04
743                                                                                     ;   protocol (1 start, 8 data, 1 even parity
,
744                                                                                     ;   1 stop); LSB before MSB; enable receiver
745                                                                                     ;   and its interrupts; transmitter interrup
ts
746                                                                                     ;   disabled.
747       P:0001CD P:0001CD 07F41B            MOVEP             #$0003,X:SCCR           ; SCI clock: utility board data rate =
                            000003
748                                                                                     ;   (390,625 kbits/sec); internal clock.
749       P:0001CF P:0001CF 07F41F            MOVEP             #%011,X:PCRE            ; Port Control Register = RXD, TXD enabled
                            000003
750       P:0001D1 P:0001D1 07F41E            MOVEP             #%000,X:PRRE            ; Port Direction Register (0 = Input)
                            000000
751    
752                                 ;       PE0 = RXD
753                                 ;       PE1 = TXD
754                                 ;       PE2 = SCLK
755    
756                                 ; Program one of the three timers as an exposure timer
757       P:0001D3 P:0001D3 07F403            MOVEP             #$C34F,X:TPLR           ; Prescaler to generate millisecond timer,
                            00C34F
758                                                                                     ;  counting from the system clock / 2 = 50 M
Hz
759       P:0001D5 P:0001D5 07F40F            MOVEP             #$208200,X:TCSR0        ; Clear timer complete bit and enable presca
ler
                            208200
760       P:0001D7 P:0001D7 07F40E            MOVEP             #0,X:TLR0               ; Timer load register
                            000000
761    
762                                 ; Enable interrupts for the SCI port only
763       P:0001D9 P:0001D9 08F4BF            MOVEP             #$000000,X:IPRC         ; No interrupts allowed
                            000000
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 15



764       P:0001DB P:0001DB 08F4BE            MOVEP             #>$80,X:IPRP            ; Enable SCI interrupt only, IPR = 1
                            000080
765       P:0001DD P:0001DD 00FCB8            ANDI    #$FC,MR                           ; Unmask all interrupt levels
766    
767                                 ; Initialize the fiber optic serial receiver circuitry
768       P:0001DE P:0001DE 061480            DO      #20,L_FO_INIT
                            0001E3
769       P:0001E0 P:0001E0 5FF000            MOVE                          Y:RDFO,B
                            FFFFF1
770       P:0001E2 P:0001E2 0605A0            REP     #5
771       P:0001E3 P:0001E3 000000            NOP
772                                 L_FO_INIT
773    
774                                 ; Pulse PRSFIFO* low to revive the CMDRST* instruction and reset the FIFO
775       P:0001E4 P:0001E4 44F400            MOVE              #1000000,X0             ; Delay by 10 milliseconds
                            0F4240
776       P:0001E6 P:0001E6 06C400            DO      X0,*+3
                            0001E8
777       P:0001E8 P:0001E8 000000            NOP
778       P:0001E9 P:0001E9 0A8908            BCLR    #8,X:HDR
779       P:0001EA P:0001EA 0614A0            REP     #20
780       P:0001EB P:0001EB 000000            NOP
781       P:0001EC P:0001EC 0A8928            BSET    #8,X:HDR
782    
783                                 ; Reset the utility board
784       P:0001ED P:0001ED 0A0F05            BCLR    #5,X:<LATCH
785       P:0001EE P:0001EE 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Clear reset utility board bit
                            00000F
786       P:0001F0 P:0001F0 06C8A0            REP     #200                              ; Delay by RESET* low time
787       P:0001F1 P:0001F1 000000            NOP
788       P:0001F2 P:0001F2 0A0F25            BSET    #5,X:<LATCH
789       P:0001F3 P:0001F3 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Clear reset utility board bit
                            00000F
790       P:0001F5 P:0001F5 56F400            MOVE              #200000,A               ; Delay 2 msec for utility boot
                            030D40
791       P:0001F7 P:0001F7 06CE00            DO      A,*+3
                            0001F9
792       P:0001F9 P:0001F9 000000            NOP
793    
794                                 ; Put all the analog switch inputs to low so they draw minimum current
795       P:0001FA P:0001FA 012F23            BSET    #3,X:PCRD                         ; Turn the serial clock on
796       P:0001FB P:0001FB 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                            0C3000
797       P:0001FD P:0001FD 20001B            CLR     B
798       P:0001FE P:0001FE 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC write
s
799       P:0001FF P:0001FF 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writ
es
                            001000
800       P:000201 P:000201 060F80            DO      #15,L_ANALOG                      ; Fifteen video processor boards maximum
                            000209
801       P:000203 P:000203 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
802       P:000204 P:000204 200040            ADD     X0,A
803       P:000205 P:000205 5F7000            MOVE                          B,Y:WRSS    ; This is for the fast analog switches
                            FFFFF3
804       P:000207 P:000207 0620A3            REP     #800                              ; Delay for the serial data transmission
805       P:000208 P:000208 000000            NOP
806       P:000209 P:000209 200068            ADD     X1,B                              ; Increment the video and clock driver numbe
rs
807                                 L_ANALOG
808       P:00020A P:00020A 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
809       P:00020B P:00020B 0C0223            JMP     <SKIP
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 16



810    
811                                 ; Transmit contents of accumulator A1 over the synchronous serial transmitter
812                                 XMIT_A_WORD
813       P:00020C P:00020C 07F42C            MOVEP             #0,X:TX10               ; This helps, don't know why
                            000000
814       P:00020E P:00020E 547000            MOVE              A1,X:SV_A1
                            00000E
815       P:000210 P:000210 000000            NOP
816       P:000211 P:000211 01A786            JCLR    #TDE,X:SSISR1,*                   ; Start bit
                            000211
817       P:000213 P:000213 07F42C            MOVEP             #$010000,X:TX10
                            010000
818       P:000215 P:000215 060380            DO      #3,L_X
                            00021B
819       P:000217 P:000217 01A786            JCLR    #TDE,X:SSISR1,*                   ; Three data bytes
                            000217
820       P:000219 P:000219 04CCCC            MOVEP             A1,X:TX10
821       P:00021A P:00021A 0C1E90            LSL     #8,A
822       P:00021B P:00021B 000000            NOP
823                                 L_X
824       P:00021C P:00021C 01A786            JCLR    #TDE,X:SSISR1,*                   ; Zeroes to bring transmitter low
                            00021C
825       P:00021E P:00021E 07F42C            MOVEP             #0,X:TX10
                            000000
826       P:000220 P:000220 54F000            MOVE              X:SV_A1,A1
                            00000E
827       P:000222 P:000222 00000C            RTS
828    
829                                 SKIP
830    
831                                 ; Set up the circular SCI buffer, 32 words in size
832       P:000223 P:000223 64F400            MOVE              #SCI_TABLE,R4
                            000400
833       P:000225 P:000225 051FA4            MOVE              #31,M4
834       P:000226 P:000226 647000            MOVE              R4,X:(SCI_TABLE+33)
                            000421
835    
836                                           IF      @SCP("HOST","ROM")
844                                           ENDIF
845    
846       P:000228 P:000228 44F400            MOVE              #>$AC,X0
                            0000AC
847       P:00022A P:00022A 440100            MOVE              X0,X:<FO_HDR
848    
849       P:00022B P:00022B 0C0181            JMP     <STARTUP
850    
851                                 ;  ****************  X: Memory tables  ********************
852    
853                                 ; Define the address in P: space where the table of constants begins
854    
855                                  X_BOOT_START
856       00022A                              EQU     @LCV(L)-2
857    
858                                           IF      @SCP("HOST","ROM")
860                                           ENDIF
861                                           IF      @SCP("HOST","HOST")
862       X:000000 X:000000                   ORG     X:0,X:0
863                                           ENDIF
864    
865                                 ; Special storage area - initialization constants and scratch space
866       X:000000 X:000000         STATUS    DC      $40004                            ; Controller status bits
867    
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 17



868       000001                    FO_HDR    EQU     STATUS+1                          ; Fiber optic write bytes
869       000005                    HEADER    EQU     FO_HDR+4                          ; Command header
870       000006                    NWORDS    EQU     HEADER+1                          ; Number of words in the command
871       000007                    COM_BUF   EQU     NWORDS+1                          ; Command buffer
872       00000E                    SV_A1     EQU     COM_BUF+7                         ; Save accumulator A1
873    
874                                           IF      @SCP("HOST","ROM")
879                                           ENDIF
880    
881                                           IF      @SCP("HOST","HOST")
882       X:00000F X:00000F                   ORG     X:$F,X:$F
883                                           ENDIF
884    
885                                 ; Parameter table in P: space to be copied into X: space during
886                                 ;   initialization, and is copied from ROM by the DSP boot
887       X:00000F X:00000F         LATCH     DC      $3A                               ; Starting value in latch chip U25
888                                  EXPOSURE_TIME
889       X:000010 X:000010                   DC      0                                 ; Exposure time in milliseconds
890                                  ELAPSED_TIME
891       X:000011 X:000011                   DC      0                                 ; Time elapsed so far in the exposure
892       X:000012 X:000012         ONE       DC      1                                 ; One
893       X:000013 X:000013         TWO       DC      2                                 ; Two
894       X:000014 X:000014         THREE     DC      3                                 ; Three
895       X:000015 X:000015         SEVEN     DC      7                                 ; Seven
896       X:000016 X:000016         MASK1     DC      $FCFCF8                           ; Mask for checking header
897       X:000017 X:000017         MASK2     DC      $030300                           ; Mask for checking header
898       X:000018 X:000018         DONE      DC      'DON'                             ; Standard reply
899       X:000019 X:000019         SBRD      DC      $020000                           ; Source Identification number
900       X:00001A X:00001A         TIM_DRB   DC      $000200                           ; Destination = timing board number
901       X:00001B X:00001B         DMASK     DC      $00FF00                           ; Mask to get destination board number
902       X:00001C X:00001C         SMASK     DC      $FF0000                           ; Mask to get source board number
903       X:00001D X:00001D         ERR       DC      'ERR'                             ; An error occurred
904       X:00001E X:00001E         C100K     DC      100000                            ; Delay for WRROM = 1 millisec
905       X:00001F X:00001F         IDL_ADR   DC      TST_RCV                           ; Address of idling routine
906       X:000020 X:000020         EXP_ADR   DC      0                                 ; Jump to this address during exposures
907    
908                                 ; Places for saving register values
909       X:000021 X:000021         SAVE_SR   DC      0                                 ; Status Register
910       X:000022 X:000022         SAVE_X1   DC      0
911       X:000023 X:000023         SAVE_A1   DC      0
912       X:000024 X:000024         SAVE_R0   DC      0
913       X:000025 X:000025         RCV_ERR   DC      0
914       X:000026 X:000026         SCI_A1    DC      0                                 ; Contents of accumulator A1 in RCV ISR
915       X:000027 X:000027         SCI_R0    DC      SRXL
916    
917                                 ; Command table
918       000028                    COM_TBL_R EQU     @LCV(R)
919       X:000028 X:000028         COM_TBL   DC      'TDL',TDL                         ; Test Data Link
920       X:00002A X:00002A                   DC      'RDM',RDMEM                       ; Read from DSP or EEPROM memory
921       X:00002C X:00002C                   DC      'WRM',WRMEM                       ; Write to DSP memory
922       X:00002E X:00002E                   DC      'LDA',LDAPPL                      ; Load application from EEPROM to DSP
923       X:000030 X:000030                   DC      'STP',STOP_IDLE_CLOCKING
924       X:000032 X:000032                   DC      'DON',START                       ; Nothing special
925       X:000034 X:000034                   DC      'ERR',START                       ; Nothing special
926    
927                                  END_COMMAND_TABLE
928       000036                              EQU     @LCV(R)
929    
930                                 ; The table at SCI_TABLE is for words received from the utility board, written by
931                                 ;   the interrupt service routine SCI_RCV. Note that it is 32 words long,
932                                 ;   hard coded, and the 33rd location contains the pointer to words that have
933                                 ;   been processed by moving them from the SCI_TABLE to the COM_BUF.
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timboot.s  Page 18



934    
935                                           IF      @SCP("HOST","ROM")
937                                           ENDIF
938    
939       000036                    END_ADR   EQU     @LCV(L)                           ; End address of P: code written to ROM
940                                           INCLUDE "timhdr.s"
941                                        COMMENT *
942    
943                                 This is a header file that has some HIPO-specific stuff in it.  It is
944                                 vastly stripped down compared to the original since most of the things in it
945                                 are now in timboot.asm.
946    
947                                 I believe that all the following stuff can be zapped out.  Comment out for now.
948    
949                                         PAGE    132     ; Printronix page width - 132 columns
950    
951                                 ; Some basic structural definitions
952                                 APL_ADR EQU     $130    ; P: memory location where application code begins
953                                 APL_LEN EQU     $200-APL_ADR ; Maximum length of application program
954    
955                                 ; CHANGING MISC_LEN FROM 0X280 TO A LARGER NUMBER BREAKS THE ROM COPY APPROACH!
956                                 ; However if all you do is download there is a lot more memory available.
957                                 MISC_LEN EQU    $450    ; Maximum length of "miscellanous" code
958                                 ;MISC_LEN EQU   $3F0    ; Maximum length of "miscellanous" code
959                                 ; MISC_LEN EQU  $280    ; Maximum length of "miscellanous" code
960    
961                                 COM_LEN EQU     $40     ; Length of memory for application commands
962                                 TIM_ISR EQU     $3C     ; DSP timer interrupt service routine address
963                                 PGM_CON EQU     $3E     ; Program continues on here
964                                 COM_TBL EQU     $80     ; Starting address of command table in X: memory
965                                 N_W_APL EQU     $500    ; Number of words in each application
966                                 NUM_COM EQU     40      ; Number of entries in command table
967    
968                                 RST_ISR EQU     $00     ; Hardware reset interrupt
969                                 ROM_ID  EQU     $06     ; Location of program Identification = SWI interrupt
970                                 START   EQU     $08     ; Starting address of program
971                                 RCV_BUF EQU     $60     ; Starting address of receiver buffer in X:
972                                 TBL_ADR EQU     $0F     ; (IR) Waveform tables starting address
973    
974                                 ROM_OFF EQU     $4000   ; Boot program offset address in EEPROM
975                                 LD_X    EQU     $4200   ; Assembler loads X: starting at this EEPROM address
976                                 RD_X    EQU     $C600   ; DSP reads X: from this EEPROM address
977    
978                                 ; Define DSP port addresses
979                                 WRSS    EQU     $FF80   ; Write clock driver and VP switch states
980                                 RDFO    EQU     $FFC0   ; Read serial receiver fiber optic contents
981                                 WRFO    EQU     $FFC0   ; Write to fiber optic serial transmitter
982                                 RDAD    EQU     $FFA0   ; Read A/D datum into DSP
983                                 RDAD0   EQU     $FFA0   ; Address for reading A/D #0
984                                 RDAD1   EQU     $FFA1   ; Address for reading A/D #1
985                                 WRLATCH EQU     $FFC1   ; Write to timing board latch
986                                 RSTWDT  EQU     $6000   ; Address to reset the timing board watchdog timer
987                                 BCR     EQU     $FFFE   ; Bus (=Port A) Control Register -> Wait States
988                                 PBC     EQU     $FFE0   ; Port B Control Register
989                                 PBDDR   EQU     $FFE2   ; Port B Data Direction Register
990                                 PBD     EQU     $FFE4   ; Port B Data Register
991                                 PCC     EQU     $FFE1   ; Port C Control Register
992                                 PCDDR   EQU     $FFE3   ; PortC Data Direction Register
993                                 PCD     EQU     $FFE5   ; Port C Data Register
994                                 IPR     EQU     $FFFF   ; Interrupt Priority Register
995                                 SSITX   EQU     $FFEF   ; SSI Transmit and Receive data register
996                                 SSIRX   EQU     $FFEF   ; SSI Transmit and Receive data register
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timhdr.s  Page 19



997                                 SSISR   EQU     $FFEE   ; SSI Status Register
998                                 CRA     EQU     $FFEC   ; SSI Control Register A
999                                 CRB     EQU     $FFED   ; SSI Control Regsiter B
1000                                TCSR    EQU     $FFDE   ; Timer control and status register
1001                                TCR     EQU     $FFDF   ; Timer count register
1002   
1003                                ; Hardware bit definitions all over the place
1004                                SSI_TDE EQU     6       ; SSI Transmitter data register empty
1005                                SSI_RDF EQU     7       ; SSI Receiver data register full
1006                                LVEN    EQU     2       ; Low voltage enable (+/-15 volt nominal)
1007                                HVEN    EQU     3       ; Enable high voltage (+32V nominal)
1008                                TIM_U_RST EQU   5       ; Timing to utility board reset bit number in U25
1009                                PWRST   EQU     13      ; Power control board reset
1010                                RST_FIFO EQU    7       ; Reset FIFO bit number in control latch U25
1011                                EF      EQU     9       ; FIFO empty flag, low true
1012                                TIM_BIT EQU     0       ; Timer status bit
1013                                WW      EQU     1       ; Word width = 1 for 16-bit image data, 0 for 24-bit
1014                                CDAC    EQU     0       ; Bit number in U25 for clearing DACs
1015                                ENCK    EQU     2       ; Bit number in U25 for enabling analog switches
1016                                DUALCLK EQU     1       ; Set to clock two halves of clock driver board together
1017   
1018                                ; Software status bits, defined at X:<STATUS = X:0
1019                                ST_RCV  EQU     0       ; Set if FO, cleared if SSI
1020                                TST_IMG EQU     10      ; Set if controller is to generate a test image
1021                                SHUT    EQU     11      ; Set if opening shutter at beginning of exposure
1022   
1023                                IDLMODE EQU     2       ; Set if need to idle after readout
1024                                ST_SHUT EQU     3       ; Set to indicate shutter is closed, clear for open
1025                                ST_RDC  EQU     4       ; Set if executing 'RDC' command - reading out
1026                                SPLIT_S EQU     5       ; Set if split serial
1027                                SPLIT_P EQU     6       ; Set if split parallel
1028                                MPP     EQU     7       ; Set if parallels are in MPP mode
1029   
1030                                END OF COMMENT HERE
1031                                        *
1032                                ; additional X:<STATUS bits
1033                                ; NOTE
1034                                ; NOTE
1035                                ; the NOT_CLR, and MPP X:<STATUS bits are pre-empted.
1036      000008                    ST_ABRT   EQU     8                                 ; Set if an abort (readout or exp) in progre
ss
1037      000007                    ST_EXP    EQU     7                                 ; Set if presently in EXPOSE or waiting for 
trigger
1038      00000A                    ST_SBFAIL EQU     10                                ; LATCHED if SETBIAS dac table bad
1039   
1040   
1041                                ; move IMGVAR down to $80 as per Confluence July 1 #1
1042                                ;IMGVAR_ADR EQU $100            ;  Special Image Mode variables Starting Address in X:
1043      000080                    IMGVAR_ADR EQU    $80                               ;  Special Image Mode variables Starting Add
ress in X:
1044   
1045                                ; Additional software status bit, defined at X:<STATUS = X:0
1046      000008                    TRIGGER   EQU     8                                 ; Set if a Hardware triggered exposure
1047   
1048                                ; add these HDR (port B) bits for thermo cool statuses
1049      000004                    STS0      EQU     4                                 ; STATUS 0, thermocool
1050      000005                    STS1      EQU     5                                 ; STATUS 1, thermocool
1051   
1052                                ; Image mode bits, defined at X:<IMAGE_MODE
1053   
1054      000000                    FDOTS     EQU     0                                 ; Fast Dots
1055      000001                    FIND      EQU     1                                 ; Find
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timhdr.s  Page 20



1056      000002                    SDOTS     EQU     2                                 ; Slow Dots
1057      000003                    SERIES    EQU     3                                 ; Series
1058      000004                    SINGLE    EQU     4                                 ; Single
1059      000005                    STRIP     EQU     5                                 ; Stripscan
1060      000006                    F_OCC     EQU     6                                 ; Fast occultation, keep as 6 for compatibil
ity
1061      000007                    B_OCC     EQU     7                                 ; Basic occultation
1062      000008                    P_OCC     EQU     8                                 ; Pipelined occultation
1063   
1064                                ; Image Status, define at X:<ISTATUS
1065      000000                    NO_SKIP   EQU     0                                 ; Set for slow dots, fast and pipelined occu
ltation mode
1066                                                                                    ; to avoid parallel skipping to the subframe
 boundary.
1067      000001                    OPEN_CLOSE EQU    1                                 ; Set if shutter opens/closes each image
1068                                                                                    ; Clear if shutter stays open for many image
s
1069      000002                    STORAGE   EQU     2                                 ; Set if storage area is to be clocked
1070   
1071      0000C8                    MAXDACTBL EQU     200                               ; largest table for SET_DAC (to verify R0 ad
dress)
1072   
1073                                          INCLUDE "infospec.s"
1074                                ; General DSP info field specifications.
1075                                ; These values are 'addresses' and used as the argument for the INF command.
1076   
1077                                 GET_VERSION
1078      000000                              EQU     0                                 ; IVERSION field
1079      000001                    GET_FLAVOR EQU    1                                 ; IFLAVOR field
1080      000002                    GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
1081      000003                    GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
1082      000004                    GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if availabl
e)
1083                                 GET_TEMP2STS
1084      000005                              EQU     5                                 ; two bits of thermo cool status for GWAVES
1085   
1086                                          INCLUDE "timinfospec.s"
1087                                ; TIM DSP info field specifications.
1088                                ; These values are 'addresses' and used as the argument for the INF command.
1089   
1090                                 GET_CAPABLE
1091      000100                              EQU     $100                              ; ICAPABLE field (what dsp supports).
1092                                 GET_INT_TIM
1093      000101                              EQU     $101                              ; Integration time per pixel in leach units
1094                                 GET_R_DELAY
1095      000102                              EQU     $102                              ; Serial overlap in leach units
1096                                 GET_SI_DELAY
1097      000103                              EQU     $103                              ; Parallel overlap in leach units
1098   
1099                                          INCLUDE "timinfo.s"
1100                                ; DSP Version
1101      04507F                    IVERSION  EQU     282751                            ; 1.5/1
1102   
1103      612020                    IFLAVOR   EQU     'a  '                             ; a
1104   
1105      00AF27                    ITIME0    EQU     44839                             ; lo order time: 2016 8 20  19:27:35 GMT
1106   
1107      0057B8                    ITIME1    EQU     22456                             ; hi order time: 2016 8 20  19:27:35 GMT
1108   
1109      000000                    ISVNREV   EQU     0                                 ; most recent code svn rev
1110   
1111                                ; this need to be defined externally due to a problem in timboot.s
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  tim.s  Page 21



1112                                ; as per Confluence, July 6, #1
1113      00005A                    EXPOSING  EQU     TST_RCV                           ; Address if exposing
1114                                 CONTINUE_READING
1115      00005A                              EQU     TST_RCV                           ; Address if reading out
1116   
1117                                ; tim capability definitions
1118                                 FINDCAPABLE
1119      000001                              EQU     1                                 ; Find exposure mode
1120                                 SNGLCAPABLE
1121      000002                              EQU     2                                 ; Single exposure mode
1122                                 SERICAPABLE
1123      000004                              EQU     4                                 ; Series exposure mode
1124                                 BASCCAPABLE
1125      000008                              EQU     8                                 ; Basic occ exposure mode
1126                                 FASTCAPABLE
1127      000010                              EQU     16                                ; Fast occ exposure mode
1128                                 PIPECAPABLE
1129      000020                              EQU     32                                ; Pipeline occ exposure mode
1130                                 FDOTCAPABLE
1131      000040                              EQU     64                                ; Fast dots exposure mode
1132                                 SDOTCAPABLE
1133      000080                              EQU     128                               ; Slow dots exposure mode
1134                                 STRPCAPABLE
1135      000100                              EQU     256                               ; Slow dots exposure mode
1136      0001CB                    TIMCAPABLE EQU    FINDCAPABLE+SNGLCAPABLE+STRPCAPABLE+BASCCAPABLE+FDOTCAPABLE+SDOTCAPABLE
1137   
1138      P:00022C P:00022C                   ORG     P:,P:
1139   
1140                                ; Remove SHUTTER_CC advertisement as per Confluence July 4 #3
1141                                ;CC     EQU     ARC22+ARC47+SHUTTER_CC+SPLIT_SERIAL+SUBARRAY+BINNING
1142      003C97                    CC        EQU     ARC22+ARC47+SPLIT_SERIAL+SPLIT_PARALLEL+SUBARRAY+BINNING+SHUTTER_CC
1143   
1144                                ; Put number of words of application in P: for loading application from EEPROM
1145      P:00022C P:00022C                   DC      TIMBOOT_X_MEMORY-@LCV(L)-1
1146   
1147                                ;**************************************************************************
1148                                ;                                                                         *
1149                                ;    Permanent address register assignments                               *
1150                                ;        R1 - Address of SSI receiver contents                            *
1151                                ;        R2 - Address of SCI receiver contents                            *
1152                                ;        R3 - Pointer to current top of command buffer                    *
1153                                ;        R4 - Pointer to processed contents of command buffer             *
1154                                ;        R5 - Temporary register for processing SSI and SCI contents      *
1155                                ;        R6 - CCD clock driver address for CCD #0 = $FF80                 *
1156                                ;                It is also the A/D address of analog board #0            *
1157                                ;        R6 CURRENTLY UNUSED (geniii)
1158                                ;                                                                         *
1159                                ;    Other registers                                                      *
1160                                ;        R0, R7 - Temporary registers used all over the place.            *
1161                                ;        R5 - Can be used as a temporary register but is circular,        *
1162                                ;               modulo 32.                                                *
1163                                ;**************************************************************************
1164   
1165                                ;  ***********************   CCD  READOUT   ***********************
1166                                ; RDCCD is now a subroutine
1167                                ; Adding several CLOCK_WAITs as per Jun 29 #8.
1168   
1169                                RDCCD
1170      P:00022D P:00022D 0A20A2            JSET    #STORAGE,X:ISTATUS,RCCD1
                            000233
1171                                ; Do the frame transfer if STORAGE==0, else skip it.
1172      P:00022F P:00022F 4DB900            MOVE                          Y:<S_SIZE,X1
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  tim.s  Page 22



1173      P:000230 P:000230 0D0792            JSR     <CLOCK_WAIT
1174                                ; mitigation attempt 2- remove ishift
1175      P:000231 P:000231 0BF080            JSR     ISHIFT                            ; Do the frame transfer
                            000784
1176                                ;       JSR     <CLOCK_WAIT  ; mitigation attempt 1
1177   
1178                                ; Calculate some readout parameters.
1179                                ; This is also an alternative entry point for skipping the frame transfer
1180                                ; STORAGE also selects ganged or storage only parallels during readout
1181                                ; NO_SKIP skips over the section that parallel skips to the subframe start
1182   
1183      P:000233 P:000233 5E9A00  RCCD1     MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1184      P:000234 P:000234 200003            TST     A
1185      P:000235 P:000235 0E2240            JNE     <SUB_IMG
1186      P:000236 P:000236 5C1700            MOVE                          A1,Y:<NP_SKIP ; Zero these all out.  Full frame
1187      P:000237 P:000237 5C1800            MOVE                          A1,Y:<NS_SKP1
1188      P:000238 P:000238 5C1900            MOVE                          A1,Y:<NS_SKP2
1189      P:000239 P:000239 5E8100            MOVE                          Y:<NSR,A    ; NSERIALS_READ = NSR
1190      P:00023A P:00023A 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            00023D
1191      P:00023C P:00023C 200022            ASR     A                                 ; Split serials require / 2
1192      P:00023D P:00023D 000000            NOP
1193      P:00023E P:00023E 5E1100            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1194      P:00023F P:00023F 0C0250            JMP     <SETUP
1195   
1196                                ; Loop over the required number of subimage boxes if NBOXES > 0
1197      P:000240 P:000240 67F400  SUB_IMG   MOVE              #READ_TABLE,R7          ; Parameter table for subimage readout
                            00001E
1198      P:000242 P:000242 061A40            DO      Y:<NBOXES,L_NBOXES                ; Loop over number of boxes
                            0002D9
1199      P:000244 P:000244 4CDF00            MOVE                          Y:(R7)+,X0
1200      P:000245 P:000245 4C1700            MOVE                          X0,Y:<NP_SKIP
1201      P:000246 P:000246 4CDF00            MOVE                          Y:(R7)+,X0
1202      P:000247 P:000247 4C1800            MOVE                          X0,Y:<NS_SKP1
1203      P:000248 P:000248 4CDF00            MOVE                          Y:(R7)+,X0
1204      P:000249 P:000249 4C1900            MOVE                          X0,Y:<NS_SKP2
1205      P:00024A P:00024A 5E9C00            MOVE                          Y:<NS_READ,A
1206      P:00024B P:00024B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                            00024E
1207      P:00024D P:00024D 200022            ASR     A
1208      P:00024E P:00024E 000000            NOP
1209      P:00024F P:00024F 5E1100            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1210   
1211                                ; Calculate the fast readout parameters
1212      P:000250 P:000250 0D0683  SETUP     JSR     <SETUP_SUBROUTINE
1213      P:000251 P:000251 0D0792            JSR     <CLOCK_WAIT
1214   
1215                                ; Skip over the required number of rows for subimage readout
1216                                ; If #NO_SKIP == 0 skip rows up to first subframe, storage clocks only
1217      P:000252 P:000252 0A20A0            JSET    #NO_SKIP,X:ISTATUS,CLR_SR
                            00025F
1218      P:000254 P:000254 5E9700            MOVE                          Y:<NP_SKIP,A ; Number of rows NP_SKIP to skip
1219      P:000255 P:000255 200003            TST     A
1220      P:000256 P:000256 0EA25F            JEQ     <CLR_SR                           ; If zero, skip this shift
1221      P:000257 P:000257 061740            DO      Y:<NP_SKIP,L_SKIP1                ; Clock number of rows to skip
                            00025E
1222      P:000259 P:000259 688F00            MOVE                          Y:<IS_PAR_CLR,R0 ; SR kept clear with DG
1223      P:00025A P:00025A 0A20A2            JSET    #STORAGE,X:ISTATUS,GANG_SK        ; if STORAGE == 0 store clocks only
                            00025D
1224                                ;        mitigation attempt 3- don't use S_PAR_CLR (but it was a full fr test)
1225      P:00025C P:00025C 689000            MOVE                          Y:<S_PAR_CLR,R0 ; SR kept clear with DG
1226                                GANG_SK
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  tim.s  Page 23



1227      P:00025D P:00025D 0D02E0            JSR     <CLOCK
1228      P:00025E P:00025E 000000            NOP
1229                                L_SKIP1
1230   
1231                                ; Clear out the accumulated charge from the serial shift register
1232                                ; Leave this commented-out code in until we can test it with a subframe
1233                                ; CLR_SR MOVE   #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1234                                ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1235                                ;       NOP
1236                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1237                                ;       DO      Y:<NSCLR,*+3            ; Number of waveform entries total
1238                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1239                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1240   
1241      P:00025F P:00025F 60F400  CLR_SR    MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel skip
                            0002AC
1242      P:000261 P:000261 0D02E0            JSR     <CLOCK
1243   
1244                                ; Parallel shift the image into the serial shift register
1245      P:000262 P:000262 4C8200            MOVE                          Y:<NPR,X0   ; Number of rows set by host computer
1246      P:000263 P:000263 5E9A00            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1247      P:000264 P:000264 200003            TST     A
1248      P:000265 P:000265 0EA267            JEQ     *+2
1249      P:000266 P:000266 4C9D00            MOVE                          Y:<NP_READ,X0 ; If NBOXES .NE. 0 use subimage table
1250   
1251                                ; Main loop over each line to be read out
1252                                ; If split parallels have to divide NPR by two to be loop counter
1253                                ; Subimages implicitly assumes that parallels are not split
1254      P:000267 P:000267 0A0086            JCLR    #SPLIT_P,X:STATUS,PLOOP           ; skip this if not split parallels
                            00026E
1255      P:000269 P:000269 5EF000            MOVE                          Y:NPR,A     ; Get NPR
                            000002
1256      P:00026B P:00026B 200022            ASR     A                                 ; Divide by 2
1257      P:00026C P:00026C 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1258      P:00026D P:00026D 21C400            MOVE              A,X0                    ; Overwrite loop counter in X0
1259   
1260                                ; Finally start the row loop
1261      P:00026E P:00026E 06C400  PLOOP     DO      X0,LPR                            ; Number of rows to read out
                            0002D8
1262   
1263                                ; Check for a command once per line. Only the ABORT command is allowed
1264                                ; NOT DONE- check for ABEXP in expose only
1265                                ;       JSR     <GET_RCV                ; Was a command received?
1266                                ;       JCC     <CONTINUE_RD            ; If no, continue reading out
1267                                ; as per Confluence July 5 #7
1268                                ;       JMP     <PRC_RCV                ; If yes, go process it
1269      P:000270 P:000270 0C0278            JMP     <CONTINUE_RD
1270   
1271                                ; Abort the readout currently underway (cmd destination)
1272                                ABR_RDC
1273      P:000271 P:000271 200013            CLR     A
1274      P:000272 P:000272 5EBD00            MOVE                          Y:<TESTLOC1,A
1275      P:000273 P:000273 014180            ADD     #1,A
1276      P:000274 P:000274 0A0028            BSET    #ST_ABRT,X:<STATUS
1277      P:000275 P:000275 5C3D00            MOVE                          A1,Y:<TESTLOC1
1278   
1279      P:000276 P:000276 0A0084            JCLR    #ST_RDC,X:<STATUS,ABORT_EXPOSURE
                            0007D0
1280                                ; "Can't happen"
1281                                ; already in readout- so just fall thru and continue,
1282                                ; having set the ST_ABRT flag.
1283                                ; currently we just let this readout segment run to the end and
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  tim.s  Page 24



1284                                ; handle the abort in the outer xxx_PROC code- this has
1285                                ; the advantage of ending the overall exposure on a frame boundary
1286                                ; in the case of 3-d images.
1287                                ; A more abrupt ending of the RDCCD code could be arranged if needed.
1288   
1289                                ;       ENDDO                           ; Properly terminate row loop
1290                                ;       MOVE    Y:<NBOXES,A             ; NBOXES = 0 => full image readout
1291                                ;       TST     A
1292                                ;       JEQ     *+2
1293                                ;       ENDDO                           ; Properly terminate box loop
1294                                ;       NOP
1295                                ;       CLR     A
1296                                ;       INC     A
1297                                ;       NOP
1298                                ;       MOVE    A0,Y:<IFLPCNT
1299                                ;       RTS                             ; Return early from subroutine
1300   
1301                                ; Move the row into the serial register.
1302                                 CONTINUE_RD
1303      P:000278 P:000278 060640            DO      Y:<NPBIN,LPR_I                    ; Transfer # of rows, with binning
                            00027F
1304      P:00027A P:00027A 688D00            MOVE                          Y:<IS_PAR_CLK,R0
1305      P:00027B P:00027B 0A20A2            JSET    #STORAGE,X:ISTATUS,GANGED         ; if STORAGE == 1 ganged parallels
                            00027E
1306                                ;       mitigation attempt 4- don't use S_PAR_CLK- seemed to work
1307      P:00027D P:00027D 688E00            MOVE                          Y:<S_PAR_CLK,R0 ; if STORAGE == 0 store clocks only
1308      P:00027E P:00027E 0D02E0  GANGED    JSR     <CLOCK                            ; Parallel clocking
1309      P:00027F P:00027F 000000            NOP
1310                                LPR_I
1311   
1312                                ; Skip over NS_SKP1 columns for subimage readout
1313                                ;       MOVE    Y:<NS_SKP1,A            ; Number of columns to skip
1314      P:000280 P:000280 5E9300            MOVE                          Y:<NSKIP1,A ; Number of waveforms for skip
1315      P:000281 P:000281 200003            TST     A
1316      P:000282 P:000282 0EA287            JEQ     <L_READ
1317                                ;       MOVE    #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1318      P:000283 P:000283 0506A1            MOVE              #<(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-1),M1 ; Modularity
1319   
1320                                ;       Fix for new interface CLOCKCT
1321                                ;       June 30 bottom "questions and comments" #2,3
1322      P:000284 P:000284 698900            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1323      P:000285 P:000285 218400            MOVE              A1,X0                   ; how many
1324      P:000286 P:000286 0D02E6            JSR     <CLOCKCT
1325                                ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1326                                ;       NOP
1327                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1328                                ;       DO      Y:<NSKIP1,LS_SKIP1      ; Number of waveform entries total
1329                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1330                                ;LS_SKIP1
1331                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1332   
1333                                ; Finally read some real pixels - this is the serial binning routine
1334      P:000287 P:000287 200013  L_READ    CLR     A
1335      P:000288 P:000288 20001B            CLR     B
1336      P:000289 P:000289 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1337      P:00028A P:00028A 50F400            MOVE              #>5,A0                  ; If binning > 4, do general binning
                            000005
1338      P:00028C P:00028C 200005            CMP     B,A                               ; else do special waveforms via NO_BIN
1339      P:00028D P:00028D 0E729F            JGT     <NO_BIN                           ; Skip over general serial binning software
1340      P:00028E P:00028E 00000B            DEC     B                                 ; serial binning factor minus 1
1341      P:00028F P:00028F 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1342      P:000290 P:000290 212700            MOVE              B0,Y1
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  tim.s  Page 25



1343      P:000291 P:000291 061140            DO      Y:<NSERIALS_READ,LSR_BIN          ; Number of pixels to read out
                            00029D
1344      P:000293 P:000293 688C00            MOVE                          Y:<INITIAL_CLOCK,R0 ; (already /2 if split serials)
1345      P:000294 P:000294 0D02E0            JSR     <CLOCK
1346                                ;       DO      Y:<NSBIN,LSR_I          ; Bin serially NSBIN times
1347      P:000295 P:000295 06C700            DO      Y1,LSR_I                          ; Bin serially NSBIN times
                            000299
1348      P:000297 P:000297 688B00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1349      P:000298 P:000298 0D02E0            JSR     <CLOCK                            ;   shift register
1350      P:000299 P:000299 000000            NOP
1351                                LSR_I
1352      P:00029A P:00029A 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                            000079
1353      P:00029C P:00029C 0D02E0            JSR     <CLOCK
1354                                ;       MOVE    Y1,Y:<INTERVAL          ; HACK.  Use for debugging
1355      P:00029D P:00029D 000000            NOP
1356                                LSR_BIN
1357      P:00029E P:00029E 0C02A5            JMP     <OVER_RD                          ; All done binning
1358   
1359                                ; This is the routine for serial binning from 1 to 4 using hardwired waveforms
1360      P:00029F P:00029F 588A00  NO_BIN    MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1361      P:0002A0 P:0002A0 00000A            DEC     A                                 ; waveform - 1 into M1
1362      P:0002A1 P:0002A1 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1363      P:0002A2 P:0002A2 04C8A1            MOVE              A0,M1                   ; Modularity
1364                                ;       Fix for new interface CLOCKCT
1365                                ;       June 30 bottom "questions and comments" #2,3
1366      P:0002A3 P:0002A3 4C9400            MOVE                          Y:<NREAD,X0 ; how many
1367      P:0002A4 P:0002A4 0D02E6            JSR     <CLOCKCT
1368                                ;       NOP
1369                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1370                                ;       DO      Y:<NREAD,LSR            ; Number of waveform entries total
1371                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1372                                ;LSR
1373                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1374   
1375                                ; If NR_BIAS=0 clobber SR with DG and skip to end of row loop
1376      P:0002A5 P:0002A5 5E9B00  OVER_RD   MOVE                          Y:<NR_BIAS,A ; Is NR_BIAS zero?
1377      P:0002A6 P:0002A6 200003            TST     A
1378      P:0002A7 P:0002A7 0E22AD            JNE     <OVR_RD1                          ; no, go to the NS_SKP2 section
1379      P:0002A8 P:0002A8 60F400            MOVE              #DUMP_SERIAL,R0         ; yes, clobber SR with DG
                            0002AC
1380      P:0002AA P:0002AA 0D02E0            JSR     <CLOCK
1381      P:0002AB P:0002AB 0AF080            JMP     END_ROW                           ; and go to the end of the row loop
                            0002D8
1382                                ; Skip over NS_SKP2 columns for subimage readout to get to overscan region
1383      P:0002AD P:0002AD 5E9900  OVR_RD1   MOVE                          Y:<NS_SKP2,A ; Number of columns to skip
1384      P:0002AE P:0002AE 200003            TST     A
1385      P:0002AF P:0002AF 0EA2B4            JEQ     <L_BIAS
1386                                ;       MOVE    #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1387      P:0002B0 P:0002B0 0506A1            MOVE              #<(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-1),M1 ; Modularity
1388      P:0002B1 P:0002B1 698900            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1389                                ;       Fix for new interface CLOCKCT
1390                                ;       June 30 bottom "questions and comments" #2,3
1391      P:0002B2 P:0002B2 4C9500            MOVE                          Y:<NSKIP2,X0 ; how many
1392      P:0002B3 P:0002B3 0D02E6            JSR     <CLOCKCT
1393                                ;       NOP
1394                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1395                                ;       DO      Y:<NSKIP2,LS_SKIP2      ; Number of waveform entries total
1396                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1397                                ;LS_SKIP2
1398                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1399   
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  tim.s  Page 26



1400                                ; And read the bias pixels if in subimage readout mode
1401                                ; I think this means that if NBOXES==0 you have to have NSR include bias px.
1402      P:0002B4 P:0002B4 5E9A00  L_BIAS    MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1403      P:0002B5 P:0002B5 200003            TST     A
1404      P:0002B6 P:0002B6 0EA2D8            JEQ     <END_ROW
1405   
1406                                ; Finally read some real bias pixels
1407      P:0002B7 P:0002B7 200013            CLR     A
1408      P:0002B8 P:0002B8 20001B            CLR     B
1409      P:0002B9 P:0002B9 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1410      P:0002BA P:0002BA 50F400            MOVE              #>5,A0                  ; If binning > 4, do general binning
                            000005
1411      P:0002BC P:0002BC 200005            CMP     B,A                               ; else do special waveforms via NO_BIN_BIAS
1412      P:0002BD P:0002BD 0E72D2            JGT     <NO_BIN_BIAS                      ; Skip over general serial binning software
1413      P:0002BE P:0002BE 00000B            DEC     B                                 ; serial binning factor minus 1
1414      P:0002BF P:0002BF 5E9B00            MOVE                          Y:<NR_BIAS,A
1415      P:0002C0 P:0002C0 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            0002C3
1416      P:0002C2 P:0002C2 200022            ASR     A                                 ; Split serials require / 2
1417      P:0002C3 P:0002C3 212700            MOVE              B0,Y1
1418      P:0002C4 P:0002C4 06CE00            DO      A,LBIAS_BIN                       ; Number of pixels to read out
                            0002D0
1419      P:0002C6 P:0002C6 688C00            MOVE                          Y:<INITIAL_CLOCK,R0
1420      P:0002C7 P:0002C7 0D02E0            JSR     <CLOCK
1421      P:0002C8 P:0002C8 06C700            DO      Y1,LBIAS_I                        ; Bin serially NSBIN times
                            0002CC
1422                                ;       DO      Y:<NSBIN,LBIAS_I        ; Bin serially NSBIN times
1423      P:0002CA P:0002CA 688B00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1424      P:0002CB P:0002CB 0D02E0            JSR     <CLOCK                            ;   shift register
1425      P:0002CC P:0002CC 000000            NOP
1426                                LBIAS_I
1427      P:0002CD P:0002CD 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                            000079
1428      P:0002CF P:0002CF 0D02E0            JSR     <CLOCK
1429      P:0002D0 P:0002D0 000000            NOP
1430                                LBIAS_BIN
1431      P:0002D1 P:0002D1 0C02D8            JMP     <END_ROW                          ; All done binning
1432   
1433                                ; This is the routine for serial binning from 1 to 4 using hardwired waveforms
1434                                ; NBIAS is already divided by 2 in SETUP_SUBROUTINE if split serials.
1435                                NO_BIN_BIAS
1436      P:0002D2 P:0002D2 588A00            MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1437      P:0002D3 P:0002D3 00000A            DEC     A                                 ; waveform - 1 into M1
1438      P:0002D4 P:0002D4 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1439      P:0002D5 P:0002D5 04C8A1            MOVE              A0,M1                   ; Modularity
1440                                ;       Fix for new interface CLOCKCT
1441                                ;       June 30 bottom "questions and comments" #2,3
1442      P:0002D6 P:0002D6 4C9600            MOVE                          Y:<NBIAS,X0 ; how many
1443      P:0002D7 P:0002D7 0D02E6            JSR     <CLOCKCT
1444                                ;       NOP
1445                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1446                                ;       DO      Y:<NBIAS,*+3            ; Number of waveform entries total
1447                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1448                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1449      P:0002D8 P:0002D8 000000  END_ROW   NOP
1450      P:0002D9 P:0002D9 000000  LPR       NOP                                       ; End of parallel loop
1451      P:0002DA P:0002DA 000000  L_NBOXES  NOP                                       ; End of subimage boxes loop
1452      P:0002DB P:0002DB 000000            NOP
1453      P:0002DC P:0002DC 307700            MOVE              #<DCRST_LAST,R0         ; get DC Restore going
1454      P:0002DD P:0002DD 0D02E0            JSR     <CLOCK
1455      P:0002DE P:0002DE 0D0792            JSR     <CLOCK_WAIT
1456      P:0002DF P:0002DF 00000C            RTS
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  tim.s  Page 27



1457   
1458                                ; ***************** END OF CCD READOUT SUBROUTINE  ************
1459   
1460                                ; Core subroutine for clocking out CCD charge
1461                                ; Must keep in tim.s to insure that it is in fast P memory
1462                                ; Modified for FIFO magement and new processor as per
1463                                ; June 30 bottom "questions and comments" #2,3
1464   
1465                                ; CLOCK assumes waveform in R0, which begins with a count field
1466                                ; NOTE: in geniii, this count is 1 larger than genii because it
1467                                ; is a straight count of the # of points in the wave- gen-ii
1468                                ; needed a count 1 smaller since there was a pipeline that was
1469                                ; primed with a starter pixel.
1470                                CLOCK
1471      P:0002E0 P:0002E0 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002E0
1472      P:0002E2 P:0002E2 065860            REP     Y:(R0)+
1473      P:0002E3 P:0002E3 09D8F3            MOVEP             Y:(R0)+,Y:WRSS          ; next piece of the waveform
1474      P:0002E4 P:0002E4 000000            NOP                                       ; just in case
1475      P:0002E5 P:0002E5 00000C            RTS
1476   
1477                                ; CLOCKCT assumes waveform in R1, without a count field, and the
1478                                ; count in X0, and modulus counter in M1.
1479                                ; In order to manage the FIFO (SSFHF) we copy the wave out in a block of 16 pts
1480                                ; at a time. The SSFHF check happens at the start of each block.
1481                                ; Note that count in X0 is again a straight count requiring a fix to FASTSKP
1482                                ; CLOCKCT trashes A
1483                                CLOCKCT
1484      P:0002E6 P:0002E6 200013            CLR     A
1485      P:0002E7 P:0002E7 208E00            MOVE              X0,A
1486                                CLKBLKFULL
1487                                                                                    ; see if we can do a full block in the wavef
orm.
1488      P:0002E8 P:0002E8 015085            CMP     #16,A
1489      P:0002E9 P:0002E9 0E92F0            JLT     <CLKBLKREM
1490                                                                                    ; 16 or more points remain
1491      P:0002EA P:0002EA 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002EA
1492      P:0002EC P:0002EC 0610A0            REP     #16
1493      P:0002ED P:0002ED 09D9F3            MOVEP             Y:(R1)+,Y:WRSS          ; next modulo piece of the waveform
1494      P:0002EE P:0002EE 015084            SUB     #16,A
1495      P:0002EF P:0002EF 0C02E8            JMP     <CLKBLKFULL
1496                                CLKBLKREM
1497                                                                                    ; last little bit..
1498      P:0002F0 P:0002F0 200003            TST     A
1499      P:0002F1 P:0002F1 0EF2F7            JLE     <CLOCK1                           ; no it divided evenly so all done--
1500                                                                                    ; do the remainder of 1 to 15 pts.
1501      P:0002F2 P:0002F2 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002F2
1502      P:0002F4 P:0002F4 06CE00            DO      A,CLOCK1
                            0002F6
1503      P:0002F6 P:0002F6 09D9F3            MOVEP             Y:(R1)+,Y:WRSS          ; next modulo piece of the waveform
1504                                CLOCK1
1505      P:0002F7 P:0002F7 000000            NOP                                       ; just in case
1506      P:0002F8 P:0002F8 00000C            RTS
1507   
1508                                ;CLOCK   MOVE    Y:(R0)+,X0             ; # of waveform entries
1509                                ;        MOVE    Y:(R0)+,A              ; Start the pipeline
1510                                ;        DO      X0,CLK1                 ; Repeat X0 times
1511                                ;        MOVE    A,X:(R6) Y:(R0)+,A      ; Send out the waveform
1512                                ;CLK1
1513                                ;        MOVE    A,X:(R6)               ; Flush out the pipeline
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  tim.s  Page 28



1514                                ;        RTS                            ; Return from subroutine
1515   
1516                                ; Include miscellaneous timing commands
1517                                          INCLUDE "timmisc.s"                       ; Custom
1518                                ; This file is for utilities that are in common to all the timing board
1519                                ;   programs, located starting at P:$200 in external SRAM
1520   
1521                                          IF      @SCP("10","50")
1523                                          ENDIF
1524                                          IF      @SCP("10","200")
1526                                          ENDIF
1527                                          IF      @SCP("10","10")
1528      00000A                    SDELAY    EQU     10
1529                                          ENDIF
1530   
1531   
1532                                ;  ****************  PROGRAM CODE IN SRAM PROGRAM SPACE    *******************
1533                                ; Put all the following code in SRAM, starting at P:$200.
1534                                          IF      @SCP("HOST","HOST")
1535                                ; as per Confluence, July 9
1536                                ;       ORG     P:$200,P:$200   ; Download address
1537      P:0002F9 P:0002F9                   ORG     P:,P:                             ; Download address
1538                                          ELSE
1540                                          ENDIF
1541   
1542                                ; Fast clear of CCD, executed as a command
1543      P:0002F9 P:0002F9 0D02FB  CLEAR     JSR     <CLR_CCD
1544      P:0002FA P:0002FA 0C008F            JMP     <FINISH
1545   
1546                                ; Fast clear image before each exposure, executed as a subroutine.  Uses DG
1547      P:0002FB P:0002FB 060440  CLR_CCD   DO      Y:<NPCLR,LPCLR                    ; Loop over number of lines in image
                            000300
1548      P:0002FD P:0002FD 60F400            MOVE              #ABCD_CLEAR_SPLIT,R0    ; Address of parallel transfer waveform
                            00026C
1549      P:0002FF P:0002FF 0D02E0            JSR     <CLOCK                            ; Go clock out the CCD charge
1550      P:000300 P:000300 000000            NOP                                       ; Do loop restriction
1551                                LPCLR
1552      P:000301 P:000301 60F400            MOVE              #DUMP_SERIAL,R0
                            0002AC
1553      P:000303 P:000303 0D02E0            JSR     <CLOCK                            ; and wipe out the dregs in the SR
1554      P:000304 P:000304 245A00            MOVE              #TST_RCV,X0             ; Wait for commands during exposure
1555      P:000305 P:000305 441F00            MOVE              X0,X:<IDL_ADR           ;  instead of idling
1556      P:000306 P:000306 00000C            RTS
1557   
1558                                ; Keep the CCD idling when not reading out
1559      P:000307 P:000307 060340  IDLE      DO      Y:<NS_CLR,IDL1                    ; Loop over number of pixels per line
                            000310
1560      P:000309 P:000309 303F00            MOVE              #<SERIAL_IDLE,R0        ; Serial transfer on pixel
1561      P:00030A P:00030A 0D02E0            JSR     <CLOCK                            ; Go to it
1562      P:00030B P:00030B 330700            MOVE              #COM_BUF,R3
1563      P:00030C P:00030C 0D00A5            JSR     <GET_RCV                          ; Check for FO or SSI commands
1564      P:00030D P:00030D 0E0310            JCC     <NO_COM                           ; Continue IDLE if no commands received
1565      P:00030E P:00030E 00008C            ENDDO
1566      P:00030F P:00030F 0C005D            JMP     <PRC_RCV                          ; Go process header and command
1567      P:000310 P:000310 000000  NO_COM    NOP
1568                                IDL1
1569      P:000311 P:000311 60F400            MOVE              #ABCD_CLEAR_SPLIT,R0    ; Address of parallel clocking waveform
                            00026C
1570      P:000313 P:000313 0D02E0            JSR     <CLOCK                            ; Go clock out the CCD charge
1571      P:000314 P:000314 0C0307            JMP     <IDLE
1572   
1573                                ; Start the exposure timer and monitor its progress
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 29



1574      P:000315 P:000315 07F40E  EXPOSE    MOVEP             #0,X:TLR0               ; Load 0 into counter timer
                            000000
1575      P:000317 P:000317 240000            MOVE              #0,X0
1576      P:000318 P:000318 441100            MOVE              X0,X:<ELAPSED_TIME      ; Set elapsed exposure time to zero
1577                                ;       CLR     B                       ; possibly fix bug as per
1578      P:000319 P:000319 579000            MOVE              X:<EXPOSURE_TIME,B
1579      P:00031A P:00031A 20000B            TST     B                                 ; Special test for zero exposure time
1580      P:00031B P:00031B 0EA327            JEQ     <END_EXP                          ; Don't even start an exposure
1581      P:00031C P:00031C 01418C            SUB     #1,B                              ; Timer counts from X:TCPR0+1 to zero
1582      P:00031D P:00031D 010F20            BSET    #TIM_BIT,X:TCSR0                  ; Enable the timer #0
1583      P:00031E P:00031E 577000            MOVE              B,X:TCPR0
                            FFFF8D
1584      P:000320 P:000320 0A8989  CHK_RCV   JCLR    #EF,X:HDR,CHK_TIM                 ; Simple test for fast execution
                            000325
1585      P:000322 P:000322 330700            MOVE              #COM_BUF,R3             ; The beginning of the command buffer
1586      P:000323 P:000323 0D00A5            JSR     <GET_RCV                          ; Check for an incoming command
1587      P:000324 P:000324 0E805D            JCS     <PRC_RCV                          ; If command is received, go check it
1588      P:000325 P:000325 018F95  CHK_TIM   JCLR    #TCF,X:TCSR0,CHK_RCV              ; Wait for timer to equal compare value
                            000320
1589      P:000327 P:000327 010F00  END_EXP   BCLR    #TIM_BIT,X:TCSR0                  ; Disable the timer
1590      P:000328 P:000328 0AE780            JMP     (R7)                              ; This contains the return address
1591   
1592                                ; Select which readouts to process
1593                                ;   'SOS'  Amplifier_name
1594                                ;       Amplifier_names = '__A', '__B', '__C', '__D', '_AB', '_CD', '_BD', 'ALL'
1595   
1596                                ;       Correct command ptr to R3 as per "Four Points" #2
1597   
1598      P:000329 P:000329 44DB00  SEL_OS    MOVE              X:(R3)+,X0              ; Get amplifier(s) name
1599      P:00032A P:00032A 0D032C            JSR     <SELECT_OUTPUT_SOURCE
1600      P:00032B P:00032B 0C0090            JMP     <FINISH1
1601   
1602                                ; A massive subroutine for setting all the addresses depending on the
1603                                ; output source(s) selection and binning parameter.  Most of the
1604                                ; waveforms are in fast Y memory (< 0xFF) but there isn't enough
1605                                ; space for the fast serial binning waveforms for binning factors
1606                                ; 1 through 4.  These are in high Y memory and have to be copied in.
1607   
1608                                SELECT_OUTPUT_SOURCE
1609                                ;  a little bit of aliasing
1610      P:00032C P:00032C 56F400            MOVE              #'__L',A
                            5F5F4C
1611      P:00032E P:00032E 200045            CMP     X0,A
1612      P:00032F P:00032F 0AF0AA            JEQ     ALIAS_A
                            00033F
1613      P:000331 P:000331 56F400            MOVE              #'__R',A
                            5F5F52
1614      P:000333 P:000333 200045            CMP     X0,A
1615      P:000334 P:000334 0AF0AA            JEQ     ALIAS_B
                            0003A1
1616      P:000336 P:000336 56F400            MOVE              #'_LR',A
                            5F4C52
1617      P:000338 P:000338 200045            CMP     X0,A
1618      P:000339 P:000339 0AF0AA            JEQ     ALIAS_AB
                            0004C7
1619   
1620                                ; Set all the waveform addresses depending on which readout/binning mode
1621      P:00033B P:00033B 56F400            MOVE              #'__A',A                ; LEFT Amplifier = readout #0
                            5F5F41
1622      P:00033D P:00033D 200045            CMP     X0,A
1623      P:00033E P:00033E 0E239D            JNE     <CMP_B
1624                                ALIAS_A
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 30



1625      P:00033F P:00033F 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1626      P:000340 P:000340 46F400            MOVE              #ABCD_UP,Y0
                            00022F
1627      P:000342 P:000342 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
1628      P:000344 P:000344 46F400            MOVE              #CD_UP,Y0
                            00027A
1629      P:000346 P:000346 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1630      P:000348 P:000348 46F400            MOVE              #ABCD_CLEAR_UP,Y0
                            000250
1631      P:00034A P:00034A 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1632      P:00034C P:00034C 46F400            MOVE              #CD_CLEAR_UP,Y0
                            000290
1633      P:00034E P:00034E 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1634   
1635                                                                                    ; serials for general binning
1636      P:000350 P:000350 46F400            MOVE              #SERIAL_SKIP_EH,Y0
                            0000E8
1637      P:000352 P:000352 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
1638      P:000354 P:000354 46F400            MOVE              #INITIAL_CLOCK_EH,Y0
                            000054
1639      P:000356 P:000356 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
1640      P:000358 P:000358 46F400            MOVE              #SERIAL_CLOCK_EH,Y0
                            000069
1641      P:00035A P:00035A 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
1642      P:00035C P:00035C 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000),Y0 ;
42
                            03200A
1643                                ;       MOVE    #(CLK2+$030000+000+000+000+000+H2L+H2R+000+000),Y0
1644      P:00035E P:00035E 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007E
1645                                ; 42
1646                                ;        MOVE    #$00F063,Y0             ; Channel 3 only
1647      P:000360 P:000360 46F400            MOVE              #$00F0C3,Y0             ; Channel 3 only
                            00F0C3
1648      P:000362 P:000362 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            00007A
1649      P:000364 P:000364 4E7000            MOVE                          Y0,Y:SXMIT_EH_1 ; and into all the hard-coded binned cas
es in high Y
                            0002B8
1650      P:000366 P:000366 4E7000            MOVE                          Y0,Y:SXMIT_EH_2
                            0002E8
1651      P:000368 P:000368 4E7000            MOVE                          Y0,Y:SXMIT_EH_3
                            00032A
1652      P:00036A P:00036A 4E7000            MOVE                          Y0,Y:SXMIT_EH_4
                            00037E
1653   
1654      P:00036C P:00036C 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1655      P:00036D P:00036D 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1656                                ; Now go through copying in the serial read waveform if binning more than 4.
1657      P:00036E P:00036E 200013            CLR     A
1658      P:00036F P:00036F 20001B            CLR     B
1659      P:000370 P:000370 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1660      P:000372 P:000372 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 31



1661      P:000373 P:000373 50F400            MOVE              #>4,A0
                            000004
1662      P:000375 P:000375 200005            CMP     B,A
1663      P:000376 P:000376 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1664      P:000377 P:000377 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
1665      P:000378 P:000378 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1666      P:000379 P:000379 0A1E81  TRY_1_A   JCLR    #1,X:BINBIT,TRY_2_A
                            000382
1667                                ;       MOVE    #1,A0                   ; HACK
1668                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1669      P:00037B P:00037B 51F400            MOVE              #(END_SERIAL_READ_EH_1-SERIAL_READ_EH_1),B0
                            00000E
1670      P:00037D P:00037D 60F400            MOVE              #SERIAL_READ_EH_1,R0    ; Here if H amp, bin by 1
                            0002B2
1671      P:00037F P:00037F 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1672      P:000380 P:000380 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1673      P:000381 P:000381 0C064B            JMP     <CMP_END
1674      P:000382 P:000382 0A1E82  TRY_2_A   JCLR    #2,X:BINBIT,TRY_3_A
                            00038B
1675      P:000384 P:000384 51F400            MOVE              #(END_SERIAL_READ_EH_2-SERIAL_READ_EH_2),B0
                            000014
1676      P:000386 P:000386 60F400            MOVE              #SERIAL_READ_EH_2,R0    ; Here if H amp, bin by 2
                            0002DC
1677      P:000388 P:000388 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1678      P:000389 P:000389 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1679      P:00038A P:00038A 0C064B            JMP     <CMP_END
1680      P:00038B P:00038B 0A1E83  TRY_3_A   JCLR    #3,X:<BINBIT,TRY_4_A
                            000394
1681      P:00038D P:00038D 51F400            MOVE              #(END_SERIAL_READ_EH_3-SERIAL_READ_EH_3),B0
                            00001A
1682      P:00038F P:00038F 60F400            MOVE              #SERIAL_READ_EH_3,R0    ; Here if H amp, bin by 3
                            000318
1683      P:000391 P:000391 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1684      P:000392 P:000392 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1685      P:000393 P:000393 0C064B            JMP     <CMP_END
1686      P:000394 P:000394 0A1E84  TRY_4_A   JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
1687      P:000396 P:000396 51F400            MOVE              #(END_SERIAL_READ_EH_4-SERIAL_READ_EH_4),B0
                            000020
1688      P:000398 P:000398 60F400            MOVE              #SERIAL_READ_EH_4,R0    ; Here if H amp, bin by 4
                            000366
1689      P:00039A P:00039A 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1690      P:00039B P:00039B 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1691      P:00039C P:00039C 0C064B            JMP     <CMP_END
1692   
1693      P:00039D P:00039D 56F400  CMP_B     MOVE              #'__B',A                ;  B Amplifier = e2v G amp = Leach channel #
2
                            5F5F42
1694      P:00039F P:00039F 200045            CMP     X0,A
1695      P:0003A0 P:0003A0 0E23FF            JNE     <CMP_C
1696                                ALIAS_B
1697      P:0003A1 P:0003A1 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1698      P:0003A2 P:0003A2 46F400            MOVE              #ABCD_UP,Y0
                            00022F
1699      P:0003A4 P:0003A4 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
1700      P:0003A6 P:0003A6 46F400            MOVE              #CD_UP,Y0
                            00027A
1701      P:0003A8 P:0003A8 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1702      P:0003AA P:0003AA 46F400            MOVE              #ABCD_CLEAR_UP,Y0
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 32



                            000250
1703      P:0003AC P:0003AC 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1704      P:0003AE P:0003AE 46F400            MOVE              #CD_CLEAR_UP,Y0
                            000290
1705      P:0003B0 P:0003B0 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1706   
1707                                                                                    ; serials for general binning
1708      P:0003B2 P:0003B2 46F400            MOVE              #SERIAL_SKIP_FG,Y0
                            0000F0
1709      P:0003B4 P:0003B4 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
1710      P:0003B6 P:0003B6 46F400            MOVE              #INITIAL_CLOCK_FG,Y0
                            00005B
1711      P:0003B8 P:0003B8 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
1712      P:0003BA P:0003BA 46F400            MOVE              #SERIAL_CLOCK_FG,Y0
                            000070
1713      P:0003BC P:0003BC 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
1714                                                                                    ; 42
1715      P:0003BE P:0003BE 46F400            MOVE              #(CLK2+$030000+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032011
1716                                ;       MOVE    #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),Y0
1717      P:0003C0 P:0003C0 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007E
1718                                ;        MOVE    #$00F042,Y0             ; Channel 2 only
1719      P:0003C2 P:0003C2 46F400            MOVE              #$00F082,Y0             ; Channel 2 only
                            00F082
1720      P:0003C4 P:0003C4 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            00007A
1721      P:0003C6 P:0003C6 4E7000            MOVE                          Y0,Y:SXMIT_FG_1 ; and into all the hard-coded binned cas
es in high Y
                            0002C6
1722      P:0003C8 P:0003C8 4E7000            MOVE                          Y0,Y:SXMIT_FG_2
                            0002FC
1723      P:0003CA P:0003CA 4E7000            MOVE                          Y0,Y:SXMIT_FG_3
                            000344
1724      P:0003CC P:0003CC 4E7000            MOVE                          Y0,Y:SXMIT_FG_4
                            00039E
1725   
1726      P:0003CE P:0003CE 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1727      P:0003CF P:0003CF 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1728                                ; Now go through copying in the serial read waveform if binning more than 4.
1729      P:0003D0 P:0003D0 200013            CLR     A
1730      P:0003D1 P:0003D1 20001B            CLR     B
1731      P:0003D2 P:0003D2 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1732      P:0003D4 P:0003D4 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1733      P:0003D5 P:0003D5 50F400            MOVE              #>4,A0
                            000004
1734      P:0003D7 P:0003D7 200005            CMP     B,A
1735      P:0003D8 P:0003D8 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1736      P:0003D9 P:0003D9 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
1737      P:0003DA P:0003DA 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1738      P:0003DB P:0003DB 0A1E81  TRY_1_B   JCLR    #1,X:BINBIT,TRY_2_B
                            0003E4
1739                                ;       MOVE    #2,A0                   ; HACK
1740                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 33



1741      P:0003DD P:0003DD 51F400            MOVE              #(END_SERIAL_READ_FG_1-SERIAL_READ_FG_1),B0
                            00000E
1742      P:0003DF P:0003DF 60F400            MOVE              #SERIAL_READ_FG_1,R0    ; Here if G amp, bin by 1
                            0002C0
1743      P:0003E1 P:0003E1 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1744      P:0003E2 P:0003E2 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1745      P:0003E3 P:0003E3 0C064B            JMP     <CMP_END
1746      P:0003E4 P:0003E4 0A1E82  TRY_2_B   JCLR    #2,X:BINBIT,TRY_3_B
                            0003ED
1747      P:0003E6 P:0003E6 51F400            MOVE              #(END_SERIAL_READ_FG_2-SERIAL_READ_FG_2),B0
                            000014
1748      P:0003E8 P:0003E8 60F400            MOVE              #SERIAL_READ_FG_2,R0    ; Here if G amp, bin by 2
                            0002F0
1749      P:0003EA P:0003EA 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1750      P:0003EB P:0003EB 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1751      P:0003EC P:0003EC 0C064B            JMP     <CMP_END
1752      P:0003ED P:0003ED 0A1E83  TRY_3_B   JCLR    #3,X:BINBIT,TRY_4_B
                            0003F6
1753      P:0003EF P:0003EF 51F400            MOVE              #(END_SERIAL_READ_FG_3-SERIAL_READ_FG_3),B0
                            00001A
1754      P:0003F1 P:0003F1 60F400            MOVE              #SERIAL_READ_FG_3,R0    ; Here if G amp, bin by 3
                            000332
1755      P:0003F3 P:0003F3 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1756      P:0003F4 P:0003F4 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1757      P:0003F5 P:0003F5 0C064B            JMP     <CMP_END
1758      P:0003F6 P:0003F6 0A1E84  TRY_4_B   JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
1759      P:0003F8 P:0003F8 51F400            MOVE              #(END_SERIAL_READ_FG_4-SERIAL_READ_FG_4),B0
                            000020
1760      P:0003FA P:0003FA 60F400            MOVE              #SERIAL_READ_FG_4,R0    ; Here if G amp, bin by 4
                            000386
1761      P:0003FC P:0003FC 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1762      P:0003FD P:0003FD 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1763      P:0003FE P:0003FE 0C064B            JMP     <CMP_END
1764   
1765      P:0003FF P:0003FF 56F400  CMP_C     MOVE              #'__C',A                ;  C Amplifier = e2v E amp = Leach channel #
0
                            5F5F43
1766      P:000401 P:000401 200045            CMP     X0,A
1767      P:000402 P:000402 0E2461            JNE     <CMP_D
1768      P:000403 P:000403 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1769      P:000404 P:000404 46F400            MOVE              #ABCD_DOWN,Y0
                            00023A
1770      P:000406 P:000406 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
1771      P:000408 P:000408 46F400            MOVE              #AB_DOWN,Y0
                            000285
1772      P:00040A P:00040A 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1773      P:00040C P:00040C 46F400            MOVE              #ABCD_CLEAR_DOWN,Y0
                            00025E
1774      P:00040E P:00040E 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1775      P:000410 P:000410 46F400            MOVE              #AB_CLEAR_DOWN,Y0
                            00029E
1776      P:000412 P:000412 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1777   
1778                                                                                    ; serials for general binning
1779      P:000414 P:000414 46F400            MOVE              #SERIAL_SKIP_EH,Y0
                            0000E8
1780      P:000416 P:000416 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 34



                            000009
1781      P:000418 P:000418 46F400            MOVE              #INITIAL_CLOCK_EH,Y0
                            000054
1782      P:00041A P:00041A 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
1783      P:00041C P:00041C 46F400            MOVE              #SERIAL_CLOCK_EH,Y0
                            000069
1784      P:00041E P:00041E 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
1785                                                                                    ; 42
1786      P:000420 P:000420 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000),Y0
                            03200A
1787                                ;       MOVE    #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),Y0
1788      P:000422 P:000422 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007E
1789                                ;        MOVE    #$00F000,Y0             ; Channel 0 only
1790      P:000424 P:000424 46F400            MOVE              #$00F000,Y0             ; Channel 0 only
                            00F000
1791      P:000426 P:000426 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            00007A
1792      P:000428 P:000428 4E7000            MOVE                          Y0,Y:SXMIT_EH_1 ; and into all the hard-coded binned cas
es in high Y
                            0002B8
1793      P:00042A P:00042A 4E7000            MOVE                          Y0,Y:SXMIT_EH_2
                            0002E8
1794      P:00042C P:00042C 4E7000            MOVE                          Y0,Y:SXMIT_EH_3
                            00032A
1795      P:00042E P:00042E 4E7000            MOVE                          Y0,Y:SXMIT_EH_4
                            00037E
1796   
1797      P:000430 P:000430 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1798      P:000431 P:000431 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1799                                ; Now go through copying in the serial read waveform if binning more than 4.
1800      P:000432 P:000432 200013            CLR     A
1801      P:000433 P:000433 20001B            CLR     B
1802      P:000434 P:000434 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1803      P:000436 P:000436 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1804      P:000437 P:000437 50F400            MOVE              #>4,A0
                            000004
1805      P:000439 P:000439 200005            CMP     B,A
1806      P:00043A P:00043A 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1807      P:00043B P:00043B 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
1808      P:00043C P:00043C 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1809      P:00043D P:00043D 0A1E81  TRY_1_C   JCLR    #1,X:BINBIT,TRY_2_C
                            000446
1810                                ;       MOVE    #2,A0                   ; HACK
1811                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1812      P:00043F P:00043F 51F400            MOVE              #(END_SERIAL_READ_EH_1-SERIAL_READ_EH_1),B0
                            00000E
1813      P:000441 P:000441 60F400            MOVE              #SERIAL_READ_EH_1,R0    ; Here if E amp, bin by 1
                            0002B2
1814      P:000443 P:000443 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1815      P:000444 P:000444 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1816      P:000445 P:000445 0C064B            JMP     <CMP_END
1817      P:000446 P:000446 0A1E82  TRY_2_C   JCLR    #2,X:BINBIT,TRY_3_C
                            00044F
1818      P:000448 P:000448 51F400            MOVE              #(END_SERIAL_READ_EH_2-SERIAL_READ_EH_2),B0
                            000014
1819      P:00044A P:00044A 60F400            MOVE              #SERIAL_READ_EH_2,R0    ; Here if E amp, bin by 2
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 35



                            0002DC
1820      P:00044C P:00044C 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1821      P:00044D P:00044D 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1822      P:00044E P:00044E 0C064B            JMP     <CMP_END
1823      P:00044F P:00044F 0A1E83  TRY_3_C   JCLR    #3,X:BINBIT,TRY_4_C
                            000458
1824      P:000451 P:000451 51F400            MOVE              #(END_SERIAL_READ_EH_3-SERIAL_READ_EH_3),B0
                            00001A
1825      P:000453 P:000453 60F400            MOVE              #SERIAL_READ_EH_3,R0    ; Here if E amp, bin by 3
                            000318
1826      P:000455 P:000455 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1827      P:000456 P:000456 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1828      P:000457 P:000457 0C064B            JMP     <CMP_END
1829      P:000458 P:000458 0A1E84  TRY_4_C   JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
1830      P:00045A P:00045A 51F400            MOVE              #(END_SERIAL_READ_EH_4-SERIAL_READ_EH_4),B0
                            000020
1831      P:00045C P:00045C 60F400            MOVE              #SERIAL_READ_EH_4,R0    ; Here if E amp, bin by 4
                            000366
1832      P:00045E P:00045E 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1833      P:00045F P:00045F 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1834      P:000460 P:000460 0C064B            JMP     <CMP_END
1835   
1836      P:000461 P:000461 56F400  CMP_D     MOVE              #'__D',A                ;  D Amplifier = e2v F amp = Leach channel #
1
                            5F5F44
1837      P:000463 P:000463 200045            CMP     X0,A
1838      P:000464 P:000464 0E24C3            JNE     <CMP_AB
1839      P:000465 P:000465 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1840      P:000466 P:000466 46F400            MOVE              #ABCD_DOWN,Y0
                            00023A
1841      P:000468 P:000468 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
1842      P:00046A P:00046A 46F400            MOVE              #AB_DOWN,Y0
                            000285
1843      P:00046C P:00046C 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1844      P:00046E P:00046E 46F400            MOVE              #ABCD_CLEAR_DOWN,Y0
                            00025E
1845      P:000470 P:000470 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1846      P:000472 P:000472 46F400            MOVE              #AB_CLEAR_DOWN,Y0
                            00029E
1847      P:000474 P:000474 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1848   
1849                                                                                    ; serials for general binning
1850      P:000476 P:000476 46F400            MOVE              #SERIAL_SKIP_FG,Y0
                            0000F0
1851      P:000478 P:000478 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
1852      P:00047A P:00047A 46F400            MOVE              #INITIAL_CLOCK_FG,Y0
                            00005B
1853      P:00047C P:00047C 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
1854      P:00047E P:00047E 46F400            MOVE              #SERIAL_CLOCK_FG,Y0
                            000070
1855      P:000480 P:000480 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
1856                                                                                    ; 42
1857      P:000482 P:000482 46F400            MOVE              #(CLK2+$030000+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032011
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 36



1858                                ;       MOVE    #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),Y0
1859      P:000484 P:000484 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007E
1860                                ;        MOVE    #$00F021,Y0             ; Channel 1 only
1861      P:000486 P:000486 46F400            MOVE              #$00F041,Y0             ; Channel 1 only
                            00F041
1862      P:000488 P:000488 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            00007A
1863      P:00048A P:00048A 4E7000            MOVE                          Y0,Y:SXMIT_FG_1 ; and into all the hard-coded binned cas
es in high Y
                            0002C6
1864      P:00048C P:00048C 4E7000            MOVE                          Y0,Y:SXMIT_FG_2
                            0002FC
1865      P:00048E P:00048E 4E7000            MOVE                          Y0,Y:SXMIT_FG_3
                            000344
1866      P:000490 P:000490 4E7000            MOVE                          Y0,Y:SXMIT_FG_4
                            00039E
1867   
1868      P:000492 P:000492 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1869      P:000493 P:000493 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1870                                ; Now go through copying in the serial read waveform if binning more than 4.
1871      P:000494 P:000494 200013            CLR     A
1872      P:000495 P:000495 20001B            CLR     B
1873      P:000496 P:000496 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1874      P:000498 P:000498 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1875      P:000499 P:000499 50F400            MOVE              #>4,A0
                            000004
1876      P:00049B P:00049B 200005            CMP     B,A
1877      P:00049C P:00049C 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1878      P:00049D P:00049D 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
1879      P:00049E P:00049E 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1880      P:00049F P:00049F 0A1E81  TRY_1_D   JCLR    #1,X:BINBIT,TRY_2_D
                            0004A8
1881                                ;       MOVE    #2,A0                   ; HACK
1882                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1883      P:0004A1 P:0004A1 51F400            MOVE              #(END_SERIAL_READ_FG_1-SERIAL_READ_FG_1),B0
                            00000E
1884      P:0004A3 P:0004A3 60F400            MOVE              #SERIAL_READ_FG_1,R0    ; Here if F amp, bin by 1
                            0002C0
1885      P:0004A5 P:0004A5 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1886      P:0004A6 P:0004A6 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1887      P:0004A7 P:0004A7 0C064B            JMP     <CMP_END
1888      P:0004A8 P:0004A8 0A1E82  TRY_2_D   JCLR    #2,X:BINBIT,TRY_3_D
                            0004B1
1889      P:0004AA P:0004AA 51F400            MOVE              #(END_SERIAL_READ_FG_2-SERIAL_READ_FG_2),B0
                            000014
1890      P:0004AC P:0004AC 60F400            MOVE              #SERIAL_READ_FG_2,R0    ; Here if F amp, bin by 2
                            0002F0
1891      P:0004AE P:0004AE 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1892      P:0004AF P:0004AF 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1893      P:0004B0 P:0004B0 0C064B            JMP     <CMP_END
1894      P:0004B1 P:0004B1 0A1E83  TRY_3_D   JCLR    #3,X:BINBIT,TRY_4_D
                            0004BA
1895      P:0004B3 P:0004B3 51F400            MOVE              #(END_SERIAL_READ_FG_3-SERIAL_READ_FG_3),B0
                            00001A
1896      P:0004B5 P:0004B5 60F400            MOVE              #SERIAL_READ_FG_3,R0    ; Here if F amp, bin by 3
                            000332
1897      P:0004B7 P:0004B7 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1898      P:0004B8 P:0004B8 0D0651            JSR     <WAVECPY                          ; Copy the waveform
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 37



1899      P:0004B9 P:0004B9 0C064B            JMP     <CMP_END
1900      P:0004BA P:0004BA 0A1E84  TRY_4_D   JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
1901      P:0004BC P:0004BC 51F400            MOVE              #(END_SERIAL_READ_FG_4-SERIAL_READ_FG_4),B0
                            000020
1902      P:0004BE P:0004BE 60F400            MOVE              #SERIAL_READ_FG_4,R0    ; Here if F amp, bin by 4
                            000386
1903      P:0004C0 P:0004C0 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1904      P:0004C1 P:0004C1 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1905      P:0004C2 P:0004C2 0C064B            JMP     <CMP_END
1906   
1907      P:0004C3 P:0004C3 56F400  CMP_AB    MOVE              #'_AB',A                ;  AB Amplifier = e2v HG amp = Leach channel
s 2-3
                            5F4142
1908      P:0004C5 P:0004C5 200045            CMP     X0,A
1909      P:0004C6 P:0004C6 0E2525            JNE     <CMP_CD
1910                                ALIAS_AB
1911      P:0004C7 P:0004C7 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1912      P:0004C8 P:0004C8 46F400            MOVE              #ABCD_UP,Y0
                            00022F
1913      P:0004CA P:0004CA 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
1914      P:0004CC P:0004CC 46F400            MOVE              #CD_UP,Y0
                            00027A
1915      P:0004CE P:0004CE 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1916      P:0004D0 P:0004D0 46F400            MOVE              #ABCD_CLEAR_UP,Y0
                            000250
1917      P:0004D2 P:0004D2 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1918      P:0004D4 P:0004D4 46F400            MOVE              #CD_CLEAR_UP,Y0
                            000290
1919      P:0004D6 P:0004D6 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1920   
1921      P:0004D8 P:0004D8 46F400            MOVE              #SERIAL_SKIP_SPLIT,Y0
                            0000F8
1922      P:0004DA P:0004DA 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
1923      P:0004DC P:0004DC 46F400            MOVE              #INITIAL_CLOCK_SPLIT,Y0
                            00004D
1924      P:0004DE P:0004DE 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
1925      P:0004E0 P:0004E0 46F400            MOVE              #SERIAL_CLOCK_SPLIT,Y0
                            000062
1926      P:0004E2 P:0004E2 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
1927                                ;       42
1928                                ;       MOVE    #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),Y0
1929      P:0004E4 P:0004E4 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032012
1930   
1931      P:0004E6 P:0004E6 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007E
1932                                ; MOVE    #$00F062,Y0             ; Channels 2-3
1933      P:0004E8 P:0004E8 46F400            MOVE              #$00F0C2,Y0             ; Channels 2-3
                            00F0C2
1934      P:0004EA P:0004EA 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            00007A
1935      P:0004EC P:0004EC 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_1 ; and into all the hard-coded binned 
cases in high Y
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 38



                            0002D4
1936      P:0004EE P:0004EE 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_2
                            000310
1937      P:0004F0 P:0004F0 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_3
                            00035E
1938      P:0004F2 P:0004F2 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_4
                            0003BE
1939   
1940   
1941      P:0004F4 P:0004F4 0A0025            BSET    #SPLIT_S,X:STATUS                 ; Serials split
1942      P:0004F5 P:0004F5 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; Parallels not split
1943   
1944                                ; Now go through copying in the serial read waveform if binning more than 4.
1945      P:0004F6 P:0004F6 200013            CLR     A
1946      P:0004F7 P:0004F7 20001B            CLR     B
1947      P:0004F8 P:0004F8 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1948      P:0004FA P:0004FA 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1949      P:0004FB P:0004FB 50F400            MOVE              #>4,A0
                            000004
1950      P:0004FD P:0004FD 200005            CMP     B,A
1951      P:0004FE P:0004FE 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1952      P:0004FF P:0004FF 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
1953      P:000500 P:000500 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1954      P:000501 P:000501 0A1E81  TRY_1_AB  JCLR    #1,X:BINBIT,TRY_2_AB
                            00050A
1955                                ;       MOVE    #3,A0                   ; HACK
1956                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1957      P:000503 P:000503 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                            00000E
1958      P:000505 P:000505 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if HG amp, bin by 1
                            0002CE
1959      P:000507 P:000507 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1960      P:000508 P:000508 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1961      P:000509 P:000509 0C064B            JMP     <CMP_END
1962      P:00050A P:00050A 0A1E82  TRY_2_AB  JCLR    #2,X:BINBIT,TRY_3_AB
                            000513
1963      P:00050C P:00050C 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                            000014
1964      P:00050E P:00050E 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if HG amp, bin by 2
                            000304
1965      P:000510 P:000510 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1966      P:000511 P:000511 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1967      P:000512 P:000512 0C064B            JMP     <CMP_END
1968      P:000513 P:000513 0A1E83  TRY_3_AB  JCLR    #3,X:BINBIT,TRY_4_AB
                            00051C
1969      P:000515 P:000515 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                            00001A
1970      P:000517 P:000517 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if HG amp, bin by 3
                            00034C
1971      P:000519 P:000519 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1972      P:00051A P:00051A 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1973      P:00051B P:00051B 0C064B            JMP     <CMP_END
1974      P:00051C P:00051C 0A1E84  TRY_4_AB  JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
1975      P:00051E P:00051E 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                            000020
1976      P:000520 P:000520 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if HG amp, bin by 4
                            0003A6
1977      P:000522 P:000522 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1978      P:000523 P:000523 0D0651            JSR     <WAVECPY                          ; Copy the waveform
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 39



1979      P:000524 P:000524 0C064B            JMP     <CMP_END
1980   
1981      P:000525 P:000525 56F400  CMP_CD    MOVE              #'_CD',A                ;  CD Amplifier = e2v EF amp = Leach channel
s 0-1
                            5F4344
1982      P:000527 P:000527 200045            CMP     X0,A
1983      P:000528 P:000528 0E2587            JNE     <CMP_BD
1984      P:000529 P:000529 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1985      P:00052A P:00052A 46F400            MOVE              #ABCD_DOWN,Y0
                            00023A
1986      P:00052C P:00052C 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
1987      P:00052E P:00052E 46F400            MOVE              #AB_DOWN,Y0
                            000285
1988      P:000530 P:000530 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1989      P:000532 P:000532 46F400            MOVE              #ABCD_CLEAR_DOWN,Y0
                            00025E
1990      P:000534 P:000534 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1991      P:000536 P:000536 46F400            MOVE              #AB_CLEAR_DOWN,Y0
                            00029E
1992      P:000538 P:000538 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1993   
1994      P:00053A P:00053A 46F400            MOVE              #SERIAL_SKIP_SPLIT,Y0
                            0000F8
1995      P:00053C P:00053C 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
1996      P:00053E P:00053E 46F400            MOVE              #INITIAL_CLOCK_SPLIT,Y0
                            00004D
1997      P:000540 P:000540 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
1998      P:000542 P:000542 46F400            MOVE              #SERIAL_CLOCK_SPLIT,Y0
                            000062
1999      P:000544 P:000544 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
2000                                ;       42
2001                                ;       MOVE    #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),Y0
2002      P:000546 P:000546 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032012
2003      P:000548 P:000548 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007E
2004   
2005                                ;        MOVE    #$00F020,Y0             ; Channels 0-1
2006      P:00054A P:00054A 46F400            MOVE              #$00F040,Y0             ; Channels 0-1
                            00F040
2007      P:00054C P:00054C 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            00007A
2008      P:00054E P:00054E 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_1 ; and into all the hard-coded binned 
cases in high Y
                            0002D4
2009      P:000550 P:000550 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_2
                            000310
2010      P:000552 P:000552 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_3
                            00035E
2011      P:000554 P:000554 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_4
                            0003BE
2012   
2013   
2014      P:000556 P:000556 0A0025            BSET    #SPLIT_S,X:STATUS                 ; Serials split
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 40



2015      P:000557 P:000557 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; Parallels not split
2016   
2017                                ; Now go through copying in the serial read waveform if binning more than 4.
2018      P:000558 P:000558 200013            CLR     A
2019      P:000559 P:000559 20001B            CLR     B
2020      P:00055A P:00055A 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
2021      P:00055C P:00055C 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
2022      P:00055D P:00055D 50F400            MOVE              #>4,A0
                            000004
2023      P:00055F P:00055F 200005            CMP     B,A
2024      P:000560 P:000560 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
2025      P:000561 P:000561 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
2026      P:000562 P:000562 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
2027      P:000563 P:000563 0A1E81  TRY_1_CD  JCLR    #1,X:BINBIT,TRY_2_CD
                            00056C
2028                                ;       MOVE    #3,A0                   ; HACK
2029                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
2030      P:000565 P:000565 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                            00000E
2031      P:000567 P:000567 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if EF amp, bin by 1
                            0002CE
2032      P:000569 P:000569 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2033      P:00056A P:00056A 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2034      P:00056B P:00056B 0C064B            JMP     <CMP_END
2035      P:00056C P:00056C 0A1E82  TRY_2_CD  JCLR    #2,X:BINBIT,TRY_3_CD
                            000575
2036      P:00056E P:00056E 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                            000014
2037      P:000570 P:000570 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if EF amp, bin by 2
                            000304
2038      P:000572 P:000572 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2039      P:000573 P:000573 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2040      P:000574 P:000574 0C064B            JMP     <CMP_END
2041      P:000575 P:000575 0A1E83  TRY_3_CD  JCLR    #3,X:BINBIT,TRY_4_CD
                            00057E
2042      P:000577 P:000577 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                            00001A
2043      P:000579 P:000579 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if EF amp, bin by 3
                            00034C
2044      P:00057B P:00057B 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2045      P:00057C P:00057C 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2046      P:00057D P:00057D 0C064B            JMP     <CMP_END
2047      P:00057E P:00057E 0A1E84  TRY_4_CD  JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
2048      P:000580 P:000580 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                            000020
2049      P:000582 P:000582 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if EF amp, bin by 4
                            0003A6
2050      P:000584 P:000584 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2051      P:000585 P:000585 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2052      P:000586 P:000586 0C064B            JMP     <CMP_END
2053   
2054      P:000587 P:000587 56F400  CMP_BD    MOVE              #'_BD',A                ;  BD Amplifier = e2v FG amp = Leach channel
s 1-2
                            5F4244
2055      P:000589 P:000589 200045            CMP     X0,A                              ; Note that EH amplifier isn't possible - Le
ach channels 0 & 3
2056      P:00058A P:00058A 0E25E9            JNE     <CMP_ALL                          ; are not adjacent so SXMIT doesn't work.
2057      P:00058B P:00058B 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
2058      P:00058C P:00058C 46F400            MOVE              #ABCD_SPLIT,Y0
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 41



                            000245
2059      P:00058E P:00058E 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
2060      P:000590 P:000590 46F400            MOVE              #CD_UP,Y0
                            00027A
2061      P:000592 P:000592 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
2062      P:000594 P:000594 46F400            MOVE              #ABCD_CLEAR_SPLIT,Y0
                            00026C
2063      P:000596 P:000596 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
2064      P:000598 P:000598 46F400            MOVE              #CD_CLEAR_UP,Y0
                            000290
2065      P:00059A P:00059A 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
2066   
2067      P:00059C P:00059C 46F400            MOVE              #SERIAL_SKIP_FG,Y0
                            0000F0
2068      P:00059E P:00059E 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
2069      P:0005A0 P:0005A0 46F400            MOVE              #INITIAL_CLOCK_FG,Y0
                            00005B
2070      P:0005A2 P:0005A2 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
2071      P:0005A4 P:0005A4 46F400            MOVE              #SERIAL_CLOCK_FG,Y0
                            000070
2072      P:0005A6 P:0005A6 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
2073                                ;       42
2074                                ;       MOVE    #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),Y0
2075      P:0005A8 P:0005A8 46F400            MOVE              #(CLK2+$030000+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032011
2076      P:0005AA P:0005AA 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007E
2077   
2078      P:0005AC P:0005AC 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; Serials not split
2079                                                                                    ;MOVE    #$00F041,Y0             ; Channels 
1-2
2080      P:0005AD P:0005AD 46F400            MOVE              #$00F081,Y0             ; Channels 1-2
                            00F081
2081      P:0005AF P:0005AF 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            00007A
2082      P:0005B1 P:0005B1 4E7000            MOVE                          Y0,Y:SXMIT_FG_1 ; and into all the hard-coded binned cas
es in high Y
                            0002C6
2083      P:0005B3 P:0005B3 4E7000            MOVE                          Y0,Y:SXMIT_FG_2
                            0002FC
2084      P:0005B5 P:0005B5 4E7000            MOVE                          Y0,Y:SXMIT_FG_3
                            000344
2085      P:0005B7 P:0005B7 4E7000            MOVE                          Y0,Y:SXMIT_FG_4
                            00039E
2086   
2087   
2088      P:0005B9 P:0005B9 0A0026            BSET    #SPLIT_P,X:STATUS                 ; Parallels split
2089   
2090                                ; Now go through copying in the serial read waveform if binning more than 4.
2091      P:0005BA P:0005BA 200013            CLR     A
2092      P:0005BB P:0005BB 20001B            CLR     B
2093      P:0005BC P:0005BC 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
2094      P:0005BE P:0005BE 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 42



2095      P:0005BF P:0005BF 50F400            MOVE              #>4,A0
                            000004
2096      P:0005C1 P:0005C1 200005            CMP     B,A
2097      P:0005C2 P:0005C2 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
2098      P:0005C3 P:0005C3 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
2099      P:0005C4 P:0005C4 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
2100      P:0005C5 P:0005C5 0A1E81  TRY_1_BD  JCLR    #1,X:BINBIT,TRY_2_BD
                            0005CE
2101                                ;       MOVE    #3,A0                   ; HACK
2102                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
2103      P:0005C7 P:0005C7 51F400            MOVE              #(END_SERIAL_READ_FG_1-SERIAL_READ_FG_1),B0
                            00000E
2104      P:0005C9 P:0005C9 60F400            MOVE              #SERIAL_READ_FG_1,R0    ; Here if FG amp, bin by 1
                            0002C0
2105      P:0005CB P:0005CB 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2106      P:0005CC P:0005CC 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2107      P:0005CD P:0005CD 0C064B            JMP     <CMP_END
2108      P:0005CE P:0005CE 0A1E82  TRY_2_BD  JCLR    #2,X:BINBIT,TRY_3_BD
                            0005D7
2109      P:0005D0 P:0005D0 51F400            MOVE              #(END_SERIAL_READ_FG_2-SERIAL_READ_FG_2),B0
                            000014
2110      P:0005D2 P:0005D2 60F400            MOVE              #SERIAL_READ_FG_2,R0    ; Here if FG amp, bin by 2
                            0002F0
2111      P:0005D4 P:0005D4 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2112      P:0005D5 P:0005D5 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2113      P:0005D6 P:0005D6 0C064B            JMP     <CMP_END
2114      P:0005D7 P:0005D7 0A1E83  TRY_3_BD  JCLR    #3,X:BINBIT,TRY_4_BD
                            0005E0
2115      P:0005D9 P:0005D9 51F400            MOVE              #(END_SERIAL_READ_FG_3-SERIAL_READ_FG_3),B0
                            00001A
2116      P:0005DB P:0005DB 60F400            MOVE              #SERIAL_READ_FG_3,R0    ; Here if FG amp, bin by 3
                            000332
2117      P:0005DD P:0005DD 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2118      P:0005DE P:0005DE 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2119      P:0005DF P:0005DF 0C064B            JMP     <CMP_END
2120      P:0005E0 P:0005E0 0A1E84  TRY_4_BD  JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
2121      P:0005E2 P:0005E2 51F400            MOVE              #(END_SERIAL_READ_FG_4-SERIAL_READ_FG_4),B0
                            000020
2122      P:0005E4 P:0005E4 60F400            MOVE              #SERIAL_READ_FG_4,R0    ; Here if FG amp, bin by 4
                            000386
2123      P:0005E6 P:0005E6 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2124      P:0005E7 P:0005E7 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2125      P:0005E8 P:0005E8 0C064B            JMP     <CMP_END
2126   
2127      P:0005E9 P:0005E9 56F400  CMP_ALL   MOVE              #'ALL',A                ;  ABCD Amplifier = e2v EFGH amp = Leach cha
nnels 0-3
                            414C4C
2128      P:0005EB P:0005EB 200045            CMP     X0,A
2129      P:0005EC P:0005EC 0E264E            JNE     <CMP_ERROR
2130      P:0005ED P:0005ED 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
2131      P:0005EE P:0005EE 46F400            MOVE              #ABCD_SPLIT,Y0
                            000245
2132      P:0005F0 P:0005F0 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
2133      P:0005F2 P:0005F2 46F400            MOVE              #CD_UP,Y0
                            00027A
2134      P:0005F4 P:0005F4 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels; NA for split pa
rallels
                            00000E
2135      P:0005F6 P:0005F6 46F400            MOVE              #ABCD_CLEAR_SPLIT,Y0
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 43



                            00026C
2136      P:0005F8 P:0005F8 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
2137      P:0005FA P:0005FA 46F400            MOVE              #CD_CLEAR_UP,Y0
                            000290
2138      P:0005FC P:0005FC 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only; NA for split p
arallels
                            000010
2139   
2140      P:0005FE P:0005FE 46F400            MOVE              #SERIAL_SKIP_SPLIT,Y0
                            0000F8
2141      P:000600 P:000600 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
2142      P:000602 P:000602 46F400            MOVE              #INITIAL_CLOCK_SPLIT,Y0
                            00004D
2143      P:000604 P:000604 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
2144      P:000606 P:000606 46F400            MOVE              #SERIAL_CLOCK_SPLIT,Y0
                            000062
2145      P:000608 P:000608 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
2146                                ;       42
2147                                ;       MOVE    #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),Y0
2148      P:00060A P:00060A 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032012
2149   
2150      P:00060C P:00060C 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007E
2151                                ;        MOVE    #$00F060,Y0             ; All four channels
2152      P:00060E P:00060E 46F400            MOVE              #$00F0C0,Y0             ; All four channels
                            00F0C0
2153      P:000610 P:000610 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            00007A
2154      P:000612 P:000612 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_1 ; and into all the hard-coded binned 
cases in high Y
                            0002D4
2155      P:000614 P:000614 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_2
                            000310
2156      P:000616 P:000616 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_3
                            00035E
2157      P:000618 P:000618 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_4
                            0003BE
2158   
2159   
2160      P:00061A P:00061A 0A0025            BSET    #SPLIT_S,X:<STATUS                ; Serials split
2161      P:00061B P:00061B 0A0026            BSET    #SPLIT_P,X:<STATUS                ; Parallels split
2162   
2163                                ; Now go through copying in the serial read waveform if binning more than 4.
2164      P:00061C P:00061C 200013            CLR     A
2165      P:00061D P:00061D 20001B            CLR     B
2166      P:00061E P:00061E 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
2167      P:000620 P:000620 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
2168      P:000621 P:000621 50F400            MOVE              #>4,A0
                            000004
2169      P:000623 P:000623 200005            CMP     B,A
2170      P:000624 P:000624 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
2171      P:000625 P:000625 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
2172      P:000626 P:000626 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
2173      P:000627 P:000627 0A1E81  TRY_1_ALL JCLR    #1,X:BINBIT,TRY_2_ALL
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 44



                            000630
2174                                ;       MOVE    #3,A0                   ; HACK
2175                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
2176      P:000629 P:000629 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                            00000E
2177      P:00062B P:00062B 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if ALL amp, bin by 1
                            0002CE
2178      P:00062D P:00062D 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2179      P:00062E P:00062E 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2180      P:00062F P:00062F 0C064B            JMP     <CMP_END
2181      P:000630 P:000630 0A1E82  TRY_2_ALL JCLR    #2,X:BINBIT,TRY_3_ALL
                            000639
2182      P:000632 P:000632 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                            000014
2183      P:000634 P:000634 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if ALL amp, bin by 2
                            000304
2184      P:000636 P:000636 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2185      P:000637 P:000637 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2186      P:000638 P:000638 0C064B            JMP     <CMP_END
2187      P:000639 P:000639 0A1E83  TRY_3_ALL JCLR    #3,X:BINBIT,TRY_4_ALL
                            000642
2188      P:00063B P:00063B 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                            00001A
2189      P:00063D P:00063D 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if ALL amp, bin by 3
                            00034C
2190      P:00063F P:00063F 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2191      P:000640 P:000640 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2192      P:000641 P:000641 0C064B            JMP     <CMP_END
2193      P:000642 P:000642 0A1E84  TRY_4_ALL JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
2194      P:000644 P:000644 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                            000020
2195      P:000646 P:000646 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if ALL amp, bin by 4
                            0003A6
2196      P:000648 P:000648 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2197      P:000649 P:000649 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2198      P:00064A P:00064A 0C064B            JMP     <CMP_END
2199   
2200   
2201                                ;       returns modified as per "Four points", #1
2202      P:00064B P:00064B 47F400  CMP_END   MOVE              #'DON',Y1
                            444F4E
2203      P:00064D P:00064D 00000C            RTS
2204                                CMP_ERROR
2205      P:00064E P:00064E 47F400            MOVE              #'ERR',Y1
                            455252
2206      P:000650 P:000650 00000C            RTS
2207   
2208                                ; Short function to copy in waveforms from high Y to fast Y memory.
2209                                ; R0 is the source address, R7 the destination, and X0 is intermediary reg.
2210                                WAVECPY
2211      P:000651 P:000651 06C900            DO      B0,WAVELP                         ; Copy the waveform; B0 is SERWAVLEN already
                            000655
2212      P:000653 P:000653 4CD800            MOVE                          Y:(R0)+,X0
2213      P:000654 P:000654 4C5F00            MOVE                          X0,Y:(R7)+
2214      P:000655 P:000655 000000            NOP
2215                                WAVELP
2216      P:000656 P:000656 000000            NOP
2217      P:000657 P:000657 00000C            RTS
2218   
2219                                ; Short function to set the correct bit in BINBIT based on NSBIN
2220                                ; Called only if NSBIN is less than 6.
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 45



2221   
2222                                SET_BINBIT
2223                                ;       MOVE    Y:<TESTLOC1,A0                  ; HACK - test if this code is executed
2224                                ;       INC     A                               ; HACK
2225                                ;       MOVE    A0,Y:<TESTLOC1                  ; HACK
2226      P:000658 P:000658 50F400            MOVE              #>1,A0                  ; Put a bit in A and shift to right spot
                            000001
2227      P:00065A P:00065A 060540            DO      Y:<NSBIN,BINLOOP                  ; Bit zero position not used, 1-5 used
                            00065C
2228      P:00065C P:00065C 200032            ASL     A
2229                                BINLOOP
2230      P:00065D P:00065D 507000            MOVE              A0,X:BINBIT             ; set bit 1-5 for SELECT_OUTPUT_SOURCE jump 
table
                            00001E
2231      P:00065F P:00065F 00000C            RTS
2232   
2233   
2234                                ; Set the number of rows and columns and binning factors
2235                                ;       Correct command ptr to R3 as per "Four Points" #2
2236                                SET_ROWS_COLUMNS
2237      P:000660 P:000660 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NSR = NAXIS1
2238      P:000661 P:000661 4C7000            MOVE                          X0,Y:NSR
                            000001
2239      P:000663 P:000663 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NPR = NAXIS2
2240      P:000664 P:000664 4C7000            MOVE                          X0,Y:NPR
                            000002
2241      P:000666 P:000666 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NSBIN
2242      P:000667 P:000667 4C7000            MOVE                          X0,Y:NSBIN
                            000005
2243      P:000669 P:000669 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NPBIN
2244      P:00066A P:00066A 4C7000            MOVE                          X0,Y:NPBIN
                            000006
2245      P:00066C P:00066C 4CBB00            MOVE                          Y:<AMPVAL,X0 ; Get ampval in X0 for SOS call
2246      P:00066D P:00066D 0D032C            JSR     <SELECT_OUTPUT_SOURCE             ; Update serial read waveform in case binnin
g changed
2247      P:00066E P:00066E 0C008F            JMP     <FINISH                           ; no error return possible
2248   
2249                                ; Set the variables for the time-resolved modes
2250                                ;       Correct command ptr to R3 as per "Four Points" #2
2251                                SET_IMAGE_PARAM
2252      P:00066F P:00066F 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Image mode
2253      P:000670 P:000670 447000            MOVE              X0,X:IMAGE_MODE
                            000080
2254      P:000672 P:000672 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Iframes = NAXIS3
2255      P:000673 P:000673 4C7000            MOVE                          X0,Y:IFRAMES
                            000038
2256      P:000675 P:000675 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Srows
2257      P:000676 P:000676 4C7000            MOVE                          X0,Y:SROWS
                            000036
2258      P:000678 P:000678 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Interval
2259                                ;       MOVE    X0,Y:INTERVAL           ; HACK - Using Interval as a test location
2260      P:000679 P:000679 0C008F            JMP     <FINISH
2261   
2262   
2263                                ; Set the hardware trigger bit, executed as a command
2264                                ;       Correct command ptr to R3 as per "Four Points" #2
2265                                ; Disable h/w trigger and return error (for now) as per June 30, #8
2266                                ; Disabled temporarily for LMI as well.
2267                                SET_TRIGGER
2268      P:00067A P:00067A 44DB00            MOVE              X:(R3)+,X0              ; Get the trigger value
2269      P:00067B P:00067B 56F400            MOVE              #'_ON',A
                            5F4F4E
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 46



2270      P:00067D P:00067D 200045            CMP     X0,A
2271      P:00067E P:00067E 0AF0A2            JNE     NO_TRIGGER
                            000681
2272                                ;       JSET    #11,X:PBD,TRIG_CLR      ; Is Trigger running?
2273      P:000680 P:000680 0C008D            JMP     <ERROR                            ; Yes! report Error!  Why do this?
2274                                ;TRIG_CLR
2275                                ;       BSET    #TRIGGER,X:<STATUS      ; Set status bit, hardware trigger
2276                                ;       JMP     <FINISH
2277                                NO_TRIGGER
2278      P:000681 P:000681 0A0008            BCLR    #TRIGGER,X:<STATUS                ; Clear Status bit, software timing
2279      P:000682 P:000682 0C008F            JMP     <FINISH
2280   
2281                                ; Calculate the fast read parameters for each readout box
2282                                SETUP_SUBROUTINE
2283      P:000683 P:000683 4C8A00            MOVE                          Y:<SERWAVLEN,X0 ; # of waveforms
2284      P:000684 P:000684 4D9100            MOVE                          Y:<NSERIALS_READ,X1 ; Number of pixels to read
2285      P:000685 P:000685 0D079D            JSR     <FASTSKP                          ; Compute number of clocks required
2286      P:000686 P:000686 4D1400            MOVE                          X1,Y:<NREAD ; Number of waveforms per line
2287      P:000687 P:000687 5E9B00            MOVE                          Y:<NR_BIAS,A ; Number of pixels to read
2288      P:000688 P:000688 0A0085            JCLR    #SPLIT_S,X:STATUS,USPLS           ; Split serials require / 2
                            00068C
2289      P:00068A P:00068A 200022            ASR     A
2290      P:00068B P:00068B 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2291                                USPLS
2292      P:00068C P:00068C 21C500            MOVE              A,X1                    ; Number of waveforms per line
2293      P:00068D P:00068D 0D079D            JSR     <FASTSKP                          ; Compute number of clocks required
2294      P:00068E P:00068E 4D1600            MOVE                          X1,Y:<NBIAS ; Number of waveforms per line
2295      P:00068F P:00068F 44F400            MOVE              #(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT),X0 ; # of waveforms
                            000007
2296      P:000691 P:000691 4D8300            MOVE                          Y:<NS_CLR,X1 ; Number of pixels to skip
2297      P:000692 P:000692 0D079D            JSR     <FASTSKP                          ; Compute number of clocks required
2298      P:000693 P:000693 4D1200            MOVE                          X1,Y:<NSCLR ; Number of waveforms per line
2299      P:000694 P:000694 4D9800            MOVE                          Y:<NS_SKP1,X1 ; Number of pixels to skip
2300      P:000695 P:000695 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
2301      P:000696 P:000696 2000F0            MPY     Y1,X1,A
2302      P:000697 P:000697 200022            ASR     A
2303      P:000698 P:000698 210500            MOVE              A0,X1
2304      P:000699 P:000699 0D079D            JSR     <FASTSKP                          ; Compute number of clocks required
2305      P:00069A P:00069A 4D1300            MOVE                          X1,Y:<NSKIP1 ; Number of waveforms per line
2306      P:00069B P:00069B 4D9900            MOVE                          Y:<NS_SKP2,X1 ; Number of pixels to skip
2307      P:00069C P:00069C 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
2308      P:00069D P:00069D 2000F0            MPY     Y1,X1,A
2309      P:00069E P:00069E 200022            ASR     A
2310      P:00069F P:00069F 210500            MOVE              A0,X1
2311      P:0006A0 P:0006A0 0D079D            JSR     <FASTSKP                          ; Compute number of clocks required
2312      P:0006A1 P:0006A1 4D1500            MOVE                          X1,Y:<NSKIP2 ; Number of waveforms per line
2313      P:0006A2 P:0006A2 4D9700            MOVE                          Y:<NP_SKIP,X1
2314      P:0006A3 P:0006A3 4F8600            MOVE                          Y:<NPBIN,Y1
2315      P:0006A4 P:0006A4 2000F0            MPY     X1,Y1,A
2316      P:0006A5 P:0006A5 200022            ASR     A
2317      P:0006A6 P:0006A6 581700            MOVE                          A0,Y:<NP_SKIP
2318      P:0006A7 P:0006A7 00000C            RTS
2319   
2320                                ; Returns immediately if hardware triggering is not being used
2321                                ; Blocks until the trigger is found to be high twice in a row.
2322                                ; Waits until the trigger goes high
2323                                ; Trigger support disabled temporarily for LMI as well.
2324                                WAIT_UNTIL_TRIGGER
2325      P:0006A8 P:0006A8 0A0088            JCLR    #TRIGGER,X:STATUS,UNTIL_TRIGGER_RETURN
                            0006AD
2326      P:0006AA P:0006AA 000000            NOP
2327                                ;       JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER       ; Is Trigger Low?
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 47



2328      P:0006AB P:0006AB 000000            NOP                                       ; Pause
2329                                ;       JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER       ; Is Trigger still Low?
2330      P:0006AC P:0006AC 000000            NOP
2331                                UNTIL_TRIGGER_RETURN
2332      P:0006AD P:0006AD 00000C            RTS
2333   
2334                                ; Returns immediately if hardware triggering is not being used
2335                                ; Blocks until the trigger is found to be low twice in a row.
2336                                ; Waits while the trigger is high
2337                                ; Trigger support disabled temporarily for LMI as well.
2338                                WAIT_WHILE_TRIGGER
2339      P:0006AE P:0006AE 0A0088            JCLR    #TRIGGER,X:STATUS,WHILE_TRIGGER_RETURN
                            0006B3
2340      P:0006B0 P:0006B0 000000            NOP
2341                                ;       JSET    #11,X:PBD,WAIT_WHILE_TRIGGER       ; Is Trigger High?
2342      P:0006B1 P:0006B1 000000            NOP                                       ; Pause
2343                                ;       JSET    #11,X:PBD,WAIT_WHILE_TRIGGER       ; Is Trigger still High?
2344      P:0006B2 P:0006B2 000000            NOP
2345                                WHILE_TRIGGER_RETURN
2346      P:0006B3 P:0006B3 00000C            RTS
2347   
2348                                ; Like WAIT_WHILE_TRIGGER but clears the CCD while waiting
2349                                ; Pro:  Clears CCD while waiting.  Con: timing rattiness of 1 parallel time
2350                                ; Returns immediately if hardware triggering is not being used
2351                                ; Blocks until the trigger is found to be low twice in a row.
2352                                ; Waits while the trigger is high
2353                                ; Trigger support disabled temporarily for LMI as well.
2354                                CLEAR_WHILE_TRIGGER
2355      P:0006B4 P:0006B4 0A0088            JCLR    #TRIGGER,X:STATUS,CLEAR_TRIG_RETURN
                            0006B8
2356                                ;       MOVE    #IS_PAR_CLR,R0          ; Address of parallel transfer waveform
2357                                ;       JSR     <CLOCK                  ; Go clock out the CCD charge
2358                                ;       JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER       ; Is Trigger High?
2359      P:0006B6 P:0006B6 000000            NOP                                       ; Pause
2360                                ;       JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER      ; Is Trigger still High?
2361      P:0006B7 P:0006B7 000000            NOP
2362                                CLEAR_TRIG_RETURN
2363      P:0006B8 P:0006B8 00000C            RTS
2364   
2365                                ; Subroutine to compute SROWS in unbinned pixels and store in UBSROWS
2366   
2367                                UB_CONV
2368      P:0006B9 P:0006B9 4CB600            MOVE                          Y:<SROWS,X0
2369      P:0006BA P:0006BA 4D8600            MOVE                          Y:<NPBIN,X1 ; Adjust for for parallel binning factor
2370      P:0006BB P:0006BB 2000A0            MPY     X0,X1,A
2371      P:0006BC P:0006BC 200022            ASR     A
2372      P:0006BD P:0006BD 583700            MOVE                          A0,Y:<UBSROWS ; Put unbinned number in UBSROWS
2373      P:0006BE P:0006BE 00000C            RTS
2374   
2375                                ; Key code segments for the HIPO modes.
2376                                ; Jump table to the various modes - see also timhdr.s
2377                                START_FT_EXPOSURE
2378      P:0006BF P:0006BF 0A0008            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of lingering abort flag
2379      P:0006C0 P:0006C0 0A00AA            JSET    #ST_SBFAIL,X:<STATUS,EXPMODE_ST
                            0006CC
2380                                ; go to transition bias levels and then to DD
2381      P:0006C2 P:0006C2 60F400            MOVE              #DACS_TRANS,R0
                            0001CA
2382   
2383                                          IF      @SCP("DACSLOG","SUPPORTED")
2387                                          ENDIF
2388   
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 48



2389      P:0006C4 P:0006C4 0BF080            JSR     SET_BIASES
                            00083A
2390   
2391   
2392      P:0006C6 P:0006C6 0A00AA            JSET    #ST_SBFAIL,X:<STATUS,EXPMODE_ST
                            0006CC
2393                                ; go to deep depletion bias levels, preparation for imaging
2394      P:0006C8 P:0006C8 60F400            MOVE              #DACS_DD,R0
                            000100
2395      P:0006CA P:0006CA 0BF080            JSR     SET_BIASES
                            00083A
2396   
2397                                          IF      @SCP("DACSLOG","SUPPORTED")
2410                                          ENDIF
2411   
2412                                EXPMODE_ST
2413   
2414      P:0006CC P:0006CC 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2415      P:0006CE P:0006CE 0AC421            JSET    #FIND,X0,SINGLE_PROC
                            000703
2416      P:0006D0 P:0006D0 0AC424            JSET    #SINGLE,X0,SINGLE_PROC
                            000703
2417                                ;       JSET    #SERIES,X0,SERIES_PROC        ; defunct.  Use basic occ.
2418      P:0006D2 P:0006D2 0AC420            JSET    #FDOTS,X0,FDOT_PROC
                            0006DD
2419      P:0006D4 P:0006D4 0AC422            JSET    #SDOTS,X0,SDOT_PROC               ; slow dots & strips use sdot_proc
                            00073B
2420      P:0006D6 P:0006D6 0AC425            JSET    #STRIP,X0,SDOT_PROC
                            00073B
2421      P:0006D8 P:0006D8 0AC427            JSET    #B_OCC,X0,SINGLE_PROC             ; basic occ uses single_proc
                            000703
2422                                ;        JSET    #F_OCC,X0,FPO_PROC             ; fast & pipelined occ use occ_proc
2423                                ;        JSET    #P_OCC,X0,FPO_PROC
2424      P:0006DA P:0006DA 44F400            MOVE              #'ERR',X0               ; error if not a valid mode
                            455252
2425      P:0006DC P:0006DC 0C008D            JMP     <ERROR
2426   
2427                                FDOT_PROC                                           ; used by fdots only
2428                                ; Start by replacing SROWS (binned rows) with unbinned rows.  Will get rewritten on next SEX com
mand
2429                                ; Leave the DO loop in here - no reason to change it - won't exceed 65535 dots, for sure!
2430      P:0006DD P:0006DD 0D06B9            JSR     UB_CONV                           ; Fill in unbinned SROWS
2431      P:0006DE P:0006DE 4C8200            MOVE                          Y:<NPR,X0
2432      P:0006DF P:0006DF 4C1D00            MOVE                          X0,Y:<NP_READ ; Make sure that NP_READ=NPR in case of su
bframe
2433      P:0006E0 P:0006E0 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
2434      P:0006E1 P:0006E1 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for FDOTS
2435      P:0006E2 P:0006E2 0A2020            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe bou
ndary
2436      P:0006E3 P:0006E3 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            000765
2437      P:0006E5 P:0006E5 0D02FB            JSR     <CLR_CCD                          ; Clear out the CCD
2438      P:0006E6 P:0006E6 0D06AE            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2439                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2440      P:0006E7 P:0006E7 0D07B4            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2441      P:0006E8 P:0006E8 063840            DO      Y:<IFRAMES,FDOT_LOOP              ; Loop over the number of FDOTS
                            0006F9
2442      P:0006EA P:0006EA 0A00A8            JSET    #TRIGGER,X:STATUS,FDX_END         ; If no triggering jump to expose image func
tion
                            0006F0
2443      P:0006EC P:0006EC 67F400            MOVE              #FDX_END,R7             ; Store the Address into R7
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 49



                            0006F0
2444      P:0006EE P:0006EE 0A0027            BSET    #ST_EXP,X:<STATUS
2445      P:0006EF P:0006EF 0C0315            JMP     <EXPOSE                           ; Delay for specified exposure time
2446                                FDX_END
2447      P:0006F0 P:0006F0 0A0007            BCLR    #ST_EXP,X:<STATUS
2448      P:0006F1 P:0006F1 0A0088            JCLR    #ST_ABRT,X:<STATUS,FDX_NXT        ; got abort underway?
                            0006F5
2449      P:0006F3 P:0006F3 00008C            ENDDO
2450      P:0006F4 P:0006F4 0C0701            JMP     <FDOT_FINI
2451                                FDX_NXT
2452      P:0006F5 P:0006F5 0D06A8            JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2453      P:0006F6 P:0006F6 4DB700            MOVE                          Y:<UBSROWS,X1 ; Number of unbinned rows per shift
2454      P:0006F7 P:0006F7 0D0784            JSR     <ISHIFT                           ; Clock out the waveforms
2455      P:0006F8 P:0006F8 0D06AE            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2456      P:0006F9 P:0006F9 000000            NOP
2457                                FDOT_LOOP
2458      P:0006FA P:0006FA 0D07BB            JSR     <C_CSHUT                          ; Conditionally close shutter
2459      P:0006FB P:0006FB 063840            DO      Y:<IFRAMES,FDOT_LP1               ; Loop over the number of FDOTS during reado
ut
                            000700
2460      P:0006FD P:0006FD 0A0024            BSET    #ST_RDC,X:<STATUS
2461      P:0006FE P:0006FE 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD
2462      P:0006FF P:0006FF 0A0004            BCLR    #ST_RDC,X:<STATUS
2463      P:000700 P:000700 000000            NOP
2464                                FDOT_LP1
2465                                FDOT_FINI
2466                                ;       CLOSE SHUTTER if abt??
2467                                ;       JSR     <WAIT_UNTIL_TRIGGER             ; If taking more than one set of dots sync. trig
ger.  Vestigial?
2468      P:000701 P:000701 0AF080            JMP     CLEANUP                           ; clean up after command.
                            00076D
2469   
2470                                SINGLE_PROC                                         ; Used by find, single, and basic occ
2471      P:000703 P:000703 0A2001            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for find & basic occ
2472      P:000704 P:000704 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2473      P:000706 P:000706 0AC404            JCLR    #SINGLE,X0,NOT_SINGM              ; But if single mode,
                            000709
2474      P:000708 P:000708 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
2475                                NOT_SINGM
2476   
2477                                ; Note: LMI uses both storage and img area for singles for maximum frame.
2478      P:000709 P:000709 0A2002            BCLR    #STORAGE,X:<ISTATUS               ; Do the FT, no storage clocks only during r
eadout
2479      P:00070A P:00070A 0AC427            JSET    #B_OCC,X0,AN_OCC                  ; STORAGE=0 for basic, 1 otherwise
                            00070D
2480      P:00070C P:00070C 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't do the FT, ganged clocks only during
 readout
2481                                AN_OCC
2482   
2483      P:00070D P:00070D 0A2000            BCLR    #NO_SKIP,X:<ISTATUS               ; Do parallel skip up to the subframe bounda
ry
2484                                          IF      @SCP("10","0")
2485                                          ELSE
2486      P:00070E P:00070E 060A80            DO      #SDELAY,SNGL_DELAY1
                            000715
2487      P:000710 P:000710 44F400            MOVE              #25000,X0
                            0061A8
2488      P:000712 P:000712 06C400            DO      X0,SNGL_DELAY0
                            000714
2489      P:000714 P:000714 000000            NOP
2490                                 SNGL_DELAY0
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 50



2491      P:000715 P:000715 000000            NOP
2492                                 SNGL_DELAY1
2493      P:000716 P:000716 000000            NOP
2494                                          ENDIF
2495   
2496      P:000717 P:000717 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            000765
2497      P:000719 P:000719 0D02FB            JSR     <CLR_CCD                          ; Clear out the CCD
2498      P:00071A P:00071A 0D06AE            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2499                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2500      P:00071B P:00071B 4CB800            MOVE                          Y:<IFRAMES,X0
2501      P:00071C P:00071C 4C3C00            MOVE                          X0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
2502      P:00071D P:00071D 0D07B4  SN_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2503                                ;        JSET    #TRIGGER,X:STATUS,SNX_END       ; If no triggering jump to expose image functio
n
2504      P:00071E P:00071E 67F400            MOVE              #SNX_END,R7             ; Store the Address into R7
                            000722
2505      P:000720 P:000720 0A0027            BSET    #ST_EXP,X:<STATUS
2506      P:000721 P:000721 0C0315            JMP     <EXPOSE                           ; Delay for specified exposure time
2507                                SNX_END
2508      P:000722 P:000722 0A0007            BCLR    #ST_EXP,X:<STATUS
2509      P:000723 P:000723 0A00A8            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                            000734
2510   
2511      P:000725 P:000725 0D06A8            JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2512      P:000726 P:000726 0D07BB            JSR     <C_CSHUT                          ; Close shutter if open-close bit is set
2513      P:000727 P:000727 0A0024            BSET    #ST_RDC,X:<STATUS
2514      P:000728 P:000728 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD
2515      P:000729 P:000729 0A0004            BCLR    #ST_RDC,X:<STATUS
2516      P:00072A P:00072A 0D06AE            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2517      P:00072B P:00072B 0A00A8            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                            000734
2518      P:00072D P:00072D 200013            CLR     A
2519      P:00072E P:00072E 58BC00            MOVE                          Y:<IFLPCNT,A0
2520      P:00072F P:00072F 00000A            DEC     A                                 ; Get loop count, decrement, and loop till z
ero
2521      P:000730 P:000730 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2522      P:000731 P:000731 583C00            MOVE                          A0,Y:<IFLPCNT
2523      P:000732 P:000732 200003            TST     A
2524      P:000733 P:000733 0E271D            JNE     SN_LP                             ; End of IFRAMES loop
2525                                SNX_FINI
2526      P:000734 P:000734 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2527                                                                                    ; if you abort a find does the shutter close
?
2528      P:000736 P:000736 0AC421            JSET    #FIND,X0,SNX_DONE
                            000739
2529      P:000738 P:000738 0D07BD            JSR     <CSHUT                            ; Close the shutter unless in find mode
2530                                SNX_DONE
2531      P:000739 P:000739 0AF080            JMP     CLEANUP                           ; clean up after command.
                            00076D
2532   
2533                                ; NO abort support
2534                                SDOT_PROC                                           ; Used by slow dots and strips
2535      P:00073B P:00073B 4CB600            MOVE                          Y:<SROWS,X0
2536      P:00073C P:00073C 4C1D00            MOVE                          X0,Y:<NP_READ ; Make sure that NP_READ=SROWS
2537      P:00073D P:00073D 0A2001            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for strips
2538      P:00073E P:00073E 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2539      P:000740 P:000740 0AC402            JCLR    #SDOTS,X0,SDOT_STORE              ; But if sdots mode,
                            000743
2540      P:000742 P:000742 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 51



2541                                SDOT_STORE
2542      P:000743 P:000743 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for SDOTS an
d strips
2543      P:000744 P:000744 0A2020            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe bou
ndary
2544      P:000745 P:000745 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            000765
2545      P:000747 P:000747 0D02FB            JSR     <CLR_CCD                          ; Clear out the CCD
2546      P:000748 P:000748 0D06AE            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2547                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2548      P:000749 P:000749 4CB800            MOVE                          Y:<IFRAMES,X0
2549      P:00074A P:00074A 4C3C00            MOVE                          X0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
2550      P:00074B P:00074B 0D07B4  SD_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2551      P:00074C P:00074C 0A00A8            JSET    #TRIGGER,X:STATUS,SDX_END         ; If no triggering jump to expose image func
tion
                            000755
2552      P:00074E P:00074E 67F400            MOVE              #SDX_END,R7             ; Store the Address into R7
                            000755
2553      P:000750 P:000750 0A0027            BSET    #ST_EXP,X:<STATUS
2554      P:000751 P:000751 0C0315            JMP     <EXPOSE                           ; Delay for specified exposure time
2555      P:000752 P:000752 0A0007            BCLR    #ST_EXP,X:<STATUS
2556      P:000753 P:000753 0A00A8            JSET    #ST_ABRT,X:<STATUS,SDX_FINI       ; got abort underway?
                            000762
2557      P:000755 P:000755 0D06A8  SDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2558      P:000756 P:000756 0D07BB            JSR     <C_CSHUT                          ; Close shutter if open-close is set
2559      P:000757 P:000757 0A0024            BSET    #ST_RDC,X:<STATUS
2560      P:000758 P:000758 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD.
2561      P:000759 P:000759 0A0004            BCLR    #ST_RDC,X:<STATUS
2562                                                                                    ; No FT or parallel skip since STORAGE=1
2563      P:00075A P:00075A 0D06AE            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2564      P:00075B P:00075B 200013            CLR     A
2565      P:00075C P:00075C 58BC00            MOVE                          Y:<IFLPCNT,A0
2566      P:00075D P:00075D 00000A            DEC     A                                 ; Get loop count, decrement, and loop till z
ero
2567      P:00075E P:00075E 000000            NOP
2568      P:00075F P:00075F 583C00            MOVE                          A0,Y:<IFLPCNT
2569      P:000760 P:000760 200003            TST     A
2570      P:000761 P:000761 0E274B            JNE     SD_LP                             ; End of IFRAMES loop
2571                                SDX_FINI
2572      P:000762 P:000762 0D07BD            JSR     <CSHUT                            ; Unconditionally close shutter
2573      P:000763 P:000763 0AF080            JMP     CLEANUP                           ; clean up after command.
                            00076D
2574   
2575                                ; Fast/Pipeline Occultations NOT supported- LMI isn't a fast camera
2576                                        COMMENT *
2577   
2578                                FPO_PROC                                        ; Used by fast and pipelined occultation modes
2579                                        MOVE    Y:<NP_READ,X0
2580                                        MOVE    X0,Y:<SROWS                     ; Make sure that SROWS=NP_READ
2581                                        JSR     UB_CONV                         ; Fill in unbinned SROWS in UBSROWS
2582                                        BCLR    #OPEN_CLOSE,X:<ISTATUS          ; clear open-close for both of these modes
2583                                        BCLR    #STORAGE,X:<ISTATUS             ; Storage clocks only during readout
2584                                        BSET    #NO_SKIP,X:<ISTATUS             ; Don't parallel skip up to the subframe boundar
y
2585                                        JSR     IMG_INI                         ; Set up the status bits and PCI card
2586                                        JSR     <CLR_CCD                        ; Clear out the CCD
2587                                        JSR     <WAIT_WHILE_TRIGGER             ; wait for low trigger, or
2588                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2589                                        JSR     <C_OSHUT                        ; Open shutter if not a dark frame
2590                                        MOVE    Y:<IFRAMES,X0
2591                                        MOVE    X0,Y:<IFLPCNT                   ; Set up 24-bit loop counter in IFLPCNT
2592                                FP_LP   JSET    #TRIGGER,X:STATUS,FPO_END       ; If no triggering jump to expose image function
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 52



2593                                        MOVE    #FPO_END,R7                     ; Store the Address into R7
2594                                        BSET    #ST_EXP,X:<STATUS
2595                                        JMP     <EXPOSE                         ; Delay for specified exposure time
2596                                        BCLR    #ST_EXP,X:<STATUS
2597                                        JSET    #ST_ABRT,X:<STATUS,FPO_FINI     ; got abort underway?
2598                                FPO_END JSR     <WAIT_UNTIL_TRIGGER             ; wait for high trigger or fall through
2599                                        MOVE    Y:<UBSROWS,X1                   ; Shift down UBSROWS unbinned rows
2600                                        JSR     ISHIFT                          ; Clock down subframe height
2601                                        MOVE    X:IMAGE_MODE,X0
2602                                        JSET    #P_OCC,X0,FPO_RD        ; Shift the rest of the way for F_OCC
2603                                                                                ; Go straight to readout if P_OCC
2604                                        MOVE    Y:S_SIZE,X0
2605                                        MOVE    X0,A                            ; Get only least significant 24 bits
2606                                        MOVE    Y:<UBSROWS,X0
2607                                        SUB     X0,A                            ;
2608                                        NOP                                     ; 56300 pipeline as per July 5 #4
2609                                        MOVE    A,X1                            ; X1 = S_SIZE - UBSROWS
2610                                        JSR     SSHIFT                          ; Clock storage the rest of the way
2611                                        BSET    #ST_RDC,X:<STATUS
2612                                FPO_RD  JSR     <RCCD1                          ; Finally, read out the CCD.  Skip the FT
2613                                        BCLR    #ST_RDC,X:<STATUS
2614                                        MOVE    X:IMAGE_MODE,X0
2615                                        JSET    #F_OCC,X0,FPO_SK        ; Shift back up by UBSROWS if P_OCC
2616                                        MOVE    Y:<UBSROWS,X1                   ; Shift UBSROWS unbinned rows back up
2617                                        JSR     RSHIFT                          ; Clock subframe height back up
2618                                FPO_SK  JSR     <WAIT_WHILE_TRIGGER             ; wait for low trigger
2619                                        CLR     A
2620                                        MOVE    Y:<IFLPCNT,A0
2621                                        DEC     A                               ; Get loop count, decrement, and loop till zero
2622                                        NOP                                     ; 56300 pipeline as per July 5 #4
2623                                        MOVE    A0,Y:<IFLPCNT
2624                                        TST     A
2625                                        JNE     FP_LP                           ; End of IFRAMES loop
2626                                FPO_FINI
2627                                        JSR     <CSHUT                          ; Unconditionally close shutter
2628                                        JMP     CLEANUP                         ; clean up after command.
2629                                        *
2630   
2631                                ; Support subroutines and code fragments used in the various mode code
2632                                ; IMG_INI, CLEANUP, ISHIFT, SSHIFT, RSHIFT
2633                                ;  Image initialization subroutine.  Sets up status bits & PCI card
2634                                ; Correct XMT_FO to XMT_WRD in timboot.s and change the input arg to B1
2635                                ; as per "Four Points" #3
2636   
2637      P:000765 P:000765 55F400  IMG_INI   MOVE              #$020102,B1             ; Transmit header word
                            020102
2638      P:000767 P:000767 0D00EB            JSR     <XMT_WRD
2639      P:000768 P:000768 55F400            MOVE              #'IIA',B1               ; Initialize Image Address
                            494941
2640      P:00076A P:00076A 0D00EB            JSR     <XMT_WRD
2641                                ;        BSET    #ST_RDC,X:<STATUS       ; Set status to reading out
2642      P:00076B P:00076B 0D0905            JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
2643      P:00076C P:00076C 00000C            RTS
2644   
2645                                ; Cleanup code fragment (not a subroutine) for the end all modes.  JMP to it.
2646                                ; remove WW mode reference and also do a CLOCK wait.
2647                                ; support no idling mode as per MLO code.
2648                                ; all as per July 4 confluence #1
2649   
2650                                ;CLEANUP BCLR    #WW,X:PBD               ; Clear WW to 0 for 32-bit commands
2651                                CLEANUP
2652      P:00076D P:00076D 0A00AA            JSET    #ST_SBFAIL,X:<STATUS,EXPMODE_IDL
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 53



                            000779
2653                                ; go to transition bias levels, then to standard levels
2654   
2655                                          IF      @SCP("DACSLOG","SUPPORTED")
2659                                          ENDIF
2660   
2661      P:00076F P:00076F 60F400            MOVE              #DACS_TRANS,R0
                            0001CA
2662      P:000771 P:000771 0BF080            JSR     SET_BIASES
                            00083A
2663      P:000773 P:000773 0A00AA            JSET    #ST_SBFAIL,X:<STATUS,EXPMODE_IDL
                            000779
2664                                ; go to standard inverted bias levels, preparation for idling
2665      P:000775 P:000775 60F400            MOVE              #DACS_INV,R0
                            000165
2666      P:000777 P:000777 0BF080            JSR     SET_BIASES
                            00083A
2667   
2668                                          IF      @SCP("DACSLOG","SUPPORTED")
2681                                          ENDIF
2682   
2683   
2684                                EXPMODE_IDL
2685                                ; Restore the controller to non-image data transfer and idling if necessary
2686      P:000779 P:000779 0A0082            JCLR    #IDLMODE,X:<STATUS,NO_IDL         ; Don't idle after readout
                            00077E
2687      P:00077B P:00077B 60F400            MOVE              #IDLE,R0
                            000307
2688      P:00077D P:00077D 0C077F            JMP     <CLEAN1
2689      P:00077E P:00077E 305A00  NO_IDL    MOVE              #TST_RCV,R0
2690                                CLEAN1
2691      P:00077F P:00077F 0BF080            JSR     CLOCK_WAIT                        ; so everything is transferred
                            000792
2692      P:000781 P:000781 601F00            MOVE              R0,X:<IDL_ADR
2693   
2694                                ;        BCLR    #ST_RDC,X:<STATUS       ; Clear status to NOT reading out
2695      P:000782 P:000782 0A0008            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of any abort flag
2696      P:000783 P:000783 0C0054            JMP     <START                            ; Wait for a new command
2697   
2698                                ; Shift image and storage areas down by the number of rows in X1
2699                                ISHIFT
2700                                ; NO IMO for LMI
2701                                ;       IF      @SCP("IMOMODE","IMO")
2702                                ;       MOVE    #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2703                                ;       JSR     <CLOCK                  ; IMO
2704                                ;       NOP                             ; IMO
2705                                ;       ENDIF
2706   
2707      P:000784 P:000784 06C500            DO      X1,ISH_LOOP                       ; Number of rows to shift is in X1
                            000789
2708      P:000786 P:000786 68F000            MOVE                          Y:IS_PAR_CLR,R0 ; Ganged clocks with DG running
                            00000F
2709                                ; mitigation 5
2710                                ;        JSET    #STORAGE,X:ISTATUS,GANG_SF  ; if STORAGE == 0 store clocks only
2711                                ;GANG_SF
2712   
2713      P:000788 P:000788 0D02E0            JSR     <CLOCK                            ; Parallel clocking
2714      P:000789 P:000789 000000            NOP
2715                                ISH_LOOP
2716      P:00078A P:00078A 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                            0002AC
2717      P:00078C P:00078C 0D02E0            JSR     <CLOCK
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timmisc.s  Page 54



2718                                ;       MOVE    #<IMO_LAST_CLOCK,R0             ; set clocks to 0
2719                                ;       JSR     <CLOCK
2720      P:00078D P:00078D 00000C            RTS                                       ; End of ISHIFT
2721   
2722                                        COMMENT *
2723                                ; Shift storage area only down by the number of rows in X1
2724                                SSHIFT
2725                                ; NO IMO for LMI
2726                                ;       IF      @SCP("IMOMODE","IMO")
2727                                ;       MOVE    #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2728                                ;       JSR     <CLOCK                  ; IMO
2729                                ;       NOP                             ; IMO
2730                                ;       ENDIF
2731                                        DO      X1,SSH_LOOP             ; Number of rows to shift is in X1
2732                                        MOVE    Y:<S_PAR_CLR,R0         ; Storage clocks only with DG running
2733                                        JSR     <CLOCK                  ; Parallel clocking
2734                                        NOP
2735                                SSH_LOOP
2736                                        MOVE    #DUMP_SERIAL,R0         ; clear the SR after parallel clear
2737                                        JSR     <CLOCK
2738                                        RTS                     ; End of SSHIFT
2739   
2740                                ; Used by pipelined occultation mode to move the storage area back up to
2741                                ; the seam following read of a subframe
2742                                RSHIFT
2743                                        IF      @SCP("IMOMODE","IMO")
2744                                        MOVE    #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2745                                        JSR     <CLOCK                  ; IMO
2746                                        NOP                             ; IMO
2747                                        ENDIF
2748                                        DO      X1,RVS_SHIFT            ; Number of rows to read out
2749                                        MOVE    #<R_S_PARALLEL,R0       ; Reverse parallel waveform
2750                                        JSR     <CLOCK                  ; Parallel clocking
2751                                        NOP
2752                                RVS_SHIFT
2753                                        RTS                     ; End of RSHIFT
2754                                        *
2755                                          INCLUDE "timCCDmisc.s"                    ; Generic
2756                                ; This file is for utilities that are in common to all the timing board
2757                                ;   programs, located starting at P:$200 in external SRAM
2758   
2759                                        COMMENT *
2760   
2761                                The following commands are supported in this "timmisc.s" file
2762                                PAL_DLY                 Subroutine to delay by about 8 microseconds
2763                                SET_DAC                 Transfer DAC values in (R0) table to the DACs
2764                                FASTSKP                 Compute number of waveform table entries in a readout
2765                                                                for fast clocking
2766                                OSHUT                   Subroutine call for opening the shutter
2767                                CSHUT                   Subroutine call for closing the shutter
2768                                OPEN_SHUTTER            Command for opening the shutter
2769                                CLOSE_SHUTTER           Command for closing the shutter
2770                                SET_EXP_TIME            Write desired exposure time to timing board variable
2771                                RD_EXP_TIME             Read elapsed exposure time
2772                                START_EXPOSURE          Start an exposure - 'DON' reply, clear FPA, open
2773                                                        shutter, expose, close shutter, delay Y:SH_DLY, readout
2774                                PAUSE_EXPOSURE          Close shutter, stop exposure timer
2775                                RESUME_EXPOSURE         Open shutter if necessary, resume exposure timer
2776                                ABORT_EXPOSURE          Close shutter, stop exposure timer
2777                                INF                     Return version and timing information
2778                                IDL                     Put FPA to clocking when not processing commands or
2779                                                        reading out
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 55



2780                                READ_CONTROLLER_CONFIGURATION
2781   
2782                                PWR_OFF                 Turn off ananlog power supply voltages to backplane
2783                                PWR_ON                  Turn on analog power supply voltages to backplane
2784                                SETBIAS                 Command to call SET_BIASES and reply 'DON'
2785                                SET_BIASES              Subroutine to turn on all bias and clock voltages
2786                                                        by reading them from the waveform tables and writing
2787                                                        them to the DACs
2788                                SER_ANA                 Direct the timing board DSP's synchronous serial
2789                                                        transmitter to the analog boards (clock driver, video)
2790                                SER_UTL                 Direct the timing board DSP's synchronous serial
2791                                                        transmitter to the utility board
2792                                CLR_SWS                 Clear the analog switches in the clock driver and
2793                                                        video boards to lower their power consumption, as a
2794                                                        command with a 'DON' reply
2795                                CLEAR_SWITCHES          A subroutine call for CLR_WSW
2796                                ST_GAIN                 Set the video processor gain to one of four values
2797                                WR_CNTRL
2798                                SET_DC
2799                                SET_BIAS_NUMBER
2800                                SET_MUX
2801   
2802                                        *
2803   
2804                                ; These become a single line macros, as per June 30 #12
2805                                ; Enable serial communication to the analog boards
2806                                SER_ANA   MACRO
2807 m                                        BSET    #3,X:PCRD                         ; Turn on the serial clock
2808 m                                        ENDM
2809                                ; Enable serial communication to the utility board
2810                                SER_UTL   MACRO
2811 m                                        BCLR    #3,X:PCRD                         ; Turn off the serial clock
2812 m                                        ENDM
2813   
2814   
2815                                ; Delay for serial writes to the PALs and DACs by 8 microsec
2816                                ; Conformed to gen-iii MLO as per CCDmisc comments June 30 #1
2817      P:00078E P:00078E 062083  PAL_DLY   DO      #800,*+3                          ; Wait 8 usec for serial data transmission
                            000790
2818      P:000790 P:000790 000000            NOP
2819      P:000791 P:000791 00000C            RTS
2820   
2821                                ; Wait for clocking to be complete before proceeding
2822                                ; Code added as per June 29 #5
2823                                CLOCK_WAIT
2824      P:000792 P:000792 01ADA1            JSET    #SSFEF,X:PDRD,*                   ; Wait for the SS FIFO to be empty
                            000792
2825      P:000794 P:000794 00000C            RTS
2826   
2827   
2828   
2829                                ;  Update the DACs
2830                                ; Remove cruft as per June 30 #2
2831      P:000795 P:000795 4CD800  SET_DAC   MOVE                          Y:(R0)+,X0  ; Get the number of table entries
2832      P:000796 P:000796 06C400            DO      X0,SET_L0                         ; Repeat X0 times
                            00079B
2833      P:000798 P:000798 5ED800            MOVE                          Y:(R0)+,A   ; Send out the waveform
2834      P:000799 P:000799 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
2835      P:00079A P:00079A 0D078E            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
2836      P:00079B P:00079B 000000            NOP                                       ; Do loop restriction
2837                                SET_L0
2838      P:00079C P:00079C 00000C            RTS                                       ; Return from subroutine
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 56



2839   
2840                                ; Subroutine for computing number of fast clocks needed
2841                                ; remove the offset for gen-iii, as per June 30 general comment #3
2842      P:00079D P:00079D 2000A8  FASTSKP   MPY     X0,X1,B                           ; X1 = number of pixels to skip,
2843                                                                                    ; X0 = number of waveform table entries
2844      P:00079E P:00079E 20002A            ASR     B                                 ; Correct for multiplication left shift
2845      P:00079F P:00079F 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2846      P:0007A0 P:0007A0 212500            MOVE              B0,X1                   ; Get only least significant 24 bits
2847      P:0007A1 P:0007A1 00000C            RTS
2848   
2849                                ; open (X0 = 0) or close (X0=10) shutter, h/w only.
2850                                SET_SHUTTER_STATE
2851      P:0007A2 P:0007A2 568F00            MOVE              X:LATCH,A
2852      P:0007A3 P:0007A3 0140C6            AND     #$FFEF,A
                            00FFEF
2853      P:0007A5 P:0007A5 200042            OR      X0,A
2854      P:0007A6 P:0007A6 000000            NOP
2855      P:0007A7 P:0007A7 540F00            MOVE              A1,X:LATCH
2856      P:0007A8 P:0007A8 09CC35            MOVEP             A1,Y:WRLATCH
2857      P:0007A9 P:0007A9 00000C            RTS
2858   
2859                                ; Open the shutter from the timing board, executed as a command
2860                                OPEN_SHUTTER
2861      P:0007AA P:0007AA 0A0023            BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
2862                                ;       MOVE    #0,X0
2863      P:0007AB P:0007AB 44F400            MOVE              #>$10,X0
                            000010
2864      P:0007AD P:0007AD 0D07A2            JSR     <SET_SHUTTER_STATE
2865      P:0007AE P:0007AE 0C008F            JMP     <FINISH
2866   
2867                                ; Close the shutter from the timing board, executed as a command
2868                                CLOSE_SHUTTER
2869      P:0007AF P:0007AF 0A0003            BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
2870                                ;       MOVE    #>$10,X0
2871      P:0007B0 P:0007B0 44F400            MOVE              #>0,X0
                            000000
2872      P:0007B2 P:0007B2 0D07A2            JSR     <SET_SHUTTER_STATE
2873      P:0007B3 P:0007B3 0C008F            JMP     <FINISH
2874   
2875                                ; Subroutine with two entry points.  C_OSHUT is conditional on SHUT
2876                                ; Open the shutter conditionally based on the shutter status bit #SHUT
2877                                ; This is set by the host using dspwrm to the X:<STATUS unless the frame
2878                                ; is a dark
2879                                ; Open the shutter by calling SET_SHUTTER_STATE
2880                                C_OSHUT
2881      P:0007B4 P:0007B4 0A008B            JCLR    #SHUT,X:STATUS,OSH_RTN
                            0007BA
2882                                OSHUT
2883      P:0007B6 P:0007B6 0A0023            BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
2884                                ;       MOVE    #0,X0
2885      P:0007B7 P:0007B7 44F400            MOVE              #>$10,X0
                            000010
2886      P:0007B9 P:0007B9 0D07A2            JSR     <SET_SHUTTER_STATE
2887      P:0007BA P:0007BA 00000C  OSH_RTN   RTS
2888   
2889                                ; Subroutine with two entry points.  C_CSHUT is conditional on OPEN_CLOSE
2890                                ; Close the shutter conditionally based on the open-close ISTATUS bit
2891                                ; Close the shutter by calling SET_SHUTTER_STATE
2892      P:0007BB P:0007BB 0A2081  C_CSHUT   JCLR    #OPEN_CLOSE,X:ISTATUS,CSH_RTN     ; Don't close if always open
                            0007CC
2893      P:0007BD P:0007BD 0A0003  CSHUT     BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
2894                                ;       MOVE    #>$10,X0
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 57



2895      P:0007BE P:0007BE 240000            MOVE              #0,X0
2896      P:0007BF P:0007BF 0D07A2            JSR     <SET_SHUTTER_STATE
2897   
2898                                ; after closing shutter be sure to wait SH_DEL msec to let the blades close
2899                                ; before shifting the CCD array for readout.
2900      P:0007C0 P:0007C0 5E8700            MOVE                          Y:<SH_DEL,A
2901      P:0007C1 P:0007C1 200003            TST     A
2902      P:0007C2 P:0007C2 0EF7CB            JLE     <S_DEL0
2903      P:0007C3 P:0007C3 44F400            MOVE              #25000,X0
                            0061A8
2904      P:0007C5 P:0007C5 06CE00            DO      A,S_DEL0                          ; Delay by Y:SH_DEL milliseconds
                            0007CA
2905      P:0007C7 P:0007C7 06C400            DO      X0,S_DEL1
                            0007C9
2906      P:0007C9 P:0007C9 000000            NOP
2907      P:0007CA P:0007CA 000000  S_DEL1    NOP
2908      P:0007CB P:0007CB 000000  S_DEL0    NOP
2909   
2910      P:0007CC P:0007CC 00000C  CSH_RTN   RTS
2911   
2912                                ; Set the desired exposure time
2913                                ;       Correct command ptr to R3 as per "Four Points" #2
2914                                ;       Modify exposure time var name as per June 30 #5
2915                                SET_EXP_TIME
2916      P:0007CD P:0007CD 44DB00            MOVE              X:(R3)+,X0
2917      P:0007CE P:0007CE 441000            MOVE              X0,X:<EXPOSURE_TIME
2918                                ;       MOVE    X0,X:<TGT_TIM
2919      P:0007CF P:0007CF 0C008F            JMP     <FINISH
2920   
2921   
2922                                ; Abort exposure - close the shutter, stop the timer and resume idle mode
2923                                ; Modified to match gen-iii MLO code- as per June 30 #6
2924                                ABORT_EXPOSURE
2925      P:0007D0 P:0007D0 0A00A7            JSET    #ST_EXP,X:<STATUS,DO_ABEXP
                            0007D3
2926                                ; assume we got here via the idle rcv loop
2927                                ; not currently exposing, so this is a no-op.
2928      P:0007D2 P:0007D2 0C008F            JMP     <FINISH
2929                                DO_ABEXP
2930   
2931      P:0007D3 P:0007D3 0D07BD            JSR     <CSHUT                            ; Close the shutter
2932      P:0007D4 P:0007D4 010F00            BCLR    #TIM_BIT,X:TCSR0                  ; Disable the DSP exposure timer
2933   
2934                                ; The place to return must be in R7-
2935      P:0007D5 P:0007D5 0AE780            JMP     (R7)                              ; 'return' from EXPOSE
2936   
2937   
2938   
2939                                ;       Process INF according to the single addressing parameter
2940                                ;       Correct FINISH1 datum as per "Four Points" #1
2941                                ;       Correct command ptr to R3 as per "Four Points" #2
2942                                GET_INFO
2943      P:0007D6 P:0007D6 56DB00            MOVE              X:(R3)+,A               ; 0-4 is generic, >= 0x100 tim specific
2944                                ; Remove for gen-iii per June 6 #2
2945      P:0007D7 P:0007D7 47F400            MOVE              #IVERSION,Y1
                            04507F
2946      P:0007D9 P:0007D9 46F400            MOVE              #>GET_VERSION,Y0
                            000000
2947      P:0007DB P:0007DB 200055            CMP     Y0,A
2948      P:0007DC P:0007DC 0EA090            JEQ     <FINISH1
2949                                ; Remove for gen-iii per June 6 #2
2950      P:0007DD P:0007DD 47F400            MOVE              #IFLAVOR,Y1
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 58



                            612020
2951      P:0007DF P:0007DF 46F400            MOVE              #>GET_FLAVOR,Y0
                            000001
2952      P:0007E1 P:0007E1 200055            CMP     Y0,A
2953      P:0007E2 P:0007E2 0EA090            JEQ     <FINISH1
2954      P:0007E3 P:0007E3 47F400            MOVE              #ITIME0,Y1
                            00AF27
2955      P:0007E5 P:0007E5 46F400            MOVE              #>GET_TIME0,Y0
                            000002
2956      P:0007E7 P:0007E7 200055            CMP     Y0,A
2957      P:0007E8 P:0007E8 0EA090            JEQ     <FINISH1                          ; Is it Time0?
2958      P:0007E9 P:0007E9 47F400            MOVE              #ITIME1,Y1
                            0057B8
2959      P:0007EB P:0007EB 46F400            MOVE              #>GET_TIME1,Y0
                            000003
2960      P:0007ED P:0007ED 200055            CMP     Y0,A
2961      P:0007EE P:0007EE 0EA090            JEQ     <FINISH1                          ; Is it Time1?
2962      P:0007EF P:0007EF 270000            MOVE              #ISVNREV,Y1
2963      P:0007F0 P:0007F0 46F400            MOVE              #>GET_SVNREV,Y0
                            000004
2964      P:0007F2 P:0007F2 200055            CMP     Y0,A
2965      P:0007F3 P:0007F3 0EA090            JEQ     <FINISH1                          ; Is it Svn rev?
2966      P:0007F4 P:0007F4 47F400            MOVE              #TIMCAPABLE,Y1
                            0001CB
2967      P:0007F6 P:0007F6 46F400            MOVE              #>GET_CAPABLE,Y0
                            000100
2968      P:0007F8 P:0007F8 200055            CMP     Y0,A
2969      P:0007F9 P:0007F9 0EA090            JEQ     <FINISH1                          ; Is it Tim Capabilities?
2970      P:0007FA P:0007FA 47F400            MOVE              #INT_TIM,Y1
                            0E0000
2971      P:0007FC P:0007FC 46F400            MOVE              #>GET_INT_TIM,Y0
                            000101
2972      P:0007FE P:0007FE 200055            CMP     Y0,A
2973      P:0007FF P:0007FF 0EA090            JEQ     <FINISH1                          ; Is it Integration time?
2974      P:000800 P:000800 47F400            MOVE              #R_DELAY,Y1
                            000000
2975      P:000802 P:000802 46F400            MOVE              #>GET_R_DELAY,Y0
                            000102
2976      P:000804 P:000804 200055            CMP     Y0,A
2977      P:000805 P:000805 0EA090            JEQ     <FINISH1                          ; Is it Serial time?
2978      P:000806 P:000806 47F400            MOVE              #SI_DELAY,Y1
                            A70000
2979      P:000808 P:000808 46F400            MOVE              #>GET_SI_DELAY,Y0
                            000103
2980      P:00080A P:00080A 200055            CMP     Y0,A
2981      P:00080B P:00080B 0EA090            JEQ     <FINISH1                          ; Is it Parallel time?
2982      P:00080C P:00080C 0C008D            JMP     ERROR                             ; unknown info argument
2983   
2984                                ; LMI does not use the thermocooler status bits
2985                                        COMMENT *
2986                                        MOVE    #>GET_TEMP2STS,Y0       ; Is it 2 bit temp status
2987                                        CMP     Y0,A
2988                                        JNE     <ERROR
2989                                        CLR     A
2990                                        JSET    #STS1,X:HDR,GET_STS0
2991                                        ADD     #<2,A
2992                                GET_STS0
2993                                        JSET    #STS0,X:HDR,RES_TEMPS
2994                                        ADD     #<1,A
2995                                RES_TEMPS
2996                                        NOP
2997                                        MOVE    A1,Y1
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 59



2998                                        JMP     <FINISH1
2999                                        *
3000   
3001   
3002                                ; Set software to IDLE mode
3003      P:00080D P:00080D 44F400  IDL       MOVE              #IDLE,X0                ; Exercise clocks when idling
                            000307
3004      P:00080F P:00080F 441F00            MOVE              X0,X:<IDL_ADR
3005      P:000810 P:000810 0A0022            BSET    #IDLMODE,X:<STATUS                ; Idle after readout
3006      P:000811 P:000811 0C008F            JMP     <FINISH                           ; Need to send header and 'DON'
3007   
3008                                ; Come to here on a 'STP' command so 'DON' can be sent
3009   
3010                                ; Let the host computer read the controller configuration
3011                                ;       Correct FINISH1 datum as per "Four Points" #1
3012                                READ_CONTROLLER_CONFIGURATION
3013      P:000812 P:000812 4F8800            MOVE                          Y:<CONFIG,Y1 ; Just transmit the configuration
3014      P:000813 P:000813 0C0090            JMP     <FINISH1
3015   
3016                                ; Power off
3017      P:000814 P:000814 0D0863  PWR_OFF   JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
3018      P:000815 P:000815 0A8922            BSET    #LVEN,X:HDR
3019      P:000816 P:000816 0A8923            BSET    #HVEN,X:HDR
3020      P:000817 P:000817 0C008F            JMP     <FINISH
3021   
3022                                ; Start power-on cycle
3023                                PWR_ON
3024      P:000818 P:000818 0D0863            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
3025      P:000819 P:000819 0D082C            JSR     <PON                              ; Turn on the power control board
3026      P:00081A P:00081A 0A8980            JCLR    #PWROK,X:HDR,PWR_ERR              ; Test if the power turned on properly
                            000829
3027      P:00081C P:00081C 200013            CLR     A
3028      P:00081D P:00081D 60F400            MOVE              #DACS_INV,R0            ;  standard (IDLE) INV levels here
                            000165
3029   
3030                                          IF      @SCP("DACSLOG","SUPPORTED")
3032                                          ENDIF
3033   
3034      P:00081F P:00081F 5E3E00            MOVE                          A,Y:<DUALDD_STAT
3035      P:000820 P:000820 0D083A            JSR     <SET_BIASES                       ; Turn on the DC bias supplies
3036   
3037                                          IF      @SCP("DACSLOG","SUPPORTED")
3042                                          ENDIF
3043   
3044      P:000821 P:000821 60F400            MOVE              #IDLE,R0                ; Put controller in IDLE state
                            000307
3045      P:000823 P:000823 601F00            MOVE              R0,X:<IDL_ADR
3046   
3047                                ;       as per Confluence July 4 2010 #5
3048      P:000824 P:000824 312400            MOVE              #$24,R1
3049      P:000825 P:000825 610000            MOVE              R1,X:<STATUS
3050                                ;       as per Confluence July 4 2010 #4 and July 21 note
3051      P:000826 P:000826 4CBB00            MOVE                          Y:<AMPVAL,X0
3052      P:000827 P:000827 0D032C            JSR     <SELECT_OUTPUT_SOURCE
3053      P:000828 P:000828 0C008F            JMP     <FINISH
3054   
3055                                ; The power failed to turn on because of an error on the power control board
3056      P:000829 P:000829 0A8922  PWR_ERR   BSET    #LVEN,X:HDR                       ; Turn off the low voltage emable line
3057      P:00082A P:00082A 0A8923            BSET    #HVEN,X:HDR                       ; Turn off the high voltage emable line
3058      P:00082B P:00082B 0C008D            JMP     <ERROR
3059   
3060                                ; As a subroutine, turn on the low voltages (+/- 6.5V, +/- 16.5V) and delay
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 60



3061      P:00082C P:00082C 0A8902  PON       BCLR    #LVEN,X:HDR                       ; Set these signals to DSP outputs
3062      P:00082D P:00082D 44F400            MOVE              #2000000,X0
                            1E8480
3063      P:00082F P:00082F 06C400            DO      X0,*+3                            ; Wait 20 millisec for settling
                            000831
3064      P:000831 P:000831 000000            NOP
3065   
3066                                ; Turn on the high +36 volt power line and then delay
3067      P:000832 P:000832 0A8903            BCLR    #HVEN,X:HDR                       ; HVEN = Low => Turn on +36V
3068      P:000833 P:000833 44F400            MOVE              #2000000,X0
                            1E8480
3069      P:000835 P:000835 06C400            DO      X0,*+3                            ; Wait 20 millisec for settling
                            000837
3070      P:000837 P:000837 000000            NOP
3071      P:000838 P:000838 00000C            RTS
3072   
3073                                ; LMI does not need to set VRD2 or VRD3
3074                                        COMMENT *
3075                                ;prototype code- to set leds on gwaves
3076                                SETVRDS
3077                                        MOVE    X:(R3)+,X0
3078                                        CLR     A
3079                                        MOVE    X0,A
3080                                        AND     #$3FFF,A
3081                                        ADD     #VID0+DAC_RegD,A
3082                                        MOVE    X:(R3)+,X0
3083                                        MOVE    A1,Y:VRD2_V
3084                                        MOVE    X0,A
3085                                        AND     #$3FFF,A
3086                                        ADD     #VID0+DAC_RegD,A
3087                                        MOVE    #SET_VRD2_3,R0
3088                                        MOVE    A1,Y:VRD3_V
3089                                        JSR     <SET_BIASES
3090                                        JMP     <FINISH
3091                                        *
3092   
3093                                ; This is not accessible from LOIS, so make it a no-op. If it were to be
3094                                ; implemented would need an argument
3095                                ;
3096                                SETBIAS
3097                                ;       MOVE    #DACS,R0                ; Get starting address of DAC values
3098                                ;       JSR     <SET_BIASES
3099      P:000839 P:000839 0C008F            JMP     <FINISH
3100   
3101                                ; Set all the DC bias voltages and video processor offset values, reading
3102                                ;   them from the 'DACS' table provided in R0
3103                                SET_BIASES
3104                                          SER_ANA
3106      P:00083B P:00083B 0A0F01            BCLR    #1,X:<LATCH                       ; Separate updates of clock driver
3107      P:00083C P:00083C 0A0F20            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
3108      P:00083D P:00083D 0A0F22            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
3109      P:00083E P:00083E 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                            00000F
3110      P:000840 P:000840 0D078E            JSR     <PAL_DLY                          ; Delay for all this to happen
3111   
3112                                ;  VALIDATE X0 here (between 1 and something reasonable)
3113      P:000841 P:000841 200013            CLR     A
3114      P:000842 P:000842 5CE000            MOVE                          Y:(R0),A1
3115      P:000843 P:000843 000000            NOP
3116      P:000844 P:000844 000000            NOP
3117      P:000845 P:000845 0140C4            SUB     #MAXDACTBL,A
                            0000C8
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 61



3118      P:000847 P:000847 0AF0A1            JGE     SB_FAIL
                            000856
3119                                ;       TST     A
3120                                ;       JLT     SB_FAIL
3121                                ;        CLR     A
3122                                ;        CMP     X0,A
3123                                ;        JGE     SB_FAIL
3124   
3125                                ; Read DAC values from a table, and write them to the DACs
3126      P:000849 P:000849 000000            NOP
3127      P:00084A P:00084A 065840            DO      Y:(R0)+,L_DAC                     ; Repeat Y:(R0)+ times
                            00084E
3128      P:00084C P:00084C 5ED800            MOVE                          Y:(R0)+,A   ; Read the table entry
3129   
3130                                          IF      @SCP("DACSLOG","SUPPORTED")
3133                                          ENDIF
3134   
3135      P:00084D P:00084D 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
3136      P:00084E P:00084E 000000            NOP
3137                                L_DAC
3138      P:00084F P:00084F 5EBE00            MOVE                          Y:<DUALDD_STAT,A
3139      P:000850 P:000850 000000            NOP
3140      P:000851 P:000851 014180            ADD     #1,A
3141      P:000852 P:000852 000000            NOP
3142      P:000853 P:000853 5E3E00            MOVE                          A,Y:<DUALDD_STAT
3143   
3144      P:000854 P:000854 0AF080            JMP     SB_DONE
                            00085A
3145   
3146                                SB_FAIL
3147      P:000856 P:000856 56F400            MOVE              #$FFFF,A
                            00FFFF
3148      P:000858 P:000858 000000            NOP
3149      P:000859 P:000859 5E3E00            MOVE                          A,Y:<DUALDD_STAT
3150                                ;        BSET    #ST_SBFAIL,X:<STATUS    ; we don't ever clear this
3151   
3152                                SB_DONE
3153   
3154                                ; Let the DAC voltages all ramp up before exiting
3155      P:00085A P:00085A 44F400            MOVE              #400000,X0
                            061A80
3156      P:00085C P:00085C 06C400            DO      X0,*+3                            ; 4 millisec delay
                            00085E
3157      P:00085E P:00085E 000000            NOP
3158                                          SER_UTL
3160      P:000860 P:000860 00000C            RTS
3161   
3162   
3163                                ; Enable serial communication to the analog boards
3164                                ; This becomes a single line macro above, as per June 30 #12
3165   
3166                                ;SER_ANA        BSET    #0,X:PBD                ; Set H0 for analog boards SSI
3167                                ;       MOVEP   #$0000,X:PCC            ; Software reset of SSI
3168                                ;       BCLR    #10,X:CRB               ; SSI -> continuous clock for analog
3169                                ;       MOVEP   #$0160,X:PCC            ; Re-enable the SSI
3170                                ;       RTS
3171   
3172                                ; Enable serial communication to the utility board
3173                                ; This becomes a single line macro above, as per June 30 #12
3174   
3175                                ;SER_UTL        MOVEP   #$0000,X:PCC            ; Software reset of SSI
3176                                ;       BSET    #10,X:CRB               ; SSI -> gated clock for util board
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 62



3177                                ;       MOVEP   #$0160,X:PCC            ; Enable the SSI
3178                                ;       BCLR    #0,X:PBD                ; Clear H0 for utility board SSI
3179                                ;       RTS
3180   
3181      P:000861 P:000861 0D0863  CLR_SWS   JSR     <CLEAR_SWITCHES
3182      P:000862 P:000862 0C008F            JMP     <FINISH
3183   
3184                                ; Clear all video processor analog switches to lower their power dissipation
3185                                CLEAR_SWITCHES
3186                                          SER_ANA
3188      P:000864 P:000864 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                            0C3000
3189      P:000866 P:000866 20001B            CLR     B
3190      P:000867 P:000867 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC write
s
3191      P:000868 P:000868 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writ
es
                            001000
3192      P:00086A P:00086A 060F80            DO      #15,L_VIDEO                       ; Fifteen video processor boards maximum
                            000871
3193      P:00086C P:00086C 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
3194      P:00086D P:00086D 200040            ADD     X0,A
3195      P:00086E P:00086E 5F7000            MOVE                          B,Y:WRSS
                            FFFFF3
3196      P:000870 P:000870 0D078E            JSR     <PAL_DLY                          ; Delay for the serial data transmission
3197      P:000871 P:000871 200068            ADD     X1,B
3198                                L_VIDEO
3199      P:000872 P:000872 0A0F00            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
3200      P:000873 P:000873 0A0F02            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
3201      P:000874 P:000874 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                            00000F
3202                                          SER_UTL
3204      P:000877 P:000877 00000C            RTS
3205   
3206                                ; Set the clock multiplexers
3207                                ;       Correct command ptr to R3 as per "Four Points" #2
3208                                SET_MUX
3209                                          SER_ANA                                   ; Set SSI to analog board communication
3211      P:000879 P:000879 56DB00            MOVE              X:(R3)+,A               ; Clock driver board number
3212      P:00087A P:00087A 0614A0            REP     #20
3213      P:00087B P:00087B 200033            LSL     A
3214      P:00087C P:00087C 44F400            MOVE              #$003000,X0
                            003000
3215      P:00087E P:00087E 200042            OR      X0,A
3216      P:00087F P:00087F 000000            NOP                                       ; 56300 pipeline as per July 5 #4
3217      P:000880 P:000880 21C500            MOVE              A,X1                    ; Move here for storage
3218   
3219                                ; Get the first MUX number
3220      P:000881 P:000881 56DB00            MOVE              X:(R3)+,A               ; Get the first MUX number
3221      P:000882 P:000882 0AF0A9            JLT     ERR_SM1
                            0008C9
3222      P:000884 P:000884 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                            000018
3223      P:000886 P:000886 200045            CMP     X0,A
3224      P:000887 P:000887 0AF0A1            JGE     ERR_SM1
                            0008C9
3225      P:000889 P:000889 21CF00            MOVE              A,B
3226      P:00088A P:00088A 44F400            MOVE              #>7,X0
                            000007
3227      P:00088C P:00088C 20004E            AND     X0,B
3228      P:00088D P:00088D 44F400            MOVE              #>$18,X0
                            000018
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 63



3229      P:00088F P:00088F 200046            AND     X0,A
3230      P:000890 P:000890 0E2893            JNE     <SMX_1                            ; Test for 0 <= MUX number <= 7
3231      P:000891 P:000891 0ACD63            BSET    #3,B1
3232      P:000892 P:000892 0C089E            JMP     <SMX_A
3233      P:000893 P:000893 44F400  SMX_1     MOVE              #>$08,X0
                            000008
3234      P:000895 P:000895 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
3235      P:000896 P:000896 0E2899            JNE     <SMX_2
3236      P:000897 P:000897 0ACD64            BSET    #4,B1
3237      P:000898 P:000898 0C089E            JMP     <SMX_A
3238      P:000899 P:000899 44F400  SMX_2     MOVE              #>$10,X0
                            000010
3239      P:00089B P:00089B 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
3240      P:00089C P:00089C 0E28C9            JNE     <ERR_SM1
3241      P:00089D P:00089D 0ACD65            BSET    #5,B1
3242      P:00089E P:00089E 20006A  SMX_A     OR      X1,B1                             ; Add prefix to MUX numbers
3243      P:00089F P:00089F 000000            NOP                                       ; 56300 pipeline as per July 5 #4
3244      P:0008A0 P:0008A0 21A700            MOVE              B1,Y1
3245   
3246                                ; Add on the second MUX number
3247      P:0008A1 P:0008A1 56DB00            MOVE              X:(R3)+,A               ; Get the next MUX number
3248      P:0008A2 P:0008A2 0AF0A9            JLT     ERR_SM2
                            0008CA
3249      P:0008A4 P:0008A4 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                            000018
3250      P:0008A6 P:0008A6 200045            CMP     X0,A
3251      P:0008A7 P:0008A7 0AF0A1            JGE     ERR_SM2
                            0008CA
3252      P:0008A9 P:0008A9 0606A0            REP     #6
3253      P:0008AA P:0008AA 200033            LSL     A
3254      P:0008AB P:0008AB 44F400            MOVE              #$1C0,X0
                            0001C0
3255      P:0008AD P:0008AD 21CF00            MOVE              A,B
3256      P:0008AE P:0008AE 20004E            AND     X0,B
3257      P:0008AF P:0008AF 44F400            MOVE              #>$600,X0
                            000600
3258      P:0008B1 P:0008B1 200046            AND     X0,A
3259      P:0008B2 P:0008B2 0E28B5            JNE     <SMX_3                            ; Test for 0 <= MUX number <= 7
3260      P:0008B3 P:0008B3 0ACD69            BSET    #9,B1
3261      P:0008B4 P:0008B4 0C08C0            JMP     <SMX_B
3262      P:0008B5 P:0008B5 44F400  SMX_3     MOVE              #>$200,X0
                            000200
3263      P:0008B7 P:0008B7 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
3264      P:0008B8 P:0008B8 0E28BB            JNE     <SMX_4
3265      P:0008B9 P:0008B9 0ACD6A            BSET    #10,B1
3266      P:0008BA P:0008BA 0C08C0            JMP     <SMX_B
3267      P:0008BB P:0008BB 44F400  SMX_4     MOVE              #>$400,X0
                            000400
3268      P:0008BD P:0008BD 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
3269      P:0008BE P:0008BE 0E28CA            JNE     <ERR_SM2
3270      P:0008BF P:0008BF 0ACD6B            BSET    #11,B1
3271      P:0008C0 P:0008C0 200078  SMX_B     ADD     Y1,B                              ; Add prefix to MUX numbers
3272                                ; change to match gen-iii, as per June 30, #14
3273      P:0008C1 P:0008C1 000000            NOP
3274      P:0008C2 P:0008C2 21AE00            MOVE              B1,A
3275      P:0008C3 P:0008C3 0140C6            AND     #$F01FFF,A                        ; Just to be sure
                            F01FFF
3276      P:0008C5 P:0008C5 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
3277   
3278      P:0008C6 P:0008C6 0D078E            JSR     <PAL_DLY                          ; Delay for all this to happen
3279                                          SER_UTL                                   ; Return SSI to utility board communication
3281      P:0008C8 P:0008C8 0C008F            JMP     <FINISH
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 64



3282      P:0008C9 P:0008C9 56DB00  ERR_SM1   MOVE              X:(R3)+,A
3283                                ERR_SM2
3284                                          SER_UTL                                   ; Return SSI to utility board communication
3286      P:0008CB P:0008CB 0C008D            JMP     <ERROR
3287   
3288   
3289                                ; Set the video processor gain and integrator speed for all video boards
3290                                ; Now modified as per manual for ARC-47 (1E) video board and ARC-E2V57
3291                                ; sample code
3292                                ;  Command syntax is  SGN [ #BD]  #GAIN  #SPEED, #GAIN = 0-15 (1.0-4.75)
3293                                ;                                         #SPEED = 1-15
3294                                ;       Correct command ptr to R3 as per "Four Points" #2
3295                                ;  fixes to match gen-iii as per June 30, #15
3296                                ; replaced with ARC version for E2V57- except BD is set unconditionally
3297                                ; to 0 for backwards compatibility at the LOIS end.
3298                                ;
3299   
3300                                ST_GAIN
3301                                ;       MOVE    X:(R3)+,A       ; Board number
3302                                ;       LSL     #20,A
3303      P:0008CC P:0008CC 200013            CLR     A                                 ; Video bd must be at 0.
3304      P:0008CD P:0008CD 240D00            MOVE              #$0D0000,X0
3305      P:0008CE P:0008CE 218500            MOVE              A1,X1
3306      P:0008CF P:0008CF 200042            OR      X0,A
3307      P:0008D0 P:0008D0 44DB00            MOVE              X:(R3)+,X0              ; Gain
3308      P:0008D1 P:0008D1 200042            OR      X0,A
3309                                ;
3310      P:0008D2 P:0008D2 000000            NOP
3311      P:0008D3 P:0008D3 5E7000            MOVE                          A,Y:DAC_GNSPD
                            000133
3312                                ;        JSR     <XMIT_A_WORD    ; Transmit A to TIM-A-STD
3313   
3314      P:0008D5 P:0008D5 56DB00            MOVE              X:(R3)+,A               ; Time constant (speed)
3315      P:0008D6 P:0008D6 0C1E88            LSL     #4,A
3316      P:0008D7 P:0008D7 200062            OR      X1,A1                             ; Board number is in bits #23-20
3317      P:0008D8 P:0008D8 44F400            MOVE              #$0C0100,X0
                            0C0100
3318      P:0008DA P:0008DA 200042            OR      X0,A
3319      P:0008DB P:0008DB 000000            NOP
3320      P:0008DC P:0008DC 5E3D00            MOVE                          A,Y:<TESTLOC1 ; debug
3321      P:0008DD P:0008DD 5E7000            MOVE                          A,Y:DAC_GNSPD+1
                            000134
3322                                ;        JSR     <XMIT_A_WORD    ; Transmit A to TIM-A-STD
3323      P:0008DF P:0008DF 0C008F            JMP     <FINISH
3324   
3325   
3326                                ; traditional gain-speed code
3327                                        COMMENT *
3328   
3329                                ;       SER_ANA ; Set SSI to analog board communication
3330                                        MOVE    X:(R3)+,A       ; Gain value (1,2,5 or 10)
3331                                ; making this a no-op for now
3332                                        MOVE    X:(R3)+,A       ; Gain value (1,2,5 or 10)
3333                                        JMP     <FINISH
3334                                        MOVE    #>1,X0
3335                                        CMP     X0,A            ; Check for gain = x1
3336                                        JNE     <STG2
3337                                        MOVE    #>$77,B
3338                                        JMP     <STG_A
3339                                STG2    MOVE    #>2,X0          ; Check for gain = x2
3340                                        CMP     X0,A
3341                                        JNE     <STG5
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 65



3342                                        MOVE    #>$BB,B
3343                                        JMP     <STG_A
3344                                STG5    MOVE    #>5,X0          ; Check for gain = x5
3345                                        CMP     X0,A
3346                                        JNE     <STG10
3347                                        MOVE    #>$DD,B
3348                                        JMP     <STG_A
3349                                STG10   MOVE    #>10,X0         ; Check for gain = x10
3350                                        CMP     X0,A
3351                                        JNE     <ERROR
3352                                        MOVE    #>$EE,B
3353   
3354                                STG_A   MOVE    X:(R3)+,A       ; Integrator Speed (0 for slow, 1 for fast)
3355                                        NOP
3356                                        JCLR    #0,A1,STG_B
3357                                        BSET    #8,B1
3358                                        NOP
3359                                        BSET    #9,B1
3360                                STG_B   MOVE    #$0C3C00,X0
3361                                        OR      X0,B
3362                                        NOP
3363                                        MOVE    B,Y:<GAIN       ; Store the GAIN value for later us
3364   
3365                                ; Send this same value to 15 video processor boards whether they exist or not
3366                                        MOVE    #$100000,X0     ; Increment value
3367                                        DO      #15,STG_LOOP
3368                                        MOVE    B1,A1
3369                                        JSR     <XMIT_A_WORD    ; Transmit A to TIM-A-STD
3370   
3371                                ;       MOVE    B,X:SSITX       ; Transmit the SSI word
3372                                        JSR     <PAL_DLY        ; Wait for SSI and PAL to be empty
3373                                        ADD     X0,B            ; Increment the video processor board number
3374                                        NOP
3375                                STG_LOOP
3376   
3377                                        SER_UTL                 ; Return SSI to utility board communication
3378                                        JMP     <FINISH
3379                                        *
3380   
3381   
3382                                ; Specify subarray readout coordinates, one rectangle only
3383                                ; Call this subroutine BEFORE SET_SUBARRAY_POSITIONS since it
3384                                ; initializes NBOXES
3385                                ;       Correct command ptr to R3 as per "Four Points" #2
3386                                SET_SUBARRAY_SIZES
3387      P:0008E0 P:0008E0 200013            CLR     A
3388      P:0008E1 P:0008E1 44DB00            MOVE              X:(R3)+,X0
3389      P:0008E2 P:0008E2 5E1A00            MOVE                          A,Y:<NBOXES ; Number of subimage boxes = 0 to start
3390      P:0008E3 P:0008E3 4C1B00            MOVE                          X0,Y:<NR_BIAS ; Number of bias pixels to read
3391      P:0008E4 P:0008E4 44DB00            MOVE              X:(R3)+,X0
3392      P:0008E5 P:0008E5 4C1C00            MOVE                          X0,Y:<NS_READ ; Number of columns in subimage read
3393      P:0008E6 P:0008E6 44DB00            MOVE              X:(R3)+,X0
3394      P:0008E7 P:0008E7 4C1D00            MOVE                          X0,Y:<NP_READ ; Number of rows in subimage read
3395      P:0008E8 P:0008E8 0C008F            JMP     <FINISH
3396   
3397                                ; Call this routine once for every subarray to be added to the table
3398                                ; Note that the way the variables are arranged the subframes all are the
3399                                ; same dimensions.  They also cannot overlap in the row direction.
3400                                ; SET_SUBARRAY_SIZES must be called first to initialize NBOXES
3401                                SET_SUBARRAY_POSITIONS
3402      P:0008E9 P:0008E9 4C9A00            MOVE                          Y:<NBOXES,X0 ; Next available slot
3403      P:0008EA P:0008EA 459400            MOVE              X:<THREE,X1
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 66



3404      P:0008EB P:0008EB 2000A0            MPY     X0,X1,A
3405      P:0008EC P:0008EC 200022            ASR     A
3406      P:0008ED P:0008ED 210C00            MOVE              A0,A1
3407                                ; PARAMETERIZE
3408      P:0008EE P:0008EE 44F400            MOVE              #>21,X0
                            000015
3409      P:0008F0 P:0008F0 200045            CMP     X0,A
3410      P:0008F1 P:0008F1 0E708D            JGT     <ERROR                            ; Error if number of boxes > 9
3411      P:0008F2 P:0008F2 44F400            MOVE              #READ_TABLE,X0
                            00001E
3412      P:0008F4 P:0008F4 200040            ADD     X0,A
3413      P:0008F5 P:0008F5 44DB00            MOVE              X:(R3)+,X0
3414      P:0008F6 P:0008F6 219700            MOVE              A1,R7
3415      P:0008F7 P:0008F7 000000            NOP
3416      P:0008F8 P:0008F8 000000            NOP
3417      P:0008F9 P:0008F9 000000            NOP
3418      P:0008FA P:0008FA 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of rows (parallels) to clear
3419      P:0008FB P:0008FB 44DB00            MOVE              X:(R3)+,X0
3420      P:0008FC P:0008FC 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears before
3421      P:0008FD P:0008FD 44DB00            MOVE              X:(R3)+,X0              ;  the box readout
3422      P:0008FE P:0008FE 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears after
3423      P:0008FF P:0008FF 5E9A00            MOVE                          Y:<NBOXES,A ;  the box readout
3424      P:000900 P:000900 449200            MOVE              X:<ONE,X0
3425      P:000901 P:000901 200040            ADD     X0,A                              ; Update the next available slot position
3426      P:000902 P:000902 000000            NOP
3427      P:000903 P:000903 5E1A00            MOVE                          A,Y:<NBOXES
3428      P:000904 P:000904 0C008F            JMP     <FINISH
3429   
3430                                ; Alert the PCI interface board that images are coming soon
3431                                ; This tells the PCI card how many pixels to expect for each SEX command
3432                                ; This is fairly complex.  The first value sent is NPR*IFRAMES (NAXIS2*NAXIS3).
3433                                ; The second value is NSR aka NAXIS1, but if NBOXES > 0, it is NSR*NBOXES
3434                                ; this matches nasa42, but since naxis1,2 for a full frame is > 2^12
3435                                ; there's a max of 1024 for IFRAMES. If we used an adaptive algorithm we
3436                                ; could do better.
3437                                ; Meantime LOIS will have to enforce these limits.
3438   
3439                                ; Correct XMT_FO to XMT_WRD in timboot.s and change the input arg to B1
3440                                ; as per "Four Points" #3
3441                                PCI_READ_IMAGE
3442      P:000905 P:000905 55F400            MOVE              #$020104,B1             ; Send header word to the FO transmitter
                            020104
3443      P:000907 P:000907 0D00EB            JSR     <XMT_WRD
3444      P:000908 P:000908 55F400            MOVE              #'RDA',B1
                            524441
3445      P:00090A P:00090A 0D00EB            JSR     <XMT_WRD
3446      P:00090B P:00090B 4CF000            MOVE                          Y:NPR,X0    ; NPR = NAXIS2
                            000002
3447      P:00090D P:00090D 4DF000            MOVE                          Y:IFRAMES,X1 ; IFRAMES = NAXIS3
                            000038
3448      P:00090F P:00090F 2000A8            MPY     X0,X1,B
3449      P:000910 P:000910 20002A            ASR     B                                 ; Correct for multiplication left shift
3450      P:000911 P:000911 212D00            MOVE              B0,B1
3451      P:000912 P:000912 0D00EB            JSR     <XMT_WRD                          ; Send NPR*IFRAMES to PCI card
3452      P:000913 P:000913 4CF000            MOVE                          Y:NSR,X0    ; NSR = NAXIS1
                            000001
3453      P:000915 P:000915 5E9A00            MOVE                          Y:<NBOXES,A ; If NBOXES = 0, transmit that to PCI
3454      P:000916 P:000916 208D00            MOVE              X0,B1
3455      P:000917 P:000917 200003            TST     A
3456      P:000918 P:000918 0AF0AA            JEQ     XMT
                            00091E
3457      P:00091A P:00091A 4D9A00            MOVE                          Y:<NBOXES,X1 ; If NBOXES = 0, transmit that to PCI
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  timCCDmisc.s  Page 67



3458      P:00091B P:00091B 2000A8            MPY     X0,X1,B                           ; If not, multiply by NBOXES, then send
3459      P:00091C P:00091C 20002A            ASR     B                                 ; Correct for multiplication left shift
3460      P:00091D P:00091D 212D00            MOVE              B0,B1                   ; Get only least significant 24 bits
3461      P:00091E P:00091E 000000  XMT       NOP
3462      P:00091F P:00091F 0D00EB            JSR     <XMT_WRD
3463      P:000920 P:000920 00000C            RTS
3464   
3465                                 TIMBOOT_X_MEMORY
3466      000921                              EQU     @LCV(L)
3467   
3468                                ;  ****************  Setup memory tables in X: space ********************
3469   
3470                                ; Define the address in P: space where the table of constants begins
3471   
3472                                          IF      @SCP("HOST","HOST")
3473      X:000036 X:000036                   ORG     X:END_COMMAND_TABLE,X:END_COMMAND_TABLE
3474                                          ENDIF
3475   
3476                                          IF      @SCP("HOST","ROM")
3478                                          ENDIF
3479   
3480      X:000036 X:000036                   DC      'IDL',IDL                         ; Put CCD in IDLE mode
3481                                ; Remove for gen-iii since it is in timboot as per June 30 #9
3482                                ;       DC      'STP',STP               ; Exit IDLE mode
3483                                ;       DC      'SVR',SETVRDS           ; set VRD2,3
3484      X:000038 X:000038                   DC      'SBV',SETBIAS                     ; Set DC bias supply voltages
3485      X:00003A X:00003A                   DC      'RDC',RDCCD                       ; Begin CCD readout
3486      X:00003C X:00003C                   DC      'CLR',CLEAR                       ; Fast clear the CCD
3487      X:00003E X:00003E                   DC      'SGN',ST_GAIN                     ; Set video processor gain
3488      X:000040 X:000040                   DC      'SMX',SET_MUX                     ; Set clock driver MUX output
3489   
3490      X:000042 X:000042                   DC      'ABR',ABR_RDC                     ; Abort readout
3491      X:000044 X:000044                   DC      'CRD',CONT_RD                     ; Continue reading out
3492      X:000046 X:000046                   DC      'CSW',CLR_SWS                     ; Clear analog switches to lower power
3493      X:000048 X:000048                   DC      'SOS',SEL_OS                      ; Select output source
3494      X:00004A X:00004A                   DC      'RCC',READ_CONTROLLER_CONFIGURATION
3495      X:00004C X:00004C                   DC      'SSS',SET_SUBARRAY_SIZES
3496      X:00004E X:00004E                   DC      'SSP',SET_SUBARRAY_POSITIONS
3497      X:000050 X:000050                   DC      'DON',START                       ; Nothing special
3498      X:000052 X:000052                   DC      'OSH',OPEN_SHUTTER
3499      X:000054 X:000054                   DC      'CSH',CLOSE_SHUTTER
3500      X:000056 X:000056                   DC      'PON',PWR_ON                      ; Turn on all camera biases and clocks
3501      X:000058 X:000058                   DC      'POF',PWR_OFF                     ; Turn +/- 15V power supplies off
3502      X:00005A X:00005A                   DC      'SET',SET_EXP_TIME                ; Set exposure time
3503      X:00005C X:00005C                   DC      'SEX',START_FT_EXPOSURE           ; Goes to mode-dependent jump table
3504      X:00005E X:00005E                   DC      'AEX',ABORT_EXPOSURE
3505      X:000060 X:000060                   DC      'STG',SET_TRIGGER                 ;  Set Trigger Mode on or off
3506      X:000062 X:000062                   DC      'SIP',SET_IMAGE_PARAM
3507      X:000064 X:000064                   DC      'SRC',SET_ROWS_COLUMNS            ; Set NSR, NPR, and binning
3508      X:000066 X:000066                   DC      'INF',GET_INFO                    ; info command for versioning and more
3509   
3510                                 END_APPLICATON_COMMAND_TABLE
3511      000068                              EQU     @LCV(L)
3512   
3513                                          IF      @SCP("HOST","HOST")
3514      000020                    NUM_COM   EQU     (@LCV(R)-COM_TBL_R)/2             ; No. of boot & application commands
3515                                ;EXPOSING                EQU     CHK_TIM                 ; Address if exposing
3516                                ;CONTINUE_READING        EQU     RDCCD                   ; Address if reading out
3517                                          ENDIF
3518   
3519                                ; ***********  DATA AREAS - READOUT PARAMETERS AND WAVEFORMS  ************
3520                                          IF      @SCP("HOST","HOST")
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  tim.s  Page 68



3521      X:000080 X:000080                   ORG     X:IMGVAR_ADR,X:IMGVAR_ADR
3522      X:000080 X:000080         IMAGE_MODE DC     0
3523                                ; ISTATUS                       DC              0
3524                                ; bum an unused location in low X: for ISTATUS so JSETs work
3525                                ; as per Confluence July 5 #3
3526      000020                    ISTATUS   EQU     EXP_ADR                           ; dangerous!
3527   
3528                                ; some X: variables removed as per Confluence July 1 #4
3529                                ;DSP_VERS       DC      VERSION ; code version must stay in loc,n 102!!
3530                                ;DSP_FLAV       DC      FLAVOR ;  type of dsp support must stay in loc,n 103!!
3531                                ; The next three locations are for tracking the readout timing for gain
3532                                ; calculation, exp-int calculation, and greed factor calculation
3533                                ; They are locations 0x104, 105, and 106
3534                                ;INTTIM         DC      INT_TIM ; per-pixel integration in Leach units
3535                                ;RDELAY         DC      R_DELAY ; serial overlap in Leach units
3536                                ;SIDELAY                DC      SI_DELAY ; parallel overlap in Leach units
3537   
3538                                ;BINBIT         DC      2       ; Bit representation of bin factor, bits 1-5
3539                                                                                    ; 2 = bit 1 set. Bit zero not used.
3540                                ; bum a rarely used location in low X: for BINBIT so JSETs work
3541                                ; as per Confluence July 5 #5
3542      00001E                    BINBIT    EQU     C100K                             ; dangerous!
3543                                                                                    ; Bit representation of bin factor, bits 1-5
3544                                                                                    ; 2 = bit 1 set. Bit zero not used.
3545   
3546                                          IF      @SCP("DACSLOG","SUPPORTED")
3551                                          ENDIF
3552   
3553                                 END_APPLICATION_X_MEMORY
3554      000081                              EQU     @LCV(L)
3555                                          ENDIF
3556   
3557                                          IF      @SCP("HOST","HOST")
3558      Y:000000 Y:000000                   ORG     Y:0,Y:0                           ; Download address
3559                                          ELSE
3561                                          ENDIF
3562   
3563                                ; NSR, NPR, NSBIN, and NPBIN are set by SET_ROWS_COLUMNS
3564      Y:000000 Y:000000         GAIN      DC      0                                 ; Video processor gain and integrator speed
3565      Y:000001 Y:000001         NSR       DC      280                               ; Number Serial Read, prescan + image + bias
3566      Y:000002 Y:000002         NPR       DC      264                               ; Number Parallel Read
3567                                ;NS_CLR DC      280             ; To clear serial register, twice
3568                                          IF      @SCP("6144","2000")
3570                                          ENDIF
3571                                          IF      @SCP("6144","6144")
3572      Y:000003 Y:000003         NS_CLR    DC      6144                              ; To clear serial register, twice
3573                                          ENDIF
3574                                          IF      @SCP("6160","2000")
3576                                          ENDIF
3577                                          IF      @SCP("6160","6160")
3578      Y:000004 Y:000004         NPCLR     DC      12320                             ; To clear parallel register, twice
3579                                          ENDIF
3580                                ;NPCLR   DC      528            ; To clear parallel register, twice
3581      Y:000005 Y:000005         NSBIN     DC      1                                 ; Serial binning parameter
3582      Y:000006 Y:000006         NPBIN     DC      1                                 ; Parallel binning parameter
3583                                ;NROWS  DC      264             ; Number of physical rows in CCD
3584                                ;NCOLS  DC      280             ; Number of physical columns in CCD
3585   
3586                                ; Miscellaneous definitions
3587                                ; Delete TST_DAT since it isn't used.  Need the space so S_SIZE doesn't barf.
3588                                ; TST_DAT       DC      0               ; Temporary definition for test images
3589                                          IF      @SCP("1500","500")
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  tim.s  Page 69



3593                                          ENDIF
3594                                          IF      @SCP("1500","1500")
3595      Y:000007 Y:000007         SH_DEL    DC      1500                              ; tbida empirical for lmi, 2012 Oct 26 repor
t
3596                                          ENDIF
3597      Y:000008 Y:000008         CONFIG    DC      CC                                ; Controller configuration
3598                                ; Readout peculiarity parameters
3599                                 SERIAL_SKIP
3600      Y:000009 Y:000009                   DC      SERIAL_SKIP_SPLIT                 ; Serial skipping waveforms
3601      Y:00000A Y:00000A         SERWAVLEN DC      5                                 ; Serial read waveform table length
3602   
3603                                 SERIAL_CLOCK
3604      Y:00000B Y:00000B                   DC      SERIAL_CLOCK_SPLIT                ; Serial waveform table
3605                                 INITIAL_CLOCK
3606      Y:00000C Y:00000C                   DC      INITIAL_CLOCK_SPLIT               ; Serial waveform table
3607      Y:00000D Y:00000D         IS_PAR_CLK DC     ABCD_DOWN                         ; Addr. of ganged parallel clocking
3608      Y:00000E Y:00000E         S_PAR_CLK DC      AB_DOWN                           ; Addr. of storage parallel clocking
3609      Y:00000F Y:00000F         IS_PAR_CLR DC     ABCD_CLEAR_DOWN                   ; Addr. of ganged parallel clear
3610      Y:000010 Y:000010         S_PAR_CLR DC      AB_CLEAR_DOWN                     ; Addr. of storage parallel clear
3611   
3612   
3613                                 NSERIALS_READ
3614      Y:000011 Y:000011                   DC      0                                 ; Number of serials to read
3615      Y:000012 Y:000012         NSCLR     DC      0                                 ; Number of waveforms in fast mode
3616      Y:000013 Y:000013         NSKIP1    DC      0                                 ; Number of waveforms in fast mode
3617      Y:000014 Y:000014         NREAD     DC      0                                 ; Number of waveforms in fast mode
3618      Y:000015 Y:000015         NSKIP2    DC      0                                 ; Number of waveforms in fast mode
3619      Y:000016 Y:000016         NBIAS     DC      0                                 ; Number of waveforms in fast mode
3620   
3621                                ; These three parameters are read from the READ_TABLE when needed by the
3622                                ;   RDCCD routine as it loops through the required number of boxes
3623      Y:000017 Y:000017         NP_SKIP   DC      0                                 ; Number of rows to skip
3624      Y:000018 Y:000018         NS_SKP1   DC      0                                 ; Number of serials to clear before read
3625      Y:000019 Y:000019         NS_SKP2   DC      0                                 ; Number of serials to clear after read
3626   
3627                                ; Subimage readout parameters. Ten subimage boxes maximum.
3628                                ; All subimage boxes are the same size, NS_READ x NP_READ
3629                                ; NR_BIAS, NS_READ, and NP_READ are set by SET_SUBARRAY_SIZES
3630                                ; The READ_TABLE entries and implicitly NBOXES are set by SET_SUBARRAY_POSITIONS
3631      Y:00001A Y:00001A         NBOXES    DC      0                                 ; Number of boxes to read
3632      Y:00001B Y:00001B         NR_BIAS   DC      0                                 ; Number of bias pixels to read
3633      Y:00001C Y:00001C         NS_READ   DC      0                                 ; Number of columns per box
3634      Y:00001D Y:00001D         NP_READ   DC      0                                 ; Number of rows per box
3635      Y:00001E Y:00001E         READ_TABLE DC     0,0,0                             ; #1 = Number of rows to clear,
3636      Y:000021 Y:000021                   DC      0,0,0                             ; #2 = Number of columns to skip before
3637      Y:000024 Y:000024                   DC      0,0,0                             ;   subimage read
3638      Y:000027 Y:000027                   DC      0,0,0                             ; #3 = Number of columns to clear after
3639      Y:00002A Y:00002A                   DC      0,0,0                             ;   subimage read to get to overscan area
3640      Y:00002D Y:00002D                   DC      0,0,0
3641      Y:000030 Y:000030                   DC      0,0,0
3642      Y:000033 Y:000033                   DC      0,0,0
3643                                ;       DC      0,0,0
3644   
3645                                ; IMAGE_MODE, SROWS, IFRAMES, and INTERVAL are set by SET_IMAGE_PARAM
3646                                ; UBSROWS is set later on by UB_CONV.  S_SIZE is hardwired.
3647      Y:000036 Y:000036         SROWS     DC      1                                 ; Number of Storage image rows to Loop over
3648      Y:000037 Y:000037         UBSROWS   DC      1                                 ; SROWS in unbinned pixels.  Set by UB_CONV
3649      Y:000038 Y:000038         IFRAMES   DC      1                                 ; Number of Series frames to Loop over
3650                                          IF      @SCP("6160","2000")
3652                                          ENDIF
3653                                          IF      @SCP("6160","6160")
3654      Y:000039 Y:000039         S_SIZE    DC      3080                              ; storage area =  half of total rows
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  tim.s  Page 70



3655                                          ENDIF
3656                                ;S_SIZE         DC      1000    ; Number of rows in the Storage Array
3657      Y:00003A Y:00003A         INTERVAL  DC      7                                 ; Interval to pause for soft trigger
3658      Y:00003B Y:00003B         AMPVAL    DC      0                                 ; Amplifier selected
3659      Y:00003C Y:00003C         IFLPCNT   DC      0                                 ; 24-bit IFRAMES loop counter for timmisc.s
3660      Y:00003D Y:00003D         TESTLOC1  DC      0                                 ; Test location
3661                                 DUALDD_STAT
3662      Y:00003E Y:00003E                   DC      0
3663                                ; NOTE:  TESTLOC1 is address 63 in the Y memory.  There are addressing problems
3664                                ; starting at the next address (64).
3665   
3666                                ; Include the waveform table
3667                                          INCLUDE "lmi.waveforms.s"                 ; Readout and clocking waveforms
3668                                ; Waveform tables and definitions for the e2v CCD231 6K sq. frame
3669                                ; transfer CCD for LMI.
3670   
3671                                ; CCD clock voltage definitions
3672      000000                    VIDEO     EQU     $000000                           ; Video processor board select = 0
3673      002000                    CLK2      EQU     $002000                           ; Clock driver board select = 2
3674      003000                    CLK3      EQU     $003000                           ; Clock driver board select = 3
3675      200000                    CLKV      EQU     $200000                           ; Clock driver board DAC voltage selection a
ddress
3676      000000                    VID0      EQU     $000000                           ; Address of video board DACS
3677      0E0000                    DAC_ADDR  EQU     $0E0000                           ; DAC Channel Address
3678      0F4000                    DAC_RegM  EQU     $0F4000                           ; DAC m Register
3679      0F8000                    DAC_RegC  EQU     $0F8000                           ; DAC c Register
3680      0FC000                    DAC_RegD  EQU     $0FC000                           ; DAC X1 Register
3681      1.300000E+001             Vmax      EQU     13.0                              ; Maximum clock driver voltage
3682      0.000000E+000             ZERO      EQU     0.0                               ; Unused pins
3683   
3684   
3685                                ; For NASA42 we uncommented one of these lines at a time
3686                                ;INT_TIM        EQU     $080000 ; 1.0 us/px - use gain 9.5, clips at PRAM
3687                                ;INT_TIM        EQU     $130000 ; 1.4 us/px - use gain 4.75, clips at PRAM
3688                                ;INT_TIM                EQU     $1D0000 ; 1.8 us/px - use gain 2
3689                                ;INT_TIM        EQU     $2D0000 ; 2.5 us/px - use gain 2, doesn't clip
3690                                ;INT_TIM        EQU     $600000 ; 4.7 us/px - use gain 1; Doesn't clip
3691   
3692                                ; INT_TIM, controlled by Makefile def'n INTTIM_SETTING
3693                                ; as per Confluence July 1 2010 end commentary
3694   
3695                                          IF      @SCP("E","08")
3698                                          ENDIF
3699                                          IF      @SCP("E","13")
3702                                          ENDIF
3703                                          IF      @SCP("E","1D")
3707                                          ENDIF
3708                                          IF      @SCP("E","2D")
3711                                          ENDIF
3712                                          IF      @SCP("E","E")
3713                                ; on limi, 2.5 us/pxl
3714      0E0000                    INT_TIM   EQU     $0E0000
3715                                          ENDIF
3716                                          IF      @SCP("E","60")
3719                                          ENDIF
3720   
3721   
3722   
3723                                ;ADC_TIM                EQU     $0C0000 ; Slow ADC TIME
3724      000000                    ADC_TIM   EQU     $000000                           ; Fast ADC TIME
3725   
3726   
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 71



3727                                ; Delay numbers in clocking
3728                                ;SI_DELAY       EQU     $A70000 ; 25 microsecond parallel delay time
3729   
3730                                ; SI_DELAY, controlled by Makefile def'n SIDELAY_SETTING
3731                                ; as per Confluence July 1 2010 end commentary
3732                                          IF      @SCP("A7","BF")
3735                                          ENDIF
3736                                          IF      @SCP("A7","A7")
3737                                ; 25 us parallel delay time
3738      A70000                    SI_DELAY  EQU     $A70000                           ; 25 microsecond parallel delay time
3739                                          ENDIF
3740   
3741   
3742      A70000                    DG_DELAY  EQU     $A70000                           ; 25 microsecond dump gate delay time
3743                                ;
3744                                ;R_DELAY                EQU     $060000 ; Fast serial regisiter transfer delay.  Set to $0x06000
0.
3745   
3746                                ; R_DELAY, controlled by Makefile def'n RDELAY_SETTING
3747                                ; as per Confluence July 1 2010 end commentary
3748                                          IF      @SCP("00","00")
3749   
3750      000000                    R_DELAY   EQU     $000000                           ; Fast serial register transfer delay
3751                                          ENDIF
3752                                          IF      @SCP("00","06")
3754                                          ENDIF
3755   
3756   
3757   
3758      030000                    CDS_TIM   EQU     $030000                           ; Delay for single clock between reset & dat
a
3759   
3760   
3761                                ; bitwise symbols for integrator manipulation.
3762                                ; Video processor bit definition
3763                                ;             6     5    4     3      2        1         0
3764                                ;            xfer, A/D, integ, Pol-, fixed 0, DCrestore, rst (1 => switch open)
3765                                ; for the ARC-47 1C (incl. all of gen-ii) it was
3766                                ;            xfer, A/D, integ, Pol+, Pol-,    DCrestore, rst (1 => switch open)
3767   
3768                                ; goes with VIDEO
3769      000078                    INT_INIT  EQU     %1111000                          ; Change nearly everything
3770                                ; goes with VIDEO
3771      00007B                    INT_RSTOFF EQU    %1111011                          ; Stop resetting integrator
3772                                ; goes with VIDEO and INT_TIM
3773      00000B                    INT_MINUS EQU     %0001011                          ; Integrate reset level
3774                                ; goes with VIDEO
3775      000013                    INT_STOP  EQU     %0010011                          ; Stop Integrate
3776                                ; goes with VIDEO and INT_TIM
3777      000003                    INT_PLUS  EQU     %0000011                          ; Integrate signal level
3778                                ; goes with VIDEO and ADC_TIM
3779      000013                    INT_SMPL  EQU     %0010011                          ; Stop integrate, A/D is sampling
3780                                ; goes with VIDEO
3781      000010                    INT_DCR   EQU     %0010000                          ; Reset integ. and DC restore
3782   
3783   
3784                                ; DEEP DEPLETION LEVELS
3785                                ; These are available for use during integration & readout
3786   
3787                                ; Clock voltages in volts
3788      1.200000E+001             RG_HI_D   EQU     +12.0                             ; Reset
3789      1.000000E+000             RG_LO_D   EQU     +1.0                              ;
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 72



3790      1.000000E+001             R_HI_D    EQU     +10.0                             ; Serials
3791      1.300000E+000             R_LO_D    EQU     +1.3                              ; TWEAKED
3792      1.000000E+001             SW_HI_D   EQU     +10.0                             ; Summing well, mode 1
3793      1.300000E+000             SW_LO_D   EQU     +1.3                              ; TWEAKED
3794                                ; SW_HI EQU     +2.0    ; Summing well, mode 2
3795                                ; SW_LO EQU     +2.0    ;
3796      1.000000E+001             SI_HI_D   EQU     +10.0                             ; Parallels
3797      0.000000E+000             SI_LO_D   EQU     0.0                               ;
3798      1.000000E+001             TG_HI_D   EQU     +10.0                             ; Transfer Gate
3799      0.000000E+000             TG_LO_D   EQU     0.0                               ;
3800      1.200000E+001             DG_HI_D   EQU     +12.0                             ; Dump Gate
3801      0.000000E+000             DG_LO_D   EQU     0.0                               ;
3802   
3803                                ; DC Bias voltages in volts
3804      3.045000E+001             VOD_D     EQU     30.45                             ; Output Drain Left. TWEAKED
3805                                ; VOD is 1 volt lower than specified because of IR drop in lopass filts.
3806      1.750000E+001             VRD_D     EQU     17.5                              ; Reset Drain Left TWEAKED
3807                                ;VRD     EQU     18.0    ; Reset Drain Left
3808   
3809      1.700000E+000             VOG_D     EQU     1.7                               ; output Gate, mode 1 TWEAKED
3810                                ; VOG   EQU     +18.0   ; Output Gate, mode 2
3811      2.950000E+001             VDD_D     EQU     +29.5                             ; Dump Drain TWEAKED
3812   
3813                                ; from gwaves_CCD67.  Not used in this DSP.
3814                                ; these don't fit into the 3 level scheme, so comment out.
3815                                ;VABG    EQU     -6.0    ; Anti-blooming gate
3816      6.000000E+000             PWR_D     EQU     +6.0                              ; Preamp power - xxx Not used, keep as place
holder
3817   
3818   
3819      002640                    OFFSET    EQU     $2640                             ; this is not used
3820   
3821                                ; Video offsets used to control bias levels; OFFSET0,1,2,3
3822                                ; control named amplifiers C, D, B and A respectively.
3823                                ; Increasing the offset by 1 count seems to decrease the bias level by
3824                                ; .94 ADU as measured on a $300 count offset Aug 2016. This is not linear.
3825                                ;
3826                                ; It is normal procedure to adjust these levels when introducing a
3827                                ; new chip from e2v to get about a 1K ADU  pedestal for every amplifier.
3828   
3829                                ; The values used in 2012 for the "Science Grade 5"
3830                                ; chip with serial 'CCD231-C6-F08_SN-10382-14-01' with unknown characteristics were
3831                                ;  $28B2,  $2617,  $2B3C,  $2204
3832                                ; or possibly they were
3833                                ;  $2CB2,  $2A17,  $2F3C,  $2640
3834                                ;
3835                                ; The values used between 2013 and July 2016 for the "Science Grade 1"
3836                                ; chip with serial   'CCD231-C6-F08_SN-10413-07-01' were
3837                                ;  $2300,  $2377,  $229C,  $2240
3838                                ;
3839                                ; The values used in August 2016 for the "Science Grade 5"
3840                                ; chip with serial 'CCD231-C6-F08_SN-10382-14-01' subsequent to 1st balancing were
3841                                ;  $2B55,  $2672,  $2D8C,  $2204
3842   
3843                                ; The levels needed for a bare controller noise floor are different again-
3844                                ; don't currently have these.
3845                                ;
3846   
3847      002B55                    OFFSET0   EQU     $2B55                             ; e2v E, Peter's C, board 0, ch 0
3848      002672                    OFFSET1   EQU     $2672                             ; e2v F, Peter's D, board 0, ch 1
3849      002D8C                    OFFSET2   EQU     $2D8C                             ; e2v G, Peter's B, board 1, ch 0
3850      002204                    OFFSET3   EQU     $2204                             ; e2v H, Peter's A, board 1, ch 1
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 73



3851   
3857                                ;OFFSET0        EQU     $2B55   ; e2v E, Peter's C, board 0, ch 0
3858   
3864                                ;OFFSET1        EQU     $2672   ; e2v F, Peter's D, board 0, ch 1
3865   
3871                                ;OFFSET2        EQU     $2D8C   ; e2v G, Peter's B, board 1, ch 0
3872   
3875                                ;OFFSET3        EQU     $2204   ; e2v H, Peter's A, board 1, ch 1
3876   
3877                                ; INVERTED LEVELS
3878                                ; These are available for use during startup & idling
3879                                ; they are the DD levels minus 9 volts
3880   
3881                                ; Clock voltages in volts
3882      3.000000E+000             RG_HI_I   EQU     +3.0                              ; Reset
3883      -8.000000E+000            RG_LO_I   EQU     -8.0                              ;
3884      1.000000E+000             R_HI_I    EQU     +1.0                              ; Serials
3885      -7.700000E+000            R_LO_I    EQU     -7.7                              ; TWEAKED
3886      1.000000E+000             SW_HI_I   EQU     +1.0                              ; Summing well, mode 1
3887      -7.700000E+000            SW_LO_I   EQU     -7.7                              ; TWEAKED
3888                                ; SW_HI EQU     +2.0    ; Summing well, mode 2
3889                                ; SW_LO EQU     +2.0    ;
3890      1.000000E+000             SI_HI_I   EQU     +1.0                              ; Parallels
3891      -9.000000E+000            SI_LO_I   EQU     -9.0                              ;
3892      1.000000E+000             TG_HI_I   EQU     +1.0                              ; Transfer Gate
3893      -9.000000E+000            TG_LO_I   EQU     -9.0                              ;
3894      3.000000E+000             DG_HI_I   EQU     +3.0                              ; Dump Gate
3895      -9.000000E+000            DG_LO_I   EQU     -9.0                              ;
3896   
3897                                ; DC Bias voltages in volts
3898      2.145000E+001             VOD_I     EQU     21.45                             ; Output Drain Left. TWEAKED
3899                                ; VOD is 1 volt lower than specified because of IR drop in lopass filts.
3900      8.500000E+000             VRD_I     EQU     8.5                               ; Reset Drain Left TWEAKED
3901                                ;VRD     EQU     18.0    ; Reset Drain Left
3902   
3903      -7.300000E+000            VOG_I     EQU     -7.3                              ; output Gate, mode 1 TWEAKED
3904                                ; VOG   EQU     +18.0   ; Output Gate, mode 2
3905      2.050000E+001             VDD_I     EQU     +20.5                             ; Dump Drain TWEAKED
3906   
3907                                ; from gwaves_CCD67.  Not used in this DSP.
3908                                ; these don't fit into the 3 level scheme, so comment out.
3909                                ;VABG    EQU     -6.0    ; Anti-blooming gate
3910      6.000000E+000             PWR_I     EQU     +6.0                              ; Preamp power - xxx Not used, keep as place
holder
3911   
3912                                ; TRANSITION LEVELS
3913                                ; These are available for the sole purpose of buffering voltage swings
3914   
3915                                ; Clock voltages in volts
3916      3.000000E+000             RG_HI_T   EQU     +3.0                              ; Reset
3917      0.000000E+000             RG_LO_T   EQU     0.0                               ;
3918      1.000000E+000             R_HI_T    EQU     +1.0                              ; Serials
3919      0.000000E+000             R_LO_T    EQU     0.0                               ; TWEAKED
3920      1.000000E+000             SW_HI_T   EQU     +1.0                              ; Summing well, mode 1
3921      0.000000E+000             SW_LO_T   EQU     0.0                               ; TWEAKED
3922                                ; SW_HI EQU     +2.0    ; Summing well, mode 2
3923                                ; SW_LO EQU     +2.0    ;
3924      1.000000E+000             SI_HI_T   EQU     +1.0                              ; Parallels
3925      0.000000E+000             SI_LO_T   EQU     0.0                               ;
3926      1.000000E+000             TG_HI_T   EQU     +1.0                              ; Transfer Gate
3927      0.000000E+000             TG_LO_T   EQU     0.0                               ;
3928      3.000000E+000             DG_HI_T   EQU     +3.0                              ; Dump Gate
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 74



3929      0.000000E+000             DG_LO_T   EQU     0.0                               ;
3930   
3931                                ; DC Bias voltages in volts
3932      2.145000E+001             VOD_T     EQU     21.45                             ; Output Drain Left. TWEAKED
3933                                ; VOD is 1 volt lower than specified because of IR drop in lopass filts.
3934      8.500000E+000             VRD_T     EQU     8.5                               ; Reset Drain Left TWEAKED
3935                                ;VRD     EQU     18.0    ; Reset Drain Left
3936   
3937      0.000000E+000             VOG_T     EQU     0.0                               ; output Gate, mode 1 TWEAKED
3938                                ; VOG   EQU     +18.0   ; Output Gate, mode 2
3939      2.050000E+001             VDD_T     EQU     +20.5                             ; Dump Drain TWEAKED
3940   
3941                                ; from gwaves_CCD67.  Not used in this DSP.
3942                                ; these don't fit into the 3 level scheme, so comment out.
3943                                ;VABG    EQU     -6.0    ; Anti-blooming gate
3944      6.000000E+000             PWR_T     EQU     +6.0                              ; Preamp power - xxx Not used, keep as place
holder
3945   
3946   
3947   
3948   
3949                                ; Define switch state bits for the lower CCD clock driver bank CLK2
3950                                ; In the LMI CCD serial 3 on E/F is on a single pin and serial 3 on G/H is too.
3951                                ; As it happens serial 3 on all four go up and down together so this doesn't
3952                                ; have any effect.  To save effort I've left the symbols the same as they
3953                                ; were (SEH3 now really runs serial 3 on E&F and SFG3 runs serial 3 on G&H).
3954                                ; Pins 11-12, clocks 10 & 11, are not used
3955      000001                    SEH1      EQU     1                                 ; Serial #1 E & H registers, Pin 1 - clock 0
3956      000002                    SEH2      EQU     2                                 ; Serial #2 E & H registers, Pin 2 - clock 1
3957      000004                    SEH3      EQU     4                                 ; Serial #3 E & F registers, Pin 3 - clock 2
3958      000008                    SFG1      EQU     8                                 ; Serial #1 F & G registers, Pin 4 - clock 3
3959      000010                    SFG2      EQU     $10                               ; Serial #2 F & G registers, Pin 5 - clock 4
3960      000020                    SFG3      EQU     $20                               ; Serial #3 G & H registers, Pin 6 - clock 5
3961      000040                    SWEH      EQU     $40                               ; Summing well E & H registers, Pin 7 - cloc
k 6
3962      000080                    SWFG      EQU     $80                               ; Summing well F & G registers, Pin 8 - cloc
k 7
3963      000100                    REH       EQU     $100                              ; Reset Gate E & H registers, Pin 9 - clock 
8
3964      000200                    RFG       EQU     $200                              ; Reset Gate F & G registers, Pin 10 - clock
 9
3965   
3966                                ; Define switch state bits for the upper CCD clock driver bank CLK3
3967                                ; All 12 of these are used
3968      000001                    AB1       EQU     1                                 ; Parallel A & B, phase #1, Pin 13 - clock 1
2
3969      000002                    AB2       EQU     2                                 ; Parallel A & B, phase #2, Pin 14 - clock 1
3
3970      000004                    AB3       EQU     4                                 ; Parallel A & B, phase #3, Pin 15 - clock 1
4
3971      000008                    AB4       EQU     8                                 ; Parallel A & B, phase #4, Pin 16 - clock 1
5
3972      000010                    CD1       EQU     $10                               ; Parallel C & D, phase #1, Pin 17 - clock 1
6
3973      000020                    CD2       EQU     $20                               ; Parallel C & D, phase #2, Pin 18 - clock 1
7
3974      000040                    CD3       EQU     $40                               ; Parallel C & D, phase #3, Pin 19 - clock 1
8
3975      000080                    CD4       EQU     $80                               ; Parallel C & D, phase #4, Pin 33 - clock 1
9
3976      000100                    TGA       EQU     $100                              ; Transfer Gate A, Pin 34 - clock 20
3977      000200                    TGD       EQU     $200                              ; Transfer Gate D, Pin 35 - clock 21
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 75



3978      000400                    DGA       EQU     $400                              ; Dump Gate A, Pin 36 - clock 22
3979      000800                    DGD       EQU     $800                              ; Dump Gate D, Pin 37 - clock 23
3980   
3981                                ;                  EH Side                                            FG Side
3982                                ;  OG  SW  1  2  3  1 .... EH1  EH2  EH3  FG2  FG1  .....  1  3  2  1  SW  OG
3983   
3984                                ; Transfer gate dumps into serial 1 and 2.
3985                                ; Serial 1 & 2 are high between serial clock code lumps.
3986   
3987                                ; Video processor bit definition
3988                                ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3989   
3990                                SERIAL_IDLE                                         ; Split serial during idle
3991      Y:00003F Y:00003F                   DC      END_SERIAL_IDLE-SERIAL_IDLE-1
3992      Y:000040 Y:000040                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3993      Y:000041 Y:000041                   DC      VIDEO+INT_INIT                    ; Change nearly everything
3994      Y:000042 Y:000042                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
3995      Y:000043 Y:000043                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3996      Y:000044 Y:000044                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3997      Y:000045 Y:000045                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3998      Y:000046 Y:000046                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
3999      Y:000047 Y:000047                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4000      Y:000048 Y:000048                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4001      Y:000049 Y:000049                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4002      Y:00004A Y:00004A                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4003      Y:00004B Y:00004B                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4004      Y:00004C Y:00004C                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4005                                END_SERIAL_IDLE
4006   
4007                                ; The following waveforms are for binned operation.  This is for mode 1, i.e.
4008                                ; using a summing well.  Mode 2 uses SW as a second OG and binning has to be
4009                                ; done on the output node like in HIPO.
4010   
4011                                INITIAL_CLOCK_SPLIT                                 ; Both amplifiers
4012      Y:00004D Y:00004D                   DC      END_INITIAL_CLOCK_SPLIT-INITIAL_CLOCK_SPLIT-1
4013      Y:00004E Y:00004E                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4014      Y:00004F Y:00004F                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4015      Y:000050 Y:000050                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4016      Y:000051 Y:000051                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4017      Y:000052 Y:000052                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4018      Y:000053 Y:000053                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4019                                END_INITIAL_CLOCK_SPLIT
4020   
4021                                INITIAL_CLOCK_EH                                    ; Shift to E and H amplifiers
4022      Y:000054 Y:000054                   DC      END_INITIAL_CLOCK_EH-INITIAL_CLOCK_EH-1
4023      Y:000055 Y:000055                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4024      Y:000056 Y:000056                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4025      Y:000057 Y:000057                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4026      Y:000058 Y:000058                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4027      Y:000059 Y:000059                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4028      Y:00005A Y:00005A                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4029                                END_INITIAL_CLOCK_EH
4030   
4031                                INITIAL_CLOCK_FG                                    ; Shift to F and G amplifiers
4032      Y:00005B Y:00005B                   DC      END_INITIAL_CLOCK_FG-INITIAL_CLOCK_FG-1
4033      Y:00005C Y:00005C                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4034      Y:00005D Y:00005D                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4035      Y:00005E Y:00005E                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4036      Y:00005F Y:00005F                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4037      Y:000060 Y:000060                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4038      Y:000061 Y:000061                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4039                                END_INITIAL_CLOCK_FG
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 76



4040   
4041                                SERIAL_CLOCK_SPLIT                                  ; Both amplifiers
4042      Y:000062 Y:000062                   DC      END_SERIAL_CLOCK_SPLIT-SERIAL_CLOCK_SPLIT-1
4043      Y:000063 Y:000063                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4044      Y:000064 Y:000064                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4045      Y:000065 Y:000065                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4046      Y:000066 Y:000066                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4047      Y:000067 Y:000067                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4048      Y:000068 Y:000068                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4049                                END_SERIAL_CLOCK_SPLIT
4050   
4051                                SERIAL_CLOCK_EH                                     ; Shift to E and H amplifiers
4052      Y:000069 Y:000069                   DC      END_SERIAL_CLOCK_EH-SERIAL_CLOCK_EH-1
4053      Y:00006A Y:00006A                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4054      Y:00006B Y:00006B                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4055      Y:00006C Y:00006C                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4056      Y:00006D Y:00006D                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4057      Y:00006E Y:00006E                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4058      Y:00006F Y:00006F                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4059                                END_SERIAL_CLOCK_EH
4060   
4061                                SERIAL_CLOCK_FG                                     ; Shift to F and G amplifiers
4062      Y:000070 Y:000070                   DC      END_SERIAL_CLOCK_FG-SERIAL_CLOCK_FG-1
4063      Y:000071 Y:000071                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4064      Y:000072 Y:000072                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4065      Y:000073 Y:000073                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4066      Y:000074 Y:000074                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4067      Y:000075 Y:000075                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4068      Y:000076 Y:000076                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4069                                END_SERIAL_CLOCK_FG
4070   
4071                                DCRST_LAST
4072      Y:000077 Y:000077                   DC      DCRST_LAST_END-DCRST_LAST-1
4073      Y:000078 Y:000078                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4074                                DCRST_LAST_END
4075   
4076                                VIDEO_PROCESS
4077      Y:000079 Y:000079                   DC      END_VIDEO_PROCESS-VIDEO_PROCESS-1
4078                                SXMIT_VP
4079      Y:00007A Y:00007A                   DC      $00F020                           ; A/D data to fiber; overwritten by SOS
4080      Y:00007B Y:00007B                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4081      Y:00007C Y:00007C                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4082      Y:00007D Y:00007D                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4083                                CCLK_1                                              ; The following line is overwritten by timmi
sc.s
4084      Y:00007E Y:00007E                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4085      Y:00007F Y:00007F                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4086      Y:000080 Y:000080                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4087      Y:000081 Y:000081                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4088                                END_VIDEO_PROCESS
4089   
4090                                ; Starting Y: address of circular waveforms for no-overhead access
4091      0000C0                    STRT_CIR  EQU     $C0
4092                                ;ROM_DISP       EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+STRT_CIR
4093                                ;DAC_DISP       EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+$100
4094   
4095                                ; Check for Y: data memory overflow
4096                                          IF      @CVS(N,*)>STRT_CIR
4098                                          ENDIF                                     ;  will not overflow
4099   
4100                                ; The fast serial code with the circulating address register must start
4101                                ;   on a boundary that is a multiple of the address register modulus.
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 77



4102   
4103                                          IF      @SCP("HOST","HOST")
4104      Y:0000C0 Y:0000C0                   ORG     Y:STRT_CIR,Y:STRT_CIR             ; Download address
4105                                          ELSE
4107                                          ENDIF
4108   
4109                                ; This is an area to copy in the serial fast binned waveforms from high Y memory
4110                                ; It is 0x28 = 40 locations long, enough to put in a binned-by-four waveform
4111                                ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4112                                SERIAL_READ                                         ; Split serial during idle
4113      Y:0000C0 Y:0000C0                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4114      Y:0000C1 Y:0000C1                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4115      Y:0000C2 Y:0000C2                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4116      Y:0000C3 Y:0000C3                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4117      Y:0000C4 Y:0000C4                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4118      Y:0000C5 Y:0000C5                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4119      Y:0000C6 Y:0000C6                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4120      Y:0000C7 Y:0000C7                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4121      Y:0000C8 Y:0000C8                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4122      Y:0000C9 Y:0000C9                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4123      Y:0000CA Y:0000CA                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4124      Y:0000CB Y:0000CB                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4125      Y:0000CC Y:0000CC                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4126      Y:0000CD Y:0000CD                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4127      Y:0000CE Y:0000CE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4128      Y:0000CF Y:0000CF                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4129      Y:0000D0 Y:0000D0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4130      Y:0000D1 Y:0000D1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4131      Y:0000D2 Y:0000D2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4132      Y:0000D3 Y:0000D3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4133      Y:0000D4 Y:0000D4                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4134      Y:0000D5 Y:0000D5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4135      Y:0000D6 Y:0000D6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4136      Y:0000D7 Y:0000D7                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4137                                SXMIT
4138      Y:0000D8 Y:0000D8                   DC      $00F000                           ; Transmit A/D data to host; overwritten by 
SOS
4139      Y:0000D9 Y:0000D9                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4140      Y:0000DA Y:0000DA                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4141      Y:0000DB Y:0000DB                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4142      Y:0000DC Y:0000DC                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4143      Y:0000DD Y:0000DD                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4144      Y:0000DE Y:0000DE                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4145      Y:0000DF Y:0000DF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4146                                END_SERIAL_READ
4147   
4148   
4149                                ; Serial clocking waveform for skipping
4150                                          IF      @SCP("HOST","HOST")
4151      Y:0000E8 Y:0000E8                   ORG     Y:STRT_CIR+$28,Y:STRT_CIR+$28     ; Download address
4152                                          ELSE
4154                                          ENDIF
4155   
4156                                ; There are three serial skip waveforms that must all be the same length
4157                                SERIAL_SKIP_EH
4158      Y:0000E8 Y:0000E8                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4159      Y:0000E9 Y:0000E9                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4160      Y:0000EA Y:0000EA                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+0000
4161      Y:0000EB Y:0000EB                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+0000
4162      Y:0000EC Y:0000EC                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+0000
4163      Y:0000ED Y:0000ED                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4164      Y:0000EE Y:0000EE                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 78



4165                                END_SERIAL_SKIP_EH
4166   
4167                                          IF      @SCP("HOST","HOST")
4168      Y:0000F0 Y:0000F0                   ORG     Y:STRT_CIR+$30,Y:STRT_CIR+$30     ; Download address
4169                                          ELSE
4171                                          ENDIF
4172   
4173                                SERIAL_SKIP_FG
4174      Y:0000F0 Y:0000F0                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4175      Y:0000F1 Y:0000F1                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4176      Y:0000F2 Y:0000F2                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+0000
4177      Y:0000F3 Y:0000F3                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+0000
4178      Y:0000F4 Y:0000F4                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+0000
4179      Y:0000F5 Y:0000F5                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4180      Y:0000F6 Y:0000F6                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4181                                END_SERIAL_SKIP_FG
4182   
4183                                          IF      @SCP("HOST","HOST")
4184      Y:0000F8 Y:0000F8                   ORG     Y:STRT_CIR+$38,Y:STRT_CIR+$38     ; Download address
4185                                          ELSE
4187                                          ENDIF
4188   
4189                                SERIAL_SKIP_SPLIT
4190      Y:0000F8 Y:0000F8                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4191      Y:0000F9 Y:0000F9                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4192      Y:0000FA Y:0000FA                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+SFG1+0000+SFG3+0000
4193      Y:0000FB Y:0000FB                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+0000
4194      Y:0000FC Y:0000FC                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+0000+SFG2+SFG3+0000
4195      Y:0000FD Y:0000FD                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4196      Y:0000FE Y:0000FE                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4197                                END_SERIAL_SKIP_SPLIT
4198   
4199   
4200                                ; Put all the following code in SRAM.
4201                                          IF      @SCP("HOST","HOST")
4202      Y:000100 Y:000100                   ORG     Y:$100,Y:$100                     ; Download address
4203                                          ELSE
4205                                          ENDIF
4206   
4207                                ; DACS from gwaves_CCD67 dropped in here
4208                                ; Initialization of clock driver and video processor DACs and switches
4209   
4210                                ; for DD levels used during integration & readout
4211                                ; This is for the ARC 47 4-channel video board
4212      Y:000100 Y:000100         DACS_DD   DC      END_DACS_DD-DACS_DD-1
4213      Y:000101 Y:000101                   DC      CLKV+$0A0080                      ; DAC = unbuffered mode
4214      Y:000102 Y:000102                   DC      CLKV+$000100+@CVI((R_HI_D+Vmax)/(2*Vmax)*255) ; Pin #1, S1 EH
4215      Y:000103 Y:000103                   DC      CLKV+$000200+@CVI((R_LO_D+Vmax)/(2*Vmax)*255)
4216      Y:000104 Y:000104                   DC      CLKV+$000400+@CVI((R_HI_D+Vmax)/(2*Vmax)*255) ; Pin #2, S2 EH
4217      Y:000105 Y:000105                   DC      CLKV+$000800+@CVI((R_LO_D+Vmax)/(2*Vmax)*255)
4218      Y:000106 Y:000106                   DC      CLKV+$002000+@CVI((R_HI_D+Vmax)/(2*Vmax)*255) ; Pin #3, S3 EF
4219      Y:000107 Y:000107                   DC      CLKV+$004000+@CVI((R_LO_D+Vmax)/(2*Vmax)*255)
4220      Y:000108 Y:000108                   DC      CLKV+$008000+@CVI((R_HI_D+Vmax)/(2*Vmax)*255) ; Pin #4, S1 FG
4221      Y:000109 Y:000109                   DC      CLKV+$010000+@CVI((R_LO_D+Vmax)/(2*Vmax)*255)
4222      Y:00010A Y:00010A                   DC      CLKV+$020100+@CVI((R_HI_D+Vmax)/(2*Vmax)*255) ; Pin #5, S2 FG
4223      Y:00010B Y:00010B                   DC      CLKV+$020200+@CVI((R_LO_D+Vmax)/(2*Vmax)*255)
4224      Y:00010C Y:00010C                   DC      CLKV+$020400+@CVI((R_HI_D+Vmax)/(2*Vmax)*255) ; Pin #6, S3 GH
4225      Y:00010D Y:00010D                   DC      CLKV+$020800+@CVI((R_LO_D+Vmax)/(2*Vmax)*255)
4226      Y:00010E Y:00010E                   DC      CLKV+$022000+@CVI((SW_HI_D+Vmax)/(2*Vmax)*255) ; Pin #7, SW EH
4227      Y:00010F Y:00010F                   DC      CLKV+$024000+@CVI((SW_LO_D+Vmax)/(2*Vmax)*255)
4228      Y:000110 Y:000110                   DC      CLKV+$028000+@CVI((SW_HI_D+Vmax)/(2*Vmax)*255) ; Pin #8, SW FG
4229      Y:000111 Y:000111                   DC      CLKV+$030000+@CVI((SW_LO_D+Vmax)/(2*Vmax)*255)
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 79



4230      Y:000112 Y:000112                   DC      CLKV+$040100+@CVI((RG_HI_D+Vmax)/(2*Vmax)*255) ; Pin #9, RG EH outputs
4231      Y:000113 Y:000113                   DC      CLKV+$040200+@CVI((RG_LO_D+Vmax)/(2*Vmax)*255)
4232      Y:000114 Y:000114                   DC      CLKV+$040400+@CVI((RG_HI_D+Vmax)/(2*Vmax)*255) ; Pin #10, RG FG outputs
4233      Y:000115 Y:000115                   DC      CLKV+$040800+@CVI((RG_LO_D+Vmax)/(2*Vmax)*255)
4234      Y:000116 Y:000116                   DC      CLKV+$042000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #11, Unused
4235      Y:000117 Y:000117                   DC      CLKV+$044000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4236      Y:000118 Y:000118                   DC      CLKV+$048000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #12, Unused
4237      Y:000119 Y:000119                   DC      CLKV+$050000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4238   
4239      Y:00011A Y:00011A                   DC      CLKV+$060100+@CVI((SI_HI_D+Vmax)/(2*Vmax)*255) ; Pin #13, AB1
4240      Y:00011B Y:00011B                   DC      CLKV+$060200+@CVI((SI_LO_D+Vmax)/(2*Vmax)*255)
4241      Y:00011C Y:00011C                   DC      CLKV+$060400+@CVI((SI_HI_D+Vmax)/(2*Vmax)*255) ; Pin #14, AB2
4242      Y:00011D Y:00011D                   DC      CLKV+$060800+@CVI((SI_LO_D+Vmax)/(2*Vmax)*255)
4243      Y:00011E Y:00011E                   DC      CLKV+$062000+@CVI((SI_HI_D+Vmax)/(2*Vmax)*255) ; Pin #15, AB3
4244      Y:00011F Y:00011F                   DC      CLKV+$064000+@CVI((SI_LO_D+Vmax)/(2*Vmax)*255)
4245      Y:000120 Y:000120                   DC      CLKV+$068000+@CVI((SI_HI_D+Vmax)/(2*Vmax)*255) ; Pin #16, AB4
4246      Y:000121 Y:000121                   DC      CLKV+$070000+@CVI((SI_LO_D+Vmax)/(2*Vmax)*255)
4247      Y:000122 Y:000122                   DC      CLKV+$080100+@CVI((SI_HI_D+Vmax)/(2*Vmax)*255) ; Pin #17, CD1
4248      Y:000123 Y:000123                   DC      CLKV+$080200+@CVI((SI_LO_D+Vmax)/(2*Vmax)*255)
4249      Y:000124 Y:000124                   DC      CLKV+$080400+@CVI((SI_HI_D+Vmax)/(2*Vmax)*255) ; Pin #18, CD2
4250      Y:000125 Y:000125                   DC      CLKV+$080800+@CVI((SI_LO_D+Vmax)/(2*Vmax)*255)
4251      Y:000126 Y:000126                   DC      CLKV+$082000+@CVI((SI_HI_D+Vmax)/(2*Vmax)*255) ; Pin #19, CD3
4252      Y:000127 Y:000127                   DC      CLKV+$084000+@CVI((SI_LO_D+Vmax)/(2*Vmax)*255)
4253      Y:000128 Y:000128                   DC      CLKV+$088000+@CVI((SI_HI_D+Vmax)/(2*Vmax)*255) ; Pin #33, CD4
4254      Y:000129 Y:000129                   DC      CLKV+$090000+@CVI((SI_LO_D+Vmax)/(2*Vmax)*255)
4255      Y:00012A Y:00012A                   DC      CLKV+$0A0100+@CVI((TG_HI_D+Vmax)/(2*Vmax)*255) ; Pin #34, TGA
4256      Y:00012B Y:00012B                   DC      CLKV+$0A0200+@CVI((TG_LO_D+Vmax)/(2*Vmax)*255)
4257      Y:00012C Y:00012C                   DC      CLKV+$0A0400+@CVI((TG_HI_D+Vmax)/(2*Vmax)*255) ; Pin #35, TGD
4258      Y:00012D Y:00012D                   DC      CLKV+$0A0800+@CVI((TG_LO_D+Vmax)/(2*Vmax)*255)
4259      Y:00012E Y:00012E                   DC      CLKV+$0A2000+@CVI((DG_HI_D+Vmax)/(2*Vmax)*255) ; Pin #36, DGA
4260      Y:00012F Y:00012F                   DC      CLKV+$0A4000+@CVI((DG_LO_D+Vmax)/(2*Vmax)*255)
4261      Y:000130 Y:000130                   DC      CLKV+$0A8000+@CVI((DG_HI_D+Vmax)/(2*Vmax)*255) ; Pin #37, DGD
4262      Y:000131 Y:000131                   DC      CLKV+$0B0000+@CVI((DG_LO_D+Vmax)/(2*Vmax)*255)
4263   
4264                                ; Commands for the ARC-47 video board
4265      Y:000132 Y:000132                   DC      VID0+$0C0000                      ; Normal Image data D17-D2
4266   
4267                                ; Gain : $0D000g, g = 0 to %1111, Gain = 1.00 to 4.75 in steps of 0.25
4268                                ; See Bob's ARC47 manual for the gain table.
4269                                ; define for DD levels -only-
4270                                DAC_GNSPD
4271      Y:000133 Y:000133                   DC      VID0+$0D000F                      ; This is for 4.75 gain
4272                                ;       DC      VID0+$0D0000    ; fix for arc-47 gen-iii default gain 1
4273   
4274                                ; Integrator time constant: $0C01t0, t = 0 to %1111.
4275                                ; See Bob's ARC47 manual for integration time constant table.
4276      Y:000134 Y:000134                   DC      VID0+$0C0180                      ; integrator parameter for 0.5 us (integrato
r gain = 1.0)
4277   
4278      3.045000E+001             VOD_MAX   EQU     30.45
4279      1.990000E+001             VRD_MAX   EQU     19.90
4280      8.700000E+000             VOG_MAX   EQU     8.70
4281      001FFF                    DAC_ZERO  EQU     $1FFF                             ; Bipolar
4282   
4283      003FFF                    DAC_VOD_D EQU     @CVI((VOD_D/VOD_MAX)*16384-1)     ; Unipolar
4284      003847                    DAC_VRD_D EQU     @CVI((VRD_D/VRD_MAX)*16384-1)     ; Unipolar
4285      00263F                    DAC_VOG_D EQU     @CVI(((VOG_D+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
4286                                ;DAC_VABG       EQU     @CVI(((VABG+VOG_MAX)/VOG_MAX)*8192-1)   ; Bipolar
4287      003DFF                    DAC_VDD_D EQU     @CVI((VDD_D/VOD_MAX)*16384-1)     ; Unipolar
4288      003610                    DAC_PWR_D EQU     @CVI(((PWR_D+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
4289   
4290                                ; Initialize the ARC-47 DAC For DC_BIAS
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 80



4291      Y:000135 Y:000135                   DC      VID0+DAC_ADDR+$000000             ; Vod0, pin 52
4292      Y:000136 Y:000136                   DC      VID0+DAC_RegD+DAC_VOD_D
4293      Y:000137 Y:000137                   DC      VID0+DAC_ADDR+$000004             ; Vrd0, pin 13
4294      Y:000138 Y:000138                   DC      VID0+DAC_RegD+DAC_VRD_D
4295      Y:000139 Y:000139                   DC      VID0+DAC_ADDR+$000008             ; Vog0, pin 29
4296      Y:00013A Y:00013A                   DC      VID0+DAC_RegD+DAC_VOG_D
4297      Y:00013B Y:00013B                   DC      VID0+DAC_ADDR+$00000C             ; NC, pin 5, NC
4298      Y:00013C Y:00013C                   DC      VID0+DAC_RegD+DAC_ZERO
4299   
4300      Y:00013D Y:00013D                   DC      VID0+DAC_ADDR+$000001             ; Vod1, pin 32
4301      Y:00013E Y:00013E                   DC      VID0+DAC_RegD+DAC_VOD_D
4302      Y:00013F Y:00013F                   DC      VID0+DAC_ADDR+$000005             ; Vrd1, pin 55
4303      Y:000140 Y:000140                   DC      VID0+DAC_RegD+DAC_VRD_D
4304      Y:000141 Y:000141                   DC      VID0+DAC_ADDR+$000009             ; Vabg, pin 8
4305      Y:000142 Y:000142                   DC      VID0+DAC_RegD+DAC_VOG_D
4306      Y:000143 Y:000143                   DC      VID0+DAC_ADDR+$00000D             ; NC, pin 47, NC
4307      Y:000144 Y:000144                   DC      VID0+DAC_RegD+DAC_ZERO
4308   
4309      Y:000145 Y:000145                   DC      VID0+DAC_ADDR+$000002             ; Vod2, pin 11
4310      Y:000146 Y:000146                   DC      VID0+DAC_RegD+DAC_VOD_D
4311      Y:000147 Y:000147                   DC      VID0+DAC_ADDR+$000006             ; Vrd2, pin 35
4312      Y:000148 Y:000148                   DC      VID0+DAC_RegD+DAC_VRD_D
4313      Y:000149 Y:000149                   DC      VID0+DAC_ADDR+$00000A             ; Vog2, pin 50
4314      Y:00014A Y:00014A                   DC      VID0+DAC_RegD+DAC_VOG_D
4315      Y:00014B Y:00014B                   DC      VID0+DAC_ADDR+$00000E             ; NC, pin 27, NC
4316      Y:00014C Y:00014C                   DC      VID0+DAC_RegD+DAC_ZERO
4317   
4318      Y:00014D Y:00014D                   DC      VID0+DAC_ADDR+$000003             ; Vod3, pin 53
4319      Y:00014E Y:00014E                   DC      VID0+DAC_RegD+DAC_VOD_D
4320      Y:00014F Y:00014F                   DC      VID0+DAC_ADDR+$000007             ; Vrd3, pin 14
4321      Y:000150 Y:000150                   DC      VID0+DAC_RegD+DAC_VRD_D
4322      Y:000151 Y:000151                   DC      VID0+DAC_ADDR+$00000B             ; Vog3, pin 30
4323      Y:000152 Y:000152                   DC      VID0+DAC_RegD+DAC_VOG_D
4324      Y:000153 Y:000153                   DC      VID0+DAC_ADDR+$00000F             ; NC, pin 6, NC
4325      Y:000154 Y:000154                   DC      VID0+DAC_RegD+DAC_ZERO
4326   
4327      Y:000155 Y:000155                   DC      VID0+DAC_ADDR+$000010             ; Vod4, pin 33, VDD
4328      Y:000156 Y:000156                   DC      VID0+DAC_RegD+DAC_VDD_D
4329      Y:000157 Y:000157                   DC      VID0+DAC_ADDR+$000011             ; Vrd4, pin 56, NC
4330      Y:000158 Y:000158                   DC      VID0+DAC_RegD+DAC_PWR_D
4331      Y:000159 Y:000159                   DC      VID0+DAC_ADDR+$000012             ; Vog4, pin 9, NC
4332      Y:00015A Y:00015A                   DC      VID0+DAC_RegD+DAC_ZERO
4333      Y:00015B Y:00015B                   DC      VID0+DAC_ADDR+$000013             ; Vrsv4,pin 48, NC
4334      Y:00015C Y:00015C                   DC      VID0+DAC_RegD+DAC_ZERO
4335   
4336                                ; Initialize the ARC-47 DAC For Video Offsets
4337      Y:00015D Y:00015D                   DC      VID0+DAC_ADDR+$000014
4338      Y:00015E Y:00015E                   DC      VID0+DAC_RegD+OFFSET0
4339      Y:00015F Y:00015F                   DC      VID0+DAC_ADDR+$000015
4340      Y:000160 Y:000160                   DC      VID0+DAC_RegD+OFFSET1
4341      Y:000161 Y:000161                   DC      VID0+DAC_ADDR+$000016
4342      Y:000162 Y:000162                   DC      VID0+DAC_RegD+OFFSET2
4343      Y:000163 Y:000163                   DC      VID0+DAC_ADDR+$000017
4344      Y:000164 Y:000164                   DC      VID0+DAC_RegD+OFFSET3
4345   
4346                                END_DACS_DD
4347   
4348                                ; Initialization of clock driver and video processor DACs and switches
4349   
4350                                ; for Inverted levels used during startup & idling
4351                                ; This is for the ARC 47 4-channel video board
4352      Y:000165 Y:000165         DACS_INV  DC      END_DACS_INV-DACS_INV-1
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 81



4353      Y:000166 Y:000166                   DC      CLKV+$0A0080                      ; DAC = unbuffered mode
4354      Y:000167 Y:000167                   DC      CLKV+$000100+@CVI((R_HI_I+Vmax)/(2*Vmax)*255) ; Pin #1, S1 EH
4355      Y:000168 Y:000168                   DC      CLKV+$000200+@CVI((R_LO_I+Vmax)/(2*Vmax)*255)
4356      Y:000169 Y:000169                   DC      CLKV+$000400+@CVI((R_HI_I+Vmax)/(2*Vmax)*255) ; Pin #2, S2 EH
4357      Y:00016A Y:00016A                   DC      CLKV+$000800+@CVI((R_LO_I+Vmax)/(2*Vmax)*255)
4358      Y:00016B Y:00016B                   DC      CLKV+$002000+@CVI((R_HI_I+Vmax)/(2*Vmax)*255) ; Pin #3, S3 EF
4359      Y:00016C Y:00016C                   DC      CLKV+$004000+@CVI((R_LO_I+Vmax)/(2*Vmax)*255)
4360      Y:00016D Y:00016D                   DC      CLKV+$008000+@CVI((R_HI_I+Vmax)/(2*Vmax)*255) ; Pin #4, S1 FG
4361      Y:00016E Y:00016E                   DC      CLKV+$010000+@CVI((R_LO_I+Vmax)/(2*Vmax)*255)
4362      Y:00016F Y:00016F                   DC      CLKV+$020100+@CVI((R_HI_I+Vmax)/(2*Vmax)*255) ; Pin #5, S2 FG
4363      Y:000170 Y:000170                   DC      CLKV+$020200+@CVI((R_LO_I+Vmax)/(2*Vmax)*255)
4364      Y:000171 Y:000171                   DC      CLKV+$020400+@CVI((R_HI_I+Vmax)/(2*Vmax)*255) ; Pin #6, S3 GH
4365      Y:000172 Y:000172                   DC      CLKV+$020800+@CVI((R_LO_I+Vmax)/(2*Vmax)*255)
4366      Y:000173 Y:000173                   DC      CLKV+$022000+@CVI((SW_HI_I+Vmax)/(2*Vmax)*255) ; Pin #7, SW EH
4367      Y:000174 Y:000174                   DC      CLKV+$024000+@CVI((SW_LO_I+Vmax)/(2*Vmax)*255)
4368      Y:000175 Y:000175                   DC      CLKV+$028000+@CVI((SW_HI_I+Vmax)/(2*Vmax)*255) ; Pin #8, SW FG
4369      Y:000176 Y:000176                   DC      CLKV+$030000+@CVI((SW_LO_I+Vmax)/(2*Vmax)*255)
4370      Y:000177 Y:000177                   DC      CLKV+$040100+@CVI((RG_HI_I+Vmax)/(2*Vmax)*255) ; Pin #9, RG EH outputs
4371      Y:000178 Y:000178                   DC      CLKV+$040200+@CVI((RG_LO_I+Vmax)/(2*Vmax)*255)
4372      Y:000179 Y:000179                   DC      CLKV+$040400+@CVI((RG_HI_I+Vmax)/(2*Vmax)*255) ; Pin #10, RG FG outputs
4373      Y:00017A Y:00017A                   DC      CLKV+$040800+@CVI((RG_LO_I+Vmax)/(2*Vmax)*255)
4374      Y:00017B Y:00017B                   DC      CLKV+$042000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #11, Unused
4375      Y:00017C Y:00017C                   DC      CLKV+$044000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4376      Y:00017D Y:00017D                   DC      CLKV+$048000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #12, Unused
4377      Y:00017E Y:00017E                   DC      CLKV+$050000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4378   
4379      Y:00017F Y:00017F                   DC      CLKV+$060100+@CVI((SI_HI_I+Vmax)/(2*Vmax)*255) ; Pin #13, AB1
4380      Y:000180 Y:000180                   DC      CLKV+$060200+@CVI((SI_LO_I+Vmax)/(2*Vmax)*255)
4381      Y:000181 Y:000181                   DC      CLKV+$060400+@CVI((SI_HI_I+Vmax)/(2*Vmax)*255) ; Pin #14, AB2
4382      Y:000182 Y:000182                   DC      CLKV+$060800+@CVI((SI_LO_I+Vmax)/(2*Vmax)*255)
4383      Y:000183 Y:000183                   DC      CLKV+$062000+@CVI((SI_HI_I+Vmax)/(2*Vmax)*255) ; Pin #15, AB3
4384      Y:000184 Y:000184                   DC      CLKV+$064000+@CVI((SI_LO_I+Vmax)/(2*Vmax)*255)
4385      Y:000185 Y:000185                   DC      CLKV+$068000+@CVI((SI_HI_I+Vmax)/(2*Vmax)*255) ; Pin #16, AB4
4386      Y:000186 Y:000186                   DC      CLKV+$070000+@CVI((SI_LO_I+Vmax)/(2*Vmax)*255)
4387      Y:000187 Y:000187                   DC      CLKV+$080100+@CVI((SI_HI_I+Vmax)/(2*Vmax)*255) ; Pin #17, CD1
4388      Y:000188 Y:000188                   DC      CLKV+$080200+@CVI((SI_LO_I+Vmax)/(2*Vmax)*255)
4389      Y:000189 Y:000189                   DC      CLKV+$080400+@CVI((SI_HI_I+Vmax)/(2*Vmax)*255) ; Pin #18, CD2
4390      Y:00018A Y:00018A                   DC      CLKV+$080800+@CVI((SI_LO_I+Vmax)/(2*Vmax)*255)
4391      Y:00018B Y:00018B                   DC      CLKV+$082000+@CVI((SI_HI_I+Vmax)/(2*Vmax)*255) ; Pin #19, CD3
4392      Y:00018C Y:00018C                   DC      CLKV+$084000+@CVI((SI_LO_I+Vmax)/(2*Vmax)*255)
4393      Y:00018D Y:00018D                   DC      CLKV+$088000+@CVI((SI_HI_I+Vmax)/(2*Vmax)*255) ; Pin #33, CD4
4394      Y:00018E Y:00018E                   DC      CLKV+$090000+@CVI((SI_LO_I+Vmax)/(2*Vmax)*255)
4395      Y:00018F Y:00018F                   DC      CLKV+$0A0100+@CVI((TG_HI_I+Vmax)/(2*Vmax)*255) ; Pin #34, TGA
4396      Y:000190 Y:000190                   DC      CLKV+$0A0200+@CVI((TG_LO_I+Vmax)/(2*Vmax)*255)
4397      Y:000191 Y:000191                   DC      CLKV+$0A0400+@CVI((TG_HI_I+Vmax)/(2*Vmax)*255) ; Pin #35, TGD
4398      Y:000192 Y:000192                   DC      CLKV+$0A0800+@CVI((TG_LO_I+Vmax)/(2*Vmax)*255)
4399      Y:000193 Y:000193                   DC      CLKV+$0A2000+@CVI((DG_HI_I+Vmax)/(2*Vmax)*255) ; Pin #36, DGA
4400      Y:000194 Y:000194                   DC      CLKV+$0A4000+@CVI((DG_LO_I+Vmax)/(2*Vmax)*255)
4401      Y:000195 Y:000195                   DC      CLKV+$0A8000+@CVI((DG_HI_I+Vmax)/(2*Vmax)*255) ; Pin #37, DGD
4402      Y:000196 Y:000196                   DC      CLKV+$0B0000+@CVI((DG_LO_I+Vmax)/(2*Vmax)*255)
4403   
4404                                ; Commands for the ARC-47 video board
4405      Y:000197 Y:000197                   DC      VID0+$0C0000                      ; Normal Image data D17-D2
4406   
4407                                ; Gain : $0D000g, g = 0 to %1111, Gain = 1.00 to 4.75 in steps of 0.25
4408                                ; See Bob's ARC47 manual for the gain table.
4409                                ; the label is not defined here- the setgain command will not touch
4410                                ;DAC_GNSPD
4411      Y:000198 Y:000198                   DC      VID0+$0D000F                      ; This is for 4.75 gain
4412                                ;       DC      VID0+$0D0000    ; fix for arc-47 gen-iii default gain 1
4413   
4414                                ; Integrator time constant: $0C01t0, t = 0 to %1111.
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 82



4415                                ; See Bob's ARC47 manual for integration time constant table.
4416      Y:000199 Y:000199                   DC      VID0+$0C0180                      ; integrator parameter for 0.5 us (integrato
r gain = 1.0)
4417   
4418                                ;VOD_MAX        EQU     30.45
4419                                ;VRD_MAX        EQU     19.90
4420                                ;VOG_MAX        EQU     8.70
4421      002D14                    DAC_VOD_I EQU     @CVI((VOD_I/VOD_MAX)*16384-1)     ; Unipolar
4422      001B55                    DAC_VRD_I EQU     @CVI((VRD_I/VRD_MAX)*16384-1)     ; Unipolar
4423      000525                    DAC_VOG_I EQU     @CVI(((VOG_I+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
4424                                ;DAC_VABG       EQU     @CVI(((VABG+VOG_MAX)/VOG_MAX)*8192-1)   ; Bipolar
4425      002B15                    DAC_VDD_I EQU     @CVI((VDD_I/VOD_MAX)*16384-1)     ; Unipolar
4426      003610                    DAC_PWR_I EQU     @CVI(((PWR_I+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
4427                                ;DAC_ZERO EQU   $1FFF                                   ; Bipolar
4428   
4429                                ; Initialize the ARC-47 DAC For DC_BIAS
4430      Y:00019A Y:00019A                   DC      VID0+DAC_ADDR+$000000             ; Vod0, pin 52
4431      Y:00019B Y:00019B                   DC      VID0+DAC_RegD+DAC_VOD_I
4432      Y:00019C Y:00019C                   DC      VID0+DAC_ADDR+$000004             ; Vrd0, pin 13
4433      Y:00019D Y:00019D                   DC      VID0+DAC_RegD+DAC_VRD_I
4434      Y:00019E Y:00019E                   DC      VID0+DAC_ADDR+$000008             ; Vog0, pin 29
4435      Y:00019F Y:00019F                   DC      VID0+DAC_RegD+DAC_VOG_I
4436      Y:0001A0 Y:0001A0                   DC      VID0+DAC_ADDR+$00000C             ; NC, pin 5, NC
4437      Y:0001A1 Y:0001A1                   DC      VID0+DAC_RegD+DAC_ZERO
4438   
4439      Y:0001A2 Y:0001A2                   DC      VID0+DAC_ADDR+$000001             ; Vod1, pin 32
4440      Y:0001A3 Y:0001A3                   DC      VID0+DAC_RegD+DAC_VOD_I
4441      Y:0001A4 Y:0001A4                   DC      VID0+DAC_ADDR+$000005             ; Vrd1, pin 55
4442      Y:0001A5 Y:0001A5                   DC      VID0+DAC_RegD+DAC_VRD_I
4443      Y:0001A6 Y:0001A6                   DC      VID0+DAC_ADDR+$000009             ; Vabg, pin 8
4444      Y:0001A7 Y:0001A7                   DC      VID0+DAC_RegD+DAC_VOG_I
4445      Y:0001A8 Y:0001A8                   DC      VID0+DAC_ADDR+$00000D             ; NC, pin 47, NC
4446      Y:0001A9 Y:0001A9                   DC      VID0+DAC_RegD+DAC_ZERO
4447   
4448      Y:0001AA Y:0001AA                   DC      VID0+DAC_ADDR+$000002             ; Vod2, pin 11
4449      Y:0001AB Y:0001AB                   DC      VID0+DAC_RegD+DAC_VOD_I
4450      Y:0001AC Y:0001AC                   DC      VID0+DAC_ADDR+$000006             ; Vrd2, pin 35
4451      Y:0001AD Y:0001AD                   DC      VID0+DAC_RegD+DAC_VRD_I
4452      Y:0001AE Y:0001AE                   DC      VID0+DAC_ADDR+$00000A             ; Vog2, pin 50
4453      Y:0001AF Y:0001AF                   DC      VID0+DAC_RegD+DAC_VOG_I
4454      Y:0001B0 Y:0001B0                   DC      VID0+DAC_ADDR+$00000E             ; NC, pin 27, NC
4455      Y:0001B1 Y:0001B1                   DC      VID0+DAC_RegD+DAC_ZERO
4456   
4457      Y:0001B2 Y:0001B2                   DC      VID0+DAC_ADDR+$000003             ; Vod3, pin 53
4458      Y:0001B3 Y:0001B3                   DC      VID0+DAC_RegD+DAC_VOD_I
4459      Y:0001B4 Y:0001B4                   DC      VID0+DAC_ADDR+$000007             ; Vrd3, pin 14
4460      Y:0001B5 Y:0001B5                   DC      VID0+DAC_RegD+DAC_VRD_I
4461      Y:0001B6 Y:0001B6                   DC      VID0+DAC_ADDR+$00000B             ; Vog3, pin 30
4462      Y:0001B7 Y:0001B7                   DC      VID0+DAC_RegD+DAC_VOG_I
4463      Y:0001B8 Y:0001B8                   DC      VID0+DAC_ADDR+$00000F             ; NC, pin 6, NC
4464      Y:0001B9 Y:0001B9                   DC      VID0+DAC_RegD+DAC_ZERO
4465   
4466      Y:0001BA Y:0001BA                   DC      VID0+DAC_ADDR+$000010             ; Vod4, pin 33, VDD
4467      Y:0001BB Y:0001BB                   DC      VID0+DAC_RegD+DAC_VDD_I
4468      Y:0001BC Y:0001BC                   DC      VID0+DAC_ADDR+$000011             ; Vrd4, pin 56, NC
4469      Y:0001BD Y:0001BD                   DC      VID0+DAC_RegD+DAC_PWR_I
4470      Y:0001BE Y:0001BE                   DC      VID0+DAC_ADDR+$000012             ; Vog4, pin 9, NC
4471      Y:0001BF Y:0001BF                   DC      VID0+DAC_RegD+DAC_ZERO
4472      Y:0001C0 Y:0001C0                   DC      VID0+DAC_ADDR+$000013             ; Vrsv4,pin 48, NC
4473      Y:0001C1 Y:0001C1                   DC      VID0+DAC_RegD+DAC_ZERO
4474   
4475                                ; Initialize the ARC-47 DAC For Video Offsets
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 83



4476      Y:0001C2 Y:0001C2                   DC      VID0+DAC_ADDR+$000014
4477      Y:0001C3 Y:0001C3                   DC      VID0+DAC_RegD+OFFSET0
4478      Y:0001C4 Y:0001C4                   DC      VID0+DAC_ADDR+$000015
4479      Y:0001C5 Y:0001C5                   DC      VID0+DAC_RegD+OFFSET1
4480      Y:0001C6 Y:0001C6                   DC      VID0+DAC_ADDR+$000016
4481      Y:0001C7 Y:0001C7                   DC      VID0+DAC_RegD+OFFSET2
4482      Y:0001C8 Y:0001C8                   DC      VID0+DAC_ADDR+$000017
4483      Y:0001C9 Y:0001C9                   DC      VID0+DAC_RegD+OFFSET3
4484   
4485                                END_DACS_INV
4486   
4487   
4488                                ; Initialization of clock driver and video processor DACs and switches
4489   
4490                                ; for Transition levels used moving to or from the DD levels
4491                                ; This is for the ARC 47 4-channel video board
4492      Y:0001CA Y:0001CA         DACS_TRANS DC     END_DACS_TRANS-DACS_TRANS-1
4493      Y:0001CB Y:0001CB                   DC      CLKV+$0A0080                      ; DAC = unbuffered mode
4494      Y:0001CC Y:0001CC                   DC      CLKV+$000100+@CVI((R_HI_T+Vmax)/(2*Vmax)*255) ; Pin #1, S1 EH
4495      Y:0001CD Y:0001CD                   DC      CLKV+$000200+@CVI((R_LO_T+Vmax)/(2*Vmax)*255)
4496      Y:0001CE Y:0001CE                   DC      CLKV+$000400+@CVI((R_HI_T+Vmax)/(2*Vmax)*255) ; Pin #2, S2 EH
4497      Y:0001CF Y:0001CF                   DC      CLKV+$000800+@CVI((R_LO_T+Vmax)/(2*Vmax)*255)
4498      Y:0001D0 Y:0001D0                   DC      CLKV+$002000+@CVI((R_HI_T+Vmax)/(2*Vmax)*255) ; Pin #3, S3 EF
4499      Y:0001D1 Y:0001D1                   DC      CLKV+$004000+@CVI((R_LO_T+Vmax)/(2*Vmax)*255)
4500      Y:0001D2 Y:0001D2                   DC      CLKV+$008000+@CVI((R_HI_T+Vmax)/(2*Vmax)*255) ; Pin #4, S1 FG
4501      Y:0001D3 Y:0001D3                   DC      CLKV+$010000+@CVI((R_LO_T+Vmax)/(2*Vmax)*255)
4502      Y:0001D4 Y:0001D4                   DC      CLKV+$020100+@CVI((R_HI_T+Vmax)/(2*Vmax)*255) ; Pin #5, S2 FG
4503      Y:0001D5 Y:0001D5                   DC      CLKV+$020200+@CVI((R_LO_T+Vmax)/(2*Vmax)*255)
4504      Y:0001D6 Y:0001D6                   DC      CLKV+$020400+@CVI((R_HI_T+Vmax)/(2*Vmax)*255) ; Pin #6, S3 GH
4505      Y:0001D7 Y:0001D7                   DC      CLKV+$020800+@CVI((R_LO_T+Vmax)/(2*Vmax)*255)
4506      Y:0001D8 Y:0001D8                   DC      CLKV+$022000+@CVI((SW_HI_T+Vmax)/(2*Vmax)*255) ; Pin #7, SW EH
4507      Y:0001D9 Y:0001D9                   DC      CLKV+$024000+@CVI((SW_LO_T+Vmax)/(2*Vmax)*255)
4508      Y:0001DA Y:0001DA                   DC      CLKV+$028000+@CVI((SW_HI_T+Vmax)/(2*Vmax)*255) ; Pin #8, SW FG
4509      Y:0001DB Y:0001DB                   DC      CLKV+$030000+@CVI((SW_LO_T+Vmax)/(2*Vmax)*255)
4510      Y:0001DC Y:0001DC                   DC      CLKV+$040100+@CVI((RG_HI_I+Vmax)/(2*Vmax)*255) ; Pin #9, RG EH outputs
4511      Y:0001DD Y:0001DD                   DC      CLKV+$040200+@CVI((RG_LO_T+Vmax)/(2*Vmax)*255)
4512      Y:0001DE Y:0001DE                   DC      CLKV+$040400+@CVI((RG_HI_T+Vmax)/(2*Vmax)*255) ; Pin #10, RG FG outputs
4513      Y:0001DF Y:0001DF                   DC      CLKV+$040800+@CVI((RG_LO_T+Vmax)/(2*Vmax)*255)
4514      Y:0001E0 Y:0001E0                   DC      CLKV+$042000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #11, Unused
4515      Y:0001E1 Y:0001E1                   DC      CLKV+$044000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4516      Y:0001E2 Y:0001E2                   DC      CLKV+$048000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #12, Unused
4517      Y:0001E3 Y:0001E3                   DC      CLKV+$050000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4518   
4519      Y:0001E4 Y:0001E4                   DC      CLKV+$060100+@CVI((SI_HI_T+Vmax)/(2*Vmax)*255) ; Pin #13, AB1
4520      Y:0001E5 Y:0001E5                   DC      CLKV+$060200+@CVI((SI_LO_T+Vmax)/(2*Vmax)*255)
4521      Y:0001E6 Y:0001E6                   DC      CLKV+$060400+@CVI((SI_HI_T+Vmax)/(2*Vmax)*255) ; Pin #14, AB2
4522      Y:0001E7 Y:0001E7                   DC      CLKV+$060800+@CVI((SI_LO_T+Vmax)/(2*Vmax)*255)
4523      Y:0001E8 Y:0001E8                   DC      CLKV+$062000+@CVI((SI_HI_T+Vmax)/(2*Vmax)*255) ; Pin #15, AB3
4524      Y:0001E9 Y:0001E9                   DC      CLKV+$064000+@CVI((SI_LO_T+Vmax)/(2*Vmax)*255)
4525      Y:0001EA Y:0001EA                   DC      CLKV+$068000+@CVI((SI_HI_T+Vmax)/(2*Vmax)*255) ; Pin #16, AB4
4526      Y:0001EB Y:0001EB                   DC      CLKV+$070000+@CVI((SI_LO_T+Vmax)/(2*Vmax)*255)
4527      Y:0001EC Y:0001EC                   DC      CLKV+$080100+@CVI((SI_HI_T+Vmax)/(2*Vmax)*255) ; Pin #17, CD1
4528      Y:0001ED Y:0001ED                   DC      CLKV+$080200+@CVI((SI_LO_T+Vmax)/(2*Vmax)*255)
4529      Y:0001EE Y:0001EE                   DC      CLKV+$080400+@CVI((SI_HI_T+Vmax)/(2*Vmax)*255) ; Pin #18, CD2
4530      Y:0001EF Y:0001EF                   DC      CLKV+$080800+@CVI((SI_LO_T+Vmax)/(2*Vmax)*255)
4531      Y:0001F0 Y:0001F0                   DC      CLKV+$082000+@CVI((SI_HI_T+Vmax)/(2*Vmax)*255) ; Pin #19, CD3
4532      Y:0001F1 Y:0001F1                   DC      CLKV+$084000+@CVI((SI_LO_T+Vmax)/(2*Vmax)*255)
4533      Y:0001F2 Y:0001F2                   DC      CLKV+$088000+@CVI((SI_HI_T+Vmax)/(2*Vmax)*255) ; Pin #33, CD4
4534      Y:0001F3 Y:0001F3                   DC      CLKV+$090000+@CVI((SI_LO_T+Vmax)/(2*Vmax)*255)
4535      Y:0001F4 Y:0001F4                   DC      CLKV+$0A0100+@CVI((TG_HI_T+Vmax)/(2*Vmax)*255) ; Pin #34, TGA
4536      Y:0001F5 Y:0001F5                   DC      CLKV+$0A0200+@CVI((TG_LO_T+Vmax)/(2*Vmax)*255)
4537      Y:0001F6 Y:0001F6                   DC      CLKV+$0A0400+@CVI((TG_HI_T+Vmax)/(2*Vmax)*255) ; Pin #35, TGD
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 84



4538      Y:0001F7 Y:0001F7                   DC      CLKV+$0A0800+@CVI((TG_LO_T+Vmax)/(2*Vmax)*255)
4539      Y:0001F8 Y:0001F8                   DC      CLKV+$0A2000+@CVI((DG_HI_T+Vmax)/(2*Vmax)*255) ; Pin #36, DGA
4540      Y:0001F9 Y:0001F9                   DC      CLKV+$0A4000+@CVI((DG_LO_T+Vmax)/(2*Vmax)*255)
4541      Y:0001FA Y:0001FA                   DC      CLKV+$0A8000+@CVI((DG_HI_T+Vmax)/(2*Vmax)*255) ; Pin #37, DGD
4542      Y:0001FB Y:0001FB                   DC      CLKV+$0B0000+@CVI((DG_LO_T+Vmax)/(2*Vmax)*255)
4543   
4544                                ; Commands for the ARC-47 video board
4545      Y:0001FC Y:0001FC                   DC      VID0+$0C0000                      ; Normal Image data D17-D2
4546   
4547                                ; Gain : $0D000g, g = 0 to %1111, Gain = 1.00 to 4.75 in steps of 0.25
4548                                ; See Bob's ARC47 manual for the gain table.
4549                                ; the label is not defined here- the setgain command will not touch
4550                                ;DAC_GNSPD
4551      Y:0001FD Y:0001FD                   DC      VID0+$0D000F                      ; This is for 4.75 gain
4552                                ;       DC      VID0+$0D0000    ; fix for arc-47 gen-iii default gain 1
4553   
4554                                ; Integrator time constant: $0C01t0, t = 0 to %1111.
4555                                ; See Bob's ARC47 manual for integration time constant table.
4556      Y:0001FE Y:0001FE                   DC      VID0+$0C0180                      ; integrator parameter for 0.5 us (integrato
r gain = 1.0)
4557   
4558                                ;VOD_MAX        EQU     30.45
4559                                ;VRD_MAX        EQU     19.90
4560                                ;VOG_MAX        EQU     8.70
4561      002D14                    DAC_VOD_T EQU     @CVI((VOD_T/VOD_MAX)*16384-1)     ; Unipolar
4562      001B55                    DAC_VRD_T EQU     @CVI((VRD_T/VRD_MAX)*16384-1)     ; Unipolar
4563      001FFF                    DAC_VOG_T EQU     @CVI(((VOG_T+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
4564                                ;DAC_VABG       EQU     @CVI(((VABG+VOG_MAX)/VOG_MAX)*8192-1)   ; Bipolar
4565      002B15                    DAC_VDD_T EQU     @CVI((VDD_T/VOD_MAX)*16384-1)     ; Unipolar
4566      003610                    DAC_PWR_T EQU     @CVI(((PWR_T+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
4567                                ;DAC_ZERO EQU   $1FFF                                   ; Bipolar
4568   
4569                                ; Initialize the ARC-47 DAC For DC_BIAS
4570      Y:0001FF Y:0001FF                   DC      VID0+DAC_ADDR+$000000             ; Vod0, pin 52
4571      Y:000200 Y:000200                   DC      VID0+DAC_RegD+DAC_VOD_T
4572      Y:000201 Y:000201                   DC      VID0+DAC_ADDR+$000004             ; Vrd0, pin 13
4573      Y:000202 Y:000202                   DC      VID0+DAC_RegD+DAC_VRD_T
4574      Y:000203 Y:000203                   DC      VID0+DAC_ADDR+$000008             ; Vog0, pin 29
4575      Y:000204 Y:000204                   DC      VID0+DAC_RegD+DAC_VOG_T
4576      Y:000205 Y:000205                   DC      VID0+DAC_ADDR+$00000C             ; NC, pin 5, NC
4577      Y:000206 Y:000206                   DC      VID0+DAC_RegD+DAC_ZERO
4578   
4579      Y:000207 Y:000207                   DC      VID0+DAC_ADDR+$000001             ; Vod1, pin 32
4580      Y:000208 Y:000208                   DC      VID0+DAC_RegD+DAC_VOD_T
4581      Y:000209 Y:000209                   DC      VID0+DAC_ADDR+$000005             ; Vrd1, pin 55
4582      Y:00020A Y:00020A                   DC      VID0+DAC_RegD+DAC_VRD_T
4583      Y:00020B Y:00020B                   DC      VID0+DAC_ADDR+$000009             ; Vabg, pin 8
4584      Y:00020C Y:00020C                   DC      VID0+DAC_RegD+DAC_VOG_T
4585      Y:00020D Y:00020D                   DC      VID0+DAC_ADDR+$00000D             ; NC, pin 47, NC
4586      Y:00020E Y:00020E                   DC      VID0+DAC_RegD+DAC_ZERO
4587   
4588      Y:00020F Y:00020F                   DC      VID0+DAC_ADDR+$000002             ; Vod2, pin 11
4589      Y:000210 Y:000210                   DC      VID0+DAC_RegD+DAC_VOD_T
4590      Y:000211 Y:000211                   DC      VID0+DAC_ADDR+$000006             ; Vrd2, pin 35
4591      Y:000212 Y:000212                   DC      VID0+DAC_RegD+DAC_VRD_T
4592      Y:000213 Y:000213                   DC      VID0+DAC_ADDR+$00000A             ; Vog2, pin 50
4593      Y:000214 Y:000214                   DC      VID0+DAC_RegD+DAC_VOG_T
4594      Y:000215 Y:000215                   DC      VID0+DAC_ADDR+$00000E             ; NC, pin 27, NC
4595      Y:000216 Y:000216                   DC      VID0+DAC_RegD+DAC_ZERO
4596   
4597      Y:000217 Y:000217                   DC      VID0+DAC_ADDR+$000003             ; Vod3, pin 53
4598      Y:000218 Y:000218                   DC      VID0+DAC_RegD+DAC_VOD_T
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 85



4599      Y:000219 Y:000219                   DC      VID0+DAC_ADDR+$000007             ; Vrd3, pin 14
4600      Y:00021A Y:00021A                   DC      VID0+DAC_RegD+DAC_VRD_T
4601      Y:00021B Y:00021B                   DC      VID0+DAC_ADDR+$00000B             ; Vog3, pin 30
4602      Y:00021C Y:00021C                   DC      VID0+DAC_RegD+DAC_VOG_T
4603      Y:00021D Y:00021D                   DC      VID0+DAC_ADDR+$00000F             ; NC, pin 6, NC
4604      Y:00021E Y:00021E                   DC      VID0+DAC_RegD+DAC_ZERO
4605   
4606      Y:00021F Y:00021F                   DC      VID0+DAC_ADDR+$000010             ; Vod4, pin 33, VDD
4607      Y:000220 Y:000220                   DC      VID0+DAC_RegD+DAC_VDD_T
4608      Y:000221 Y:000221                   DC      VID0+DAC_ADDR+$000011             ; Vrd4, pin 56, NC
4609      Y:000222 Y:000222                   DC      VID0+DAC_RegD+DAC_PWR_T
4610      Y:000223 Y:000223                   DC      VID0+DAC_ADDR+$000012             ; Vog4, pin 9, NC
4611      Y:000224 Y:000224                   DC      VID0+DAC_RegD+DAC_ZERO
4612      Y:000225 Y:000225                   DC      VID0+DAC_ADDR+$000013             ; Vrsv4,pin 48, NC
4613      Y:000226 Y:000226                   DC      VID0+DAC_RegD+DAC_ZERO
4614   
4615                                ; Initialize the ARC-47 DAC For Video Offsets
4616      Y:000227 Y:000227                   DC      VID0+DAC_ADDR+$000014
4617      Y:000228 Y:000228                   DC      VID0+DAC_RegD+OFFSET0
4618      Y:000229 Y:000229                   DC      VID0+DAC_ADDR+$000015
4619      Y:00022A Y:00022A                   DC      VID0+DAC_RegD+OFFSET1
4620      Y:00022B Y:00022B                   DC      VID0+DAC_ADDR+$000016
4621      Y:00022C Y:00022C                   DC      VID0+DAC_RegD+OFFSET2
4622      Y:00022D Y:00022D                   DC      VID0+DAC_ADDR+$000017
4623      Y:00022E Y:00022E                   DC      VID0+DAC_RegD+OFFSET3
4624   
4625                                END_DACS_TRANS
4626   
4627   
4628                                ;  ***  Definitions for Y: memory waveform tables  *****
4629                                ; Put the parallel clock waveforms in slow external Y memory since there isn't
4630                                ; enough room in the fast memory for everything we need.  The parallels are
4631                                ; way slow anyway so the slowness of the access can be tweaked with SI_DELAY.
4632                                ; Clock whole CCD up toward the GH serial register.  Serial phases 1 & 2 high.
4633                                ; CD goes 2-3-4-1, AB goes 3-2-1-4
4634                                ; Parallel phases 2 & 3 high during integration.
4635   
4636                                ; Serial clock convention:    REH SEH1 SEH2 SEH3 SWEH RFG SFG1 SFG2 SFG3 SWFG
4637                                ; Parallel clock convention:  AB1 AB2 AB3 AB4 TGA DGA CD1 CD2 CD3 CD4 TGD DGD
4638   
4639                                ; ADD DC RESTORE based on gwaves!
4640                                ABCD_UP
4641      Y:00022F Y:00022F                   DC      END_ABCD_UP-ABCD_UP-1
4642      Y:000230 Y:000230                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4643      Y:000231 Y:000231                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4644      Y:000232 Y:000232                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+000
4645      Y:000233 Y:000233                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+000+CD3+CD4+000+000
4646      Y:000234 Y:000234                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+000+000+CD1+000+CD3+CD4+TGD+000
4647      Y:000235 Y:000235                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+000+000+CD1+000+000+CD4+TGD+000
4648      Y:000236 Y:000236                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+000+000+CD1+CD2+000+CD4+TGD+000
4649      Y:000237 Y:000237                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+000+000+CD1+CD2+000+000+TGD+000
4650      Y:000238 Y:000238                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+000+000+CD1+CD2+CD3+000+TGD+000
4651      Y:000239 Y:000239                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4652                                END_ABCD_UP
4653   
4654                                ; Clock whole CCD down toward the EF serial register.  Serial phases 1 & 2 high.
4655                                ; AB goes 2-3-4-1, CD goes 3-2-1-4
4656                                ; Parallel phases 2 & 3 high during integration.
4657                                ; ADD DC RESTORE based on gwaves!
4658                                ABCD_DOWN
4659      Y:00023A Y:00023A                   DC      END_ABCD_DOWN-ABCD_DOWN-1
4660      Y:00023B Y:00023B                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 86



4661      Y:00023C Y:00023C                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4662      Y:00023D Y:00023D                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+000+CD1+CD2+CD3+000+000+000
4663      Y:00023E Y:00023E                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+000+CD1+CD2+000+000+000+000
4664      Y:00023F Y:00023F                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+000+CD1+CD2+000+CD4+000+000
4665      Y:000240 Y:000240                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+000+CD1+000+000+CD4+000+000
4666      Y:000241 Y:000241                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+000+CD1+000+CD3+CD4+000+000
4667      Y:000242 Y:000242                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+000+CD3+CD4+000+000
4668      Y:000243 Y:000243                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+000
4669      Y:000244 Y:000244                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4670                                END_ABCD_DOWN
4671   
4672                                ; Clock whole CCD split.  Serial phases 1 & 2 high.
4673                                ; ABCD all go 2-3-4-1
4674                                ; Parallel phases 2 & 3 high during integration.
4675                                ; ADD DC RESTORE based on gwaves!
4676                                ABCD_SPLIT
4677      Y:000245 Y:000245                   DC      END_ABCD_SPLIT-ABCD_SPLIT-1
4678      Y:000246 Y:000246                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4679      Y:000247 Y:000247                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4680      Y:000248 Y:000248                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+000+000+CD2+CD3+CD4+000+000
4681      Y:000249 Y:000249                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+000+000+000+CD3+CD4+000+000
4682      Y:00024A Y:00024A                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+000+CD1+000+CD3+CD4+TGD+000
4683      Y:00024B Y:00024B                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+000+CD1+000+000+CD4+TGD+000
4684      Y:00024C Y:00024C                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+000+CD1+CD2+000+CD4+TGD+000
4685      Y:00024D Y:00024D                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+CD1+CD2+000+000+TGD+000
4686      Y:00024E Y:00024E                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+CD1+CD2+CD3+000+TGD+000
4687      Y:00024F Y:00024F                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4688                                END_ABCD_SPLIT
4689   
4690                                ; Clear whole CCD up toward the GH serial register.  Serial phases 1 & 2 high.
4691                                ; CD goes 2-3-4-1, AB goes 3-2-1-4
4692                                ; Parallel phases 2 & 3 high during integration.
4693                                ; ADD DC RESTORE based on gwaves!
4694                                ABCD_CLEAR_UP
4695      Y:000250 Y:000250                   DC      END_ABCD_CLEAR_UP-ABCD_CLEAR_UP-1
4696      Y:000251 Y:000251                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4697      Y:000252 Y:000252                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4698      Y:000253 Y:000253                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+DGD
4699      Y:000254 Y:000254                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+000+CD3+CD4+000+DGD
4700      Y:000255 Y:000255                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+000+000+CD1+000+CD3+CD4+TGD+DGD
4701      Y:000256 Y:000256                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+000+000+CD1+000+000+CD4+TGD+DGD
4702      Y:000257 Y:000257                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+000+000+CD1+CD2+000+CD4+TGD+DGD
4703      Y:000258 Y:000258                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+000+000+CD1+CD2+000+000+TGD+DGD
4704      Y:000259 Y:000259                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+000+000+CD1+CD2+CD3+000+TGD+DGD
4705      Y:00025A Y:00025A                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+DGD
4706      Y:00025B Y:00025B                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4707      Y:00025C Y:00025C                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4708      Y:00025D Y:00025D                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4709                                END_ABCD_CLEAR_UP
4710   
4711                                ; Clear whole CCD down toward the EF serial register.  Serial phases 1 & 2 high.
4712                                ; AB goes 2-3-4-1, CD goes 3-2-1-4
4713                                ; Parallel phases 2 & 3 high during integration.
4714                                ; ADD DC RESTORE based on gwaves!
4715                                ABCD_CLEAR_DOWN
4716      Y:00025E Y:00025E                   DC      END_ABCD_CLEAR_DOWN-ABCD_CLEAR_DOWN-1
4717      Y:00025F Y:00025F                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4718      Y:000260 Y:000260                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4719      Y:000261 Y:000261                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+DGA+CD1+CD2+CD3+000+000+000
4720      Y:000262 Y:000262                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+DGA+CD1+CD2+000+000+000+000
4721      Y:000263 Y:000263                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+DGA+CD1+CD2+000+CD4+000+000
4722      Y:000264 Y:000264                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+DGA+CD1+000+000+CD4+000+000
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 87



4723      Y:000265 Y:000265                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+DGA+CD1+000+CD3+CD4+000+000
4724      Y:000266 Y:000266                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+DGA+000+000+CD3+CD4+000+000
4725      Y:000267 Y:000267                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+DGA+000+CD2+CD3+CD4+000+000
4726      Y:000268 Y:000268                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+000
4727      Y:000269 Y:000269                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4728      Y:00026A Y:00026A                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4729      Y:00026B Y:00026B                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4730                                END_ABCD_CLEAR_DOWN
4731   
4732                                ; Clear whole CCD split.  Serial phases 1 & 2 high.
4733                                ; ABCD all go 2-3-4-1
4734                                ; Parallel phases 2 & 3 high during integration.
4735                                ; ADD DC RESTORE based on gwaves!
4736                                ABCD_CLEAR_SPLIT
4737      Y:00026C Y:00026C                   DC      END_ABCD_CLEAR_SPLIT-ABCD_CLEAR_SPLIT-1
4738      Y:00026D Y:00026D                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4739      Y:00026E Y:00026E                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4740      Y:00026F Y:00026F                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+DGA+000+CD2+CD3+CD4+000+DGD
4741      Y:000270 Y:000270                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+DGA+000+000+CD3+CD4+000+DGD
4742      Y:000271 Y:000271                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+DGA+CD1+000+CD3+CD4+TGD+DGD
4743      Y:000272 Y:000272                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+DGA+CD1+000+000+CD4+TGD+DGD
4744      Y:000273 Y:000273                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+DGA+CD1+CD2+000+CD4+TGD+DGD
4745      Y:000274 Y:000274                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+DGA+CD1+CD2+000+000+TGD+DGD
4746      Y:000275 Y:000275                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+DGA+CD1+CD2+CD3+000+TGD+DGD
4747      Y:000276 Y:000276                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+DGD
4748      Y:000277 Y:000277                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4749      Y:000278 Y:000278                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4750      Y:000279 Y:000279                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4751                                END_ABCD_CLEAR_SPLIT
4752   
4753                                ; Clock CD section up toward the GH serial register; AB static.  Serial phases 1 & 2 high.
4754                                ; CD goes 2-3-4-1
4755                                ; Parallel phases 2 & 3 high during integration.
4756                                ; ADD DC RESTORE based on gwaves!
4757                                CD_UP
4758      Y:00027A Y:00027A                   DC      END_CD_UP-CD_UP-1
4759      Y:00027B Y:00027B                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4760      Y:00027C Y:00027C                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4761      Y:00027D Y:00027D                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+000
4762      Y:00027E Y:00027E                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+000+CD3+CD4+000+000
4763      Y:00027F Y:00027F                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+CD3+CD4+TGD+000
4764      Y:000280 Y:000280                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+000+CD4+TGD+000
4765      Y:000281 Y:000281                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+CD4+TGD+000
4766      Y:000282 Y:000282                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+000+TGD+000
4767      Y:000283 Y:000283                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+CD3+000+TGD+000
4768      Y:000284 Y:000284                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4769                                END_CD_UP
4770   
4771                                ; Clock AB section down toward the EF serial register; CD static.  Serial phases 1 & 2 high.
4772                                ; AB goes 2-3-4-1
4773                                ; Parallel phases 2 & 3 high during integration.
4774                                ; ADD DC RESTORE based on gwaves!
4775                                AB_DOWN
4776      Y:000285 Y:000285                   DC      END_AB_DOWN-AB_DOWN-1
4777      Y:000286 Y:000286                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4778      Y:000287 Y:000287                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4779      Y:000288 Y:000288                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+000+000+CD2+CD3+000+000+000
4780      Y:000289 Y:000289                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+000+000+CD2+CD3+000+000+000
4781      Y:00028A Y:00028A                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+000+000+CD2+CD3+000+000+000
4782      Y:00028B Y:00028B                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+000+000+CD2+CD3+000+000+000
4783      Y:00028C Y:00028C                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+000+000+CD2+CD3+000+000+000
4784      Y:00028D Y:00028D                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+CD2+CD3+000+000+000
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 88



4785      Y:00028E Y:00028E                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4786      Y:00028F Y:00028F                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4787                                END_AB_DOWN
4788   
4789                                ; Clear CD section up toward the GH serial register; AB static.  Serial phases 1 & 2 high.
4790                                ; CD goes 2-3-4-1
4791                                ; Parallel phases 2 & 3 high during integration.
4792                                ; ADD DC RESTORE based on gwaves!
4793                                CD_CLEAR_UP
4794      Y:000290 Y:000290                   DC      END_CD_CLEAR_UP-CD_CLEAR_UP-1
4795      Y:000291 Y:000291                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4796      Y:000292 Y:000292                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4797      Y:000293 Y:000293                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+DGD
4798      Y:000294 Y:000294                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+000+CD3+CD4+000+DGD
4799      Y:000295 Y:000295                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+CD3+CD4+TGD+DGD
4800      Y:000296 Y:000296                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+000+CD4+TGD+DGD
4801      Y:000297 Y:000297                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+CD4+TGD+DGD
4802      Y:000298 Y:000298                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+000+TGD+DGD
4803      Y:000299 Y:000299                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+CD3+000+TGD+DGD
4804      Y:00029A Y:00029A                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+DGD
4805      Y:00029B Y:00029B                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4806      Y:00029C Y:00029C                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4807      Y:00029D Y:00029D                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4808                                END_CD_CLEAR_UP
4809   
4810                                ; Clear AB section down toward the EF serial register; CD static.  Serial phases 1 & 2 high.
4811                                ; AB goes 2-3-4-1
4812                                ; Parallel phases 2 & 3 high during integration.
4813                                ; ADD DC RESTORE based on gwaves!
4814                                AB_CLEAR_DOWN
4815      Y:00029E Y:00029E                   DC      END_AB_CLEAR_DOWN-AB_CLEAR_DOWN-1
4816      Y:00029F Y:00029F                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4817      Y:0002A0 Y:0002A0                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4818      Y:0002A1 Y:0002A1                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4819      Y:0002A2 Y:0002A2                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4820      Y:0002A3 Y:0002A3                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4821      Y:0002A4 Y:0002A4                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4822      Y:0002A5 Y:0002A5                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4823      Y:0002A6 Y:0002A6                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+DGA+000+CD2+CD3+000+000+000
4824      Y:0002A7 Y:0002A7                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+000
4825      Y:0002A8 Y:0002A8                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+000
4826      Y:0002A9 Y:0002A9                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4827      Y:0002AA Y:0002AA                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4828      Y:0002AB Y:0002AB                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4829                                END_AB_CLEAR_DOWN
4830   
4831                                ; Dump both the EF and GH serial registers using DGA and DGD
4832                                DUMP_SERIAL
4833      Y:0002AC Y:0002AC                   DC      END_DUMP_SERIAL-DUMP_SERIAL-1
4834      Y:0002AD Y:0002AD                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4835      Y:0002AE Y:0002AE                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+DGD
4836      Y:0002AF Y:0002AF                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4837      Y:0002B0 Y:0002B0                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4838      Y:0002B1 Y:0002B1                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4839                                END_DUMP_SERIAL
4840   
4841   
4842   
4843   
4844                                ; Parallel waveforms done.  Move on to the layered serial ones.
4845   
4846                                ;       These are the 12 fast serial read waveforms for left, right,
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 89



4847                                ;       and split reads for serial binning factors from 1 to 4.
4848   
4849                                ;       Unbinned waveforms
4850                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4851                                SERIAL_READ_EH_1
4852      Y:0002B2 Y:0002B2                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4853      Y:0002B3 Y:0002B3                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4854      Y:0002B4 Y:0002B4                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4855      Y:0002B5 Y:0002B5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4856      Y:0002B6 Y:0002B6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4857      Y:0002B7 Y:0002B7                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4858                                SXMIT_EH_1
4859      Y:0002B8 Y:0002B8                   DC      $00F000                           ; Transmit A/D data to host
4860      Y:0002B9 Y:0002B9                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4861      Y:0002BA Y:0002BA                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4862      Y:0002BB Y:0002BB                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4863      Y:0002BC Y:0002BC                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4864      Y:0002BD Y:0002BD                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4865      Y:0002BE Y:0002BE                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4866      Y:0002BF Y:0002BF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4867                                END_SERIAL_READ_EH_1
4868   
4869                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4870                                SERIAL_READ_FG_1
4871      Y:0002C0 Y:0002C0                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4872      Y:0002C1 Y:0002C1                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4873      Y:0002C2 Y:0002C2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4874      Y:0002C3 Y:0002C3                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4875      Y:0002C4 Y:0002C4                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4876      Y:0002C5 Y:0002C5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4877                                SXMIT_FG_1
4878      Y:0002C6 Y:0002C6                   DC      $00F021                           ; Transmit A/D data to host
4879      Y:0002C7 Y:0002C7                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4880      Y:0002C8 Y:0002C8                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4881      Y:0002C9 Y:0002C9                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4882      Y:0002CA Y:0002CA                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4883      Y:0002CB Y:0002CB                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4884      Y:0002CC Y:0002CC                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4885      Y:0002CD Y:0002CD                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4886                                END_SERIAL_READ_FG_1
4887   
4888                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4889                                SERIAL_READ_SPLIT_1
4890      Y:0002CE Y:0002CE                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4891      Y:0002CF Y:0002CF                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4892      Y:0002D0 Y:0002D0                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4893      Y:0002D1 Y:0002D1                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4894      Y:0002D2 Y:0002D2                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4895      Y:0002D3 Y:0002D3                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4896                                SXMIT_SPLIT_1
4897      Y:0002D4 Y:0002D4                   DC      $00F020                           ; Transmit A/D data to host
4898      Y:0002D5 Y:0002D5                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4899      Y:0002D6 Y:0002D6                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4900      Y:0002D7 Y:0002D7                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4901      Y:0002D8 Y:0002D8                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4902      Y:0002D9 Y:0002D9                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4903      Y:0002DA Y:0002DA                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4904      Y:0002DB Y:0002DB                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4905                                END_SERIAL_READ_SPLIT_1
4906   
4907                                ;       Bin by 2 waveforms
4908                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 90



4909                                SERIAL_READ_EH_2
4910      Y:0002DC Y:0002DC                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4911      Y:0002DD Y:0002DD                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4912      Y:0002DE Y:0002DE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4913      Y:0002DF Y:0002DF                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4914      Y:0002E0 Y:0002E0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4915      Y:0002E1 Y:0002E1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4916      Y:0002E2 Y:0002E2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4917      Y:0002E3 Y:0002E3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4918      Y:0002E4 Y:0002E4                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4919      Y:0002E5 Y:0002E5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4920      Y:0002E6 Y:0002E6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4921      Y:0002E7 Y:0002E7                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4922                                SXMIT_EH_2
4923      Y:0002E8 Y:0002E8                   DC      $00F000                           ; Transmit A/D data to host
4924      Y:0002E9 Y:0002E9                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4925      Y:0002EA Y:0002EA                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4926      Y:0002EB Y:0002EB                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4927      Y:0002EC Y:0002EC                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4928      Y:0002ED Y:0002ED                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4929      Y:0002EE Y:0002EE                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4930      Y:0002EF Y:0002EF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4931                                END_SERIAL_READ_EH_2
4932   
4933                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4934                                SERIAL_READ_FG_2
4935      Y:0002F0 Y:0002F0                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4936      Y:0002F1 Y:0002F1                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4937      Y:0002F2 Y:0002F2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4938      Y:0002F3 Y:0002F3                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4939      Y:0002F4 Y:0002F4                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4940      Y:0002F5 Y:0002F5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4941      Y:0002F6 Y:0002F6                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4942      Y:0002F7 Y:0002F7                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4943      Y:0002F8 Y:0002F8                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4944      Y:0002F9 Y:0002F9                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4945      Y:0002FA Y:0002FA                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4946      Y:0002FB Y:0002FB                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4947                                SXMIT_FG_2
4948      Y:0002FC Y:0002FC                   DC      $00F021                           ; Transmit A/D data to host
4949      Y:0002FD Y:0002FD                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4950      Y:0002FE Y:0002FE                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4951      Y:0002FF Y:0002FF                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4952      Y:000300 Y:000300                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4953      Y:000301 Y:000301                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4954      Y:000302 Y:000302                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4955      Y:000303 Y:000303                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4956                                END_SERIAL_READ_FG_2
4957   
4958                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4959                                SERIAL_READ_SPLIT_2
4960      Y:000304 Y:000304                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4961      Y:000305 Y:000305                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4962      Y:000306 Y:000306                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4963      Y:000307 Y:000307                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4964      Y:000308 Y:000308                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4965      Y:000309 Y:000309                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4966      Y:00030A Y:00030A                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4967      Y:00030B Y:00030B                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4968      Y:00030C Y:00030C                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4969      Y:00030D Y:00030D                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4970      Y:00030E Y:00030E                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 91



4971      Y:00030F Y:00030F                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4972                                SXMIT_SPLIT_2
4973      Y:000310 Y:000310                   DC      $00F020                           ; Transmit A/D data to host
4974      Y:000311 Y:000311                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4975      Y:000312 Y:000312                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4976      Y:000313 Y:000313                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4977      Y:000314 Y:000314                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4978      Y:000315 Y:000315                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4979      Y:000316 Y:000316                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4980      Y:000317 Y:000317                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4981                                END_SERIAL_READ_SPLIT_2
4982   
4983                                ;       Bin by 3 waveforms
4984                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4985                                SERIAL_READ_EH_3
4986      Y:000318 Y:000318                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4987      Y:000319 Y:000319                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4988      Y:00031A Y:00031A                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4989      Y:00031B Y:00031B                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4990      Y:00031C Y:00031C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4991      Y:00031D Y:00031D                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4992      Y:00031E Y:00031E                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4993      Y:00031F Y:00031F                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4994      Y:000320 Y:000320                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4995      Y:000321 Y:000321                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4996      Y:000322 Y:000322                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4997      Y:000323 Y:000323                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4998      Y:000324 Y:000324                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4999      Y:000325 Y:000325                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
5000      Y:000326 Y:000326                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
5001      Y:000327 Y:000327                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
5002      Y:000328 Y:000328                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
5003      Y:000329 Y:000329                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
5004                                SXMIT_EH_3
5005      Y:00032A Y:00032A                   DC      $00F000                           ; Transmit A/D data to host
5006      Y:00032B Y:00032B                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
5007      Y:00032C Y:00032C                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
5008      Y:00032D Y:00032D                   DC      VIDEO+INT_STOP                    ; Stop Integrate
5009      Y:00032E Y:00032E                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
5010      Y:00032F Y:00032F                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
5011      Y:000330 Y:000330                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
5012      Y:000331 Y:000331                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
5013                                END_SERIAL_READ_EH_3
5014   
5015                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
5016                                SERIAL_READ_FG_3
5017      Y:000332 Y:000332                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
5018      Y:000333 Y:000333                   DC      VIDEO+INT_INIT                    ; Change nearly everything
5019      Y:000334 Y:000334                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
5020      Y:000335 Y:000335                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
5021      Y:000336 Y:000336                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
5022      Y:000337 Y:000337                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
5023      Y:000338 Y:000338                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
5024      Y:000339 Y:000339                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
5025      Y:00033A Y:00033A                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
5026      Y:00033B Y:00033B                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
5027      Y:00033C Y:00033C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
5028      Y:00033D Y:00033D                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
5029      Y:00033E Y:00033E                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
5030      Y:00033F Y:00033F                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
5031      Y:000340 Y:000340                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
5032      Y:000341 Y:000341                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 92



5033      Y:000342 Y:000342                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
5034      Y:000343 Y:000343                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
5035                                SXMIT_FG_3
5036      Y:000344 Y:000344                   DC      $00F021                           ; Transmit A/D data to host
5037      Y:000345 Y:000345                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
5038      Y:000346 Y:000346                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
5039      Y:000347 Y:000347                   DC      VIDEO+INT_STOP                    ; Stop Integrate
5040      Y:000348 Y:000348                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
5041      Y:000349 Y:000349                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
5042      Y:00034A Y:00034A                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
5043      Y:00034B Y:00034B                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
5044                                END_SERIAL_READ_FG_3
5045   
5046                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
5047                                SERIAL_READ_SPLIT_3
5048      Y:00034C Y:00034C                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
5049      Y:00034D Y:00034D                   DC      VIDEO+INT_INIT                    ; Change nearly everything
5050      Y:00034E Y:00034E                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
5051      Y:00034F Y:00034F                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
5052      Y:000350 Y:000350                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
5053      Y:000351 Y:000351                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
5054      Y:000352 Y:000352                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
5055      Y:000353 Y:000353                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
5056      Y:000354 Y:000354                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
5057      Y:000355 Y:000355                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
5058      Y:000356 Y:000356                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
5059      Y:000357 Y:000357                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
5060      Y:000358 Y:000358                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
5061      Y:000359 Y:000359                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
5062      Y:00035A Y:00035A                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
5063      Y:00035B Y:00035B                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
5064      Y:00035C Y:00035C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
5065      Y:00035D Y:00035D                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
5066                                SXMIT_SPLIT_3
5067      Y:00035E Y:00035E                   DC      $00F020                           ; Transmit A/D data to host
5068      Y:00035F Y:00035F                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
5069      Y:000360 Y:000360                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
5070      Y:000361 Y:000361                   DC      VIDEO+INT_STOP                    ; Stop Integrate
5071      Y:000362 Y:000362                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
5072      Y:000363 Y:000363                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
5073      Y:000364 Y:000364                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
5074      Y:000365 Y:000365                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
5075                                END_SERIAL_READ_SPLIT_3
5076   
5077                                ;       Bin by 4 waveforms
5078                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
5079                                SERIAL_READ_EH_4
5080      Y:000366 Y:000366                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
5081      Y:000367 Y:000367                   DC      VIDEO+INT_INIT                    ; Change nearly everything
5082      Y:000368 Y:000368                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
5083      Y:000369 Y:000369                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
5084      Y:00036A Y:00036A                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
5085      Y:00036B Y:00036B                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
5086      Y:00036C Y:00036C                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
5087      Y:00036D Y:00036D                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
5088      Y:00036E Y:00036E                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
5089      Y:00036F Y:00036F                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
5090      Y:000370 Y:000370                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
5091      Y:000371 Y:000371                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
5092      Y:000372 Y:000372                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
5093      Y:000373 Y:000373                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
5094      Y:000374 Y:000374                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 93



5095      Y:000375 Y:000375                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
5096      Y:000376 Y:000376                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
5097      Y:000377 Y:000377                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
5098      Y:000378 Y:000378                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
5099      Y:000379 Y:000379                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
5100      Y:00037A Y:00037A                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
5101      Y:00037B Y:00037B                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
5102      Y:00037C Y:00037C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
5103      Y:00037D Y:00037D                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
5104                                SXMIT_EH_4
5105      Y:00037E Y:00037E                   DC      $00F000                           ; Transmit A/D data to host
5106      Y:00037F Y:00037F                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
5107      Y:000380 Y:000380                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
5108      Y:000381 Y:000381                   DC      VIDEO+INT_STOP                    ; Stop Integrate
5109      Y:000382 Y:000382                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
5110      Y:000383 Y:000383                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
5111      Y:000384 Y:000384                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
5112      Y:000385 Y:000385                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
5113                                END_SERIAL_READ_EH_4
5114   
5115                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
5116                                SERIAL_READ_FG_4
5117      Y:000386 Y:000386                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
5118      Y:000387 Y:000387                   DC      VIDEO+INT_INIT                    ; Change nearly everything
5119      Y:000388 Y:000388                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
5120      Y:000389 Y:000389                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
5121      Y:00038A Y:00038A                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
5122      Y:00038B Y:00038B                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
5123      Y:00038C Y:00038C                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
5124      Y:00038D Y:00038D                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
5125      Y:00038E Y:00038E                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
5126      Y:00038F Y:00038F                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
5127      Y:000390 Y:000390                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
5128      Y:000391 Y:000391                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
5129      Y:000392 Y:000392                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
5130      Y:000393 Y:000393                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
5131      Y:000394 Y:000394                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
5132      Y:000395 Y:000395                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
5133      Y:000396 Y:000396                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
5134      Y:000397 Y:000397                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
5135      Y:000398 Y:000398                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
5136      Y:000399 Y:000399                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
5137      Y:00039A Y:00039A                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
5138      Y:00039B Y:00039B                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
5139      Y:00039C Y:00039C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
5140      Y:00039D Y:00039D                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
5141                                SXMIT_FG_4
5142      Y:00039E Y:00039E                   DC      $00F021                           ; Transmit A/D data to host
5143      Y:00039F Y:00039F                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
5144      Y:0003A0 Y:0003A0                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
5145      Y:0003A1 Y:0003A1                   DC      VIDEO+INT_STOP                    ; Stop Integrate
5146      Y:0003A2 Y:0003A2                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
5147      Y:0003A3 Y:0003A3                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
5148      Y:0003A4 Y:0003A4                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
5149      Y:0003A5 Y:0003A5                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
5150                                END_SERIAL_READ_FG_4
5151   
5152                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
5153                                SERIAL_READ_SPLIT_4
5154      Y:0003A6 Y:0003A6                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
5155      Y:0003A7 Y:0003A7                   DC      VIDEO+INT_INIT                    ; Change nearly everything
5156      Y:0003A8 Y:0003A8                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
Motorola DSP56300 Assembler  Version 6.2.23   116-08-20  12:27:37  lmi.waveforms.s  Page 94



5157      Y:0003A9 Y:0003A9                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
5158      Y:0003AA Y:0003AA                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
5159      Y:0003AB Y:0003AB                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
5160      Y:0003AC Y:0003AC                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
5161      Y:0003AD Y:0003AD                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
5162      Y:0003AE Y:0003AE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
5163      Y:0003AF Y:0003AF                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
5164      Y:0003B0 Y:0003B0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
5165      Y:0003B1 Y:0003B1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
5166      Y:0003B2 Y:0003B2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
5167      Y:0003B3 Y:0003B3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
5168      Y:0003B4 Y:0003B4                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
5169      Y:0003B5 Y:0003B5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
5170      Y:0003B6 Y:0003B6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
5171      Y:0003B7 Y:0003B7                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
5172      Y:0003B8 Y:0003B8                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
5173      Y:0003B9 Y:0003B9                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
5174      Y:0003BA Y:0003BA                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
5175      Y:0003BB Y:0003BB                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
5176      Y:0003BC Y:0003BC                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
5177      Y:0003BD Y:0003BD                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
5178                                SXMIT_SPLIT_4
5179      Y:0003BE Y:0003BE                   DC      $00F020                           ; Transmit A/D data to host
5180      Y:0003BF Y:0003BF                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
5181      Y:0003C0 Y:0003C0                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
5182      Y:0003C1 Y:0003C1                   DC      VIDEO+INT_STOP                    ; Stop Integrate
5183      Y:0003C2 Y:0003C2                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
5184      Y:0003C3 Y:0003C3                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
5185      Y:0003C4 Y:0003C4                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
5186      Y:0003C5 Y:0003C5                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
5187                                END_SERIAL_READ_SPLIT_4
5188   
5189                                 END_APPLICATON_Y_MEMORY
5190      0003C6                              EQU     @LCV(L)
5191   
5192                                ;  End of program
5193                                          END

0    Errors
0    Warnings


