Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  tim.s  Page 1



1                          ; This file is used to generate DSP code for the Gen III ARC-22/32/47
2                          ;    board set.
3                          ;
4                          ; This file contains two subroutines and X and Y data areas.  The two
5                          ; subroutines are RDCCD (with secondary entry point RCCD1) and CLOCK.
6                          ; These need to be in fast P memory.  The boot code and tim.s are there.
7                          ; tim.s includes timmisc.s, timCCDmisc.s and the waveforms file at the
8                          ; end.
9      
10                                   PAGE    132                               ; Printronix page width - 132 columns
11     
12                         ; Include a header file that defines global parameters
13     
14                                   INCLUDE "timboot.s"
15                         ;  This file is used to generate boot DSP code for the Gen III 250 MHz fiber
16                         ;       optic timing board = ARC22 using a DSP56303 as its main processor.
17     
18                         ; Various addressing control registers
19        FFFFFB           BCR       EQU     $FFFFFB                           ; Bus Control Register
20        FFFFF9           AAR0      EQU     $FFFFF9                           ; Address Attribute Register, channel 0
21        FFFFF8           AAR1      EQU     $FFFFF8                           ; Address Attribute Register, channel 1
22        FFFFF7           AAR2      EQU     $FFFFF7                           ; Address Attribute Register, channel 2
23        FFFFF6           AAR3      EQU     $FFFFF6                           ; Address Attribute Register, channel 3
24        FFFFFD           PCTL      EQU     $FFFFFD                           ; PLL control register
25        FFFFFE           IPRP      EQU     $FFFFFE                           ; Interrupt Priority register - Peripheral
26        FFFFFF           IPRC      EQU     $FFFFFF                           ; Interrupt Priority register - Core
27     
28                         ; Port E is the Synchronous Communications Interface (SCI) port
29        FFFF9F           PCRE      EQU     $FFFF9F                           ; Port Control Register
30        FFFF9E           PRRE      EQU     $FFFF9E                           ; Port Direction Register
31        FFFF9D           PDRE      EQU     $FFFF9D                           ; Port Data Register
32        FFFF9C           SCR       EQU     $FFFF9C                           ; SCI Control Register
33        FFFF9B           SCCR      EQU     $FFFF9B                           ; SCI Clock Control Register
34     
35        FFFF9A           SRXH      EQU     $FFFF9A                           ; SCI Receive Data Register, High byte
36        FFFF99           SRXM      EQU     $FFFF99                           ; SCI Receive Data Register, Middle byte
37        FFFF98           SRXL      EQU     $FFFF98                           ; SCI Receive Data Register, Low byte
38     
39        FFFF97           STXH      EQU     $FFFF97                           ; SCI Transmit Data register, High byte
40        FFFF96           STXM      EQU     $FFFF96                           ; SCI Transmit Data register, Middle byte
41        FFFF95           STXL      EQU     $FFFF95                           ; SCI Transmit Data register, Low byte
42     
43        FFFF94           STXA      EQU     $FFFF94                           ; SCI Transmit Address Register
44        FFFF93           SSR       EQU     $FFFF93                           ; SCI Status Register
45     
46        000009           SCITE     EQU     9                                 ; X:SCR bit set to enable the SCI transmitter
47        000008           SCIRE     EQU     8                                 ; X:SCR bit set to enable the SCI receiver
48        000000           TRNE      EQU     0                                 ; This is set in X:SSR when the transmitter
49                                                                             ;  shift and data registers are both empty
50        000001           TDRE      EQU     1                                 ; This is set in X:SSR when the transmitter
51                                                                             ;  data register is empty
52        000002           RDRF      EQU     2                                 ; X:SSR bit set when receiver register is full
53        00000F           SELSCI    EQU     15                                ; 1 for SCI to backplane, 0 to front connector
54     
55     
56                         ; ESSI Flags
57        000006           TDE       EQU     6                                 ; Set when transmitter data register is empty
58        000007           RDF       EQU     7                                 ; Set when receiver is full of data
59        000010           TE        EQU     16                                ; Transmitter enable
60     
61                         ; Phase Locked Loop initialization
62        050003           PLL_INIT  EQU     $050003                           ; PLL = 25 MHz x 2 = 100 MHz
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 2



63     
64                         ; Port B general purpose I/O
65        FFFFC4           HPCR      EQU     $FFFFC4                           ; Control register (bits 1-6 cleared for GPIO)
66        FFFFC9           HDR       EQU     $FFFFC9                           ; Data register
67        FFFFC8           HDDR      EQU     $FFFFC8                           ; Data Direction Register bits (=1 for output)
68     
69                         ; Port C is Enhanced Synchronous Serial Port 0 = ESSI0
70        FFFFBF           PCRC      EQU     $FFFFBF                           ; Port C Control Register
71        FFFFBE           PRRC      EQU     $FFFFBE                           ; Port C Data direction Register
72        FFFFBD           PDRC      EQU     $FFFFBD                           ; Port C GPIO Data Register
73        FFFFBC           TX00      EQU     $FFFFBC                           ; Transmit Data Register #0
74        FFFFB8           RX0       EQU     $FFFFB8                           ; Receive data register
75        FFFFB7           SSISR0    EQU     $FFFFB7                           ; Status Register
76        FFFFB6           CRB0      EQU     $FFFFB6                           ; Control Register B
77        FFFFB5           CRA0      EQU     $FFFFB5                           ; Control Register A
78     
79                         ; Port D is Enhanced Synchronous Serial Port 1 = ESSI1
80        FFFFAF           PCRD      EQU     $FFFFAF                           ; Port D Control Register
81        FFFFAE           PRRD      EQU     $FFFFAE                           ; Port D Data direction Register
82        FFFFAD           PDRD      EQU     $FFFFAD                           ; Port D GPIO Data Register
83        FFFFAC           TX10      EQU     $FFFFAC                           ; Transmit Data Register 0
84        FFFFA7           SSISR1    EQU     $FFFFA7                           ; Status Register
85        FFFFA6           CRB1      EQU     $FFFFA6                           ; Control Register B
86        FFFFA5           CRA1      EQU     $FFFFA5                           ; Control Register A
87     
88                         ; Timer module addresses
89        FFFF8F           TCSR0     EQU     $FFFF8F                           ; Timer control and status register
90        FFFF8E           TLR0      EQU     $FFFF8E                           ; Timer load register = 0
91        FFFF8D           TCPR0     EQU     $FFFF8D                           ; Timer compare register = exposure time
92        FFFF8C           TCR0      EQU     $FFFF8C                           ; Timer count register = elapsed time
93        FFFF83           TPLR      EQU     $FFFF83                           ; Timer prescaler load register => milliseconds
94        FFFF82           TPCR      EQU     $FFFF82                           ; Timer prescaler count register
95        000000           TIM_BIT   EQU     0                                 ; Set to enable the timer
96        000009           TRM       EQU     9                                 ; Set to enable the timer preloading
97        000015           TCF       EQU     21                                ; Set when timer counter = compare register
98     
99                         ; Board specific addresses and constants
100       FFFFF1           RDFO      EQU     $FFFFF1                           ; Read incoming fiber optic data byte
101       FFFFF2           WRFO      EQU     $FFFFF2                           ; Write fiber optic data replies
102       FFFFF3           WRSS      EQU     $FFFFF3                           ; Write switch state
103       FFFFF5           WRLATCH   EQU     $FFFFF5                           ; Write to a latch
104       010000           RDAD      EQU     $010000                           ; Read A/D values into the DSP
105       000009           EF        EQU     9                                 ; Serial receiver empty flag
106    
107                        ; DSP port A bit equates
108       000000           PWROK     EQU     0                                 ; Power control board says power is OK
109       000001           LED1      EQU     1                                 ; Control one of two LEDs
110       000002           LVEN      EQU     2                                 ; Low voltage power enable
111       000003           HVEN      EQU     3                                 ; High voltage power enable
112       00000E           SSFHF     EQU     14                                ; Switch state FIFO half full flag
113       00000A           EXT_IN0   EQU     10                                ; External digital I/O to the timing board
114       00000B           EXT_IN1   EQU     11
115       00000C           EXT_OUT0  EQU     12
116       00000D           EXT_OUT1  EQU     13
117    
118                        ; Port D equate
119       000001           SSFEF     EQU     1                                 ; Switch state FIFO empty flag
120    
121                        ; Other equates
122       000002           WRENA     EQU     2                                 ; Enable writing to the EEPROM
123    
124                        ; Latch U25 bit equates
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 3



125       000000           CDAC      EQU     0                                 ; Clear the analog board DACs
126       000002           ENCK      EQU     2                                 ; Enable the clock outputs
127       000004           SHUTTER   EQU     4                                 ; Control the shutter
128       000005           TIM_U_RST EQU     5                                 ; Reset the utility board
129    
130                        ; Software status bits, defined at X:<STATUS = X:0
131       000000           ST_RCV    EQU     0                                 ; Set to indicate word is from SCI = utility board
132       000002           IDLMODE   EQU     2                                 ; Set if need to idle after readout
133       000003           ST_SHUT   EQU     3                                 ; Set to indicate shutter is closed, clear for open
134       000004           ST_RDC    EQU     4                                 ; Set if executing 'RDC' command - reading out
135       000005           SPLIT_S   EQU     5                                 ; Set if split serial
136       000006           SPLIT_P   EQU     6                                 ; Set if split parallel
137       000007           MPP       EQU     7                                 ; Set if parallels are in MPP mode
138       000008           NOT_CLR   EQU     8                                 ; Set if not to clear CCD before exposure
139       00000A           TST_IMG   EQU     10                                ; Set if controller is to generate a test image
140       00000B           SHUT      EQU     11                                ; Set if opening shutter at beginning of exposure
141       00000C           ST_DITH   EQU     12                                ; Set if to dither during exposure
142       00000D           ST_SYNC   EQU     13                                ; Set if starting exposure on SYNC = high signal
143       00000E           ST_CNRD   EQU     14                                ; Set if in continous readout mode
144       00000F           ST_DIRTY  EQU     15                                ; Set if waveform tables need to be updated
145       000010           ST_SA     EQU     16                                ; Set if in subarray readout mode
146    
147                        ; Address for the table containing the incoming SCI words
148       000400           SCI_TABLE EQU     $400
149    
150    
151                        ; Specify controller configuration bits of the X:STATUS word
152                        ;   to describe the software capabilities of this application file
153                        ; The bit is set (=1) if the capability is supported by the controller
154    
155    
156                                COMMENT *
157    
158                        BIT #'s         FUNCTION
159                        2,1,0           Video Processor
160                                                000     ARC41, CCD Rev. 3
161                                                001     CCD Gen I
162                                                010     ARC42, dual readout CCD
163                                                011     ARC44, 4-readout IR coadder
164                                                100     ARC45. dual readout CCD
165                                                101     ARC46 = 8-channel IR
166                                                110     ARC48 = 8 channel CCD
167                                                111     ARC47 = 4-channel CCD
168    
169                        4,3             Timing Board
170                                                00      ARC20, Rev. 4, Gen II
171                                                01      Gen I
172                                                10      ARC22, Gen III, 250 MHz
173    
174                        6,5             Utility Board
175                                                00      No utility board
176                                                01      ARC50
177    
178                        7               Shutter
179                                                0       No shutter support
180                                                1       Yes shutter support
181    
182                        9,8             Temperature readout
183                                                00      No temperature readout
184                                                01      Polynomial Diode calibration
185                                                10      Linear temperature sensor calibration
186    
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 4



187                        10              Subarray readout
188                                                0       Not supported
189                                                1       Yes supported
190    
191                        11              Binning
192                                                0       Not supported
193                                                1       Yes supported
194    
195                        12              Split-Serial readout
196                                                0       Not supported
197                                                1       Yes supported
198    
199                        13              Split-Parallel readout
200                                                0       Not supported
201                                                1       Yes supported
202    
203                        14              MPP = Inverted parallel clocks
204                                                0       Not supported
205                                                1       Yes supported
206    
207                        16,15           Clock Driver Board
208                                                00      ARC30 or ARC31
209                                                01      ARC32, CCD and IR
210                                                11      No clock driver board (Gen I)
211    
212                        19,18,17                Special implementations
213                                                000     Somewhere else
214                                                001     Mount Laguna Observatory
215                                                010     NGST Aladdin
216                                                xxx     Other
217                                *
218    
219                        CCDVIDREV3B
220       000000                     EQU     $000000                           ; CCD Video Processor Rev. 3
221       000000           ARC41     EQU     $000000
222       000001           VIDGENI   EQU     $000001                           ; CCD Video Processor Gen I
223       000002           IRREV4    EQU     $000002                           ; IR Video Processor Rev. 4
224       000002           ARC42     EQU     $000002
225       000003           COADDER   EQU     $000003                           ; IR Coadder
226       000003           ARC44     EQU     $000003
227       000004           CCDVIDREV5 EQU    $000004                           ; Differential input CCD video Rev. 5
228       000004           ARC45     EQU     $000004
229       000005           ARC46     EQU     $000005                           ; 8-channel IR video board
230       000006           ARC48     EQU     $000006                           ; 8-channel CCD video board
231       000007           ARC47     EQU     $000007                           ; 4-channel CCD video board
232       000000           TIMREV4   EQU     $000000                           ; Timing Revision 4 = 50 MHz
233       000000           ARC20     EQU     $000000
234       000008           TIMGENI   EQU     $000008                           ; Timing Gen I = 40 MHz
235       000010           TIMREV5   EQU     $000010                           ; Timing Revision 5 = 250 MHz
236       000010           ARC22     EQU     $000010
237       008000           ARC32     EQU     $008000                           ; CCD & IR clock driver board
238       000020           UTILREV3  EQU     $000020                           ; Utility Rev. 3 supported
239       000020           ARC50     EQU     $000020
240       000080           SHUTTER_CC EQU    $000080                           ; Shutter supported
241       000100           TEMP_POLY EQU     $000100                           ; Polynomial calibration
242                        TEMP_LINEAR
243       000200                     EQU     $000200                           ; Linear calibration
244       000400           SUBARRAY  EQU     $000400                           ; Subarray readout supported
245       000800           BINNING   EQU     $000800                           ; Binning supported
246                        SPLIT_SERIAL
247       001000                     EQU     $001000                           ; Split serial supported
248                        SPLIT_PARALLEL
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 5



249       002000                     EQU     $002000                           ; Split parallel supported
250       004000           MPP_CC    EQU     $004000                           ; Inverted clocks supported
251       018000           CLKDRVGENI EQU    $018000                           ; No clock driver board - Gen I
252       020000           MLO       EQU     $020000                           ; Set if Mount Laguna Observatory
253       040000           NGST      EQU     $040000                           ; NGST Aladdin implementation
254       100000           CONT_RD   EQU     $100000                           ; Continuous readout implemented
255    
256                        ; Special address for two words for the DSP to bootstrap code from the EEPROM
257                                  IF      @SCP("HOST","ROM")
264                                  ENDIF
265    
266                                  IF      @SCP("HOST","HOST")
267       P:000000 P:000000                   ORG     P:0,P:0
268       P:000000 P:000000 0C0190            JMP     <INIT
269       P:000001 P:000001 000000            NOP
270                                           ENDIF
271    
272                                 ;  This ISR receives serial words a byte at a time over the asynchronous
273                                 ;    serial link (SCI) and squashes them into a single 24-bit word
274       P:000002 P:000002 602400  SCI_RCV   MOVE              R0,X:<SAVE_R0           ; Save R0
275       P:000003 P:000003 052139            MOVEC             SR,X:<SAVE_SR           ; Save Status Register
276       P:000004 P:000004 60A700            MOVE              X:<SCI_R0,R0            ; Restore R0 = pointer to SCI receive regist
er
277       P:000005 P:000005 542300            MOVE              A1,X:<SAVE_A1           ; Save A1
278       P:000006 P:000006 452200            MOVE              X1,X:<SAVE_X1           ; Save X1
279       P:000007 P:000007 54A600            MOVE              X:<SCI_A1,A1            ; Get SRX value of accumulator contents
280       P:000008 P:000008 45E000            MOVE              X:(R0),X1               ; Get the SCI byte
281       P:000009 P:000009 0AD041            BCLR    #1,R0                             ; Test for the address being $FFF6 = last by
te
282       P:00000A P:00000A 000000            NOP
283       P:00000B P:00000B 000000            NOP
284       P:00000C P:00000C 000000            NOP
285       P:00000D P:00000D 205862            OR      X1,A      (R0)+                   ; Add the byte into the 24-bit word
286       P:00000E P:00000E 0E0013            JCC     <MID_BYT                          ; Not the last byte => only restore register
s
287       P:00000F P:00000F 545C00  END_BYT   MOVE              A1,X:(R4)+              ; Put the 24-bit word into the SCI buffer
288       P:000010 P:000010 60F400            MOVE              #SRXL,R0                ; Re-establish first address of SCI interfac
e
                            FFFF98
289       P:000012 P:000012 2C0000            MOVE              #0,A1                   ; For zeroing out SCI_A1
290       P:000013 P:000013 602700  MID_BYT   MOVE              R0,X:<SCI_R0            ; Save the SCI receiver address
291       P:000014 P:000014 542600            MOVE              A1,X:<SCI_A1            ; Save A1 for next interrupt
292       P:000015 P:000015 05A139            MOVEC             X:<SAVE_SR,SR           ; Restore Status Register
293       P:000016 P:000016 54A300            MOVE              X:<SAVE_A1,A1           ; Restore A1
294       P:000017 P:000017 45A200            MOVE              X:<SAVE_X1,X1           ; Restore X1
295       P:000018 P:000018 60A400            MOVE              X:<SAVE_R0,R0           ; Restore R0
296       P:000019 P:000019 000004            RTI                                       ; Return from interrupt service
297    
298                                 ; Clear error condition and interrupt on SCI receiver
299       P:00001A P:00001A 077013  CLR_ERR   MOVEP             X:SSR,X:RCV_ERR         ; Read SCI status register
                            000025
300       P:00001C P:00001C 077018            MOVEP             X:SRXL,X:RCV_ERR        ; This clears any error
                            000025
301       P:00001E P:00001E 000004            RTI
302    
303       P:00001F P:00001F                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
304       P:000030 P:000030                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
305       P:000040 P:000040                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
306    
307                                 ; Tune the table so the following instruction is at P:$50 exactly.
308       P:000050 P:000050 0D0002            JSR     SCI_RCV                           ; SCI receive data interrupt
309       P:000051 P:000051 000000            NOP
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 6



310       P:000052 P:000052 0D001A            JSR     CLR_ERR                           ; SCI receive error interrupt
311       P:000053 P:000053 000000            NOP
312    
313                                 ; *******************  Command Processing  ******************
314    
315                                 ; Read the header and check it for self-consistency
316       P:000054 P:000054 609F00  START     MOVE              X:<IDL_ADR,R0
317       P:000055 P:000055 018FA0            JSET    #TIM_BIT,X:TCSR0,EXPOSING         ; If exposing go check the timer
                            00005A
318       P:000057 P:000057 0A00A4            JSET    #ST_RDC,X:<STATUS,CONTINUE_READING
                            00005A
319       P:000059 P:000059 0AE080            JMP     (R0)
320    
321       P:00005A P:00005A 330700  TST_RCV   MOVE              #<COM_BUF,R3
322       P:00005B P:00005B 0D00A5            JSR     <GET_RCV
323       P:00005C P:00005C 0E005B            JCC     *-1
324    
325                                 ; Check the header and read all the remaining words in the command
326       P:00005D P:00005D 0C00FF  PRC_RCV   JMP     <CHK_HDR                          ; Update HEADER and NWORDS
327       P:00005E P:00005E 578600  PR_RCV    MOVE              X:<NWORDS,B             ; Read this many words total in the command
328       P:00005F P:00005F 000000            NOP
329       P:000060 P:000060 01418C            SUB     #1,B                              ; We've already read the header
330       P:000061 P:000061 000000            NOP
331       P:000062 P:000062 06CF00            DO      B,RD_COM
                            00006A
332       P:000064 P:000064 205B00            MOVE              (R3)+                   ; Increment past what's been read already
333       P:000065 P:000065 0B0080  GET_WRD   JSCLR   #ST_RCV,X:STATUS,CHK_FO
                            0000A9
334       P:000067 P:000067 0B00A0            JSSET   #ST_RCV,X:STATUS,CHK_SCI
                            0000D5
335       P:000069 P:000069 0E0065            JCC     <GET_WRD
336       P:00006A P:00006A 000000            NOP
337       P:00006B P:00006B 330700  RD_COM    MOVE              #<COM_BUF,R3            ; Restore R3 = beginning of the command
338    
339                                 ; Is this command for the timing board?
340       P:00006C P:00006C 448500            MOVE              X:<HEADER,X0
341       P:00006D P:00006D 579B00            MOVE              X:<DMASK,B
342       P:00006E P:00006E 459A4E            AND     X0,B      X:<TIM_DRB,X1           ; Extract destination byte
343       P:00006F P:00006F 20006D            CMP     X1,B                              ; Does header = timing board number?
344       P:000070 P:000070 0EA080            JEQ     <COMMAND                          ; Yes, process it here
345       P:000071 P:000071 0E909D            JLT     <FO_XMT                           ; Send it to fiber optic transmitter
346    
347                                 ; Transmit the command to the utility board over the SCI port
348       P:000072 P:000072 060600            DO      X:<NWORDS,DON_XMT                 ; Transmit NWORDS
                            00007E
349       P:000074 P:000074 60F400            MOVE              #STXL,R0                ; SCI first byte address
                            FFFF95
350       P:000076 P:000076 44DB00            MOVE              X:(R3)+,X0              ; Get the 24-bit word to transmit
351       P:000077 P:000077 060380            DO      #3,SCI_SPT
                            00007D
352       P:000079 P:000079 019381            JCLR    #TDRE,X:SSR,*                     ; Continue ONLY if SCI XMT is empty
                            000079
353       P:00007B P:00007B 445800            MOVE              X0,X:(R0)+              ; Write to SCI, byte pointer + 1
354       P:00007C P:00007C 000000            NOP                                       ; Delay for the status flag to be set
355       P:00007D P:00007D 000000            NOP
356                                 SCI_SPT
357       P:00007E P:00007E 000000            NOP
358                                 DON_XMT
359       P:00007F P:00007F 0C0054            JMP     <START
360    
361                                 ; Process the receiver entry - is it in the command table ?
362       P:000080 P:000080 0203DF  COMMAND   MOVE              X:(R3+1),B              ; Get the command
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 7



363       P:000081 P:000081 205B00            MOVE              (R3)+
364       P:000082 P:000082 205B00            MOVE              (R3)+                   ; Point R3 to the first argument
365       P:000083 P:000083 302800            MOVE              #<COM_TBL,R0            ; Get the command table starting address
366       P:000084 P:000084 062080            DO      #NUM_COM,END_COM                  ; Loop over the command table
                            00008B
367       P:000086 P:000086 47D800            MOVE              X:(R0)+,Y1              ; Get the command table entry
368       P:000087 P:000087 62E07D            CMP     Y1,B      X:(R0),R2               ; Does receiver = table entries address?
369       P:000088 P:000088 0E208B            JNE     <NOT_COM                          ; No, keep looping
370       P:000089 P:000089 00008C            ENDDO                                     ; Restore the DO loop system registers
371       P:00008A P:00008A 0AE280            JMP     (R2)                              ; Jump execution to the command
372       P:00008B P:00008B 205800  NOT_COM   MOVE              (R0)+                   ; Increment the register past the table addr
ess
373                                 END_COM
374       P:00008C P:00008C 0C008D            JMP     <ERROR                            ; The command is not in the table
375    
376                                 ; It's not in the command table - send an error message
377       P:00008D P:00008D 479D00  ERROR     MOVE              X:<ERR,Y1               ; Send the message - there was an error
378       P:00008E P:00008E 0C0090            JMP     <FINISH1                          ; This protects against unknown commands
379    
380                                 ; Send a reply packet - header and reply
381       P:00008F P:00008F 479800  FINISH    MOVE              X:<DONE,Y1              ; Send 'DON' as the reply
382       P:000090 P:000090 578500  FINISH1   MOVE              X:<HEADER,B             ; Get header of incoming command
383       P:000091 P:000091 469C00            MOVE              X:<SMASK,Y0             ; This was the source byte, and is to
384       P:000092 P:000092 330700            MOVE              #<COM_BUF,R3            ;     become the destination byte
385       P:000093 P:000093 46935E            AND     Y0,B      X:<TWO,Y0
386       P:000094 P:000094 0C1ED1            LSR     #8,B                              ; Shift right eight bytes, add it to the
387       P:000095 P:000095 460600            MOVE              Y0,X:<NWORDS            ;     header, and put 2 as the number
388       P:000096 P:000096 469958            ADD     Y0,B      X:<SBRD,Y0              ;     of words in the string
389       P:000097 P:000097 200058            ADD     Y0,B                              ; Add source board's header, set Y1 for abov
e
390       P:000098 P:000098 000000            NOP
391       P:000099 P:000099 575B00            MOVE              B,X:(R3)+               ; Put the new header on the transmitter stac
k
392       P:00009A P:00009A 475B00            MOVE              Y1,X:(R3)+              ; Put the argument on the transmitter stack
393       P:00009B P:00009B 570500            MOVE              B,X:<HEADER
394       P:00009C P:00009C 0C006B            JMP     <RD_COM                           ; Decide where to send the reply, and do it
395    
396                                 ; Transmit words to the host computer over the fiber optics link
397       P:00009D P:00009D 63F400  FO_XMT    MOVE              #COM_BUF,R3
                            000007
398       P:00009F P:00009F 060600            DO      X:<NWORDS,DON_FFO                 ; Transmit all the words in the command
                            0000A3
399       P:0000A1 P:0000A1 57DB00            MOVE              X:(R3)+,B
400       P:0000A2 P:0000A2 0D00EB            JSR     <XMT_WRD
401       P:0000A3 P:0000A3 000000            NOP
402       P:0000A4 P:0000A4 0C0054  DON_FFO   JMP     <START
403    
404                                 ; Check for commands from the fiber optic FIFO and the utility board (SCI)
405       P:0000A5 P:0000A5 0D00A9  GET_RCV   JSR     <CHK_FO                           ; Check for fiber optic command from FIFO
406       P:0000A6 P:0000A6 0E80A8            JCS     <RCV_RTS                          ; If there's a command, check the header
407       P:0000A7 P:0000A7 0D00D5            JSR     <CHK_SCI                          ; Check for an SCI command
408       P:0000A8 P:0000A8 00000C  RCV_RTS   RTS
409    
410                                 ; Because of FIFO metastability require that EF be stable for two tests
411       P:0000A9 P:0000A9 0A8989  CHK_FO    JCLR    #EF,X:HDR,TST2                    ; EF = Low,  Low  => CLR SR, return
                            0000AC
412       P:0000AB P:0000AB 0C00AF            JMP     <TST3                             ;      High, Low  => try again
413       P:0000AC P:0000AC 0A8989  TST2      JCLR    #EF,X:HDR,CLR_CC                  ;      Low,  High => try again
                            0000D1
414       P:0000AE P:0000AE 0C00A9            JMP     <CHK_FO                           ;      High, High => read FIFO
415       P:0000AF P:0000AF 0A8989  TST3      JCLR    #EF,X:HDR,CHK_FO
                            0000A9
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 8



416    
417       P:0000B1 P:0000B1 08F4BB            MOVEP             #$028FE2,X:BCR          ; Slow down RDFO access
                            028FE2
418       P:0000B3 P:0000B3 000000            NOP
419       P:0000B4 P:0000B4 000000            NOP
420       P:0000B5 P:0000B5 5FF000            MOVE                          Y:RDFO,B
                            FFFFF1
421       P:0000B7 P:0000B7 2B0000            MOVE              #0,B2
422       P:0000B8 P:0000B8 0140CE            AND     #$FF,B
                            0000FF
423       P:0000BA P:0000BA 0140CD            CMP     #>$AC,B                           ; It must be $AC to be a valid word
                            0000AC
424       P:0000BC P:0000BC 0E20D1            JNE     <CLR_CC
425       P:0000BD P:0000BD 4EF000            MOVE                          Y:RDFO,Y0   ; Read the MS byte
                            FFFFF1
426       P:0000BF P:0000BF 0C1951            INSERT  #$008010,Y0,B
                            008010
427       P:0000C1 P:0000C1 4EF000            MOVE                          Y:RDFO,Y0   ; Read the middle byte
                            FFFFF1
428       P:0000C3 P:0000C3 0C1951            INSERT  #$008008,Y0,B
                            008008
429       P:0000C5 P:0000C5 4EF000            MOVE                          Y:RDFO,Y0   ; Read the LS byte
                            FFFFF1
430       P:0000C7 P:0000C7 0C1951            INSERT  #$008000,Y0,B
                            008000
431       P:0000C9 P:0000C9 000000            NOP
432       P:0000CA P:0000CA 516300            MOVE              B0,X:(R3)               ; Put the word into COM_BUF
433       P:0000CB P:0000CB 0A0000            BCLR    #ST_RCV,X:<STATUS                 ; Its a command from the host computer
434       P:0000CC P:0000CC 000000  SET_CC    NOP
435       P:0000CD P:0000CD 0AF960            BSET    #0,SR                             ; Valid word => SR carry bit = 1
436       P:0000CE P:0000CE 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
437       P:0000D0 P:0000D0 00000C            RTS
438       P:0000D1 P:0000D1 0AF940  CLR_CC    BCLR    #0,SR                             ; Not valid word => SR carry bit = 0
439       P:0000D2 P:0000D2 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
440       P:0000D4 P:0000D4 00000C            RTS
441    
442                                 ; Test the SCI (= synchronous communications interface) for new words
443       P:0000D5 P:0000D5 44F000  CHK_SCI   MOVE              X:(SCI_TABLE+33),X0
                            000421
444       P:0000D7 P:0000D7 228E00            MOVE              R4,A
445       P:0000D8 P:0000D8 209000            MOVE              X0,R0
446       P:0000D9 P:0000D9 200045            CMP     X0,A
447       P:0000DA P:0000DA 0EA0D1            JEQ     <CLR_CC                           ; There is no new SCI word
448       P:0000DB P:0000DB 44D800            MOVE              X:(R0)+,X0
449       P:0000DC P:0000DC 446300            MOVE              X0,X:(R3)
450       P:0000DD P:0000DD 220E00            MOVE              R0,A
451       P:0000DE P:0000DE 0140C5            CMP     #(SCI_TABLE+32),A                 ; Wrap it around the circular
                            000420
452       P:0000E0 P:0000E0 0EA0E4            JEQ     <INIT_PROCESSED_SCI               ;   buffer boundary
453       P:0000E1 P:0000E1 547000            MOVE              A1,X:(SCI_TABLE+33)
                            000421
454       P:0000E3 P:0000E3 0C00E9            JMP     <SCI_END
455                                 INIT_PROCESSED_SCI
456       P:0000E4 P:0000E4 56F400            MOVE              #SCI_TABLE,A
                            000400
457       P:0000E6 P:0000E6 000000            NOP
458       P:0000E7 P:0000E7 567000            MOVE              A,X:(SCI_TABLE+33)
                            000421
459       P:0000E9 P:0000E9 0A0020  SCI_END   BSET    #ST_RCV,X:<STATUS                 ; Its a utility board (SCI) word
460       P:0000EA P:0000EA 0C00CC            JMP     <SET_CC
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 9



461    
462                                 ; Transmit the word in B1 to the host computer over the fiber optic data link
463                                 XMT_WRD
464       P:0000EB P:0000EB 08F4BB            MOVEP             #$028FE2,X:BCR          ; Slow down RDFO access
                            028FE2
465       P:0000ED P:0000ED 60F400            MOVE              #FO_HDR+1,R0
                            000002
466       P:0000EF P:0000EF 060380            DO      #3,XMT_WRD1
                            0000F3
467       P:0000F1 P:0000F1 0C1D91            ASL     #8,B,B
468       P:0000F2 P:0000F2 000000            NOP
469       P:0000F3 P:0000F3 535800            MOVE              B2,X:(R0)+
470                                 XMT_WRD1
471       P:0000F4 P:0000F4 60F400            MOVE              #FO_HDR,R0
                            000001
472       P:0000F6 P:0000F6 61F400            MOVE              #WRFO,R1
                            FFFFF2
473       P:0000F8 P:0000F8 060480            DO      #4,XMT_WRD2
                            0000FB
474       P:0000FA P:0000FA 46D800            MOVE              X:(R0)+,Y0              ; Should be MOVEP  X:(R0)+,Y:WRFO
475       P:0000FB P:0000FB 4E6100            MOVE                          Y0,Y:(R1)
476                                 XMT_WRD2
477       P:0000FC P:0000FC 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
478       P:0000FE P:0000FE 00000C            RTS
479    
480                                 ; Check the command or reply header in X:(R3) for self-consistency
481       P:0000FF P:0000FF 46E300  CHK_HDR   MOVE              X:(R3),Y0
482       P:000100 P:000100 579600            MOVE              X:<MASK1,B              ; Test for S.LE.3 and D.LE.3 and N.LE.7
483       P:000101 P:000101 20005E            AND     Y0,B
484       P:000102 P:000102 0E208D            JNE     <ERROR                            ; Test failed
485       P:000103 P:000103 579700            MOVE              X:<MASK2,B              ; Test for either S.NE.0 or D.NE.0
486       P:000104 P:000104 20005E            AND     Y0,B
487       P:000105 P:000105 0EA08D            JEQ     <ERROR                            ; Test failed
488       P:000106 P:000106 579500            MOVE              X:<SEVEN,B
489       P:000107 P:000107 20005E            AND     Y0,B                              ; Extract NWORDS, must be > 0
490       P:000108 P:000108 0EA08D            JEQ     <ERROR
491       P:000109 P:000109 44E300            MOVE              X:(R3),X0
492       P:00010A P:00010A 440500            MOVE              X0,X:<HEADER            ; Its a correct header
493       P:00010B P:00010B 550600            MOVE              B1,X:<NWORDS            ; Number of words in the command
494       P:00010C P:00010C 0C005E            JMP     <PR_RCV
495    
496                                 ;  *****************  Boot Commands  *******************
497    
498                                 ; Test Data Link - simply return value received after 'TDL'
499       P:00010D P:00010D 47DB00  TDL       MOVE              X:(R3)+,Y1              ; Get the data value
500       P:00010E P:00010E 0C0090            JMP     <FINISH1                          ; Return from executing TDL command
501    
502                                 ; Read DSP or EEPROM memory ('RDM' address): read memory, reply with value
503       P:00010F P:00010F 47DB00  RDMEM     MOVE              X:(R3)+,Y1
504       P:000110 P:000110 20EF00            MOVE              Y1,B
505       P:000111 P:000111 0140CE            AND     #$0FFFFF,B                        ; Bits 23-20 need to be zeroed
                            0FFFFF
506       P:000113 P:000113 21B000            MOVE              B1,R0                   ; Need the address in an address register
507       P:000114 P:000114 20EF00            MOVE              Y1,B
508       P:000115 P:000115 000000            NOP
509       P:000116 P:000116 0ACF14            JCLR    #20,B,RDX                         ; Test address bit for Program memory
                            00011A
510       P:000118 P:000118 07E087            MOVE              P:(R0),Y1               ; Read from Program Memory
511       P:000119 P:000119 0C0090            JMP     <FINISH1                          ; Send out a header with the value
512       P:00011A P:00011A 0ACF15  RDX       JCLR    #21,B,RDY                         ; Test address bit for X: memory
                            00011E
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 10



513       P:00011C P:00011C 47E000            MOVE              X:(R0),Y1               ; Write to X data memory
514       P:00011D P:00011D 0C0090            JMP     <FINISH1                          ; Send out a header with the value
515       P:00011E P:00011E 0ACF16  RDY       JCLR    #22,B,RDR                         ; Test address bit for Y: memory
                            000122
516       P:000120 P:000120 4FE000            MOVE                          Y:(R0),Y1   ; Read from Y data memory
517       P:000121 P:000121 0C0090            JMP     <FINISH1                          ; Send out a header with the value
518       P:000122 P:000122 0ACF17  RDR       JCLR    #23,B,ERROR                       ; Test address bit for read from EEPROM memo
ry
                            00008D
519       P:000124 P:000124 479400            MOVE              X:<THREE,Y1             ; Convert to word address to a byte address
520       P:000125 P:000125 220600            MOVE              R0,Y0                   ; Get 16-bit address in a data register
521       P:000126 P:000126 2000B8            MPY     Y0,Y1,B                           ; Multiply
522       P:000127 P:000127 20002A            ASR     B                                 ; Eliminate zero fill of fractional multiply
523       P:000128 P:000128 213000            MOVE              B0,R0                   ; Need to address memory
524       P:000129 P:000129 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
525       P:00012A P:00012A 0D0178            JSR     <RD_WORD                          ; Read word from EEPROM
526       P:00012B P:00012B 21A700            MOVE              B1,Y1                   ; FINISH1 transmits Y1 as its reply
527       P:00012C P:00012C 0C0090            JMP     <FINISH1
528    
529                                 ; Program WRMEM ('WRM' address datum): write to memory, reply 'DON'.
530       P:00012D P:00012D 47DB00  WRMEM     MOVE              X:(R3)+,Y1              ; Get the address to be written to
531       P:00012E P:00012E 20EF00            MOVE              Y1,B
532       P:00012F P:00012F 0140CE            AND     #$0FFFFF,B                        ; Bits 23-20 need to be zeroed
                            0FFFFF
533       P:000131 P:000131 21B000            MOVE              B1,R0                   ; Need the address in an address register
534       P:000132 P:000132 20EF00            MOVE              Y1,B
535       P:000133 P:000133 46DB00            MOVE              X:(R3)+,Y0              ; Get datum into Y0 so MOVE works easily
536       P:000134 P:000134 0ACF14            JCLR    #20,B,WRX                         ; Test address bit for Program memory
                            000138
537       P:000136 P:000136 076086            MOVE              Y0,P:(R0)               ; Write to Program memory
538       P:000137 P:000137 0C008F            JMP     <FINISH
539       P:000138 P:000138 0ACF15  WRX       JCLR    #21,B,WRY                         ; Test address bit for X: memory
                            00013C
540       P:00013A P:00013A 466000            MOVE              Y0,X:(R0)               ; Write to X: memory
541       P:00013B P:00013B 0C008F            JMP     <FINISH
542       P:00013C P:00013C 0ACF16  WRY       JCLR    #22,B,WRR                         ; Test address bit for Y: memory
                            000140
543       P:00013E P:00013E 4E6000            MOVE                          Y0,Y:(R0)   ; Write to Y: memory
544       P:00013F P:00013F 0C008F            JMP     <FINISH
545       P:000140 P:000140 0ACF17  WRR       JCLR    #23,B,ERROR                       ; Test address bit for write to EEPROM
                            00008D
546       P:000142 P:000142 013D02            BCLR    #WRENA,X:PDRC                     ; WR_ENA* = 0 to enable EEPROM writing
547       P:000143 P:000143 460E00            MOVE              Y0,X:<SV_A1             ; Save the datum to be written
548       P:000144 P:000144 479400            MOVE              X:<THREE,Y1             ; Convert word address to a byte address
549       P:000145 P:000145 220600            MOVE              R0,Y0                   ; Get 16-bit address in a data register
550       P:000146 P:000146 2000B8            MPY     Y1,Y0,B                           ; Multiply
551       P:000147 P:000147 20002A            ASR     B                                 ; Eliminate zero fill of fractional multiply
552       P:000148 P:000148 213000            MOVE              B0,R0                   ; Need to address memory
553       P:000149 P:000149 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
554       P:00014A P:00014A 558E00            MOVE              X:<SV_A1,B1             ; Get the datum to be written
555       P:00014B P:00014B 060380            DO      #3,L1WRR                          ; Loop over three bytes of the word
                            000154
556       P:00014D P:00014D 07588D            MOVE              B1,P:(R0)+              ; Write each EEPROM byte
557       P:00014E P:00014E 0C1C91            ASR     #8,B,B
558       P:00014F P:00014F 469E00            MOVE              X:<C100K,Y0             ; Move right one byte, enter delay = 1 msec
559       P:000150 P:000150 06C600            DO      Y0,L2WRR                          ; Delay by 12 milliseconds for EEPROM write
                            000153
560       P:000152 P:000152 060CA0            REP     #12                               ; Assume 100 MHz DSP56303
561       P:000153 P:000153 000000            NOP
562                                 L2WRR
563       P:000154 P:000154 000000            NOP                                       ; DO loop nesting restriction
564                                 L1WRR
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 11



565       P:000155 P:000155 013D22            BSET    #WRENA,X:PDRC                     ; WR_ENA* = 1 to disable EEPROM writing
566       P:000156 P:000156 0C008F            JMP     <FINISH
567    
568                                 ; Load application code from P: memory into its proper locations
569       P:000157 P:000157 47DB00  LDAPPL    MOVE              X:(R3)+,Y1              ; Application number, not used yet
570       P:000158 P:000158 0D015A            JSR     <LOAD_APPLICATION
571       P:000159 P:000159 0C008F            JMP     <FINISH
572    
573                                 LOAD_APPLICATION
574       P:00015A P:00015A 60F400            MOVE              #$8000,R0               ; Starting EEPROM address
                            008000
575       P:00015C P:00015C 0D0178            JSR     <RD_WORD                          ; Number of words in boot code
576       P:00015D P:00015D 21A600            MOVE              B1,Y0
577       P:00015E P:00015E 479400            MOVE              X:<THREE,Y1
578       P:00015F P:00015F 2000B8            MPY     Y0,Y1,B
579       P:000160 P:000160 20002A            ASR     B
580       P:000161 P:000161 213000            MOVE              B0,R0                   ; EEPROM address of start of P: application
581       P:000162 P:000162 0AD06F            BSET    #15,R0                            ; To access EEPROM
582       P:000163 P:000163 0D0178            JSR     <RD_WORD                          ; Read number of words in application P:
583       P:000164 P:000164 61F400            MOVE              #(X_BOOT_START+1),R1    ; End of boot P: code that needs keeping
                            00022B
584       P:000166 P:000166 06CD00            DO      B1,RD_APPL_P
                            000169
585       P:000168 P:000168 0D0178            JSR     <RD_WORD
586       P:000169 P:000169 07598D            MOVE              B1,P:(R1)+
587                                 RD_APPL_P
588       P:00016A P:00016A 0D0178            JSR     <RD_WORD                          ; Read number of words in application X:
589       P:00016B P:00016B 61F400            MOVE              #END_COMMAND_TABLE,R1
                            000036
590       P:00016D P:00016D 06CD00            DO      B1,RD_APPL_X
                            000170
591       P:00016F P:00016F 0D0178            JSR     <RD_WORD
592       P:000170 P:000170 555900            MOVE              B1,X:(R1)+
593                                 RD_APPL_X
594       P:000171 P:000171 0D0178            JSR     <RD_WORD                          ; Read number of words in application Y:
595       P:000172 P:000172 310100            MOVE              #1,R1                   ; There is no Y: memory in the boot code
596       P:000173 P:000173 06CD00            DO      B1,RD_APPL_Y
                            000176
597       P:000175 P:000175 0D0178            JSR     <RD_WORD
598       P:000176 P:000176 5D5900            MOVE                          B1,Y:(R1)+
599                                 RD_APPL_Y
600       P:000177 P:000177 00000C            RTS
601    
602                                 ; Read one word from EEPROM location R0 into accumulator B1
603       P:000178 P:000178 060380  RD_WORD   DO      #3,L_RDBYTE
                            00017B
604       P:00017A P:00017A 07D88B            MOVE              P:(R0)+,B2
605       P:00017B P:00017B 0C1C91            ASR     #8,B,B
606                                 L_RDBYTE
607       P:00017C P:00017C 00000C            RTS
608    
609                                 ; Come to here on a 'STP' command so 'DON' can be sent
610                                 STOP_IDLE_CLOCKING
611       P:00017D P:00017D 305A00            MOVE              #<TST_RCV,R0            ; Execution address when idle => when not
612       P:00017E P:00017E 601F00            MOVE              R0,X:<IDL_ADR           ;   processing commands or reading out
613       P:00017F P:00017F 0A0002            BCLR    #IDLMODE,X:<STATUS                ; Don't idle after readout
614       P:000180 P:000180 0C008F            JMP     <FINISH
615    
616                                 ; Routines executed after the DSP boots and initializes
617       P:000181 P:000181 305A00  STARTUP   MOVE              #<TST_RCV,R0            ; Execution address when idle => when not
618       P:000182 P:000182 601F00            MOVE              R0,X:<IDL_ADR           ;   processing commands or reading out
619       P:000183 P:000183 44F400            MOVE              #50000,X0               ; Delay by 500 milliseconds
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 12



                            00C350
620       P:000185 P:000185 06C400            DO      X0,L_DELAY
                            000188
621       P:000187 P:000187 06E8A3            REP     #1000
622       P:000188 P:000188 000000            NOP
623                                 L_DELAY
624       P:000189 P:000189 57F400            MOVE              #$020002,B              ; Normal reply after booting is 'SYR'
                            020002
625       P:00018B P:00018B 0D00EB            JSR     <XMT_WRD
626       P:00018C P:00018C 57F400            MOVE              #'SYR',B
                            535952
627       P:00018E P:00018E 0D00EB            JSR     <XMT_WRD
628    
629       P:00018F P:00018F 0C0054            JMP     <START                            ; Start normal command processing
630    
631                                 ; *******************  DSP  INITIALIZATION  CODE  **********************
632                                 ; This code initializes the DSP right after booting, and is overwritten
633                                 ;   by application code
634       P:000190 P:000190 08F4BD  INIT      MOVEP             #PLL_INIT,X:PCTL        ; Initialize PLL to 100 MHz
                            050003
635       P:000192 P:000192 000000            NOP
636    
637                                 ; Set operation mode register OMR to normal expanded
638       P:000193 P:000193 0500BA            MOVEC             #$0000,OMR              ; Operating Mode Register = Normal Expanded
639       P:000194 P:000194 0500BB            MOVEC             #0,SP                   ; Reset the Stack Pointer SP
640    
641                                 ; Program the AA = address attribute pins
642       P:000195 P:000195 08F4B9            MOVEP             #$FFFC21,X:AAR0         ; Y = $FFF000 to $FFFFFF asserts commands
                            FFFC21
643       P:000197 P:000197 08F4B8            MOVEP             #$008909,X:AAR1         ; P = $008000 to $00FFFF accesses the EEPROM
                            008909
644       P:000199 P:000199 08F4B7            MOVEP             #$010C11,X:AAR2         ; X = $010000 to $010FFF reads A/D values
                            010C11
645       P:00019B P:00019B 08F4B6            MOVEP             #$080621,X:AAR3         ; Y = $080000 to $0BFFFF R/W from SRAM
                            080621
646    
647       P:00019D P:00019D 0A0F00            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
648       P:00019E P:00019E 0A0F02            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
649       P:00019F P:00019F 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                            00000F
650    
651                                 ; Program the DRAM memory access and addressing
652       P:0001A1 P:0001A1 08F4BB            MOVEP             #$028FE1,X:BCR          ; Bus Control Register
                            028FE1
653    
654                                 ; Program the Host port B for parallel I/O
655       P:0001A3 P:0001A3 08F484            MOVEP             #>1,X:HPCR              ; All pins enabled as GPIO
                            000001
656       P:0001A5 P:0001A5 08F489            MOVEP             #$810C,X:HDR
                            00810C
657       P:0001A7 P:0001A7 08F488            MOVEP             #$B10E,X:HDDR           ; Data Direction Register
                            00B10E
658                                                                                     ;  (1 for Output, 0 for Input)
659    
660                                 ; Port B conversion from software bits to schematic labels
661                                 ;       PB0 = PWROK             PB08 = PRSFIFO*
662                                 ;       PB1 = LED1              PB09 = EF*
663                                 ;       PB2 = LVEN              PB10 = EXT-IN0
664                                 ;       PB3 = HVEN              PB11 = EXT-IN1
665                                 ;       PB4 = STATUS0           PB12 = EXT-OUT0
666                                 ;       PB5 = STATUS1           PB13 = EXT-OUT1
667                                 ;       PB6 = STATUS2           PB14 = SSFHF*
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 13



668                                 ;       PB7 = STATUS3           PB15 = SELSCI
669    
670                                 ; Program the serial port ESSI0 = Port C for serial communication with
671                                 ;   the utility board
672       P:0001A9 P:0001A9 07F43F            MOVEP             #>0,X:PCRC              ; Software reset of ESSI0
                            000000
673       P:0001AB P:0001AB 07F435            MOVEP             #$180809,X:CRA0         ; Divide 100 MHz by 20 to get 5.0 MHz
                            180809
674                                                                                     ; DC[4:0] = 0 for non-network operation
675                                                                                     ; WL0-WL2 = 3 for 24-bit data words
676                                                                                     ; SSC1 = 0 for SC1 not used
677       P:0001AD P:0001AD 07F436            MOVEP             #$020020,X:CRB0         ; SCKD = 1 for internally generated clock
                            020020
678                                                                                     ; SCD2 = 0 so frame sync SC2 is an output
679                                                                                     ; SHFD = 0 for MSB shifted first
680                                                                                     ; FSL = 0, frame sync length not used
681                                                                                     ; CKP = 0 for rising clock edge transitions
682                                                                                     ; SYN = 0 for asynchronous
683                                                                                     ; TE0 = 1 to enable transmitter #0
684                                                                                     ; MOD = 0 for normal, non-networked mode
685                                                                                     ; TE0 = 0 to NOT enable transmitter #0 yet
686                                                                                     ; RE = 1 to enable receiver
687       P:0001AF P:0001AF 07F43F            MOVEP             #%111001,X:PCRC         ; Control Register (0 for GPIO, 1 for ESSI)
                            000039
688       P:0001B1 P:0001B1 07F43E            MOVEP             #%000110,X:PRRC         ; Data Direction Register (0 for In, 1 for O
ut)
                            000006
689       P:0001B3 P:0001B3 07F43D            MOVEP             #%000100,X:PDRC         ; Data Register - WR_ENA* = 1
                            000004
690    
691                                 ; Port C version = Analog boards
692                                 ;       MOVEP   #$000809,X:CRA0 ; Divide 100 MHz by 20 to get 5.0 MHz
693                                 ;       MOVEP   #$000030,X:CRB0 ; SCKD = 1 for internally generated clock
694                                 ;       MOVEP   #%100000,X:PCRC ; Control Register (0 for GPIO, 1 for ESSI)
695                                 ;       MOVEP   #%000100,X:PRRC ; Data Direction Register (0 for In, 1 for Out)
696                                 ;       MOVEP   #%000000,X:PDRC ; Data Register: 'not used' = 0 outputs
697    
698       P:0001B5 P:0001B5 07F43C            MOVEP             #0,X:TX00               ; Initialize the transmitter to zero
                            000000
699       P:0001B7 P:0001B7 000000            NOP
700       P:0001B8 P:0001B8 000000            NOP
701       P:0001B9 P:0001B9 013630            BSET    #TE,X:CRB0                        ; Enable the SSI transmitter
702    
703                                 ; Conversion from software bits to schematic labels for Port C
704                                 ;       PC0 = SC00 = UTL-T-SCK
705                                 ;       PC1 = SC01 = 2_XMT = SYNC on prototype
706                                 ;       PC2 = SC02 = WR_ENA*
707                                 ;       PC3 = SCK0 = TIM-U-SCK
708                                 ;       PC4 = SRD0 = UTL-T-STD
709                                 ;       PC5 = STD0 = TIM-U-STD
710    
711                                 ; Program the serial port ESSI1 = Port D for serial transmission to
712                                 ;   the analog boards and two parallel I/O input pins
713       P:0001BA P:0001BA 07F42F            MOVEP             #>0,X:PCRD              ; Software reset of ESSI0
                            000000
714       P:0001BC P:0001BC 07F425            MOVEP             #$000809,X:CRA1         ; Divide 100 MHz by 20 to get 5.0 MHz
                            000809
715                                                                                     ; DC[4:0] = 0
716                                                                                     ; WL[2:0] = ALC = 0 for 8-bit data words
717                                                                                     ; SSC1 = 0 for SC1 not used
718       P:0001BE P:0001BE 07F426            MOVEP             #$000030,X:CRB1         ; SCKD = 1 for internally generated clock
                            000030
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 14



719                                                                                     ; SCD2 = 1 so frame sync SC2 is an output
720                                                                                     ; SHFD = 0 for MSB shifted first
721                                                                                     ; CKP = 0 for rising clock edge transitions
722                                                                                     ; TE0 = 0 to NOT enable transmitter #0 yet
723                                                                                     ; MOD = 0 so its not networked mode
724       P:0001C0 P:0001C0 07F42F            MOVEP             #%100000,X:PCRD         ; Control Register (0 for GPIO, 1 for ESSI)
                            000020
725                                                                                     ; PD3 = SCK1, PD5 = STD1 for ESSI
726       P:0001C2 P:0001C2 07F42E            MOVEP             #%000100,X:PRRD         ; Data Direction Register (0 for In, 1 for O
ut)
                            000004
727       P:0001C4 P:0001C4 07F42D            MOVEP             #%000100,X:PDRD         ; Data Register: 'not used' = 0 outputs
                            000004
728       P:0001C6 P:0001C6 07F42C            MOVEP             #0,X:TX10               ; Initialize the transmitter to zero
                            000000
729       P:0001C8 P:0001C8 000000            NOP
730       P:0001C9 P:0001C9 000000            NOP
731       P:0001CA P:0001CA 012630            BSET    #TE,X:CRB1                        ; Enable the SSI transmitter
732    
733                                 ; Conversion from software bits to schematic labels for Port D
734                                 ; PD0 = SC10 = 2_XMT_? input
735                                 ; PD1 = SC11 = SSFEF* input
736                                 ; PD2 = SC12 = PWR_EN
737                                 ; PD3 = SCK1 = TIM-A-SCK
738                                 ; PD4 = SRD1 = PWRRST
739                                 ; PD5 = STD1 = TIM-A-STD
740    
741                                 ; Program the SCI port to communicate with the utility board
742       P:0001CB P:0001CB 07F41C            MOVEP             #$0B04,X:SCR            ; SCI programming: 11-bit asynchronous
                            000B04
743                                                                                     ;   protocol (1 start, 8 data, 1 even parity
,
744                                                                                     ;   1 stop); LSB before MSB; enable receiver
745                                                                                     ;   and its interrupts; transmitter interrup
ts
746                                                                                     ;   disabled.
747       P:0001CD P:0001CD 07F41B            MOVEP             #$0003,X:SCCR           ; SCI clock: utility board data rate =
                            000003
748                                                                                     ;   (390,625 kbits/sec); internal clock.
749       P:0001CF P:0001CF 07F41F            MOVEP             #%011,X:PCRE            ; Port Control Register = RXD, TXD enabled
                            000003
750       P:0001D1 P:0001D1 07F41E            MOVEP             #%000,X:PRRE            ; Port Direction Register (0 = Input)
                            000000
751    
752                                 ;       PE0 = RXD
753                                 ;       PE1 = TXD
754                                 ;       PE2 = SCLK
755    
756                                 ; Program one of the three timers as an exposure timer
757       P:0001D3 P:0001D3 07F403            MOVEP             #$C34F,X:TPLR           ; Prescaler to generate millisecond timer,
                            00C34F
758                                                                                     ;  counting from the system clock / 2 = 50 M
Hz
759       P:0001D5 P:0001D5 07F40F            MOVEP             #$208200,X:TCSR0        ; Clear timer complete bit and enable presca
ler
                            208200
760       P:0001D7 P:0001D7 07F40E            MOVEP             #0,X:TLR0               ; Timer load register
                            000000
761    
762                                 ; Enable interrupts for the SCI port only
763       P:0001D9 P:0001D9 08F4BF            MOVEP             #$000000,X:IPRC         ; No interrupts allowed
                            000000
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 15



764       P:0001DB P:0001DB 08F4BE            MOVEP             #>$80,X:IPRP            ; Enable SCI interrupt only, IPR = 1
                            000080
765       P:0001DD P:0001DD 00FCB8            ANDI    #$FC,MR                           ; Unmask all interrupt levels
766    
767                                 ; Initialize the fiber optic serial receiver circuitry
768       P:0001DE P:0001DE 061480            DO      #20,L_FO_INIT
                            0001E3
769       P:0001E0 P:0001E0 5FF000            MOVE                          Y:RDFO,B
                            FFFFF1
770       P:0001E2 P:0001E2 0605A0            REP     #5
771       P:0001E3 P:0001E3 000000            NOP
772                                 L_FO_INIT
773    
774                                 ; Pulse PRSFIFO* low to revive the CMDRST* instruction and reset the FIFO
775       P:0001E4 P:0001E4 44F400            MOVE              #1000000,X0             ; Delay by 10 milliseconds
                            0F4240
776       P:0001E6 P:0001E6 06C400            DO      X0,*+3
                            0001E8
777       P:0001E8 P:0001E8 000000            NOP
778       P:0001E9 P:0001E9 0A8908            BCLR    #8,X:HDR
779       P:0001EA P:0001EA 0614A0            REP     #20
780       P:0001EB P:0001EB 000000            NOP
781       P:0001EC P:0001EC 0A8928            BSET    #8,X:HDR
782    
783                                 ; Reset the utility board
784       P:0001ED P:0001ED 0A0F05            BCLR    #5,X:<LATCH
785       P:0001EE P:0001EE 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Clear reset utility board bit
                            00000F
786       P:0001F0 P:0001F0 06C8A0            REP     #200                              ; Delay by RESET* low time
787       P:0001F1 P:0001F1 000000            NOP
788       P:0001F2 P:0001F2 0A0F25            BSET    #5,X:<LATCH
789       P:0001F3 P:0001F3 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Clear reset utility board bit
                            00000F
790       P:0001F5 P:0001F5 56F400            MOVE              #200000,A               ; Delay 2 msec for utility boot
                            030D40
791       P:0001F7 P:0001F7 06CE00            DO      A,*+3
                            0001F9
792       P:0001F9 P:0001F9 000000            NOP
793    
794                                 ; Put all the analog switch inputs to low so they draw minimum current
795       P:0001FA P:0001FA 012F23            BSET    #3,X:PCRD                         ; Turn the serial clock on
796       P:0001FB P:0001FB 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                            0C3000
797       P:0001FD P:0001FD 20001B            CLR     B
798       P:0001FE P:0001FE 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC write
s
799       P:0001FF P:0001FF 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writ
es
                            001000
800       P:000201 P:000201 060F80            DO      #15,L_ANALOG                      ; Fifteen video processor boards maximum
                            000209
801       P:000203 P:000203 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
802       P:000204 P:000204 200040            ADD     X0,A
803       P:000205 P:000205 5F7000            MOVE                          B,Y:WRSS    ; This is for the fast analog switches
                            FFFFF3
804       P:000207 P:000207 0620A3            REP     #800                              ; Delay for the serial data transmission
805       P:000208 P:000208 000000            NOP
806       P:000209 P:000209 200068            ADD     X1,B                              ; Increment the video and clock driver numbe
rs
807                                 L_ANALOG
808       P:00020A P:00020A 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
809       P:00020B P:00020B 0C0223            JMP     <SKIP
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 16



810    
811                                 ; Transmit contents of accumulator A1 over the synchronous serial transmitter
812                                 XMIT_A_WORD
813       P:00020C P:00020C 07F42C            MOVEP             #0,X:TX10               ; This helps, don't know why
                            000000
814       P:00020E P:00020E 547000            MOVE              A1,X:SV_A1
                            00000E
815       P:000210 P:000210 000000            NOP
816       P:000211 P:000211 01A786            JCLR    #TDE,X:SSISR1,*                   ; Start bit
                            000211
817       P:000213 P:000213 07F42C            MOVEP             #$010000,X:TX10
                            010000
818       P:000215 P:000215 060380            DO      #3,L_X
                            00021B
819       P:000217 P:000217 01A786            JCLR    #TDE,X:SSISR1,*                   ; Three data bytes
                            000217
820       P:000219 P:000219 04CCCC            MOVEP             A1,X:TX10
821       P:00021A P:00021A 0C1E90            LSL     #8,A
822       P:00021B P:00021B 000000            NOP
823                                 L_X
824       P:00021C P:00021C 01A786            JCLR    #TDE,X:SSISR1,*                   ; Zeroes to bring transmitter low
                            00021C
825       P:00021E P:00021E 07F42C            MOVEP             #0,X:TX10
                            000000
826       P:000220 P:000220 54F000            MOVE              X:SV_A1,A1
                            00000E
827       P:000222 P:000222 00000C            RTS
828    
829                                 SKIP
830    
831                                 ; Set up the circular SCI buffer, 32 words in size
832       P:000223 P:000223 64F400            MOVE              #SCI_TABLE,R4
                            000400
833       P:000225 P:000225 051FA4            MOVE              #31,M4
834       P:000226 P:000226 647000            MOVE              R4,X:(SCI_TABLE+33)
                            000421
835    
836                                           IF      @SCP("HOST","ROM")
844                                           ENDIF
845    
846       P:000228 P:000228 44F400            MOVE              #>$AC,X0
                            0000AC
847       P:00022A P:00022A 440100            MOVE              X0,X:<FO_HDR
848    
849       P:00022B P:00022B 0C0181            JMP     <STARTUP
850    
851                                 ;  ****************  X: Memory tables  ********************
852    
853                                 ; Define the address in P: space where the table of constants begins
854    
855                                  X_BOOT_START
856       00022A                              EQU     @LCV(L)-2
857    
858                                           IF      @SCP("HOST","ROM")
860                                           ENDIF
861                                           IF      @SCP("HOST","HOST")
862       X:000000 X:000000                   ORG     X:0,X:0
863                                           ENDIF
864    
865                                 ; Special storage area - initialization constants and scratch space
866       X:000000 X:000000         STATUS    DC      $40004                            ; Controller status bits
867    
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 17



868       000001                    FO_HDR    EQU     STATUS+1                          ; Fiber optic write bytes
869       000005                    HEADER    EQU     FO_HDR+4                          ; Command header
870       000006                    NWORDS    EQU     HEADER+1                          ; Number of words in the command
871       000007                    COM_BUF   EQU     NWORDS+1                          ; Command buffer
872       00000E                    SV_A1     EQU     COM_BUF+7                         ; Save accumulator A1
873    
874                                           IF      @SCP("HOST","ROM")
879                                           ENDIF
880    
881                                           IF      @SCP("HOST","HOST")
882       X:00000F X:00000F                   ORG     X:$F,X:$F
883                                           ENDIF
884    
885                                 ; Parameter table in P: space to be copied into X: space during
886                                 ;   initialization, and is copied from ROM by the DSP boot
887       X:00000F X:00000F         LATCH     DC      $3A                               ; Starting value in latch chip U25
888                                  EXPOSURE_TIME
889       X:000010 X:000010                   DC      0                                 ; Exposure time in milliseconds
890                                  ELAPSED_TIME
891       X:000011 X:000011                   DC      0                                 ; Time elapsed so far in the exposure
892       X:000012 X:000012         ONE       DC      1                                 ; One
893       X:000013 X:000013         TWO       DC      2                                 ; Two
894       X:000014 X:000014         THREE     DC      3                                 ; Three
895       X:000015 X:000015         SEVEN     DC      7                                 ; Seven
896       X:000016 X:000016         MASK1     DC      $FCFCF8                           ; Mask for checking header
897       X:000017 X:000017         MASK2     DC      $030300                           ; Mask for checking header
898       X:000018 X:000018         DONE      DC      'DON'                             ; Standard reply
899       X:000019 X:000019         SBRD      DC      $020000                           ; Source Identification number
900       X:00001A X:00001A         TIM_DRB   DC      $000200                           ; Destination = timing board number
901       X:00001B X:00001B         DMASK     DC      $00FF00                           ; Mask to get destination board number
902       X:00001C X:00001C         SMASK     DC      $FF0000                           ; Mask to get source board number
903       X:00001D X:00001D         ERR       DC      'ERR'                             ; An error occurred
904       X:00001E X:00001E         C100K     DC      100000                            ; Delay for WRROM = 1 millisec
905       X:00001F X:00001F         IDL_ADR   DC      TST_RCV                           ; Address of idling routine
906       X:000020 X:000020         EXP_ADR   DC      0                                 ; Jump to this address during exposures
907    
908                                 ; Places for saving register values
909       X:000021 X:000021         SAVE_SR   DC      0                                 ; Status Register
910       X:000022 X:000022         SAVE_X1   DC      0
911       X:000023 X:000023         SAVE_A1   DC      0
912       X:000024 X:000024         SAVE_R0   DC      0
913       X:000025 X:000025         RCV_ERR   DC      0
914       X:000026 X:000026         SCI_A1    DC      0                                 ; Contents of accumulator A1 in RCV ISR
915       X:000027 X:000027         SCI_R0    DC      SRXL
916    
917                                 ; Command table
918       000028                    COM_TBL_R EQU     @LCV(R)
919       X:000028 X:000028         COM_TBL   DC      'TDL',TDL                         ; Test Data Link
920       X:00002A X:00002A                   DC      'RDM',RDMEM                       ; Read from DSP or EEPROM memory
921       X:00002C X:00002C                   DC      'WRM',WRMEM                       ; Write to DSP memory
922       X:00002E X:00002E                   DC      'LDA',LDAPPL                      ; Load application from EEPROM to DSP
923       X:000030 X:000030                   DC      'STP',STOP_IDLE_CLOCKING
924       X:000032 X:000032                   DC      'DON',START                       ; Nothing special
925       X:000034 X:000034                   DC      'ERR',START                       ; Nothing special
926    
927                                  END_COMMAND_TABLE
928       000036                              EQU     @LCV(R)
929    
930                                 ; The table at SCI_TABLE is for words received from the utility board, written by
931                                 ;   the interrupt service routine SCI_RCV. Note that it is 32 words long,
932                                 ;   hard coded, and the 33rd location contains the pointer to words that have
933                                 ;   been processed by moving them from the SCI_TABLE to the COM_BUF.
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timboot.s  Page 18



934    
935                                           IF      @SCP("HOST","ROM")
937                                           ENDIF
938    
939       000036                    END_ADR   EQU     @LCV(L)                           ; End address of P: code written to ROM
940                                           INCLUDE "timhdr.s"
941                                        COMMENT *
942    
943                                 This is a header file that has some HIPO-specific stuff in it.  It is
944                                 vastly stripped down compared to the original since most of the things in it
945                                 are now in timboot.asm.
946    
947                                 I believe that all the following stuff can be zapped out.  Comment out for now.
948    
949                                         PAGE    132     ; Printronix page width - 132 columns
950    
951                                 ; Some basic structural definitions
952                                 APL_ADR EQU     $130    ; P: memory location where application code begins
953                                 APL_LEN EQU     $200-APL_ADR ; Maximum length of application program
954    
955                                 ; CHANGING MISC_LEN FROM 0X280 TO A LARGER NUMBER BREAKS THE ROM COPY APPROACH!
956                                 ; However if all you do is download there is a lot more memory available.
957                                 MISC_LEN EQU    $450    ; Maximum length of "miscellanous" code
958                                 ;MISC_LEN EQU   $3F0    ; Maximum length of "miscellanous" code
959                                 ; MISC_LEN EQU  $280    ; Maximum length of "miscellanous" code
960    
961                                 COM_LEN EQU     $40     ; Length of memory for application commands
962                                 TIM_ISR EQU     $3C     ; DSP timer interrupt service routine address
963                                 PGM_CON EQU     $3E     ; Program continues on here
964                                 COM_TBL EQU     $80     ; Starting address of command table in X: memory
965                                 N_W_APL EQU     $500    ; Number of words in each application
966                                 NUM_COM EQU     40      ; Number of entries in command table
967    
968                                 RST_ISR EQU     $00     ; Hardware reset interrupt
969                                 ROM_ID  EQU     $06     ; Location of program Identification = SWI interrupt
970                                 START   EQU     $08     ; Starting address of program
971                                 RCV_BUF EQU     $60     ; Starting address of receiver buffer in X:
972                                 TBL_ADR EQU     $0F     ; (IR) Waveform tables starting address
973    
974                                 ROM_OFF EQU     $4000   ; Boot program offset address in EEPROM
975                                 LD_X    EQU     $4200   ; Assembler loads X: starting at this EEPROM address
976                                 RD_X    EQU     $C600   ; DSP reads X: from this EEPROM address
977    
978                                 ; Define DSP port addresses
979                                 WRSS    EQU     $FF80   ; Write clock driver and VP switch states
980                                 RDFO    EQU     $FFC0   ; Read serial receiver fiber optic contents
981                                 WRFO    EQU     $FFC0   ; Write to fiber optic serial transmitter
982                                 RDAD    EQU     $FFA0   ; Read A/D datum into DSP
983                                 RDAD0   EQU     $FFA0   ; Address for reading A/D #0
984                                 RDAD1   EQU     $FFA1   ; Address for reading A/D #1
985                                 WRLATCH EQU     $FFC1   ; Write to timing board latch
986                                 RSTWDT  EQU     $6000   ; Address to reset the timing board watchdog timer
987                                 BCR     EQU     $FFFE   ; Bus (=Port A) Control Register -> Wait States
988                                 PBC     EQU     $FFE0   ; Port B Control Register
989                                 PBDDR   EQU     $FFE2   ; Port B Data Direction Register
990                                 PBD     EQU     $FFE4   ; Port B Data Register
991                                 PCC     EQU     $FFE1   ; Port C Control Register
992                                 PCDDR   EQU     $FFE3   ; PortC Data Direction Register
993                                 PCD     EQU     $FFE5   ; Port C Data Register
994                                 IPR     EQU     $FFFF   ; Interrupt Priority Register
995                                 SSITX   EQU     $FFEF   ; SSI Transmit and Receive data register
996                                 SSIRX   EQU     $FFEF   ; SSI Transmit and Receive data register
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timhdr.s  Page 19



997                                 SSISR   EQU     $FFEE   ; SSI Status Register
998                                 CRA     EQU     $FFEC   ; SSI Control Register A
999                                 CRB     EQU     $FFED   ; SSI Control Regsiter B
1000                                TCSR    EQU     $FFDE   ; Timer control and status register
1001                                TCR     EQU     $FFDF   ; Timer count register
1002   
1003                                ; Hardware bit definitions all over the place
1004                                SSI_TDE EQU     6       ; SSI Transmitter data register empty
1005                                SSI_RDF EQU     7       ; SSI Receiver data register full
1006                                LVEN    EQU     2       ; Low voltage enable (+/-15 volt nominal)
1007                                HVEN    EQU     3       ; Enable high voltage (+32V nominal)
1008                                TIM_U_RST EQU   5       ; Timing to utility board reset bit number in U25
1009                                PWRST   EQU     13      ; Power control board reset
1010                                RST_FIFO EQU    7       ; Reset FIFO bit number in control latch U25
1011                                EF      EQU     9       ; FIFO empty flag, low true
1012                                TIM_BIT EQU     0       ; Timer status bit
1013                                WW      EQU     1       ; Word width = 1 for 16-bit image data, 0 for 24-bit
1014                                CDAC    EQU     0       ; Bit number in U25 for clearing DACs
1015                                ENCK    EQU     2       ; Bit number in U25 for enabling analog switches
1016                                DUALCLK EQU     1       ; Set to clock two halves of clock driver board together
1017   
1018                                ; Software status bits, defined at X:<STATUS = X:0
1019                                ST_RCV  EQU     0       ; Set if FO, cleared if SSI
1020                                TST_IMG EQU     10      ; Set if controller is to generate a test image
1021                                SHUT    EQU     11      ; Set if opening shutter at beginning of exposure
1022   
1023                                IDLMODE EQU     2       ; Set if need to idle after readout
1024                                ST_SHUT EQU     3       ; Set to indicate shutter is closed, clear for open
1025                                ST_RDC  EQU     4       ; Set if executing 'RDC' command - reading out
1026                                SPLIT_S EQU     5       ; Set if split serial
1027                                SPLIT_P EQU     6       ; Set if split parallel
1028                                MPP     EQU     7       ; Set if parallels are in MPP mode
1029   
1030                                END OF COMMENT HERE
1031                                        *
1032                                ; additional X:<STATUS bits
1033                                ; NOTE
1034                                ; NOTE
1035                                ; the NOT_CLR, and MPP X:<STATUS bits are pre-empted.
1036      000008                    ST_ABRT   EQU     8                                 ; Set if an abort (readout or exp) in progre
ss
1037      000007                    ST_EXP    EQU     7                                 ; Set if presently in EXPOSE or waiting for 
trigger
1038   
1039   
1040                                ; move IMGVAR down to $80 as per Confluence July 1 #1
1041                                ;IMGVAR_ADR EQU $100            ;  Special Image Mode variables Starting Address in X:
1042      000080                    IMGVAR_ADR EQU    $80                               ;  Special Image Mode variables Starting Add
ress in X:
1043   
1044                                ; Additional software status bit, defined at X:<STATUS = X:0
1045      000008                    TRIGGER   EQU     8                                 ; Set if a Hardware triggered exposure
1046   
1047                                ; add these HDR (port B) bits for thermo cool statuses
1048      000004                    STS0      EQU     4                                 ; STATUS 0, thermocool
1049      000005                    STS1      EQU     5                                 ; STATUS 1, thermocool
1050   
1051                                ; Image mode bits, defined at X:<IMAGE_MODE
1052   
1053      000000                    FDOTS     EQU     0                                 ; Fast Dots
1054      000001                    FIND      EQU     1                                 ; Find
1055      000002                    SDOTS     EQU     2                                 ; Slow Dots
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timhdr.s  Page 20



1056      000003                    SERIES    EQU     3                                 ; Series
1057      000004                    SINGLE    EQU     4                                 ; Single
1058      000005                    STRIP     EQU     5                                 ; Stripscan
1059      000006                    F_OCC     EQU     6                                 ; Fast occultation, keep as 6 for compatibil
ity
1060      000007                    B_OCC     EQU     7                                 ; Basic occultation
1061      000008                    P_OCC     EQU     8                                 ; Pipelined occultation
1062   
1063                                ; Image Status, define at X:<ISTATUS
1064      000000                    NO_SKIP   EQU     0                                 ; Set for slow dots, fast and pipelined occu
ltation mode
1065                                                                                    ; to avoid parallel skipping to the subframe
 boundary.
1066      000001                    OPEN_CLOSE EQU    1                                 ; Set if shutter opens/closes each image
1067                                                                                    ; Clear if shutter stays open for many image
s
1068      000002                    STORAGE   EQU     2                                 ; Set if storage area is to be clocked
1069                                          INCLUDE "infospec.s"
1070                                ; General DSP info field specifications.
1071                                ; These values are 'addresses' and used as the argument for the INF command.
1072   
1073                                 GET_VERSION
1074      000000                              EQU     0                                 ; IVERSION field
1075      000001                    GET_FLAVOR EQU    1                                 ; IFLAVOR field
1076      000002                    GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
1077      000003                    GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
1078      000004                    GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if availabl
e)
1079                                 GET_TEMP2STS
1080      000005                              EQU     5                                 ; two bits of thermo cool status for GWAVES
1081   
1082                                          INCLUDE "timinfospec.s"
1083                                ; TIM DSP info field specifications.
1084                                ; These values are 'addresses' and used as the argument for the INF command.
1085   
1086                                 GET_CAPABLE
1087      000100                              EQU     $100                              ; ICAPABLE field (what dsp supports).
1088                                 GET_INT_TIM
1089      000101                              EQU     $101                              ; Integration time per pixel in leach units
1090                                 GET_R_DELAY
1091      000102                              EQU     $102                              ; Serial overlap in leach units
1092                                 GET_SI_DELAY
1093      000103                              EQU     $103                              ; Parallel overlap in leach units
1094   
1095                                          INCLUDE "timinfo.s"
1096                                ; DSP Version
1097      04507F                    IVERSION  EQU     282751                            ; 1.5/1
1098   
1099      612020                    IFLAVOR   EQU     'a  '                             ; a
1100   
1101      007F74                    ITIME0    EQU     32628                             ; lo order time: 2012 7 3  5:13:24 GMT
1102   
1103      004FF2                    ITIME1    EQU     20466                             ; hi order time: 2012 7 3  5:13:24 GMT
1104   
1105      000000                    ISVNREV   EQU     0                                 ; most recent code svn rev
1106   
1107                                ; this need to be defined externally due to a problem in timboot.s
1108                                ; as per Confluence, July 6, #1
1109      00005A                    EXPOSING  EQU     TST_RCV                           ; Address if exposing
1110                                 CONTINUE_READING
1111      00005A                              EQU     TST_RCV                           ; Address if reading out
1112   
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  tim.s  Page 21



1113                                ; tim capability definitions
1114                                 FINDCAPABLE
1115      000001                              EQU     1                                 ; Find exposure mode
1116                                 SNGLCAPABLE
1117      000002                              EQU     2                                 ; Single exposure mode
1118                                 SERICAPABLE
1119      000004                              EQU     4                                 ; Series exposure mode
1120                                 BASCCAPABLE
1121      000008                              EQU     8                                 ; Basic occ exposure mode
1122                                 FASTCAPABLE
1123      000010                              EQU     16                                ; Fast occ exposure mode
1124                                 PIPECAPABLE
1125      000020                              EQU     32                                ; Pipeline occ exposure mode
1126                                 FDOTCAPABLE
1127      000040                              EQU     64                                ; Fast dots exposure mode
1128                                 SDOTCAPABLE
1129      000080                              EQU     128                               ; Slow dots exposure mode
1130                                 STRPCAPABLE
1131      000100                              EQU     256                               ; Slow dots exposure mode
1132      0001CB                    TIMCAPABLE EQU    FINDCAPABLE+SNGLCAPABLE+STRPCAPABLE+BASCCAPABLE+FDOTCAPABLE+SDOTCAPABLE
1133   
1134      P:00022C P:00022C                   ORG     P:,P:
1135   
1136                                ; Remove SHUTTER_CC advertisement as per Confluence July 4 #3
1137                                ;CC     EQU     ARC22+ARC47+SHUTTER_CC+SPLIT_SERIAL+SUBARRAY+BINNING
1138      003C97                    CC        EQU     ARC22+ARC47+SPLIT_SERIAL+SPLIT_PARALLEL+SUBARRAY+BINNING+SHUTTER_CC
1139   
1140                                ; Put number of words of application in P: for loading application from EEPROM
1141      P:00022C P:00022C                   DC      TIMBOOT_X_MEMORY-@LCV(L)-1
1142   
1143                                ;**************************************************************************
1144                                ;                                                                         *
1145                                ;    Permanent address register assignments                               *
1146                                ;        R1 - Address of SSI receiver contents                            *
1147                                ;        R2 - Address of SCI receiver contents                            *
1148                                ;        R3 - Pointer to current top of command buffer                    *
1149                                ;        R4 - Pointer to processed contents of command buffer             *
1150                                ;        R5 - Temporary register for processing SSI and SCI contents      *
1151                                ;        R6 - CCD clock driver address for CCD #0 = $FF80                 *
1152                                ;                It is also the A/D address of analog board #0            *
1153                                ;        R6 CURRENTLY UNUSED (geniii)
1154                                ;                                                                         *
1155                                ;    Other registers                                                      *
1156                                ;        R0, R7 - Temporary registers used all over the place.            *
1157                                ;        R5 - Can be used as a temporary register but is circular,        *
1158                                ;               modulo 32.                                                *
1159                                ;**************************************************************************
1160   
1161                                ;  ***********************   CCD  READOUT   ***********************
1162                                ; RDCCD is now a subroutine
1163                                ; Adding several CLOCK_WAITs as per Jun 29 #8.
1164   
1165                                RDCCD
1166      P:00022D P:00022D 0A20A2            JSET    #STORAGE,X:ISTATUS,RCCD1
                            000233
1167                                ; Do the frame transfer if STORAGE==0, else skip it.
1168      P:00022F P:00022F 4DBB00            MOVE                          Y:<S_SIZE,X1
1169      P:000230 P:000230 0D0778            JSR     <CLOCK_WAIT
1170                                ; mitigation attempt 2- remove ishift
1171      P:000231 P:000231 0BF080            JSR     ISHIFT                            ; Do the frame transfer
                            00076A
1172                                ;       JSR     <CLOCK_WAIT  ; mitigation attempt 1
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  tim.s  Page 22



1173   
1174                                ; Calculate some readout parameters.
1175                                ; This is also an alternative entry point for skipping the frame transfer
1176                                ; STORAGE also selects ganged or storage only parallels during readout
1177                                ; NO_SKIP skips over the section that parallel skips to the subframe start
1178   
1179      P:000233 P:000233 5E9C00  RCCD1     MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1180      P:000234 P:000234 200003            TST     A
1181      P:000235 P:000235 0E2240            JNE     <SUB_IMG
1182      P:000236 P:000236 5C1900            MOVE                          A1,Y:<NP_SKIP ; Zero these all out.  Full frame
1183      P:000237 P:000237 5C1A00            MOVE                          A1,Y:<NS_SKP1
1184      P:000238 P:000238 5C1B00            MOVE                          A1,Y:<NS_SKP2
1185      P:000239 P:000239 5E8100            MOVE                          Y:<NSR,A    ; NSERIALS_READ = NSR
1186      P:00023A P:00023A 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            00023D
1187      P:00023C P:00023C 200022            ASR     A                                 ; Split serials require / 2
1188      P:00023D P:00023D 000000            NOP
1189      P:00023E P:00023E 5E1300            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1190      P:00023F P:00023F 0C0250            JMP     <SETUP
1191   
1192                                ; Loop over the required number of subimage boxes if NBOXES > 0
1193      P:000240 P:000240 67F400  SUB_IMG   MOVE              #READ_TABLE,R7          ; Parameter table for subimage readout
                            000020
1194      P:000242 P:000242 061C40            DO      Y:<NBOXES,L_NBOXES                ; Loop over number of boxes
                            0002D9
1195      P:000244 P:000244 4CDF00            MOVE                          Y:(R7)+,X0
1196      P:000245 P:000245 4C1900            MOVE                          X0,Y:<NP_SKIP
1197      P:000246 P:000246 4CDF00            MOVE                          Y:(R7)+,X0
1198      P:000247 P:000247 4C1A00            MOVE                          X0,Y:<NS_SKP1
1199      P:000248 P:000248 4CDF00            MOVE                          Y:(R7)+,X0
1200      P:000249 P:000249 4C1B00            MOVE                          X0,Y:<NS_SKP2
1201      P:00024A P:00024A 5E9E00            MOVE                          Y:<NS_READ,A
1202      P:00024B P:00024B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                            00024E
1203      P:00024D P:00024D 200022            ASR     A
1204      P:00024E P:00024E 000000            NOP
1205      P:00024F P:00024F 5E1300            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1206   
1207                                ; Calculate the fast readout parameters
1208      P:000250 P:000250 0D0681  SETUP     JSR     <SETUP_SUBROUTINE
1209      P:000251 P:000251 0D0778            JSR     <CLOCK_WAIT
1210   
1211                                ; Skip over the required number of rows for subimage readout
1212                                ; If #NO_SKIP == 0 skip rows up to first subframe, storage clocks only
1213      P:000252 P:000252 0A20A0            JSET    #NO_SKIP,X:ISTATUS,CLR_SR
                            00025F
1214      P:000254 P:000254 5E9900            MOVE                          Y:<NP_SKIP,A ; Number of rows NP_SKIP to skip
1215      P:000255 P:000255 200003            TST     A
1216      P:000256 P:000256 0EA25F            JEQ     <CLR_SR                           ; If zero, skip this shift
1217      P:000257 P:000257 061940            DO      Y:<NP_SKIP,L_SKIP1                ; Clock number of rows to skip
                            00025E
1218      P:000259 P:000259 689100            MOVE                          Y:<IS_PAR_CLR,R0 ; SR kept clear with DG
1219      P:00025A P:00025A 0A20A2            JSET    #STORAGE,X:ISTATUS,GANG_SK        ; if STORAGE == 0 store clocks only
                            00025D
1220                                ;        mitigation attempt 3- don't use S_PAR_CLR (but it was a full fr test)
1221      P:00025C P:00025C 689200            MOVE                          Y:<S_PAR_CLR,R0 ; SR kept clear with DG
1222                                GANG_SK
1223      P:00025D P:00025D 0D02DE            JSR     <CLOCK
1224      P:00025E P:00025E 000000            NOP
1225                                L_SKIP1
1226   
1227                                ; Clear out the accumulated charge from the serial shift register
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  tim.s  Page 23



1228                                ; Leave this commented-out code in until we can test it with a subframe
1229                                ; CLR_SR MOVE   #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1230                                ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1231                                ;       NOP
1232                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1233                                ;       DO      Y:<NSCLR,*+3            ; Number of waveform entries total
1234                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1235                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1236   
1237      P:00025F P:00025F 60F400  CLR_SR    MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel skip
                            0001E2
1238      P:000261 P:000261 0D02DE            JSR     <CLOCK
1239   
1240                                ; Parallel shift the image into the serial shift register
1241      P:000262 P:000262 4C8200            MOVE                          Y:<NPR,X0   ; Number of rows set by host computer
1242      P:000263 P:000263 5E9C00            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1243      P:000264 P:000264 200003            TST     A
1244      P:000265 P:000265 0EA267            JEQ     *+2
1245      P:000266 P:000266 4C9F00            MOVE                          Y:<NP_READ,X0 ; If NBOXES .NE. 0 use subimage table
1246   
1247                                ; Main loop over each line to be read out
1248                                ; If split parallels have to divide NPR by two to be loop counter
1249                                ; Subimages implicitly assumes that parallels are not split
1250      P:000267 P:000267 0A0086            JCLR    #SPLIT_P,X:STATUS,PLOOP           ; skip this if not split parallels
                            00026E
1251      P:000269 P:000269 5EF000            MOVE                          Y:NPR,A     ; Get NPR
                            000002
1252      P:00026B P:00026B 200022            ASR     A                                 ; Divide by 2
1253      P:00026C P:00026C 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1254      P:00026D P:00026D 21C400            MOVE              A,X0                    ; Overwrite loop counter in X0
1255   
1256                                ; Finally start the row loop
1257      P:00026E P:00026E 06C400  PLOOP     DO      X0,LPR                            ; Number of rows to read out
                            0002D8
1258   
1259                                ; Check for a command once per line. Only the ABORT command is allowed
1260                                ; NOT DONE- check for ABEXP in expose only
1261                                ;       JSR     <GET_RCV                ; Was a command received?
1262                                ;       JCC     <CONTINUE_RD            ; If no, continue reading out
1263                                ; as per Confluence July 5 #7
1264                                ;       JMP     <PRC_RCV                ; If yes, go process it
1265      P:000270 P:000270 0C0278            JMP     <CONTINUE_RD
1266   
1267                                ; Abort the readout currently underway (cmd destination)
1268                                ABR_RDC
1269      P:000271 P:000271 200013            CLR     A
1270      P:000272 P:000272 5EBF00            MOVE                          Y:<TESTLOC1,A
1271      P:000273 P:000273 014180            ADD     #1,A
1272      P:000274 P:000274 0A0028            BSET    #ST_ABRT,X:<STATUS
1273      P:000275 P:000275 5C3F00            MOVE                          A1,Y:<TESTLOC1
1274   
1275      P:000276 P:000276 0A0084            JCLR    #ST_RDC,X:<STATUS,ABORT_EXPOSURE
                            0007B5
1276                                ; "Can't happen"
1277                                ; already in readout- so just fall thru and continue,
1278                                ; having set the ST_ABRT flag.
1279                                ; currently we just let this readout segment run to the end and
1280                                ; handle the abort in the outer xxx_PROC code- this has
1281                                ; the advantage of ending the overall exposure on a frame boundary
1282                                ; in the case of 3-d images.
1283                                ; A more abrupt ending of the RDCCD code could be arranged if needed.
1284   
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  tim.s  Page 24



1285                                ;       ENDDO                           ; Properly terminate row loop
1286                                ;       MOVE    Y:<NBOXES,A             ; NBOXES = 0 => full image readout
1287                                ;       TST     A
1288                                ;       JEQ     *+2
1289                                ;       ENDDO                           ; Properly terminate box loop
1290                                ;       NOP
1291                                ;       CLR     A
1292                                ;       INC     A
1293                                ;       NOP
1294                                ;       MOVE    A0,Y:<IFLPCNT
1295                                ;       RTS                             ; Return early from subroutine
1296   
1297                                ; Move the row into the serial register.
1298                                 CONTINUE_RD
1299      P:000278 P:000278 060640            DO      Y:<NPBIN,LPR_I                    ; Transfer # of rows, with binning
                            00027F
1300      P:00027A P:00027A 688F00            MOVE                          Y:<IS_PAR_CLK,R0
1301      P:00027B P:00027B 0A20A2            JSET    #STORAGE,X:ISTATUS,GANGED         ; if STORAGE == 1 ganged parallels
                            00027E
1302                                ;       mitigation attempt 4- don't use S_PAR_CLK- seemed to work
1303      P:00027D P:00027D 689000            MOVE                          Y:<S_PAR_CLK,R0 ; if STORAGE == 0 store clocks only
1304      P:00027E P:00027E 0D02DE  GANGED    JSR     <CLOCK                            ; Parallel clocking
1305      P:00027F P:00027F 000000            NOP
1306                                LPR_I
1307   
1308                                ; Skip over NS_SKP1 columns for subimage readout
1309                                ;       MOVE    Y:<NS_SKP1,A            ; Number of columns to skip
1310      P:000280 P:000280 5E9500            MOVE                          Y:<NSKIP1,A ; Number of waveforms for skip
1311      P:000281 P:000281 200003            TST     A
1312      P:000282 P:000282 0EA287            JEQ     <L_READ
1313                                ;       MOVE    #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1314      P:000283 P:000283 0506A1            MOVE              #<(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-1),M1 ; Modularity
1315   
1316                                ;       Fix for new interface CLOCKCT
1317                                ;       June 30 bottom "questions and comments" #2,3
1318      P:000284 P:000284 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1319      P:000285 P:000285 218400            MOVE              A1,X0                   ; how many
1320      P:000286 P:000286 0D02E4            JSR     <CLOCKCT
1321                                ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1322                                ;       NOP
1323                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1324                                ;       DO      Y:<NSKIP1,LS_SKIP1      ; Number of waveform entries total
1325                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1326                                ;LS_SKIP1
1327                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1328   
1329                                ; Finally read some real pixels - this is the serial binning routine
1330      P:000287 P:000287 200013  L_READ    CLR     A
1331      P:000288 P:000288 20001B            CLR     B
1332      P:000289 P:000289 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1333      P:00028A P:00028A 50F400            MOVE              #>5,A0                  ; If binning > 4, do general binning
                            000005
1334      P:00028C P:00028C 200005            CMP     B,A                               ; else do special waveforms via NO_BIN
1335      P:00028D P:00028D 0E729F            JGT     <NO_BIN                           ; Skip over general serial binning software
1336      P:00028E P:00028E 00000B            DEC     B                                 ; serial binning factor minus 1
1337      P:00028F P:00028F 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1338      P:000290 P:000290 212700            MOVE              B0,Y1
1339      P:000291 P:000291 061340            DO      Y:<NSERIALS_READ,LSR_BIN          ; Number of pixels to read out
                            00029D
1340      P:000293 P:000293 688E00            MOVE                          Y:<INITIAL_CLOCK,R0 ; (already /2 if split serials)
1341      P:000294 P:000294 0D02DE            JSR     <CLOCK
1342                                ;       DO      Y:<NSBIN,LSR_I          ; Bin serially NSBIN times
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  tim.s  Page 25



1343      P:000295 P:000295 06C700            DO      Y1,LSR_I                          ; Bin serially NSBIN times
                            000299
1344      P:000297 P:000297 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1345      P:000298 P:000298 0D02DE            JSR     <CLOCK                            ;   shift register
1346      P:000299 P:000299 000000            NOP
1347                                LSR_I
1348      P:00029A P:00029A 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                            000078
1349      P:00029C P:00029C 0D02DE            JSR     <CLOCK
1350                                ;       MOVE    Y1,Y:<INTERVAL          ; HACK.  Use for debugging
1351      P:00029D P:00029D 000000            NOP
1352                                LSR_BIN
1353      P:00029E P:00029E 0C02A5            JMP     <OVER_RD                          ; All done binning
1354   
1355                                ; This is the routine for serial binning from 1 to 4 using hardwired waveforms
1356      P:00029F P:00029F 588C00  NO_BIN    MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1357      P:0002A0 P:0002A0 00000A            DEC     A                                 ; waveform - 1 into M1
1358      P:0002A1 P:0002A1 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1359      P:0002A2 P:0002A2 04C8A1            MOVE              A0,M1                   ; Modularity
1360                                ;       Fix for new interface CLOCKCT
1361                                ;       June 30 bottom "questions and comments" #2,3
1362      P:0002A3 P:0002A3 4C9600            MOVE                          Y:<NREAD,X0 ; how many
1363      P:0002A4 P:0002A4 0D02E4            JSR     <CLOCKCT
1364                                ;       NOP
1365                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1366                                ;       DO      Y:<NREAD,LSR            ; Number of waveform entries total
1367                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1368                                ;LSR
1369                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1370   
1371                                ; If NR_BIAS=0 clobber SR with DG and skip to end of row loop
1372      P:0002A5 P:0002A5 5E9D00  OVER_RD   MOVE                          Y:<NR_BIAS,A ; Is NR_BIAS zero?
1373      P:0002A6 P:0002A6 200003            TST     A
1374      P:0002A7 P:0002A7 0E22AD            JNE     <OVR_RD1                          ; no, go to the NS_SKP2 section
1375      P:0002A8 P:0002A8 60F400            MOVE              #DUMP_SERIAL,R0         ; yes, clobber SR with DG
                            0001E2
1376      P:0002AA P:0002AA 0D02DE            JSR     <CLOCK
1377      P:0002AB P:0002AB 0AF080            JMP     END_ROW                           ; and go to the end of the row loop
                            0002D8
1378                                ; Skip over NS_SKP2 columns for subimage readout to get to overscan region
1379      P:0002AD P:0002AD 5E9B00  OVR_RD1   MOVE                          Y:<NS_SKP2,A ; Number of columns to skip
1380      P:0002AE P:0002AE 200003            TST     A
1381      P:0002AF P:0002AF 0EA2B4            JEQ     <L_BIAS
1382                                ;       MOVE    #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1383      P:0002B0 P:0002B0 0506A1            MOVE              #<(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-1),M1 ; Modularity
1384      P:0002B1 P:0002B1 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1385                                ;       Fix for new interface CLOCKCT
1386                                ;       June 30 bottom "questions and comments" #2,3
1387      P:0002B2 P:0002B2 4C9700            MOVE                          Y:<NSKIP2,X0 ; how many
1388      P:0002B3 P:0002B3 0D02E4            JSR     <CLOCKCT
1389                                ;       NOP
1390                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1391                                ;       DO      Y:<NSKIP2,LS_SKIP2      ; Number of waveform entries total
1392                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1393                                ;LS_SKIP2
1394                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1395   
1396                                ; And read the bias pixels if in subimage readout mode
1397                                ; I think this means that if NBOXES==0 you have to have NSR include bias px.
1398      P:0002B4 P:0002B4 5E9C00  L_BIAS    MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1399      P:0002B5 P:0002B5 200003            TST     A
1400      P:0002B6 P:0002B6 0EA2D8            JEQ     <END_ROW
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  tim.s  Page 26



1401   
1402                                ; Finally read some real bias pixels
1403      P:0002B7 P:0002B7 200013            CLR     A
1404      P:0002B8 P:0002B8 20001B            CLR     B
1405      P:0002B9 P:0002B9 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1406      P:0002BA P:0002BA 50F400            MOVE              #>5,A0                  ; If binning > 4, do general binning
                            000005
1407      P:0002BC P:0002BC 200005            CMP     B,A                               ; else do special waveforms via NO_BIN_BIAS
1408      P:0002BD P:0002BD 0E72D2            JGT     <NO_BIN_BIAS                      ; Skip over general serial binning software
1409      P:0002BE P:0002BE 00000B            DEC     B                                 ; serial binning factor minus 1
1410      P:0002BF P:0002BF 5E9D00            MOVE                          Y:<NR_BIAS,A
1411      P:0002C0 P:0002C0 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            0002C3
1412      P:0002C2 P:0002C2 200022            ASR     A                                 ; Split serials require / 2
1413      P:0002C3 P:0002C3 212700            MOVE              B0,Y1
1414      P:0002C4 P:0002C4 06CE00            DO      A,LBIAS_BIN                       ; Number of pixels to read out
                            0002D0
1415      P:0002C6 P:0002C6 688E00            MOVE                          Y:<INITIAL_CLOCK,R0
1416      P:0002C7 P:0002C7 0D02DE            JSR     <CLOCK
1417      P:0002C8 P:0002C8 06C700            DO      Y1,LBIAS_I                        ; Bin serially NSBIN times
                            0002CC
1418                                ;       DO      Y:<NSBIN,LBIAS_I        ; Bin serially NSBIN times
1419      P:0002CA P:0002CA 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1420      P:0002CB P:0002CB 0D02DE            JSR     <CLOCK                            ;   shift register
1421      P:0002CC P:0002CC 000000            NOP
1422                                LBIAS_I
1423      P:0002CD P:0002CD 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                            000078
1424      P:0002CF P:0002CF 0D02DE            JSR     <CLOCK
1425      P:0002D0 P:0002D0 000000            NOP
1426                                LBIAS_BIN
1427      P:0002D1 P:0002D1 0C02D8            JMP     <END_ROW                          ; All done binning
1428   
1429                                ; This is the routine for serial binning from 1 to 4 using hardwired waveforms
1430                                ; NBIAS is already divided by 2 in SETUP_SUBROUTINE if split serials.
1431                                NO_BIN_BIAS
1432      P:0002D2 P:0002D2 588C00            MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1433      P:0002D3 P:0002D3 00000A            DEC     A                                 ; waveform - 1 into M1
1434      P:0002D4 P:0002D4 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1435      P:0002D5 P:0002D5 04C8A1            MOVE              A0,M1                   ; Modularity
1436                                ;       Fix for new interface CLOCKCT
1437                                ;       June 30 bottom "questions and comments" #2,3
1438      P:0002D6 P:0002D6 4C9800            MOVE                          Y:<NBIAS,X0 ; how many
1439      P:0002D7 P:0002D7 0D02E4            JSR     <CLOCKCT
1440                                ;       NOP
1441                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1442                                ;       DO      Y:<NBIAS,*+3            ; Number of waveform entries total
1443                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1444                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1445      P:0002D8 P:0002D8 000000  END_ROW   NOP
1446      P:0002D9 P:0002D9 000000  LPR       NOP                                       ; End of parallel loop
1447      P:0002DA P:0002DA 000000  L_NBOXES  NOP                                       ; End of subimage boxes loop
1448      P:0002DB P:0002DB 000000            NOP
1449      P:0002DC P:0002DC 0D0778            JSR     <CLOCK_WAIT
1450      P:0002DD P:0002DD 00000C            RTS
1451   
1452                                ; ***************** END OF CCD READOUT SUBROUTINE  ************
1453   
1454                                ; Core subroutine for clocking out CCD charge
1455                                ; Must keep in tim.s to insure that it is in fast P memory
1456                                ; Modified for FIFO magement and new processor as per
1457                                ; June 30 bottom "questions and comments" #2,3
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  tim.s  Page 27



1458   
1459                                ; CLOCK assumes waveform in R0, which begins with a count field
1460                                ; NOTE: in geniii, this count is 1 larger than genii because it
1461                                ; is a straight count of the # of points in the wave- gen-ii
1462                                ; needed a count 1 smaller since there was a pipeline that was
1463                                ; primed with a starter pixel.
1464                                CLOCK
1465      P:0002DE P:0002DE 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002DE
1466      P:0002E0 P:0002E0 065860            REP     Y:(R0)+
1467      P:0002E1 P:0002E1 09D8F3            MOVEP             Y:(R0)+,Y:WRSS          ; next piece of the waveform
1468      P:0002E2 P:0002E2 000000            NOP                                       ; just in case
1469      P:0002E3 P:0002E3 00000C            RTS
1470   
1471                                ; CLOCKCT assumes waveform in R1, without a count field, and the
1472                                ; count in X0, and modulus counter in M1.
1473                                ; In order to manage the FIFO (SSFHF) we copy the wave out in a block of 16 pts
1474                                ; at a time. The SSFHF check happens at the start of each block.
1475                                ; Note that count in X0 is again a straight count requiring a fix to FASTSKP
1476                                ; CLOCKCT trashes A
1477                                CLOCKCT
1478      P:0002E4 P:0002E4 200013            CLR     A
1479      P:0002E5 P:0002E5 208E00            MOVE              X0,A
1480                                CLKBLKFULL
1481                                                                                    ; see if we can do a full block in the wavef
orm.
1482      P:0002E6 P:0002E6 015085            CMP     #16,A
1483      P:0002E7 P:0002E7 0E92EE            JLT     <CLKBLKREM
1484                                                                                    ; 16 or more points remain
1485      P:0002E8 P:0002E8 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002E8
1486      P:0002EA P:0002EA 0610A0            REP     #16
1487      P:0002EB P:0002EB 09D9F3            MOVEP             Y:(R1)+,Y:WRSS          ; next modulo piece of the waveform
1488      P:0002EC P:0002EC 015084            SUB     #16,A
1489      P:0002ED P:0002ED 0C02E6            JMP     <CLKBLKFULL
1490                                CLKBLKREM
1491                                                                                    ; last little bit..
1492      P:0002EE P:0002EE 200003            TST     A
1493      P:0002EF P:0002EF 0EF2F5            JLE     <CLOCK1                           ; no it divided evenly so all done--
1494                                                                                    ; do the remainder of 1 to 15 pts.
1495      P:0002F0 P:0002F0 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002F0
1496      P:0002F2 P:0002F2 06CE00            DO      A,CLOCK1
                            0002F4
1497      P:0002F4 P:0002F4 09D9F3            MOVEP             Y:(R1)+,Y:WRSS          ; next modulo piece of the waveform
1498                                CLOCK1
1499      P:0002F5 P:0002F5 000000            NOP                                       ; just in case
1500      P:0002F6 P:0002F6 00000C            RTS
1501   
1502                                ;CLOCK   MOVE    Y:(R0)+,X0             ; # of waveform entries
1503                                ;        MOVE    Y:(R0)+,A              ; Start the pipeline
1504                                ;        DO      X0,CLK1                 ; Repeat X0 times
1505                                ;        MOVE    A,X:(R6) Y:(R0)+,A      ; Send out the waveform
1506                                ;CLK1
1507                                ;        MOVE    A,X:(R6)               ; Flush out the pipeline
1508                                ;        RTS                            ; Return from subroutine
1509   
1510                                ; Include miscellaneous timing commands
1511                                          INCLUDE "timmisc.s"                       ; Custom
1512                                ; This file is for utilities that are in common to all the timing board
1513                                ;   programs, located starting at P:$200 in external SRAM
1514   
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 28



1515                                          IF      @SCP("10","50")
1517                                          ENDIF
1518                                          IF      @SCP("10","200")
1520                                          ENDIF
1521                                          IF      @SCP("10","10")
1522      00000A                    SDELAY    EQU     10
1523                                          ENDIF
1524   
1525   
1526                                ;  ****************  PROGRAM CODE IN SRAM PROGRAM SPACE    *******************
1527                                ; Put all the following code in SRAM, starting at P:$200.
1528                                          IF      @SCP("HOST","HOST")
1529                                ; as per Confluence, July 9
1530                                ;       ORG     P:$200,P:$200   ; Download address
1531      P:0002F7 P:0002F7                   ORG     P:,P:                             ; Download address
1532                                          ELSE
1534                                          ENDIF
1535   
1536                                ; Fast clear of CCD, executed as a command
1537      P:0002F7 P:0002F7 0D02F9  CLEAR     JSR     <CLR_CCD
1538      P:0002F8 P:0002F8 0C008F            JMP     <FINISH
1539   
1540                                ; Fast clear image before each exposure, executed as a subroutine.  Uses DG
1541      P:0002F9 P:0002F9 060440  CLR_CCD   DO      Y:<NPCLR,LPCLR                    ; Loop over number of lines in image
                            0002FE
1542      P:0002FB P:0002FB 60F400            MOVE              #ABCD_CLEAR_SPLIT,R0    ; Address of parallel transfer waveform
                            0001A2
1543      P:0002FD P:0002FD 0D02DE            JSR     <CLOCK                            ; Go clock out the CCD charge
1544      P:0002FE P:0002FE 000000            NOP                                       ; Do loop restriction
1545                                LPCLR
1546      P:0002FF P:0002FF 60F400            MOVE              #DUMP_SERIAL,R0
                            0001E2
1547      P:000301 P:000301 0D02DE            JSR     <CLOCK                            ; and wipe out the dregs in the SR
1548      P:000302 P:000302 245A00            MOVE              #TST_RCV,X0             ; Wait for commands during exposure
1549      P:000303 P:000303 441F00            MOVE              X0,X:<IDL_ADR           ;  instead of idling
1550      P:000304 P:000304 00000C            RTS
1551   
1552                                ; Keep the CCD idling when not reading out
1553      P:000305 P:000305 060340  IDLE      DO      Y:<NS_CLR,IDL1                    ; Loop over number of pixels per line
                            00030E
1554      P:000307 P:000307 304000            MOVE              #<SERIAL_IDLE,R0        ; Serial transfer on pixel
1555      P:000308 P:000308 0D02DE            JSR     <CLOCK                            ; Go to it
1556      P:000309 P:000309 330700            MOVE              #COM_BUF,R3
1557      P:00030A P:00030A 0D00A5            JSR     <GET_RCV                          ; Check for FO or SSI commands
1558      P:00030B P:00030B 0E030E            JCC     <NO_COM                           ; Continue IDLE if no commands received
1559      P:00030C P:00030C 00008C            ENDDO
1560      P:00030D P:00030D 0C005D            JMP     <PRC_RCV                          ; Go process header and command
1561      P:00030E P:00030E 000000  NO_COM    NOP
1562                                IDL1
1563      P:00030F P:00030F 60F400            MOVE              #ABCD_CLEAR_SPLIT,R0    ; Address of parallel clocking waveform
                            0001A2
1564      P:000311 P:000311 0D02DE            JSR     <CLOCK                            ; Go clock out the CCD charge
1565      P:000312 P:000312 0C0305            JMP     <IDLE
1566   
1567                                ; Start the exposure timer and monitor its progress
1568      P:000313 P:000313 07F40E  EXPOSE    MOVEP             #0,X:TLR0               ; Load 0 into counter timer
                            000000
1569      P:000315 P:000315 240000            MOVE              #0,X0
1570      P:000316 P:000316 441100            MOVE              X0,X:<ELAPSED_TIME      ; Set elapsed exposure time to zero
1571                                ;       CLR     B                       ; possibly fix bug as per
1572      P:000317 P:000317 579000            MOVE              X:<EXPOSURE_TIME,B
1573      P:000318 P:000318 20000B            TST     B                                 ; Special test for zero exposure time
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 29



1574      P:000319 P:000319 0EA325            JEQ     <END_EXP                          ; Don't even start an exposure
1575      P:00031A P:00031A 01418C            SUB     #1,B                              ; Timer counts from X:TCPR0+1 to zero
1576      P:00031B P:00031B 010F20            BSET    #TIM_BIT,X:TCSR0                  ; Enable the timer #0
1577      P:00031C P:00031C 577000            MOVE              B,X:TCPR0
                            FFFF8D
1578      P:00031E P:00031E 0A8989  CHK_RCV   JCLR    #EF,X:HDR,CHK_TIM                 ; Simple test for fast execution
                            000323
1579      P:000320 P:000320 330700            MOVE              #COM_BUF,R3             ; The beginning of the command buffer
1580      P:000321 P:000321 0D00A5            JSR     <GET_RCV                          ; Check for an incoming command
1581      P:000322 P:000322 0E805D            JCS     <PRC_RCV                          ; If command is received, go check it
1582      P:000323 P:000323 018F95  CHK_TIM   JCLR    #TCF,X:TCSR0,CHK_RCV              ; Wait for timer to equal compare value
                            00031E
1583      P:000325 P:000325 010F00  END_EXP   BCLR    #TIM_BIT,X:TCSR0                  ; Disable the timer
1584      P:000326 P:000326 0AE780            JMP     (R7)                              ; This contains the return address
1585   
1586                                ; Select which readouts to process
1587                                ;   'SOS'  Amplifier_name
1588                                ;       Amplifier_names = '__A', '__B', '__C', '__D', '_AB', '_CD', '_BD', 'ALL'
1589   
1590                                ;       Correct command ptr to R3 as per "Four Points" #2
1591   
1592      P:000327 P:000327 44DB00  SEL_OS    MOVE              X:(R3)+,X0              ; Get amplifier(s) name
1593      P:000328 P:000328 0D032A            JSR     <SELECT_OUTPUT_SOURCE
1594      P:000329 P:000329 0C0090            JMP     <FINISH1
1595   
1596                                ; A massive subroutine for setting all the addresses depending on the
1597                                ; output source(s) selection and binning parameter.  Most of the
1598                                ; waveforms are in fast Y memory (< 0xFF) but there isn't enough
1599                                ; space for the fast serial binning waveforms for binning factors
1600                                ; 1 through 4.  These are in high Y memory and have to be copied in.
1601   
1602                                SELECT_OUTPUT_SOURCE
1603                                ;  a little bit of aliasing
1604      P:00032A P:00032A 56F400            MOVE              #'__L',A
                            5F5F4C
1605      P:00032C P:00032C 200045            CMP     X0,A
1606      P:00032D P:00032D 0AF0AA            JEQ     ALIAS_A
                            00033D
1607      P:00032F P:00032F 56F400            MOVE              #'__R',A
                            5F5F52
1608      P:000331 P:000331 200045            CMP     X0,A
1609      P:000332 P:000332 0AF0AA            JEQ     ALIAS_B
                            00039F
1610      P:000334 P:000334 56F400            MOVE              #'_LR',A
                            5F4C52
1611      P:000336 P:000336 200045            CMP     X0,A
1612      P:000337 P:000337 0AF0AA            JEQ     ALIAS_AB
                            0004C5
1613   
1614                                ; Set all the waveform addresses depending on which readout/binning mode
1615      P:000339 P:000339 56F400            MOVE              #'__A',A                ; LEFT Amplifier = readout #0
                            5F5F41
1616      P:00033B P:00033B 200045            CMP     X0,A
1617      P:00033C P:00033C 0E239B            JNE     <CMP_B
1618                                ALIAS_A
1619      P:00033D P:00033D 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1620      P:00033E P:00033E 46F400            MOVE              #ABCD_UP,Y0
                            000165
1621      P:000340 P:000340 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000F
1622      P:000342 P:000342 46F400            MOVE              #CD_UP,Y0
                            0001B0
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 30



1623      P:000344 P:000344 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            000010
1624      P:000346 P:000346 46F400            MOVE              #ABCD_CLEAR_UP,Y0
                            000186
1625      P:000348 P:000348 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            000011
1626      P:00034A P:00034A 46F400            MOVE              #CD_CLEAR_UP,Y0
                            0001C6
1627      P:00034C P:00034C 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000012
1628   
1629                                                                                    ; serials for general binning
1630      P:00034E P:00034E 46F400            MOVE              #SERIAL_SKIP_EH,Y0
                            0000E8
1631      P:000350 P:000350 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            00000B
1632      P:000352 P:000352 46F400            MOVE              #INITIAL_CLOCK_EH,Y0
                            000055
1633      P:000354 P:000354 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000E
1634      P:000356 P:000356 46F400            MOVE              #SERIAL_CLOCK_EH,Y0
                            00006A
1635      P:000358 P:000358 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000D
1636      P:00035A P:00035A 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000),Y0 ;
42
                            03200A
1637                                ;       MOVE    #(CLK2+$030000+000+000+000+000+H2L+H2R+000+000),Y0
1638      P:00035C P:00035C 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
1639                                ; 42
1640                                ;        MOVE    #$00F063,Y0             ; Channel 3 only
1641      P:00035E P:00035E 46F400            MOVE              #$00F0C3,Y0             ; Channel 3 only
                            00F0C3
1642      P:000360 P:000360 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
1643      P:000362 P:000362 4E7000            MOVE                          Y0,Y:SXMIT_EH_1 ; and into all the hard-coded binned cas
es in high Y
                            0001EE
1644      P:000364 P:000364 4E7000            MOVE                          Y0,Y:SXMIT_EH_2
                            00021E
1645      P:000366 P:000366 4E7000            MOVE                          Y0,Y:SXMIT_EH_3
                            000260
1646      P:000368 P:000368 4E7000            MOVE                          Y0,Y:SXMIT_EH_4
                            0002B4
1647   
1648      P:00036A P:00036A 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1649      P:00036B P:00036B 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1650                                ; Now go through copying in the serial read waveform if binning more than 4.
1651      P:00036C P:00036C 200013            CLR     A
1652      P:00036D P:00036D 20001B            CLR     B
1653      P:00036E P:00036E 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1654      P:000370 P:000370 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1655      P:000371 P:000371 50F400            MOVE              #>4,A0
                            000004
1656      P:000373 P:000373 200005            CMP     B,A
1657      P:000374 P:000374 0E9649            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1658      P:000375 P:000375 0D0656            JSR     <SET_BINBIT                       ; else set BINBIT
1659      P:000376 P:000376 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 31



1660      P:000377 P:000377 0A1E81  TRY_1_A   JCLR    #1,X:BINBIT,TRY_2_A
                            000380
1661                                ;       MOVE    #1,A0                   ; HACK
1662                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1663      P:000379 P:000379 51F400            MOVE              #(END_SERIAL_READ_EH_1-SERIAL_READ_EH_1),B0
                            00000E
1664      P:00037B P:00037B 60F400            MOVE              #SERIAL_READ_EH_1,R0    ; Here if H amp, bin by 1
                            0001E8
1665      P:00037D P:00037D 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1666      P:00037E P:00037E 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1667      P:00037F P:00037F 0C0649            JMP     <CMP_END
1668      P:000380 P:000380 0A1E82  TRY_2_A   JCLR    #2,X:BINBIT,TRY_3_A
                            000389
1669      P:000382 P:000382 51F400            MOVE              #(END_SERIAL_READ_EH_2-SERIAL_READ_EH_2),B0
                            000014
1670      P:000384 P:000384 60F400            MOVE              #SERIAL_READ_EH_2,R0    ; Here if H amp, bin by 2
                            000212
1671      P:000386 P:000386 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1672      P:000387 P:000387 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1673      P:000388 P:000388 0C0649            JMP     <CMP_END
1674      P:000389 P:000389 0A1E83  TRY_3_A   JCLR    #3,X:<BINBIT,TRY_4_A
                            000392
1675      P:00038B P:00038B 51F400            MOVE              #(END_SERIAL_READ_EH_3-SERIAL_READ_EH_3),B0
                            00001A
1676      P:00038D P:00038D 60F400            MOVE              #SERIAL_READ_EH_3,R0    ; Here if H amp, bin by 3
                            00024E
1677      P:00038F P:00038F 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1678      P:000390 P:000390 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1679      P:000391 P:000391 0C0649            JMP     <CMP_END
1680      P:000392 P:000392 0A1E84  TRY_4_A   JCLR    #4,X:BINBIT,CMP_ERROR
                            00064C
1681      P:000394 P:000394 51F400            MOVE              #(END_SERIAL_READ_EH_4-SERIAL_READ_EH_4),B0
                            000020
1682      P:000396 P:000396 60F400            MOVE              #SERIAL_READ_EH_4,R0    ; Here if H amp, bin by 4
                            00029C
1683      P:000398 P:000398 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1684      P:000399 P:000399 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1685      P:00039A P:00039A 0C0649            JMP     <CMP_END
1686   
1687      P:00039B P:00039B 56F400  CMP_B     MOVE              #'__B',A                ;  B Amplifier = e2v G amp = Leach channel #
2
                            5F5F42
1688      P:00039D P:00039D 200045            CMP     X0,A
1689      P:00039E P:00039E 0E23FD            JNE     <CMP_C
1690                                ALIAS_B
1691      P:00039F P:00039F 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1692      P:0003A0 P:0003A0 46F400            MOVE              #ABCD_UP,Y0
                            000165
1693      P:0003A2 P:0003A2 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000F
1694      P:0003A4 P:0003A4 46F400            MOVE              #CD_UP,Y0
                            0001B0
1695      P:0003A6 P:0003A6 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            000010
1696      P:0003A8 P:0003A8 46F400            MOVE              #ABCD_CLEAR_UP,Y0
                            000186
1697      P:0003AA P:0003AA 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            000011
1698      P:0003AC P:0003AC 46F400            MOVE              #CD_CLEAR_UP,Y0
                            0001C6
1699      P:0003AE P:0003AE 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000012
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 32



1700   
1701                                                                                    ; serials for general binning
1702      P:0003B0 P:0003B0 46F400            MOVE              #SERIAL_SKIP_FG,Y0
                            0000F0
1703      P:0003B2 P:0003B2 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            00000B
1704      P:0003B4 P:0003B4 46F400            MOVE              #INITIAL_CLOCK_FG,Y0
                            00005C
1705      P:0003B6 P:0003B6 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000E
1706      P:0003B8 P:0003B8 46F400            MOVE              #SERIAL_CLOCK_FG,Y0
                            000071
1707      P:0003BA P:0003BA 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000D
1708                                                                                    ; 42
1709      P:0003BC P:0003BC 46F400            MOVE              #(CLK2+$030000+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032011
1710                                ;       MOVE    #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),Y0
1711      P:0003BE P:0003BE 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
1712                                ;        MOVE    #$00F042,Y0             ; Channel 2 only
1713      P:0003C0 P:0003C0 46F400            MOVE              #$00F082,Y0             ; Channel 2 only
                            00F082
1714      P:0003C2 P:0003C2 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
1715      P:0003C4 P:0003C4 4E7000            MOVE                          Y0,Y:SXMIT_FG_1 ; and into all the hard-coded binned cas
es in high Y
                            0001FC
1716      P:0003C6 P:0003C6 4E7000            MOVE                          Y0,Y:SXMIT_FG_2
                            000232
1717      P:0003C8 P:0003C8 4E7000            MOVE                          Y0,Y:SXMIT_FG_3
                            00027A
1718      P:0003CA P:0003CA 4E7000            MOVE                          Y0,Y:SXMIT_FG_4
                            0002D4
1719   
1720      P:0003CC P:0003CC 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1721      P:0003CD P:0003CD 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1722                                ; Now go through copying in the serial read waveform if binning more than 4.
1723      P:0003CE P:0003CE 200013            CLR     A
1724      P:0003CF P:0003CF 20001B            CLR     B
1725      P:0003D0 P:0003D0 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1726      P:0003D2 P:0003D2 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1727      P:0003D3 P:0003D3 50F400            MOVE              #>4,A0
                            000004
1728      P:0003D5 P:0003D5 200005            CMP     B,A
1729      P:0003D6 P:0003D6 0E9649            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1730      P:0003D7 P:0003D7 0D0656            JSR     <SET_BINBIT                       ; else set BINBIT
1731      P:0003D8 P:0003D8 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1732      P:0003D9 P:0003D9 0A1E81  TRY_1_B   JCLR    #1,X:BINBIT,TRY_2_B
                            0003E2
1733                                ;       MOVE    #2,A0                   ; HACK
1734                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1735      P:0003DB P:0003DB 51F400            MOVE              #(END_SERIAL_READ_FG_1-SERIAL_READ_FG_1),B0
                            00000E
1736      P:0003DD P:0003DD 60F400            MOVE              #SERIAL_READ_FG_1,R0    ; Here if G amp, bin by 1
                            0001F6
1737      P:0003DF P:0003DF 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1738      P:0003E0 P:0003E0 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1739      P:0003E1 P:0003E1 0C0649            JMP     <CMP_END
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 33



1740      P:0003E2 P:0003E2 0A1E82  TRY_2_B   JCLR    #2,X:BINBIT,TRY_3_B
                            0003EB
1741      P:0003E4 P:0003E4 51F400            MOVE              #(END_SERIAL_READ_FG_2-SERIAL_READ_FG_2),B0
                            000014
1742      P:0003E6 P:0003E6 60F400            MOVE              #SERIAL_READ_FG_2,R0    ; Here if G amp, bin by 2
                            000226
1743      P:0003E8 P:0003E8 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1744      P:0003E9 P:0003E9 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1745      P:0003EA P:0003EA 0C0649            JMP     <CMP_END
1746      P:0003EB P:0003EB 0A1E83  TRY_3_B   JCLR    #3,X:BINBIT,TRY_4_B
                            0003F4
1747      P:0003ED P:0003ED 51F400            MOVE              #(END_SERIAL_READ_FG_3-SERIAL_READ_FG_3),B0
                            00001A
1748      P:0003EF P:0003EF 60F400            MOVE              #SERIAL_READ_FG_3,R0    ; Here if G amp, bin by 3
                            000268
1749      P:0003F1 P:0003F1 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1750      P:0003F2 P:0003F2 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1751      P:0003F3 P:0003F3 0C0649            JMP     <CMP_END
1752      P:0003F4 P:0003F4 0A1E84  TRY_4_B   JCLR    #4,X:BINBIT,CMP_ERROR
                            00064C
1753      P:0003F6 P:0003F6 51F400            MOVE              #(END_SERIAL_READ_FG_4-SERIAL_READ_FG_4),B0
                            000020
1754      P:0003F8 P:0003F8 60F400            MOVE              #SERIAL_READ_FG_4,R0    ; Here if G amp, bin by 4
                            0002BC
1755      P:0003FA P:0003FA 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1756      P:0003FB P:0003FB 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1757      P:0003FC P:0003FC 0C0649            JMP     <CMP_END
1758   
1759      P:0003FD P:0003FD 56F400  CMP_C     MOVE              #'__C',A                ;  C Amplifier = e2v E amp = Leach channel #
0
                            5F5F43
1760      P:0003FF P:0003FF 200045            CMP     X0,A
1761      P:000400 P:000400 0E245F            JNE     <CMP_D
1762      P:000401 P:000401 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1763      P:000402 P:000402 46F400            MOVE              #ABCD_DOWN,Y0
                            000170
1764      P:000404 P:000404 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000F
1765      P:000406 P:000406 46F400            MOVE              #AB_DOWN,Y0
                            0001BB
1766      P:000408 P:000408 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            000010
1767      P:00040A P:00040A 46F400            MOVE              #ABCD_CLEAR_DOWN,Y0
                            000194
1768      P:00040C P:00040C 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            000011
1769      P:00040E P:00040E 46F400            MOVE              #AB_CLEAR_DOWN,Y0
                            0001D4
1770      P:000410 P:000410 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000012
1771   
1772                                                                                    ; serials for general binning
1773      P:000412 P:000412 46F400            MOVE              #SERIAL_SKIP_EH,Y0
                            0000E8
1774      P:000414 P:000414 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            00000B
1775      P:000416 P:000416 46F400            MOVE              #INITIAL_CLOCK_EH,Y0
                            000055
1776      P:000418 P:000418 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000E
1777      P:00041A P:00041A 46F400            MOVE              #SERIAL_CLOCK_EH,Y0
                            00006A
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 34



1778      P:00041C P:00041C 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000D
1779                                                                                    ; 42
1780      P:00041E P:00041E 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000),Y0
                            03200A
1781                                ;       MOVE    #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),Y0
1782      P:000420 P:000420 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
1783                                ;        MOVE    #$00F000,Y0             ; Channel 0 only
1784      P:000422 P:000422 46F400            MOVE              #$00F000,Y0             ; Channel 0 only
                            00F000
1785      P:000424 P:000424 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
1786      P:000426 P:000426 4E7000            MOVE                          Y0,Y:SXMIT_EH_1 ; and into all the hard-coded binned cas
es in high Y
                            0001EE
1787      P:000428 P:000428 4E7000            MOVE                          Y0,Y:SXMIT_EH_2
                            00021E
1788      P:00042A P:00042A 4E7000            MOVE                          Y0,Y:SXMIT_EH_3
                            000260
1789      P:00042C P:00042C 4E7000            MOVE                          Y0,Y:SXMIT_EH_4
                            0002B4
1790   
1791      P:00042E P:00042E 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1792      P:00042F P:00042F 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1793                                ; Now go through copying in the serial read waveform if binning more than 4.
1794      P:000430 P:000430 200013            CLR     A
1795      P:000431 P:000431 20001B            CLR     B
1796      P:000432 P:000432 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1797      P:000434 P:000434 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1798      P:000435 P:000435 50F400            MOVE              #>4,A0
                            000004
1799      P:000437 P:000437 200005            CMP     B,A
1800      P:000438 P:000438 0E9649            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1801      P:000439 P:000439 0D0656            JSR     <SET_BINBIT                       ; else set BINBIT
1802      P:00043A P:00043A 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1803      P:00043B P:00043B 0A1E81  TRY_1_C   JCLR    #1,X:BINBIT,TRY_2_C
                            000444
1804                                ;       MOVE    #2,A0                   ; HACK
1805                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1806      P:00043D P:00043D 51F400            MOVE              #(END_SERIAL_READ_EH_1-SERIAL_READ_EH_1),B0
                            00000E
1807      P:00043F P:00043F 60F400            MOVE              #SERIAL_READ_EH_1,R0    ; Here if E amp, bin by 1
                            0001E8
1808      P:000441 P:000441 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1809      P:000442 P:000442 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1810      P:000443 P:000443 0C0649            JMP     <CMP_END
1811      P:000444 P:000444 0A1E82  TRY_2_C   JCLR    #2,X:BINBIT,TRY_3_C
                            00044D
1812      P:000446 P:000446 51F400            MOVE              #(END_SERIAL_READ_EH_2-SERIAL_READ_EH_2),B0
                            000014
1813      P:000448 P:000448 60F400            MOVE              #SERIAL_READ_EH_2,R0    ; Here if E amp, bin by 2
                            000212
1814      P:00044A P:00044A 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1815      P:00044B P:00044B 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1816      P:00044C P:00044C 0C0649            JMP     <CMP_END
1817      P:00044D P:00044D 0A1E83  TRY_3_C   JCLR    #3,X:BINBIT,TRY_4_C
                            000456
1818      P:00044F P:00044F 51F400            MOVE              #(END_SERIAL_READ_EH_3-SERIAL_READ_EH_3),B0
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 35



                            00001A
1819      P:000451 P:000451 60F400            MOVE              #SERIAL_READ_EH_3,R0    ; Here if E amp, bin by 3
                            00024E
1820      P:000453 P:000453 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1821      P:000454 P:000454 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1822      P:000455 P:000455 0C0649            JMP     <CMP_END
1823      P:000456 P:000456 0A1E84  TRY_4_C   JCLR    #4,X:BINBIT,CMP_ERROR
                            00064C
1824      P:000458 P:000458 51F400            MOVE              #(END_SERIAL_READ_EH_4-SERIAL_READ_EH_4),B0
                            000020
1825      P:00045A P:00045A 60F400            MOVE              #SERIAL_READ_EH_4,R0    ; Here if E amp, bin by 4
                            00029C
1826      P:00045C P:00045C 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1827      P:00045D P:00045D 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1828      P:00045E P:00045E 0C0649            JMP     <CMP_END
1829   
1830      P:00045F P:00045F 56F400  CMP_D     MOVE              #'__D',A                ;  D Amplifier = e2v F amp = Leach channel #
1
                            5F5F44
1831      P:000461 P:000461 200045            CMP     X0,A
1832      P:000462 P:000462 0E24C1            JNE     <CMP_AB
1833      P:000463 P:000463 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1834      P:000464 P:000464 46F400            MOVE              #ABCD_DOWN,Y0
                            000170
1835      P:000466 P:000466 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000F
1836      P:000468 P:000468 46F400            MOVE              #AB_DOWN,Y0
                            0001BB
1837      P:00046A P:00046A 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            000010
1838      P:00046C P:00046C 46F400            MOVE              #ABCD_CLEAR_DOWN,Y0
                            000194
1839      P:00046E P:00046E 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            000011
1840      P:000470 P:000470 46F400            MOVE              #AB_CLEAR_DOWN,Y0
                            0001D4
1841      P:000472 P:000472 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000012
1842   
1843                                                                                    ; serials for general binning
1844      P:000474 P:000474 46F400            MOVE              #SERIAL_SKIP_FG,Y0
                            0000F0
1845      P:000476 P:000476 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            00000B
1846      P:000478 P:000478 46F400            MOVE              #INITIAL_CLOCK_FG,Y0
                            00005C
1847      P:00047A P:00047A 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000E
1848      P:00047C P:00047C 46F400            MOVE              #SERIAL_CLOCK_FG,Y0
                            000071
1849      P:00047E P:00047E 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000D
1850                                                                                    ; 42
1851      P:000480 P:000480 46F400            MOVE              #(CLK2+$030000+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032011
1852                                ;       MOVE    #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),Y0
1853      P:000482 P:000482 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
1854                                ;        MOVE    #$00F021,Y0             ; Channel 1 only
1855      P:000484 P:000484 46F400            MOVE              #$00F041,Y0             ; Channel 1 only
                            00F041
1856      P:000486 P:000486 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 36



ning
                            000079
1857      P:000488 P:000488 4E7000            MOVE                          Y0,Y:SXMIT_FG_1 ; and into all the hard-coded binned cas
es in high Y
                            0001FC
1858      P:00048A P:00048A 4E7000            MOVE                          Y0,Y:SXMIT_FG_2
                            000232
1859      P:00048C P:00048C 4E7000            MOVE                          Y0,Y:SXMIT_FG_3
                            00027A
1860      P:00048E P:00048E 4E7000            MOVE                          Y0,Y:SXMIT_FG_4
                            0002D4
1861   
1862      P:000490 P:000490 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1863      P:000491 P:000491 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1864                                ; Now go through copying in the serial read waveform if binning more than 4.
1865      P:000492 P:000492 200013            CLR     A
1866      P:000493 P:000493 20001B            CLR     B
1867      P:000494 P:000494 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1868      P:000496 P:000496 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1869      P:000497 P:000497 50F400            MOVE              #>4,A0
                            000004
1870      P:000499 P:000499 200005            CMP     B,A
1871      P:00049A P:00049A 0E9649            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1872      P:00049B P:00049B 0D0656            JSR     <SET_BINBIT                       ; else set BINBIT
1873      P:00049C P:00049C 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1874      P:00049D P:00049D 0A1E81  TRY_1_D   JCLR    #1,X:BINBIT,TRY_2_D
                            0004A6
1875                                ;       MOVE    #2,A0                   ; HACK
1876                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1877      P:00049F P:00049F 51F400            MOVE              #(END_SERIAL_READ_FG_1-SERIAL_READ_FG_1),B0
                            00000E
1878      P:0004A1 P:0004A1 60F400            MOVE              #SERIAL_READ_FG_1,R0    ; Here if F amp, bin by 1
                            0001F6
1879      P:0004A3 P:0004A3 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1880      P:0004A4 P:0004A4 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1881      P:0004A5 P:0004A5 0C0649            JMP     <CMP_END
1882      P:0004A6 P:0004A6 0A1E82  TRY_2_D   JCLR    #2,X:BINBIT,TRY_3_D
                            0004AF
1883      P:0004A8 P:0004A8 51F400            MOVE              #(END_SERIAL_READ_FG_2-SERIAL_READ_FG_2),B0
                            000014
1884      P:0004AA P:0004AA 60F400            MOVE              #SERIAL_READ_FG_2,R0    ; Here if F amp, bin by 2
                            000226
1885      P:0004AC P:0004AC 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1886      P:0004AD P:0004AD 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1887      P:0004AE P:0004AE 0C0649            JMP     <CMP_END
1888      P:0004AF P:0004AF 0A1E83  TRY_3_D   JCLR    #3,X:BINBIT,TRY_4_D
                            0004B8
1889      P:0004B1 P:0004B1 51F400            MOVE              #(END_SERIAL_READ_FG_3-SERIAL_READ_FG_3),B0
                            00001A
1890      P:0004B3 P:0004B3 60F400            MOVE              #SERIAL_READ_FG_3,R0    ; Here if F amp, bin by 3
                            000268
1891      P:0004B5 P:0004B5 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1892      P:0004B6 P:0004B6 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1893      P:0004B7 P:0004B7 0C0649            JMP     <CMP_END
1894      P:0004B8 P:0004B8 0A1E84  TRY_4_D   JCLR    #4,X:BINBIT,CMP_ERROR
                            00064C
1895      P:0004BA P:0004BA 51F400            MOVE              #(END_SERIAL_READ_FG_4-SERIAL_READ_FG_4),B0
                            000020
1896      P:0004BC P:0004BC 60F400            MOVE              #SERIAL_READ_FG_4,R0    ; Here if F amp, bin by 4
                            0002BC
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 37



1897      P:0004BE P:0004BE 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1898      P:0004BF P:0004BF 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1899      P:0004C0 P:0004C0 0C0649            JMP     <CMP_END
1900   
1901      P:0004C1 P:0004C1 56F400  CMP_AB    MOVE              #'_AB',A                ;  AB Amplifier = e2v HG amp = Leach channel
s 2-3
                            5F4142
1902      P:0004C3 P:0004C3 200045            CMP     X0,A
1903      P:0004C4 P:0004C4 0E2523            JNE     <CMP_CD
1904                                ALIAS_AB
1905      P:0004C5 P:0004C5 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1906      P:0004C6 P:0004C6 46F400            MOVE              #ABCD_UP,Y0
                            000165
1907      P:0004C8 P:0004C8 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000F
1908      P:0004CA P:0004CA 46F400            MOVE              #CD_UP,Y0
                            0001B0
1909      P:0004CC P:0004CC 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            000010
1910      P:0004CE P:0004CE 46F400            MOVE              #ABCD_CLEAR_UP,Y0
                            000186
1911      P:0004D0 P:0004D0 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            000011
1912      P:0004D2 P:0004D2 46F400            MOVE              #CD_CLEAR_UP,Y0
                            0001C6
1913      P:0004D4 P:0004D4 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000012
1914   
1915      P:0004D6 P:0004D6 46F400            MOVE              #SERIAL_SKIP_SPLIT,Y0
                            0000F8
1916      P:0004D8 P:0004D8 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            00000B
1917      P:0004DA P:0004DA 46F400            MOVE              #INITIAL_CLOCK_SPLIT,Y0
                            00004E
1918      P:0004DC P:0004DC 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000E
1919      P:0004DE P:0004DE 46F400            MOVE              #SERIAL_CLOCK_SPLIT,Y0
                            000063
1920      P:0004E0 P:0004E0 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000D
1921                                ;       42
1922                                ;       MOVE    #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),Y0
1923      P:0004E2 P:0004E2 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032012
1924   
1925      P:0004E4 P:0004E4 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
1926                                ; MOVE    #$00F062,Y0             ; Channels 2-3
1927      P:0004E6 P:0004E6 46F400            MOVE              #$00F0C2,Y0             ; Channels 2-3
                            00F0C2
1928      P:0004E8 P:0004E8 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
1929      P:0004EA P:0004EA 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_1 ; and into all the hard-coded binned 
cases in high Y
                            00020A
1930      P:0004EC P:0004EC 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_2
                            000246
1931      P:0004EE P:0004EE 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_3
                            000294
1932      P:0004F0 P:0004F0 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_4
                            0002F4
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 38



1933   
1934   
1935      P:0004F2 P:0004F2 0A0025            BSET    #SPLIT_S,X:STATUS                 ; Serials split
1936      P:0004F3 P:0004F3 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; Parallels not split
1937   
1938                                ; Now go through copying in the serial read waveform if binning more than 4.
1939      P:0004F4 P:0004F4 200013            CLR     A
1940      P:0004F5 P:0004F5 20001B            CLR     B
1941      P:0004F6 P:0004F6 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1942      P:0004F8 P:0004F8 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1943      P:0004F9 P:0004F9 50F400            MOVE              #>4,A0
                            000004
1944      P:0004FB P:0004FB 200005            CMP     B,A
1945      P:0004FC P:0004FC 0E9649            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1946      P:0004FD P:0004FD 0D0656            JSR     <SET_BINBIT                       ; else set BINBIT
1947      P:0004FE P:0004FE 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1948      P:0004FF P:0004FF 0A1E81  TRY_1_AB  JCLR    #1,X:BINBIT,TRY_2_AB
                            000508
1949                                ;       MOVE    #3,A0                   ; HACK
1950                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1951      P:000501 P:000501 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                            00000E
1952      P:000503 P:000503 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if HG amp, bin by 1
                            000204
1953      P:000505 P:000505 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1954      P:000506 P:000506 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1955      P:000507 P:000507 0C0649            JMP     <CMP_END
1956      P:000508 P:000508 0A1E82  TRY_2_AB  JCLR    #2,X:BINBIT,TRY_3_AB
                            000511
1957      P:00050A P:00050A 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                            000014
1958      P:00050C P:00050C 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if HG amp, bin by 2
                            00023A
1959      P:00050E P:00050E 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1960      P:00050F P:00050F 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1961      P:000510 P:000510 0C0649            JMP     <CMP_END
1962      P:000511 P:000511 0A1E83  TRY_3_AB  JCLR    #3,X:BINBIT,TRY_4_AB
                            00051A
1963      P:000513 P:000513 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                            00001A
1964      P:000515 P:000515 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if HG amp, bin by 3
                            000282
1965      P:000517 P:000517 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1966      P:000518 P:000518 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1967      P:000519 P:000519 0C0649            JMP     <CMP_END
1968      P:00051A P:00051A 0A1E84  TRY_4_AB  JCLR    #4,X:BINBIT,CMP_ERROR
                            00064C
1969      P:00051C P:00051C 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                            000020
1970      P:00051E P:00051E 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if HG amp, bin by 4
                            0002DC
1971      P:000520 P:000520 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1972      P:000521 P:000521 0D064F            JSR     <WAVECPY                          ; Copy the waveform
1973      P:000522 P:000522 0C0649            JMP     <CMP_END
1974   
1975      P:000523 P:000523 56F400  CMP_CD    MOVE              #'_CD',A                ;  CD Amplifier = e2v EF amp = Leach channel
s 0-1
                            5F4344
1976      P:000525 P:000525 200045            CMP     X0,A
1977      P:000526 P:000526 0E2585            JNE     <CMP_BD
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 39



1978      P:000527 P:000527 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1979      P:000528 P:000528 46F400            MOVE              #ABCD_DOWN,Y0
                            000170
1980      P:00052A P:00052A 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000F
1981      P:00052C P:00052C 46F400            MOVE              #AB_DOWN,Y0
                            0001BB
1982      P:00052E P:00052E 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            000010
1983      P:000530 P:000530 46F400            MOVE              #ABCD_CLEAR_DOWN,Y0
                            000194
1984      P:000532 P:000532 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            000011
1985      P:000534 P:000534 46F400            MOVE              #AB_CLEAR_DOWN,Y0
                            0001D4
1986      P:000536 P:000536 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000012
1987   
1988      P:000538 P:000538 46F400            MOVE              #SERIAL_SKIP_SPLIT,Y0
                            0000F8
1989      P:00053A P:00053A 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            00000B
1990      P:00053C P:00053C 46F400            MOVE              #INITIAL_CLOCK_SPLIT,Y0
                            00004E
1991      P:00053E P:00053E 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000E
1992      P:000540 P:000540 46F400            MOVE              #SERIAL_CLOCK_SPLIT,Y0
                            000063
1993      P:000542 P:000542 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000D
1994                                ;       42
1995                                ;       MOVE    #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),Y0
1996      P:000544 P:000544 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032012
1997      P:000546 P:000546 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
1998   
1999                                ;        MOVE    #$00F020,Y0             ; Channels 0-1
2000      P:000548 P:000548 46F400            MOVE              #$00F040,Y0             ; Channels 0-1
                            00F040
2001      P:00054A P:00054A 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
2002      P:00054C P:00054C 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_1 ; and into all the hard-coded binned 
cases in high Y
                            00020A
2003      P:00054E P:00054E 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_2
                            000246
2004      P:000550 P:000550 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_3
                            000294
2005      P:000552 P:000552 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_4
                            0002F4
2006   
2007   
2008      P:000554 P:000554 0A0025            BSET    #SPLIT_S,X:STATUS                 ; Serials split
2009      P:000555 P:000555 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; Parallels not split
2010   
2011                                ; Now go through copying in the serial read waveform if binning more than 4.
2012      P:000556 P:000556 200013            CLR     A
2013      P:000557 P:000557 20001B            CLR     B
2014      P:000558 P:000558 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 40



2015      P:00055A P:00055A 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
2016      P:00055B P:00055B 50F400            MOVE              #>4,A0
                            000004
2017      P:00055D P:00055D 200005            CMP     B,A
2018      P:00055E P:00055E 0E9649            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
2019      P:00055F P:00055F 0D0656            JSR     <SET_BINBIT                       ; else set BINBIT
2020      P:000560 P:000560 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
2021      P:000561 P:000561 0A1E81  TRY_1_CD  JCLR    #1,X:BINBIT,TRY_2_CD
                            00056A
2022                                ;       MOVE    #3,A0                   ; HACK
2023                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
2024      P:000563 P:000563 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                            00000E
2025      P:000565 P:000565 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if EF amp, bin by 1
                            000204
2026      P:000567 P:000567 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2027      P:000568 P:000568 0D064F            JSR     <WAVECPY                          ; Copy the waveform
2028      P:000569 P:000569 0C0649            JMP     <CMP_END
2029      P:00056A P:00056A 0A1E82  TRY_2_CD  JCLR    #2,X:BINBIT,TRY_3_CD
                            000573
2030      P:00056C P:00056C 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                            000014
2031      P:00056E P:00056E 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if EF amp, bin by 2
                            00023A
2032      P:000570 P:000570 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2033      P:000571 P:000571 0D064F            JSR     <WAVECPY                          ; Copy the waveform
2034      P:000572 P:000572 0C0649            JMP     <CMP_END
2035      P:000573 P:000573 0A1E83  TRY_3_CD  JCLR    #3,X:BINBIT,TRY_4_CD
                            00057C
2036      P:000575 P:000575 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                            00001A
2037      P:000577 P:000577 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if EF amp, bin by 3
                            000282
2038      P:000579 P:000579 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2039      P:00057A P:00057A 0D064F            JSR     <WAVECPY                          ; Copy the waveform
2040      P:00057B P:00057B 0C0649            JMP     <CMP_END
2041      P:00057C P:00057C 0A1E84  TRY_4_CD  JCLR    #4,X:BINBIT,CMP_ERROR
                            00064C
2042      P:00057E P:00057E 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                            000020
2043      P:000580 P:000580 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if EF amp, bin by 4
                            0002DC
2044      P:000582 P:000582 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2045      P:000583 P:000583 0D064F            JSR     <WAVECPY                          ; Copy the waveform
2046      P:000584 P:000584 0C0649            JMP     <CMP_END
2047   
2048      P:000585 P:000585 56F400  CMP_BD    MOVE              #'_BD',A                ;  BD Amplifier = e2v FG amp = Leach channel
s 1-2
                            5F4244
2049      P:000587 P:000587 200045            CMP     X0,A                              ; Note that EH amplifier isn't possible - Le
ach channels 0 & 3
2050      P:000588 P:000588 0E25E7            JNE     <CMP_ALL                          ; are not adjacent so SXMIT doesn't work.
2051      P:000589 P:000589 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
2052      P:00058A P:00058A 46F400            MOVE              #ABCD_SPLIT,Y0
                            00017B
2053      P:00058C P:00058C 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000F
2054      P:00058E P:00058E 46F400            MOVE              #CD_UP,Y0
                            0001B0
2055      P:000590 P:000590 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            000010
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 41



2056      P:000592 P:000592 46F400            MOVE              #ABCD_CLEAR_SPLIT,Y0
                            0001A2
2057      P:000594 P:000594 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            000011
2058      P:000596 P:000596 46F400            MOVE              #CD_CLEAR_UP,Y0
                            0001C6
2059      P:000598 P:000598 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000012
2060   
2061      P:00059A P:00059A 46F400            MOVE              #SERIAL_SKIP_FG,Y0
                            0000F0
2062      P:00059C P:00059C 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            00000B
2063      P:00059E P:00059E 46F400            MOVE              #INITIAL_CLOCK_FG,Y0
                            00005C
2064      P:0005A0 P:0005A0 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000E
2065      P:0005A2 P:0005A2 46F400            MOVE              #SERIAL_CLOCK_FG,Y0
                            000071
2066      P:0005A4 P:0005A4 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000D
2067                                ;       42
2068                                ;       MOVE    #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),Y0
2069      P:0005A6 P:0005A6 46F400            MOVE              #(CLK2+$030000+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032011
2070      P:0005A8 P:0005A8 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
2071   
2072      P:0005AA P:0005AA 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; Serials not split
2073                                                                                    ;MOVE    #$00F041,Y0             ; Channels 
1-2
2074      P:0005AB P:0005AB 46F400            MOVE              #$00F081,Y0             ; Channels 1-2
                            00F081
2075      P:0005AD P:0005AD 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
2076      P:0005AF P:0005AF 4E7000            MOVE                          Y0,Y:SXMIT_FG_1 ; and into all the hard-coded binned cas
es in high Y
                            0001FC
2077      P:0005B1 P:0005B1 4E7000            MOVE                          Y0,Y:SXMIT_FG_2
                            000232
2078      P:0005B3 P:0005B3 4E7000            MOVE                          Y0,Y:SXMIT_FG_3
                            00027A
2079      P:0005B5 P:0005B5 4E7000            MOVE                          Y0,Y:SXMIT_FG_4
                            0002D4
2080   
2081   
2082      P:0005B7 P:0005B7 0A0026            BSET    #SPLIT_P,X:STATUS                 ; Parallels split
2083   
2084                                ; Now go through copying in the serial read waveform if binning more than 4.
2085      P:0005B8 P:0005B8 200013            CLR     A
2086      P:0005B9 P:0005B9 20001B            CLR     B
2087      P:0005BA P:0005BA 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
2088      P:0005BC P:0005BC 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
2089      P:0005BD P:0005BD 50F400            MOVE              #>4,A0
                            000004
2090      P:0005BF P:0005BF 200005            CMP     B,A
2091      P:0005C0 P:0005C0 0E9649            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
2092      P:0005C1 P:0005C1 0D0656            JSR     <SET_BINBIT                       ; else set BINBIT
2093      P:0005C2 P:0005C2 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 42



2094      P:0005C3 P:0005C3 0A1E81  TRY_1_BD  JCLR    #1,X:BINBIT,TRY_2_BD
                            0005CC
2095                                ;       MOVE    #3,A0                   ; HACK
2096                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
2097      P:0005C5 P:0005C5 51F400            MOVE              #(END_SERIAL_READ_FG_1-SERIAL_READ_FG_1),B0
                            00000E
2098      P:0005C7 P:0005C7 60F400            MOVE              #SERIAL_READ_FG_1,R0    ; Here if FG amp, bin by 1
                            0001F6
2099      P:0005C9 P:0005C9 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2100      P:0005CA P:0005CA 0D064F            JSR     <WAVECPY                          ; Copy the waveform
2101      P:0005CB P:0005CB 0C0649            JMP     <CMP_END
2102      P:0005CC P:0005CC 0A1E82  TRY_2_BD  JCLR    #2,X:BINBIT,TRY_3_BD
                            0005D5
2103      P:0005CE P:0005CE 51F400            MOVE              #(END_SERIAL_READ_FG_2-SERIAL_READ_FG_2),B0
                            000014
2104      P:0005D0 P:0005D0 60F400            MOVE              #SERIAL_READ_FG_2,R0    ; Here if FG amp, bin by 2
                            000226
2105      P:0005D2 P:0005D2 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2106      P:0005D3 P:0005D3 0D064F            JSR     <WAVECPY                          ; Copy the waveform
2107      P:0005D4 P:0005D4 0C0649            JMP     <CMP_END
2108      P:0005D5 P:0005D5 0A1E83  TRY_3_BD  JCLR    #3,X:BINBIT,TRY_4_BD
                            0005DE
2109      P:0005D7 P:0005D7 51F400            MOVE              #(END_SERIAL_READ_FG_3-SERIAL_READ_FG_3),B0
                            00001A
2110      P:0005D9 P:0005D9 60F400            MOVE              #SERIAL_READ_FG_3,R0    ; Here if FG amp, bin by 3
                            000268
2111      P:0005DB P:0005DB 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2112      P:0005DC P:0005DC 0D064F            JSR     <WAVECPY                          ; Copy the waveform
2113      P:0005DD P:0005DD 0C0649            JMP     <CMP_END
2114      P:0005DE P:0005DE 0A1E84  TRY_4_BD  JCLR    #4,X:BINBIT,CMP_ERROR
                            00064C
2115      P:0005E0 P:0005E0 51F400            MOVE              #(END_SERIAL_READ_FG_4-SERIAL_READ_FG_4),B0
                            000020
2116      P:0005E2 P:0005E2 60F400            MOVE              #SERIAL_READ_FG_4,R0    ; Here if FG amp, bin by 4
                            0002BC
2117      P:0005E4 P:0005E4 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2118      P:0005E5 P:0005E5 0D064F            JSR     <WAVECPY                          ; Copy the waveform
2119      P:0005E6 P:0005E6 0C0649            JMP     <CMP_END
2120   
2121      P:0005E7 P:0005E7 56F400  CMP_ALL   MOVE              #'ALL',A                ;  ABCD Amplifier = e2v EFGH amp = Leach cha
nnels 0-3
                            414C4C
2122      P:0005E9 P:0005E9 200045            CMP     X0,A
2123      P:0005EA P:0005EA 0E264C            JNE     <CMP_ERROR
2124      P:0005EB P:0005EB 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
2125      P:0005EC P:0005EC 46F400            MOVE              #ABCD_SPLIT,Y0
                            00017B
2126      P:0005EE P:0005EE 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000F
2127      P:0005F0 P:0005F0 46F400            MOVE              #CD_UP,Y0
                            0001B0
2128      P:0005F2 P:0005F2 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels; NA for split pa
rallels
                            000010
2129      P:0005F4 P:0005F4 46F400            MOVE              #ABCD_CLEAR_SPLIT,Y0
                            0001A2
2130      P:0005F6 P:0005F6 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            000011
2131      P:0005F8 P:0005F8 46F400            MOVE              #CD_CLEAR_UP,Y0
                            0001C6
2132      P:0005FA P:0005FA 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only; NA for split p
arallels
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 43



                            000012
2133   
2134      P:0005FC P:0005FC 46F400            MOVE              #SERIAL_SKIP_SPLIT,Y0
                            0000F8
2135      P:0005FE P:0005FE 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            00000B
2136      P:000600 P:000600 46F400            MOVE              #INITIAL_CLOCK_SPLIT,Y0
                            00004E
2137      P:000602 P:000602 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000E
2138      P:000604 P:000604 46F400            MOVE              #SERIAL_CLOCK_SPLIT,Y0
                            000063
2139      P:000606 P:000606 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000D
2140                                ;       42
2141                                ;       MOVE    #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),Y0
2142      P:000608 P:000608 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032012
2143   
2144      P:00060A P:00060A 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
2145                                ;        MOVE    #$00F060,Y0             ; All four channels
2146      P:00060C P:00060C 46F400            MOVE              #$00F0C0,Y0             ; All four channels
                            00F0C0
2147      P:00060E P:00060E 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
2148      P:000610 P:000610 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_1 ; and into all the hard-coded binned 
cases in high Y
                            00020A
2149      P:000612 P:000612 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_2
                            000246
2150      P:000614 P:000614 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_3
                            000294
2151      P:000616 P:000616 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_4
                            0002F4
2152   
2153   
2154      P:000618 P:000618 0A0025            BSET    #SPLIT_S,X:<STATUS                ; Serials split
2155      P:000619 P:000619 0A0026            BSET    #SPLIT_P,X:<STATUS                ; Parallels split
2156   
2157                                ; Now go through copying in the serial read waveform if binning more than 4.
2158      P:00061A P:00061A 200013            CLR     A
2159      P:00061B P:00061B 20001B            CLR     B
2160      P:00061C P:00061C 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
2161      P:00061E P:00061E 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
2162      P:00061F P:00061F 50F400            MOVE              #>4,A0
                            000004
2163      P:000621 P:000621 200005            CMP     B,A
2164      P:000622 P:000622 0E9649            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
2165      P:000623 P:000623 0D0656            JSR     <SET_BINBIT                       ; else set BINBIT
2166      P:000624 P:000624 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
2167      P:000625 P:000625 0A1E81  TRY_1_ALL JCLR    #1,X:BINBIT,TRY_2_ALL
                            00062E
2168                                ;       MOVE    #3,A0                   ; HACK
2169                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
2170      P:000627 P:000627 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                            00000E
2171      P:000629 P:000629 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if ALL amp, bin by 1
                            000204
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 44



2172      P:00062B P:00062B 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2173      P:00062C P:00062C 0D064F            JSR     <WAVECPY                          ; Copy the waveform
2174      P:00062D P:00062D 0C0649            JMP     <CMP_END
2175      P:00062E P:00062E 0A1E82  TRY_2_ALL JCLR    #2,X:BINBIT,TRY_3_ALL
                            000637
2176      P:000630 P:000630 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                            000014
2177      P:000632 P:000632 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if ALL amp, bin by 2
                            00023A
2178      P:000634 P:000634 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2179      P:000635 P:000635 0D064F            JSR     <WAVECPY                          ; Copy the waveform
2180      P:000636 P:000636 0C0649            JMP     <CMP_END
2181      P:000637 P:000637 0A1E83  TRY_3_ALL JCLR    #3,X:BINBIT,TRY_4_ALL
                            000640
2182      P:000639 P:000639 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                            00001A
2183      P:00063B P:00063B 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if ALL amp, bin by 3
                            000282
2184      P:00063D P:00063D 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2185      P:00063E P:00063E 0D064F            JSR     <WAVECPY                          ; Copy the waveform
2186      P:00063F P:00063F 0C0649            JMP     <CMP_END
2187      P:000640 P:000640 0A1E84  TRY_4_ALL JCLR    #4,X:BINBIT,CMP_ERROR
                            00064C
2188      P:000642 P:000642 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                            000020
2189      P:000644 P:000644 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if ALL amp, bin by 4
                            0002DC
2190      P:000646 P:000646 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2191      P:000647 P:000647 0D064F            JSR     <WAVECPY                          ; Copy the waveform
2192      P:000648 P:000648 0C0649            JMP     <CMP_END
2193   
2194   
2195                                ;       returns modified as per "Four points", #1
2196      P:000649 P:000649 47F400  CMP_END   MOVE              #'DON',Y1
                            444F4E
2197      P:00064B P:00064B 00000C            RTS
2198                                CMP_ERROR
2199      P:00064C P:00064C 47F400            MOVE              #'ERR',Y1
                            455252
2200      P:00064E P:00064E 00000C            RTS
2201   
2202                                ; Short function to copy in waveforms from high Y to fast Y memory.
2203                                ; R0 is the source address, R7 the destination, and X0 is intermediary reg.
2204                                WAVECPY
2205      P:00064F P:00064F 06C900            DO      B0,WAVELP                         ; Copy the waveform; B0 is SERWAVLEN already
                            000653
2206      P:000651 P:000651 4CD800            MOVE                          Y:(R0)+,X0
2207      P:000652 P:000652 4C5F00            MOVE                          X0,Y:(R7)+
2208      P:000653 P:000653 000000            NOP
2209                                WAVELP
2210      P:000654 P:000654 000000            NOP
2211      P:000655 P:000655 00000C            RTS
2212   
2213                                ; Short function to set the correct bit in BINBIT based on NSBIN
2214                                ; Called only if NSBIN is less than 6.
2215   
2216                                SET_BINBIT
2217                                ;       MOVE    Y:<TESTLOC1,A0                  ; HACK - test if this code is executed
2218                                ;       INC     A                               ; HACK
2219                                ;       MOVE    A0,Y:<TESTLOC1                  ; HACK
2220      P:000656 P:000656 50F400            MOVE              #>1,A0                  ; Put a bit in A and shift to right spot
                            000001
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 45



2221      P:000658 P:000658 060540            DO      Y:<NSBIN,BINLOOP                  ; Bit zero position not used, 1-5 used
                            00065A
2222      P:00065A P:00065A 200032            ASL     A
2223                                BINLOOP
2224      P:00065B P:00065B 507000            MOVE              A0,X:BINBIT             ; set bit 1-5 for SELECT_OUTPUT_SOURCE jump 
table
                            00001E
2225      P:00065D P:00065D 00000C            RTS
2226   
2227   
2228                                ; Set the number of rows and columns and binning factors
2229                                ;       Correct command ptr to R3 as per "Four Points" #2
2230                                SET_ROWS_COLUMNS
2231      P:00065E P:00065E 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NSR = NAXIS1
2232      P:00065F P:00065F 4C7000            MOVE                          X0,Y:NSR
                            000001
2233      P:000661 P:000661 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NPR = NAXIS2
2234      P:000662 P:000662 4C7000            MOVE                          X0,Y:NPR
                            000002
2235      P:000664 P:000664 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NSBIN
2236      P:000665 P:000665 4C7000            MOVE                          X0,Y:NSBIN
                            000005
2237      P:000667 P:000667 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NPBIN
2238      P:000668 P:000668 4C7000            MOVE                          X0,Y:NPBIN
                            000006
2239      P:00066A P:00066A 4CBD00            MOVE                          Y:<AMPVAL,X0 ; Get ampval in X0 for SOS call
2240      P:00066B P:00066B 0D032A            JSR     <SELECT_OUTPUT_SOURCE             ; Update serial read waveform in case binnin
g changed
2241      P:00066C P:00066C 0C008F            JMP     <FINISH                           ; no error return possible
2242   
2243                                ; Set the variables for the time-resolved modes
2244                                ;       Correct command ptr to R3 as per "Four Points" #2
2245                                SET_IMAGE_PARAM
2246      P:00066D P:00066D 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Image mode
2247      P:00066E P:00066E 447000            MOVE              X0,X:IMAGE_MODE
                            000080
2248      P:000670 P:000670 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Iframes = NAXIS3
2249      P:000671 P:000671 4C7000            MOVE                          X0,Y:IFRAMES
                            00003A
2250      P:000673 P:000673 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Srows
2251      P:000674 P:000674 4C7000            MOVE                          X0,Y:SROWS
                            000038
2252      P:000676 P:000676 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Interval
2253                                ;       MOVE    X0,Y:INTERVAL           ; HACK - Using Interval as a test location
2254      P:000677 P:000677 0C008F            JMP     <FINISH
2255   
2256   
2257                                ; Set the hardware trigger bit, executed as a command
2258                                ;       Correct command ptr to R3 as per "Four Points" #2
2259                                ; Disable h/w trigger and return error (for now) as per June 30, #8
2260                                ; Disabled temporarily for LMI as well.
2261                                SET_TRIGGER
2262      P:000678 P:000678 44DB00            MOVE              X:(R3)+,X0              ; Get the trigger value
2263      P:000679 P:000679 56F400            MOVE              #'_ON',A
                            5F4F4E
2264      P:00067B P:00067B 200045            CMP     X0,A
2265      P:00067C P:00067C 0AF0A2            JNE     NO_TRIGGER
                            00067F
2266                                ;       JSET    #11,X:PBD,TRIG_CLR      ; Is Trigger running?
2267      P:00067E P:00067E 0C008D            JMP     <ERROR                            ; Yes! report Error!  Why do this?
2268                                ;TRIG_CLR
2269                                ;       BSET    #TRIGGER,X:<STATUS      ; Set status bit, hardware trigger
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 46



2270                                ;       JMP     <FINISH
2271                                NO_TRIGGER
2272      P:00067F P:00067F 0A0008            BCLR    #TRIGGER,X:<STATUS                ; Clear Status bit, software timing
2273      P:000680 P:000680 0C008F            JMP     <FINISH
2274   
2275                                ; Calculate the fast read parameters for each readout box
2276                                SETUP_SUBROUTINE
2277      P:000681 P:000681 4C8C00            MOVE                          Y:<SERWAVLEN,X0 ; # of waveforms
2278      P:000682 P:000682 4D9300            MOVE                          Y:<NSERIALS_READ,X1 ; Number of pixels to read
2279      P:000683 P:000683 0D0783            JSR     <FASTSKP                          ; Compute number of clocks required
2280      P:000684 P:000684 4D1600            MOVE                          X1,Y:<NREAD ; Number of waveforms per line
2281      P:000685 P:000685 5E9D00            MOVE                          Y:<NR_BIAS,A ; Number of pixels to read
2282      P:000686 P:000686 0A0085            JCLR    #SPLIT_S,X:STATUS,USPLS           ; Split serials require / 2
                            00068A
2283      P:000688 P:000688 200022            ASR     A
2284      P:000689 P:000689 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2285                                USPLS
2286      P:00068A P:00068A 21C500            MOVE              A,X1                    ; Number of waveforms per line
2287      P:00068B P:00068B 0D0783            JSR     <FASTSKP                          ; Compute number of clocks required
2288      P:00068C P:00068C 4D1800            MOVE                          X1,Y:<NBIAS ; Number of waveforms per line
2289      P:00068D P:00068D 44F400            MOVE              #(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT),X0 ; # of waveforms
                            000007
2290      P:00068F P:00068F 4D8300            MOVE                          Y:<NS_CLR,X1 ; Number of pixels to skip
2291      P:000690 P:000690 0D0783            JSR     <FASTSKP                          ; Compute number of clocks required
2292      P:000691 P:000691 4D1400            MOVE                          X1,Y:<NSCLR ; Number of waveforms per line
2293      P:000692 P:000692 4D9A00            MOVE                          Y:<NS_SKP1,X1 ; Number of pixels to skip
2294      P:000693 P:000693 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
2295      P:000694 P:000694 2000F0            MPY     Y1,X1,A
2296      P:000695 P:000695 200022            ASR     A
2297      P:000696 P:000696 210500            MOVE              A0,X1
2298      P:000697 P:000697 0D0783            JSR     <FASTSKP                          ; Compute number of clocks required
2299      P:000698 P:000698 4D1500            MOVE                          X1,Y:<NSKIP1 ; Number of waveforms per line
2300      P:000699 P:000699 4D9B00            MOVE                          Y:<NS_SKP2,X1 ; Number of pixels to skip
2301      P:00069A P:00069A 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
2302      P:00069B P:00069B 2000F0            MPY     Y1,X1,A
2303      P:00069C P:00069C 200022            ASR     A
2304      P:00069D P:00069D 210500            MOVE              A0,X1
2305      P:00069E P:00069E 0D0783            JSR     <FASTSKP                          ; Compute number of clocks required
2306      P:00069F P:00069F 4D1700            MOVE                          X1,Y:<NSKIP2 ; Number of waveforms per line
2307      P:0006A0 P:0006A0 4D9900            MOVE                          Y:<NP_SKIP,X1
2308      P:0006A1 P:0006A1 4F8600            MOVE                          Y:<NPBIN,Y1
2309      P:0006A2 P:0006A2 2000F0            MPY     X1,Y1,A
2310      P:0006A3 P:0006A3 200022            ASR     A
2311      P:0006A4 P:0006A4 581900            MOVE                          A0,Y:<NP_SKIP
2312      P:0006A5 P:0006A5 00000C            RTS
2313   
2314                                ; Returns immediately if hardware triggering is not being used
2315                                ; Blocks until the trigger is found to be high twice in a row.
2316                                ; Waits until the trigger goes high
2317                                ; Trigger support disabled temporarily for LMI as well.
2318                                WAIT_UNTIL_TRIGGER
2319      P:0006A6 P:0006A6 0A0088            JCLR    #TRIGGER,X:STATUS,UNTIL_TRIGGER_RETURN
                            0006AB
2320      P:0006A8 P:0006A8 000000            NOP
2321                                ;       JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER       ; Is Trigger Low?
2322      P:0006A9 P:0006A9 000000            NOP                                       ; Pause
2323                                ;       JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER       ; Is Trigger still Low?
2324      P:0006AA P:0006AA 000000            NOP
2325                                UNTIL_TRIGGER_RETURN
2326      P:0006AB P:0006AB 00000C            RTS
2327   
2328                                ; Returns immediately if hardware triggering is not being used
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 47



2329                                ; Blocks until the trigger is found to be low twice in a row.
2330                                ; Waits while the trigger is high
2331                                ; Trigger support disabled temporarily for LMI as well.
2332                                WAIT_WHILE_TRIGGER
2333      P:0006AC P:0006AC 0A0088            JCLR    #TRIGGER,X:STATUS,WHILE_TRIGGER_RETURN
                            0006B1
2334      P:0006AE P:0006AE 000000            NOP
2335                                ;       JSET    #11,X:PBD,WAIT_WHILE_TRIGGER       ; Is Trigger High?
2336      P:0006AF P:0006AF 000000            NOP                                       ; Pause
2337                                ;       JSET    #11,X:PBD,WAIT_WHILE_TRIGGER       ; Is Trigger still High?
2338      P:0006B0 P:0006B0 000000            NOP
2339                                WHILE_TRIGGER_RETURN
2340      P:0006B1 P:0006B1 00000C            RTS
2341   
2342                                ; Like WAIT_WHILE_TRIGGER but clears the CCD while waiting
2343                                ; Pro:  Clears CCD while waiting.  Con: timing rattiness of 1 parallel time
2344                                ; Returns immediately if hardware triggering is not being used
2345                                ; Blocks until the trigger is found to be low twice in a row.
2346                                ; Waits while the trigger is high
2347                                ; Trigger support disabled temporarily for LMI as well.
2348                                CLEAR_WHILE_TRIGGER
2349      P:0006B2 P:0006B2 0A0088            JCLR    #TRIGGER,X:STATUS,CLEAR_TRIG_RETURN
                            0006B6
2350                                ;       MOVE    #IS_PAR_CLR,R0          ; Address of parallel transfer waveform
2351                                ;       JSR     <CLOCK                  ; Go clock out the CCD charge
2352                                ;       JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER       ; Is Trigger High?
2353      P:0006B4 P:0006B4 000000            NOP                                       ; Pause
2354                                ;       JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER      ; Is Trigger still High?
2355      P:0006B5 P:0006B5 000000            NOP
2356                                CLEAR_TRIG_RETURN
2357      P:0006B6 P:0006B6 00000C            RTS
2358   
2359                                ; Subroutine to compute SROWS in unbinned pixels and store in UBSROWS
2360   
2361                                UB_CONV
2362      P:0006B7 P:0006B7 4CB800            MOVE                          Y:<SROWS,X0
2363      P:0006B8 P:0006B8 4D8600            MOVE                          Y:<NPBIN,X1 ; Adjust for for parallel binning factor
2364      P:0006B9 P:0006B9 2000A0            MPY     X0,X1,A
2365      P:0006BA P:0006BA 200022            ASR     A
2366      P:0006BB P:0006BB 583900            MOVE                          A0,Y:<UBSROWS ; Put unbinned number in UBSROWS
2367      P:0006BC P:0006BC 00000C            RTS
2368   
2369                                ; Key code segments for the HIPO modes.
2370                                ; Jump table to the various modes - see also timhdr.s
2371                                START_FT_EXPOSURE
2372      P:0006BD P:0006BD 0A0008            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of lingering abort flag
2373      P:0006BE P:0006BE 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2374      P:0006C0 P:0006C0 0AC421            JSET    #FIND,X0,SINGLE_PROC
                            0006F5
2375      P:0006C2 P:0006C2 0AC424            JSET    #SINGLE,X0,SINGLE_PROC
                            0006F5
2376                                ;       JSET    #SERIES,X0,SERIES_PROC        ; defunct.  Use basic occ.
2377      P:0006C4 P:0006C4 0AC420            JSET    #FDOTS,X0,FDOT_PROC
                            0006CF
2378      P:0006C6 P:0006C6 0AC422            JSET    #SDOTS,X0,SDOT_PROC               ; slow dots & strips use sdot_proc
                            00072D
2379      P:0006C8 P:0006C8 0AC425            JSET    #STRIP,X0,SDOT_PROC
                            00072D
2380      P:0006CA P:0006CA 0AC427            JSET    #B_OCC,X0,SINGLE_PROC             ; basic occ uses single_proc
                            0006F5
2381                                ;        JSET    #F_OCC,X0,FPO_PROC             ; fast & pipelined occ use occ_proc
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 48



2382                                ;        JSET    #P_OCC,X0,FPO_PROC
2383      P:0006CC P:0006CC 44F400            MOVE              #'ERR',X0               ; error if not a valid mode
                            455252
2384      P:0006CE P:0006CE 0C008D            JMP     <ERROR
2385   
2386                                FDOT_PROC                                           ; used by fdots only
2387                                ; Start by replacing SROWS (binned rows) with unbinned rows.  Will get rewritten on next SEX com
mand
2388                                ; Leave the DO loop in here - no reason to change it - won't exceed 65535 dots, for sure!
2389      P:0006CF P:0006CF 0D06B7            JSR     UB_CONV                           ; Fill in unbinned SROWS
2390      P:0006D0 P:0006D0 4C8200            MOVE                          Y:<NPR,X0
2391      P:0006D1 P:0006D1 4C1F00            MOVE                          X0,Y:<NP_READ ; Make sure that NP_READ=NPR in case of su
bframe
2392      P:0006D2 P:0006D2 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
2393      P:0006D3 P:0006D3 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for FDOTS
2394      P:0006D4 P:0006D4 0A2020            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe bou
ndary
2395      P:0006D5 P:0006D5 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            000757
2396      P:0006D7 P:0006D7 0D02F9            JSR     <CLR_CCD                          ; Clear out the CCD
2397      P:0006D8 P:0006D8 0D06AC            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2398                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2399      P:0006D9 P:0006D9 0D0799            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2400      P:0006DA P:0006DA 063A40            DO      Y:<IFRAMES,FDOT_LOOP              ; Loop over the number of FDOTS
                            0006EB
2401      P:0006DC P:0006DC 0A00A8            JSET    #TRIGGER,X:STATUS,FDX_END         ; If no triggering jump to expose image func
tion
                            0006E2
2402      P:0006DE P:0006DE 67F400            MOVE              #FDX_END,R7             ; Store the Address into R7
                            0006E2
2403      P:0006E0 P:0006E0 0A0027            BSET    #ST_EXP,X:<STATUS
2404      P:0006E1 P:0006E1 0C0313            JMP     <EXPOSE                           ; Delay for specified exposure time
2405                                FDX_END
2406      P:0006E2 P:0006E2 0A0007            BCLR    #ST_EXP,X:<STATUS
2407      P:0006E3 P:0006E3 0A0088            JCLR    #ST_ABRT,X:<STATUS,FDX_NXT        ; got abort underway?
                            0006E7
2408      P:0006E5 P:0006E5 00008C            ENDDO
2409      P:0006E6 P:0006E6 0C06F3            JMP     <FDOT_FINI
2410                                FDX_NXT
2411      P:0006E7 P:0006E7 0D06A6            JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2412      P:0006E8 P:0006E8 4DB900            MOVE                          Y:<UBSROWS,X1 ; Number of unbinned rows per shift
2413      P:0006E9 P:0006E9 0D076A            JSR     <ISHIFT                           ; Clock out the waveforms
2414      P:0006EA P:0006EA 0D06AC            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2415      P:0006EB P:0006EB 000000            NOP
2416                                FDOT_LOOP
2417      P:0006EC P:0006EC 0D079F            JSR     <C_CSHUT                          ; Conditionally close shutter
2418      P:0006ED P:0006ED 063A40            DO      Y:<IFRAMES,FDOT_LP1               ; Loop over the number of FDOTS during reado
ut
                            0006F2
2419      P:0006EF P:0006EF 0A0024            BSET    #ST_RDC,X:<STATUS
2420      P:0006F0 P:0006F0 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD
2421      P:0006F1 P:0006F1 0A0004            BCLR    #ST_RDC,X:<STATUS
2422      P:0006F2 P:0006F2 000000            NOP
2423                                FDOT_LP1
2424                                FDOT_FINI
2425                                ;       CLOSE SHUTTER if abt??
2426                                ;       JSR     <WAIT_UNTIL_TRIGGER             ; If taking more than one set of dots sync. trig
ger.  Vestigial?
2427      P:0006F3 P:0006F3 0AF080            JMP     CLEANUP                           ; clean up after command.
                            00075F
2428   
2429                                SINGLE_PROC                                         ; Used by find, single, and basic occ
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 49



2430      P:0006F5 P:0006F5 0A2001            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for find & basic occ
2431      P:0006F6 P:0006F6 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2432      P:0006F8 P:0006F8 0AC404            JCLR    #SINGLE,X0,NOT_SINGM              ; But if single mode,
                            0006FB
2433      P:0006FA P:0006FA 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
2434                                NOT_SINGM
2435   
2436                                ; Note: LMI uses both storage and img area for singles for maximum frame.
2437      P:0006FB P:0006FB 0A2002            BCLR    #STORAGE,X:<ISTATUS               ; Do the FT, no storage clocks only during r
eadout
2438      P:0006FC P:0006FC 0AC427            JSET    #B_OCC,X0,AN_OCC                  ; STORAGE=0 for basic, 1 otherwise
                            0006FF
2439      P:0006FE P:0006FE 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't do the FT, ganged clocks only during
 readout
2440                                AN_OCC
2441   
2442      P:0006FF P:0006FF 0A2000            BCLR    #NO_SKIP,X:<ISTATUS               ; Do parallel skip up to the subframe bounda
ry
2443                                          IF      @SCP("10","0")
2444                                          ELSE
2445      P:000700 P:000700 060A80            DO      #SDELAY,SNGL_DELAY1
                            000707
2446      P:000702 P:000702 44F400            MOVE              #25000,X0
                            0061A8
2447      P:000704 P:000704 06C400            DO      X0,SNGL_DELAY0
                            000706
2448      P:000706 P:000706 000000            NOP
2449                                 SNGL_DELAY0
2450      P:000707 P:000707 000000            NOP
2451                                 SNGL_DELAY1
2452      P:000708 P:000708 000000            NOP
2453                                          ENDIF
2454   
2455      P:000709 P:000709 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            000757
2456      P:00070B P:00070B 0D02F9            JSR     <CLR_CCD                          ; Clear out the CCD
2457      P:00070C P:00070C 0D06AC            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2458                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2459      P:00070D P:00070D 4CBA00            MOVE                          Y:<IFRAMES,X0
2460      P:00070E P:00070E 4C3E00            MOVE                          X0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
2461      P:00070F P:00070F 0D0799  SN_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2462                                ;        JSET    #TRIGGER,X:STATUS,SNX_END       ; If no triggering jump to expose image functio
n
2463      P:000710 P:000710 67F400            MOVE              #SNX_END,R7             ; Store the Address into R7
                            000714
2464      P:000712 P:000712 0A0027            BSET    #ST_EXP,X:<STATUS
2465      P:000713 P:000713 0C0313            JMP     <EXPOSE                           ; Delay for specified exposure time
2466                                SNX_END
2467      P:000714 P:000714 0A0007            BCLR    #ST_EXP,X:<STATUS
2468      P:000715 P:000715 0A00A8            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                            000726
2469   
2470      P:000717 P:000717 0D06A6            JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2471      P:000718 P:000718 0D079F            JSR     <C_CSHUT                          ; Close shutter if open-close bit is set
2472      P:000719 P:000719 0A0024            BSET    #ST_RDC,X:<STATUS
2473      P:00071A P:00071A 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD
2474      P:00071B P:00071B 0A0004            BCLR    #ST_RDC,X:<STATUS
2475      P:00071C P:00071C 0D06AC            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2476      P:00071D P:00071D 0A00A8            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                            000726
2477      P:00071F P:00071F 200013            CLR     A
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 50



2478      P:000720 P:000720 58BE00            MOVE                          Y:<IFLPCNT,A0
2479      P:000721 P:000721 00000A            DEC     A                                 ; Get loop count, decrement, and loop till z
ero
2480      P:000722 P:000722 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2481      P:000723 P:000723 583E00            MOVE                          A0,Y:<IFLPCNT
2482      P:000724 P:000724 200003            TST     A
2483      P:000725 P:000725 0E270F            JNE     SN_LP                             ; End of IFRAMES loop
2484                                SNX_FINI
2485      P:000726 P:000726 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2486                                                                                    ; if you abort a find does the shutter close
?
2487      P:000728 P:000728 0AC421            JSET    #FIND,X0,SNX_DONE
                            00072B
2488      P:00072A P:00072A 0D07A1            JSR     <CSHUT                            ; Close the shutter unless in find mode
2489                                SNX_DONE
2490      P:00072B P:00072B 0AF080            JMP     CLEANUP                           ; clean up after command.
                            00075F
2491   
2492                                ; NO abort support
2493                                SDOT_PROC                                           ; Used by slow dots and strips
2494      P:00072D P:00072D 4CB800            MOVE                          Y:<SROWS,X0
2495      P:00072E P:00072E 4C1F00            MOVE                          X0,Y:<NP_READ ; Make sure that NP_READ=SROWS
2496      P:00072F P:00072F 0A2001            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for strips
2497      P:000730 P:000730 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2498      P:000732 P:000732 0AC402            JCLR    #SDOTS,X0,SDOT_STORE              ; But if sdots mode,
                            000735
2499      P:000734 P:000734 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
2500                                SDOT_STORE
2501      P:000735 P:000735 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for SDOTS an
d strips
2502      P:000736 P:000736 0A2020            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe bou
ndary
2503      P:000737 P:000737 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            000757
2504      P:000739 P:000739 0D02F9            JSR     <CLR_CCD                          ; Clear out the CCD
2505      P:00073A P:00073A 0D06AC            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2506                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2507      P:00073B P:00073B 4CBA00            MOVE                          Y:<IFRAMES,X0
2508      P:00073C P:00073C 4C3E00            MOVE                          X0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
2509      P:00073D P:00073D 0D0799  SD_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2510      P:00073E P:00073E 0A00A8            JSET    #TRIGGER,X:STATUS,SDX_END         ; If no triggering jump to expose image func
tion
                            000747
2511      P:000740 P:000740 67F400            MOVE              #SDX_END,R7             ; Store the Address into R7
                            000747
2512      P:000742 P:000742 0A0027            BSET    #ST_EXP,X:<STATUS
2513      P:000743 P:000743 0C0313            JMP     <EXPOSE                           ; Delay for specified exposure time
2514      P:000744 P:000744 0A0007            BCLR    #ST_EXP,X:<STATUS
2515      P:000745 P:000745 0A00A8            JSET    #ST_ABRT,X:<STATUS,SDX_FINI       ; got abort underway?
                            000754
2516      P:000747 P:000747 0D06A6  SDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2517      P:000748 P:000748 0D079F            JSR     <C_CSHUT                          ; Close shutter if open-close is set
2518      P:000749 P:000749 0A0024            BSET    #ST_RDC,X:<STATUS
2519      P:00074A P:00074A 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD.
2520      P:00074B P:00074B 0A0004            BCLR    #ST_RDC,X:<STATUS
2521                                                                                    ; No FT or parallel skip since STORAGE=1
2522      P:00074C P:00074C 0D06AC            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2523      P:00074D P:00074D 200013            CLR     A
2524      P:00074E P:00074E 58BE00            MOVE                          Y:<IFLPCNT,A0
2525      P:00074F P:00074F 00000A            DEC     A                                 ; Get loop count, decrement, and loop till z
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 51



ero
2526      P:000750 P:000750 000000            NOP
2527      P:000751 P:000751 583E00            MOVE                          A0,Y:<IFLPCNT
2528      P:000752 P:000752 200003            TST     A
2529      P:000753 P:000753 0E273D            JNE     SD_LP                             ; End of IFRAMES loop
2530                                SDX_FINI
2531      P:000754 P:000754 0D07A1            JSR     <CSHUT                            ; Unconditionally close shutter
2532      P:000755 P:000755 0AF080            JMP     CLEANUP                           ; clean up after command.
                            00075F
2533   
2534                                ; Fast/Pipeline Occultations NOT supported- LMI isn't a fast camera
2535                                        COMMENT *
2536   
2537                                FPO_PROC                                        ; Used by fast and pipelined occultation modes
2538                                        MOVE    Y:<NP_READ,X0
2539                                        MOVE    X0,Y:<SROWS                     ; Make sure that SROWS=NP_READ
2540                                        JSR     UB_CONV                         ; Fill in unbinned SROWS in UBSROWS
2541                                        BCLR    #OPEN_CLOSE,X:<ISTATUS          ; clear open-close for both of these modes
2542                                        BCLR    #STORAGE,X:<ISTATUS             ; Storage clocks only during readout
2543                                        BSET    #NO_SKIP,X:<ISTATUS             ; Don't parallel skip up to the subframe boundar
y
2544                                        JSR     IMG_INI                         ; Set up the status bits and PCI card
2545                                        JSR     <CLR_CCD                        ; Clear out the CCD
2546                                        JSR     <WAIT_WHILE_TRIGGER             ; wait for low trigger, or
2547                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2548                                        JSR     <C_OSHUT                        ; Open shutter if not a dark frame
2549                                        MOVE    Y:<IFRAMES,X0
2550                                        MOVE    X0,Y:<IFLPCNT                   ; Set up 24-bit loop counter in IFLPCNT
2551                                FP_LP   JSET    #TRIGGER,X:STATUS,FPO_END       ; If no triggering jump to expose image function
2552                                        MOVE    #FPO_END,R7                     ; Store the Address into R7
2553                                        BSET    #ST_EXP,X:<STATUS
2554                                        JMP     <EXPOSE                         ; Delay for specified exposure time
2555                                        BCLR    #ST_EXP,X:<STATUS
2556                                        JSET    #ST_ABRT,X:<STATUS,FPO_FINI     ; got abort underway?
2557                                FPO_END JSR     <WAIT_UNTIL_TRIGGER             ; wait for high trigger or fall through
2558                                        MOVE    Y:<UBSROWS,X1                   ; Shift down UBSROWS unbinned rows
2559                                        JSR     ISHIFT                          ; Clock down subframe height
2560                                        MOVE    X:IMAGE_MODE,X0
2561                                        JSET    #P_OCC,X0,FPO_RD        ; Shift the rest of the way for F_OCC
2562                                                                                ; Go straight to readout if P_OCC
2563                                        MOVE    Y:S_SIZE,X0
2564                                        MOVE    X0,A                            ; Get only least significant 24 bits
2565                                        MOVE    Y:<UBSROWS,X0
2566                                        SUB     X0,A                            ;
2567                                        NOP                                     ; 56300 pipeline as per July 5 #4
2568                                        MOVE    A,X1                            ; X1 = S_SIZE - UBSROWS
2569                                        JSR     SSHIFT                          ; Clock storage the rest of the way
2570                                        BSET    #ST_RDC,X:<STATUS
2571                                FPO_RD  JSR     <RCCD1                          ; Finally, read out the CCD.  Skip the FT
2572                                        BCLR    #ST_RDC,X:<STATUS
2573                                        MOVE    X:IMAGE_MODE,X0
2574                                        JSET    #F_OCC,X0,FPO_SK        ; Shift back up by UBSROWS if P_OCC
2575                                        MOVE    Y:<UBSROWS,X1                   ; Shift UBSROWS unbinned rows back up
2576                                        JSR     RSHIFT                          ; Clock subframe height back up
2577                                FPO_SK  JSR     <WAIT_WHILE_TRIGGER             ; wait for low trigger
2578                                        CLR     A
2579                                        MOVE    Y:<IFLPCNT,A0
2580                                        DEC     A                               ; Get loop count, decrement, and loop till zero
2581                                        NOP                                     ; 56300 pipeline as per July 5 #4
2582                                        MOVE    A0,Y:<IFLPCNT
2583                                        TST     A
2584                                        JNE     FP_LP                           ; End of IFRAMES loop
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 52



2585                                FPO_FINI
2586                                        JSR     <CSHUT                          ; Unconditionally close shutter
2587                                        JMP     CLEANUP                         ; clean up after command.
2588                                        *
2589   
2590                                ; Support subroutines and code fragments used in the various mode code
2591                                ; IMG_INI, CLEANUP, ISHIFT, SSHIFT, RSHIFT
2592                                ;  Image initialization subroutine.  Sets up status bits & PCI card
2593                                ; Correct XMT_FO to XMT_WRD in timboot.s and change the input arg to B1
2594                                ; as per "Four Points" #3
2595   
2596      P:000757 P:000757 55F400  IMG_INI   MOVE              #$020102,B1             ; Transmit header word
                            020102
2597      P:000759 P:000759 0D00EB            JSR     <XMT_WRD
2598      P:00075A P:00075A 55F400            MOVE              #'IIA',B1               ; Initialize Image Address
                            494941
2599      P:00075C P:00075C 0D00EB            JSR     <XMT_WRD
2600                                ;        BSET    #ST_RDC,X:<STATUS       ; Set status to reading out
2601      P:00075D P:00075D 0D08D3            JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
2602      P:00075E P:00075E 00000C            RTS
2603   
2604                                ; Cleanup code fragment (not a subroutine) for the end all modes.  JMP to it.
2605                                ; remove WW mode reference and also do a CLOCK wait.
2606                                ; support no idling mode as per MLO code.
2607                                ; all as per July 4 confluence #1
2608   
2609                                ;CLEANUP BCLR    #WW,X:PBD               ; Clear WW to 0 for 32-bit commands
2610                                CLEANUP
2611   
2612                                ; Restore the controller to non-image data transfer and idling if necessary
2613      P:00075F P:00075F 0A0082            JCLR    #IDLMODE,X:<STATUS,NO_IDL         ; Don't idle after readout
                            000764
2614      P:000761 P:000761 60F400            MOVE              #IDLE,R0
                            000305
2615      P:000763 P:000763 0C0765            JMP     <CLEAN1
2616      P:000764 P:000764 305A00  NO_IDL    MOVE              #TST_RCV,R0
2617                                CLEAN1
2618      P:000765 P:000765 0BF080            JSR     CLOCK_WAIT                        ; so everything is transferred
                            000778
2619      P:000767 P:000767 601F00            MOVE              R0,X:<IDL_ADR
2620   
2621                                ;        BCLR    #ST_RDC,X:<STATUS       ; Clear status to NOT reading out
2622      P:000768 P:000768 0A0008            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of any abort flag
2623      P:000769 P:000769 0C0054            JMP     <START                            ; Wait for a new command
2624   
2625                                ; Shift image and storage areas down by the number of rows in X1
2626                                ISHIFT
2627                                ; NO IMO for LMI
2628                                ;       IF      @SCP("IMOMODE","IMO")
2629                                ;       MOVE    #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2630                                ;       JSR     <CLOCK                  ; IMO
2631                                ;       NOP                             ; IMO
2632                                ;       ENDIF
2633   
2634      P:00076A P:00076A 06C500            DO      X1,ISH_LOOP                       ; Number of rows to shift is in X1
                            00076F
2635      P:00076C P:00076C 68F000            MOVE                          Y:IS_PAR_CLR,R0 ; Ganged clocks with DG running
                            000011
2636                                ; mitigation 5
2637                                ;        JSET    #STORAGE,X:ISTATUS,GANG_SF  ; if STORAGE == 0 store clocks only
2638                                ;GANG_SF
2639   
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timmisc.s  Page 53



2640      P:00076E P:00076E 0D02DE            JSR     <CLOCK                            ; Parallel clocking
2641      P:00076F P:00076F 000000            NOP
2642                                ISH_LOOP
2643      P:000770 P:000770 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                            0001E2
2644      P:000772 P:000772 0D02DE            JSR     <CLOCK
2645                                ;       MOVE    #<IMO_LAST_CLOCK,R0             ; set clocks to 0
2646                                ;       JSR     <CLOCK
2647      P:000773 P:000773 00000C            RTS                                       ; End of ISHIFT
2648   
2649                                        COMMENT *
2650                                ; Shift storage area only down by the number of rows in X1
2651                                SSHIFT
2652                                ; NO IMO for LMI
2653                                ;       IF      @SCP("IMOMODE","IMO")
2654                                ;       MOVE    #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2655                                ;       JSR     <CLOCK                  ; IMO
2656                                ;       NOP                             ; IMO
2657                                ;       ENDIF
2658                                        DO      X1,SSH_LOOP             ; Number of rows to shift is in X1
2659                                        MOVE    Y:<S_PAR_CLR,R0         ; Storage clocks only with DG running
2660                                        JSR     <CLOCK                  ; Parallel clocking
2661                                        NOP
2662                                SSH_LOOP
2663                                        MOVE    #DUMP_SERIAL,R0         ; clear the SR after parallel clear
2664                                        JSR     <CLOCK
2665                                        RTS                     ; End of SSHIFT
2666   
2667                                ; Used by pipelined occultation mode to move the storage area back up to
2668                                ; the seam following read of a subframe
2669                                RSHIFT
2670                                        IF      @SCP("IMOMODE","IMO")
2671                                        MOVE    #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2672                                        JSR     <CLOCK                  ; IMO
2673                                        NOP                             ; IMO
2674                                        ENDIF
2675                                        DO      X1,RVS_SHIFT            ; Number of rows to read out
2676                                        MOVE    #<R_S_PARALLEL,R0       ; Reverse parallel waveform
2677                                        JSR     <CLOCK                  ; Parallel clocking
2678                                        NOP
2679                                RVS_SHIFT
2680                                        RTS                     ; End of RSHIFT
2681                                        *
2682                                          INCLUDE "timCCDmisc.s"                    ; Generic
2683                                ; This file is for utilities that are in common to all the timing board
2684                                ;   programs, located starting at P:$200 in external SRAM
2685   
2686                                        COMMENT *
2687   
2688                                The following commands are supported in this "timmisc.s" file
2689                                PAL_DLY                 Subroutine to delay by about 8 microseconds
2690                                SET_DAC                 Transfer DAC values in (R0) table to the DACs
2691                                FASTSKP                 Compute number of waveform table entries in a readout
2692                                                                for fast clocking
2693                                OSHUT                   Subroutine call for opening the shutter
2694                                CSHUT                   Subroutine call for closing the shutter
2695                                OPEN_SHUTTER            Command for opening the shutter
2696                                CLOSE_SHUTTER           Command for closing the shutter
2697                                SET_EXP_TIME            Write desired exposure time to timing board variable
2698                                RD_EXP_TIME             Read elapsed exposure time
2699                                START_EXPOSURE          Start an exposure - 'DON' reply, clear FPA, open
2700                                                        shutter, expose, close shutter, delay Y:SH_DLY, readout
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timCCDmisc.s  Page 54



2701                                PAUSE_EXPOSURE          Close shutter, stop exposure timer
2702                                RESUME_EXPOSURE         Open shutter if necessary, resume exposure timer
2703                                ABORT_EXPOSURE          Close shutter, stop exposure timer
2704                                INF                     Return version and timing information
2705                                IDL                     Put FPA to clocking when not processing commands or
2706                                                        reading out
2707                                READ_CONTROLLER_CONFIGURATION
2708   
2709                                PWR_OFF                 Turn off ananlog power supply voltages to backplane
2710                                PWR_ON                  Turn on analog power supply voltages to backplane
2711                                SETBIAS                 Command to call SET_BIASES and reply 'DON'
2712                                SET_BIASES              Subroutine to turn on all bias and clock voltages
2713                                                        by reading them from the waveform tables and writing
2714                                                        them to the DACs
2715                                SER_ANA                 Direct the timing board DSP's synchronous serial
2716                                                        transmitter to the analog boards (clock driver, video)
2717                                SER_UTL                 Direct the timing board DSP's synchronous serial
2718                                                        transmitter to the utility board
2719                                CLR_SWS                 Clear the analog switches in the clock driver and
2720                                                        video boards to lower their power consumption, as a
2721                                                        command with a 'DON' reply
2722                                CLEAR_SWITCHES          A subroutine call for CLR_WSW
2723                                ST_GAIN                 Set the video processor gain to one of four values
2724                                WR_CNTRL
2725                                SET_DC
2726                                SET_BIAS_NUMBER
2727                                SET_MUX
2728   
2729                                        *
2730   
2731                                ; These become a single line macros, as per June 30 #12
2732                                ; Enable serial communication to the analog boards
2733                                SER_ANA   MACRO
2734 m                                        BSET    #3,X:PCRD                         ; Turn on the serial clock
2735 m                                        ENDM
2736                                ; Enable serial communication to the utility board
2737                                SER_UTL   MACRO
2738 m                                        BCLR    #3,X:PCRD                         ; Turn off the serial clock
2739 m                                        ENDM
2740   
2741   
2742                                ; Delay for serial writes to the PALs and DACs by 8 microsec
2743                                ; Conformed to gen-iii MLO as per CCDmisc comments June 30 #1
2744      P:000774 P:000774 062083  PAL_DLY   DO      #800,*+3                          ; Wait 8 usec for serial data transmission
                            000776
2745      P:000776 P:000776 000000            NOP
2746      P:000777 P:000777 00000C            RTS
2747   
2748                                ; Wait for clocking to be complete before proceeding
2749                                ; Code added as per June 29 #5
2750                                CLOCK_WAIT
2751      P:000778 P:000778 01ADA1            JSET    #SSFEF,X:PDRD,*                   ; Wait for the SS FIFO to be empty
                            000778
2752      P:00077A P:00077A 00000C            RTS
2753   
2754   
2755   
2756                                ;  Update the DACs
2757                                ; Remove cruft as per June 30 #2
2758      P:00077B P:00077B 4CD800  SET_DAC   MOVE                          Y:(R0)+,X0  ; Get the number of table entries
2759      P:00077C P:00077C 06C400            DO      X0,SET_L0                         ; Repeat X0 times
                            000781
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timCCDmisc.s  Page 55



2760      P:00077E P:00077E 5ED800            MOVE                          Y:(R0)+,A   ; Send out the waveform
2761      P:00077F P:00077F 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
2762      P:000780 P:000780 0D0774            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
2763      P:000781 P:000781 000000            NOP                                       ; Do loop restriction
2764                                SET_L0
2765      P:000782 P:000782 00000C            RTS                                       ; Return from subroutine
2766   
2767                                ; Subroutine for computing number of fast clocks needed
2768                                ; remove the offset for gen-iii, as per June 30 general comment #3
2769      P:000783 P:000783 2000A8  FASTSKP   MPY     X0,X1,B                           ; X1 = number of pixels to skip,
2770                                                                                    ; X0 = number of waveform table entries
2771      P:000784 P:000784 20002A            ASR     B                                 ; Correct for multiplication left shift
2772      P:000785 P:000785 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2773      P:000786 P:000786 212500            MOVE              B0,X1                   ; Get only least significant 24 bits
2774      P:000787 P:000787 00000C            RTS
2775   
2776                                ; open (X0 = 0) or close (X0=10) shutter, h/w only.
2777                                SET_SHUTTER_STATE
2778      P:000788 P:000788 568F00            MOVE              X:LATCH,A
2779      P:000789 P:000789 0140C6            AND     #$FFEF,A
                            00FFEF
2780      P:00078B P:00078B 200042            OR      X0,A
2781      P:00078C P:00078C 000000            NOP
2782      P:00078D P:00078D 540F00            MOVE              A1,X:LATCH
2783      P:00078E P:00078E 09CC35            MOVEP             A1,Y:WRLATCH
2784      P:00078F P:00078F 00000C            RTS
2785   
2786                                ; Open the shutter from the timing board, executed as a command
2787                                OPEN_SHUTTER
2788      P:000790 P:000790 0A0023            BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
2789      P:000791 P:000791 240000            MOVE              #0,X0
2790      P:000792 P:000792 0D0788            JSR     <SET_SHUTTER_STATE
2791      P:000793 P:000793 0C008F            JMP     <FINISH
2792   
2793                                ; Close the shutter from the timing board, executed as a command
2794                                CLOSE_SHUTTER
2795      P:000794 P:000794 0A0003            BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
2796      P:000795 P:000795 44F400            MOVE              #>$10,X0
                            000010
2797      P:000797 P:000797 0D0788            JSR     <SET_SHUTTER_STATE
2798      P:000798 P:000798 0C008F            JMP     <FINISH
2799   
2800                                ; Subroutine with two entry points.  C_OSHUT is conditional on SHUT
2801                                ; Open the shutter conditionally based on the shutter status bit #SHUT
2802                                ; This is set by the host using dspwrm to the X:<STATUS unless the frame
2803                                ; is a dark
2804                                ; Open the shutter by calling SET_SHUTTER_STATE
2805                                C_OSHUT
2806      P:000799 P:000799 0A008B            JCLR    #SHUT,X:STATUS,OSH_RTN
                            00079E
2807                                OSHUT
2808      P:00079B P:00079B 0A0023            BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
2809      P:00079C P:00079C 240000            MOVE              #0,X0
2810      P:00079D P:00079D 0D0788            JSR     <SET_SHUTTER_STATE
2811      P:00079E P:00079E 00000C  OSH_RTN   RTS
2812   
2813                                ; Subroutine with two entry points.  C_CSHUT is conditional on OPEN_CLOSE
2814                                ; Close the shutter conditionally based on the open-close ISTATUS bit
2815                                ; Close the shutter by calling SET_SHUTTER_STATE
2816      P:00079F P:00079F 0A2081  C_CSHUT   JCLR    #OPEN_CLOSE,X:ISTATUS,CSH_RTN     ; Don't close if always open
                            0007B1
2817      P:0007A1 P:0007A1 0A0003  CSHUT     BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timCCDmisc.s  Page 56



2818      P:0007A2 P:0007A2 44F400            MOVE              #>$10,X0
                            000010
2819      P:0007A4 P:0007A4 0D0788            JSR     <SET_SHUTTER_STATE
2820   
2821                                ; after closing shutter be sure to wait SH_DEL msec to let the blades close
2822                                ; before shifting the CCD array for readout.
2823      P:0007A5 P:0007A5 5E8900            MOVE                          Y:<SH_DEL,A
2824      P:0007A6 P:0007A6 200003            TST     A
2825      P:0007A7 P:0007A7 0EF7B0            JLE     <S_DEL0
2826      P:0007A8 P:0007A8 44F400            MOVE              #25000,X0
                            0061A8
2827      P:0007AA P:0007AA 06CE00            DO      A,S_DEL0                          ; Delay by Y:SH_DEL milliseconds
                            0007AF
2828      P:0007AC P:0007AC 06C400            DO      X0,S_DEL1
                            0007AE
2829      P:0007AE P:0007AE 000000            NOP
2830      P:0007AF P:0007AF 000000  S_DEL1    NOP
2831      P:0007B0 P:0007B0 000000  S_DEL0    NOP
2832   
2833      P:0007B1 P:0007B1 00000C  CSH_RTN   RTS
2834   
2835                                ; Set the desired exposure time
2836                                ;       Correct command ptr to R3 as per "Four Points" #2
2837                                ;       Modify exposure time var name as per June 30 #5
2838                                SET_EXP_TIME
2839      P:0007B2 P:0007B2 44DB00            MOVE              X:(R3)+,X0
2840      P:0007B3 P:0007B3 441000            MOVE              X0,X:<EXPOSURE_TIME
2841                                ;       MOVE    X0,X:<TGT_TIM
2842      P:0007B4 P:0007B4 0C008F            JMP     <FINISH
2843   
2844   
2845                                ; Abort exposure - close the shutter, stop the timer and resume idle mode
2846                                ; Modified to match gen-iii MLO code- as per June 30 #6
2847                                ABORT_EXPOSURE
2848      P:0007B5 P:0007B5 0A00A7            JSET    #ST_EXP,X:<STATUS,DO_ABEXP
                            0007B8
2849                                ; assume we got here via the idle rcv loop
2850                                ; not currently exposing, so this is a no-op.
2851      P:0007B7 P:0007B7 0C008F            JMP     <FINISH
2852                                DO_ABEXP
2853   
2854      P:0007B8 P:0007B8 0D07A1            JSR     <CSHUT                            ; Close the shutter
2855      P:0007B9 P:0007B9 010F00            BCLR    #TIM_BIT,X:TCSR0                  ; Disable the DSP exposure timer
2856   
2857                                ; The place to return must be in R7-
2858      P:0007BA P:0007BA 0AE780            JMP     (R7)                              ; 'return' from EXPOSE
2859   
2860   
2861   
2862                                ;       Process INF according to the single addressing parameter
2863                                ;       Correct FINISH1 datum as per "Four Points" #1
2864                                ;       Correct command ptr to R3 as per "Four Points" #2
2865                                GET_INFO
2866      P:0007BB P:0007BB 56DB00            MOVE              X:(R3)+,A               ; 0-4 is generic, >= 0x100 tim specific
2867                                ; Remove for gen-iii per June 6 #2
2868      P:0007BC P:0007BC 47F400            MOVE              #IVERSION,Y1
                            04507F
2869      P:0007BE P:0007BE 46F400            MOVE              #>GET_VERSION,Y0
                            000000
2870      P:0007C0 P:0007C0 200055            CMP     Y0,A
2871      P:0007C1 P:0007C1 0EA090            JEQ     <FINISH1
2872                                ; Remove for gen-iii per June 6 #2
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timCCDmisc.s  Page 57



2873      P:0007C2 P:0007C2 47F400            MOVE              #IFLAVOR,Y1
                            612020
2874      P:0007C4 P:0007C4 46F400            MOVE              #>GET_FLAVOR,Y0
                            000001
2875      P:0007C6 P:0007C6 200055            CMP     Y0,A
2876      P:0007C7 P:0007C7 0EA090            JEQ     <FINISH1
2877      P:0007C8 P:0007C8 47F400            MOVE              #ITIME0,Y1
                            007F74
2878      P:0007CA P:0007CA 46F400            MOVE              #>GET_TIME0,Y0
                            000002
2879      P:0007CC P:0007CC 200055            CMP     Y0,A
2880      P:0007CD P:0007CD 0EA090            JEQ     <FINISH1                          ; Is it Time0?
2881      P:0007CE P:0007CE 47F400            MOVE              #ITIME1,Y1
                            004FF2
2882      P:0007D0 P:0007D0 46F400            MOVE              #>GET_TIME1,Y0
                            000003
2883      P:0007D2 P:0007D2 200055            CMP     Y0,A
2884      P:0007D3 P:0007D3 0EA090            JEQ     <FINISH1                          ; Is it Time1?
2885      P:0007D4 P:0007D4 270000            MOVE              #ISVNREV,Y1
2886      P:0007D5 P:0007D5 46F400            MOVE              #>GET_SVNREV,Y0
                            000004
2887      P:0007D7 P:0007D7 200055            CMP     Y0,A
2888      P:0007D8 P:0007D8 0EA090            JEQ     <FINISH1                          ; Is it Svn rev?
2889      P:0007D9 P:0007D9 47F400            MOVE              #TIMCAPABLE,Y1
                            0001CB
2890      P:0007DB P:0007DB 46F400            MOVE              #>GET_CAPABLE,Y0
                            000100
2891      P:0007DD P:0007DD 200055            CMP     Y0,A
2892      P:0007DE P:0007DE 0EA090            JEQ     <FINISH1                          ; Is it Tim Capabilities?
2893      P:0007DF P:0007DF 47F400            MOVE              #INT_TIM,Y1
                            1D0000
2894      P:0007E1 P:0007E1 46F400            MOVE              #>GET_INT_TIM,Y0
                            000101
2895      P:0007E3 P:0007E3 200055            CMP     Y0,A
2896      P:0007E4 P:0007E4 0EA090            JEQ     <FINISH1                          ; Is it Integration time?
2897      P:0007E5 P:0007E5 47F400            MOVE              #R_DELAY,Y1
                            000000
2898      P:0007E7 P:0007E7 46F400            MOVE              #>GET_R_DELAY,Y0
                            000102
2899      P:0007E9 P:0007E9 200055            CMP     Y0,A
2900      P:0007EA P:0007EA 0EA090            JEQ     <FINISH1                          ; Is it Serial time?
2901      P:0007EB P:0007EB 47F400            MOVE              #SI_DELAY,Y1
                            BF0000
2902      P:0007ED P:0007ED 46F400            MOVE              #>GET_SI_DELAY,Y0
                            000103
2903      P:0007EF P:0007EF 200055            CMP     Y0,A
2904      P:0007F0 P:0007F0 0EA090            JEQ     <FINISH1                          ; Is it Parallel time?
2905      P:0007F1 P:0007F1 0C008D            JMP     ERROR                             ; unknown info argument
2906   
2907                                ; LMI does not use the thermocooler status bits
2908                                        COMMENT *
2909                                        MOVE    #>GET_TEMP2STS,Y0       ; Is it 2 bit temp status
2910                                        CMP     Y0,A
2911                                        JNE     <ERROR
2912                                        CLR     A
2913                                        JSET    #STS1,X:HDR,GET_STS0
2914                                        ADD     #<2,A
2915                                GET_STS0
2916                                        JSET    #STS0,X:HDR,RES_TEMPS
2917                                        ADD     #<1,A
2918                                RES_TEMPS
2919                                        NOP
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timCCDmisc.s  Page 58



2920                                        MOVE    A1,Y1
2921                                        JMP     <FINISH1
2922                                        *
2923   
2924   
2925                                ; Set software to IDLE mode
2926      P:0007F2 P:0007F2 44F400  IDL       MOVE              #IDLE,X0                ; Exercise clocks when idling
                            000305
2927      P:0007F4 P:0007F4 441F00            MOVE              X0,X:<IDL_ADR
2928      P:0007F5 P:0007F5 0A0022            BSET    #IDLMODE,X:<STATUS                ; Idle after readout
2929      P:0007F6 P:0007F6 0C008F            JMP     <FINISH                           ; Need to send header and 'DON'
2930   
2931                                ; Come to here on a 'STP' command so 'DON' can be sent
2932   
2933                                ; Let the host computer read the controller configuration
2934                                ;       Correct FINISH1 datum as per "Four Points" #1
2935                                READ_CONTROLLER_CONFIGURATION
2936      P:0007F7 P:0007F7 4F8A00            MOVE                          Y:<CONFIG,Y1 ; Just transmit the configuration
2937      P:0007F8 P:0007F8 0C0090            JMP     <FINISH1
2938   
2939                                ; Power off
2940      P:0007F9 P:0007F9 0D0836  PWR_OFF   JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
2941      P:0007FA P:0007FA 0A8922            BSET    #LVEN,X:HDR
2942      P:0007FB P:0007FB 0A8923            BSET    #HVEN,X:HDR
2943      P:0007FC P:0007FC 0C008F            JMP     <FINISH
2944   
2945                                ; Start power-on cycle
2946                                PWR_ON
2947      P:0007FD P:0007FD 0D0836            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
2948      P:0007FE P:0007FE 0D080F            JSR     <PON                              ; Turn on the power control board
2949      P:0007FF P:0007FF 0A8980            JCLR    #PWROK,X:HDR,PWR_ERR              ; Test if the power turned on properly
                            00080C
2950      P:000801 P:000801 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                            000100
2951      P:000803 P:000803 0D0820            JSR     <SET_BIASES                       ; Turn on the DC bias supplies
2952      P:000804 P:000804 60F400            MOVE              #IDLE,R0                ; Put controller in IDLE state
                            000305
2953      P:000806 P:000806 601F00            MOVE              R0,X:<IDL_ADR
2954   
2955                                ;       as per Confluence July 4 2010 #5
2956      P:000807 P:000807 312400            MOVE              #$24,R1
2957      P:000808 P:000808 610000            MOVE              R1,X:<STATUS
2958                                ;       as per Confluence July 4 2010 #4 and July 21 note
2959      P:000809 P:000809 4CBD00            MOVE                          Y:<AMPVAL,X0
2960      P:00080A P:00080A 0D032A            JSR     <SELECT_OUTPUT_SOURCE
2961      P:00080B P:00080B 0C008F            JMP     <FINISH
2962   
2963                                ; The power failed to turn on because of an error on the power control board
2964      P:00080C P:00080C 0A8922  PWR_ERR   BSET    #LVEN,X:HDR                       ; Turn off the low voltage emable line
2965      P:00080D P:00080D 0A8923            BSET    #HVEN,X:HDR                       ; Turn off the high voltage emable line
2966      P:00080E P:00080E 0C008D            JMP     <ERROR
2967   
2968                                ; As a subroutine, turn on the low voltages (+/- 6.5V, +/- 16.5V) and delay
2969      P:00080F P:00080F 0A8902  PON       BCLR    #LVEN,X:HDR                       ; Set these signals to DSP outputs
2970      P:000810 P:000810 44F400            MOVE              #2000000,X0
                            1E8480
2971      P:000812 P:000812 06C400            DO      X0,*+3                            ; Wait 20 millisec for settling
                            000814
2972      P:000814 P:000814 000000            NOP
2973   
2974                                ; Turn on the high +36 volt power line and then delay
2975      P:000815 P:000815 0A8903            BCLR    #HVEN,X:HDR                       ; HVEN = Low => Turn on +36V
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timCCDmisc.s  Page 59



2976      P:000816 P:000816 44F400            MOVE              #2000000,X0
                            1E8480
2977      P:000818 P:000818 06C400            DO      X0,*+3                            ; Wait 20 millisec for settling
                            00081A
2978      P:00081A P:00081A 000000            NOP
2979      P:00081B P:00081B 00000C            RTS
2980   
2981                                ; LMI does not need to set VRD2 or VRD3
2982                                        COMMENT *
2983                                ;prototype code- to set leds on gwaves
2984                                SETVRDS
2985                                        MOVE    X:(R3)+,X0
2986                                        CLR     A
2987                                        MOVE    X0,A
2988                                        AND     #$3FFF,A
2989                                        ADD     #VID0+DAC_RegD,A
2990                                        MOVE    X:(R3)+,X0
2991                                        MOVE    A1,Y:VRD2_V
2992                                        MOVE    X0,A
2993                                        AND     #$3FFF,A
2994                                        ADD     #VID0+DAC_RegD,A
2995                                        MOVE    #SET_VRD2_3,R0
2996                                        MOVE    A1,Y:VRD3_V
2997                                        JSR     <SET_BIASES
2998                                        JMP     <FINISH
2999                                        *
3000   
3001                                SETBIAS
3002      P:00081C P:00081C 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                            000100
3003      P:00081E P:00081E 0D0820            JSR     <SET_BIASES
3004      P:00081F P:00081F 0C008F            JMP     <FINISH
3005   
3006                                ; Set all the DC bias voltages and video processor offset values, reading
3007                                ;   them from the 'DACS' table provided in R0
3008                                SET_BIASES
3009                                          SER_ANA
3011      P:000821 P:000821 0A0F01            BCLR    #1,X:<LATCH                       ; Separate updates of clock driver
3012      P:000822 P:000822 0A0F20            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
3013      P:000823 P:000823 0A0F22            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
3014      P:000824 P:000824 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                            00000F
3015      P:000826 P:000826 0D0774            JSR     <PAL_DLY                          ; Delay for all this to happen
3016   
3017                                ; Read DAC values from a table, and write them to the DACs
3018      P:000827 P:000827 000000            NOP
3019      P:000828 P:000828 065840            DO      Y:(R0)+,L_DAC                     ; Repeat Y:(R0)+ times
                            00082C
3020      P:00082A P:00082A 5ED800            MOVE                          Y:(R0)+,A   ; Read the table entry
3021      P:00082B P:00082B 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
3022      P:00082C P:00082C 000000            NOP
3023                                L_DAC
3024   
3025                                ; Let the DAC voltages all ramp up before exiting
3026      P:00082D P:00082D 44F400            MOVE              #400000,X0
                            061A80
3027      P:00082F P:00082F 06C400            DO      X0,*+3                            ; 4 millisec delay
                            000831
3028      P:000831 P:000831 000000            NOP
3029                                          SER_UTL
3031      P:000833 P:000833 00000C            RTS
3032   
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timCCDmisc.s  Page 60



3033                                ; Enable serial communication to the analog boards
3034                                ; This becomes a single line macro above, as per June 30 #12
3035   
3036                                ;SER_ANA        BSET    #0,X:PBD                ; Set H0 for analog boards SSI
3037                                ;       MOVEP   #$0000,X:PCC            ; Software reset of SSI
3038                                ;       BCLR    #10,X:CRB               ; SSI -> continuous clock for analog
3039                                ;       MOVEP   #$0160,X:PCC            ; Re-enable the SSI
3040                                ;       RTS
3041   
3042                                ; Enable serial communication to the utility board
3043                                ; This becomes a single line macro above, as per June 30 #12
3044   
3045                                ;SER_UTL        MOVEP   #$0000,X:PCC            ; Software reset of SSI
3046                                ;       BSET    #10,X:CRB               ; SSI -> gated clock for util board
3047                                ;       MOVEP   #$0160,X:PCC            ; Enable the SSI
3048                                ;       BCLR    #0,X:PBD                ; Clear H0 for utility board SSI
3049                                ;       RTS
3050   
3051      P:000834 P:000834 0D0836  CLR_SWS   JSR     <CLEAR_SWITCHES
3052      P:000835 P:000835 0C008F            JMP     <FINISH
3053   
3054                                ; Clear all video processor analog switches to lower their power dissipation
3055                                CLEAR_SWITCHES
3056                                          SER_ANA
3058      P:000837 P:000837 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                            0C3000
3059      P:000839 P:000839 20001B            CLR     B
3060      P:00083A P:00083A 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC write
s
3061      P:00083B P:00083B 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writ
es
                            001000
3062      P:00083D P:00083D 060F80            DO      #15,L_VIDEO                       ; Fifteen video processor boards maximum
                            000844
3063      P:00083F P:00083F 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
3064      P:000840 P:000840 200040            ADD     X0,A
3065      P:000841 P:000841 5F7000            MOVE                          B,Y:WRSS
                            FFFFF3
3066      P:000843 P:000843 0D0774            JSR     <PAL_DLY                          ; Delay for the serial data transmission
3067      P:000844 P:000844 200068            ADD     X1,B
3068                                L_VIDEO
3069      P:000845 P:000845 0A0F00            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
3070      P:000846 P:000846 0A0F02            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
3071      P:000847 P:000847 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                            00000F
3072                                          SER_UTL
3074      P:00084A P:00084A 00000C            RTS
3075   
3076                                ; Set the clock multiplexers
3077                                ;       Correct command ptr to R3 as per "Four Points" #2
3078                                SET_MUX
3079                                          SER_ANA                                   ; Set SSI to analog board communication
3081      P:00084C P:00084C 56DB00            MOVE              X:(R3)+,A               ; Clock driver board number
3082      P:00084D P:00084D 0614A0            REP     #20
3083      P:00084E P:00084E 200033            LSL     A
3084      P:00084F P:00084F 44F400            MOVE              #$003000,X0
                            003000
3085      P:000851 P:000851 200042            OR      X0,A
3086      P:000852 P:000852 000000            NOP                                       ; 56300 pipeline as per July 5 #4
3087      P:000853 P:000853 21C500            MOVE              A,X1                    ; Move here for storage
3088   
3089                                ; Get the first MUX number
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timCCDmisc.s  Page 61



3090      P:000854 P:000854 56DB00            MOVE              X:(R3)+,A               ; Get the first MUX number
3091      P:000855 P:000855 0AF0A9            JLT     ERR_SM1
                            00089C
3092      P:000857 P:000857 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                            000018
3093      P:000859 P:000859 200045            CMP     X0,A
3094      P:00085A P:00085A 0AF0A1            JGE     ERR_SM1
                            00089C
3095      P:00085C P:00085C 21CF00            MOVE              A,B
3096      P:00085D P:00085D 44F400            MOVE              #>7,X0
                            000007
3097      P:00085F P:00085F 20004E            AND     X0,B
3098      P:000860 P:000860 44F400            MOVE              #>$18,X0
                            000018
3099      P:000862 P:000862 200046            AND     X0,A
3100      P:000863 P:000863 0E2866            JNE     <SMX_1                            ; Test for 0 <= MUX number <= 7
3101      P:000864 P:000864 0ACD63            BSET    #3,B1
3102      P:000865 P:000865 0C0871            JMP     <SMX_A
3103      P:000866 P:000866 44F400  SMX_1     MOVE              #>$08,X0
                            000008
3104      P:000868 P:000868 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
3105      P:000869 P:000869 0E286C            JNE     <SMX_2
3106      P:00086A P:00086A 0ACD64            BSET    #4,B1
3107      P:00086B P:00086B 0C0871            JMP     <SMX_A
3108      P:00086C P:00086C 44F400  SMX_2     MOVE              #>$10,X0
                            000010
3109      P:00086E P:00086E 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
3110      P:00086F P:00086F 0E289C            JNE     <ERR_SM1
3111      P:000870 P:000870 0ACD65            BSET    #5,B1
3112      P:000871 P:000871 20006A  SMX_A     OR      X1,B1                             ; Add prefix to MUX numbers
3113      P:000872 P:000872 000000            NOP                                       ; 56300 pipeline as per July 5 #4
3114      P:000873 P:000873 21A700            MOVE              B1,Y1
3115   
3116                                ; Add on the second MUX number
3117      P:000874 P:000874 56DB00            MOVE              X:(R3)+,A               ; Get the next MUX number
3118      P:000875 P:000875 0AF0A9            JLT     ERR_SM2
                            00089D
3119      P:000877 P:000877 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                            000018
3120      P:000879 P:000879 200045            CMP     X0,A
3121      P:00087A P:00087A 0AF0A1            JGE     ERR_SM2
                            00089D
3122      P:00087C P:00087C 0606A0            REP     #6
3123      P:00087D P:00087D 200033            LSL     A
3124      P:00087E P:00087E 44F400            MOVE              #$1C0,X0
                            0001C0
3125      P:000880 P:000880 21CF00            MOVE              A,B
3126      P:000881 P:000881 20004E            AND     X0,B
3127      P:000882 P:000882 44F400            MOVE              #>$600,X0
                            000600
3128      P:000884 P:000884 200046            AND     X0,A
3129      P:000885 P:000885 0E2888            JNE     <SMX_3                            ; Test for 0 <= MUX number <= 7
3130      P:000886 P:000886 0ACD69            BSET    #9,B1
3131      P:000887 P:000887 0C0893            JMP     <SMX_B
3132      P:000888 P:000888 44F400  SMX_3     MOVE              #>$200,X0
                            000200
3133      P:00088A P:00088A 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
3134      P:00088B P:00088B 0E288E            JNE     <SMX_4
3135      P:00088C P:00088C 0ACD6A            BSET    #10,B1
3136      P:00088D P:00088D 0C0893            JMP     <SMX_B
3137      P:00088E P:00088E 44F400  SMX_4     MOVE              #>$400,X0
                            000400
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timCCDmisc.s  Page 62



3138      P:000890 P:000890 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
3139      P:000891 P:000891 0E289D            JNE     <ERR_SM2
3140      P:000892 P:000892 0ACD6B            BSET    #11,B1
3141      P:000893 P:000893 200078  SMX_B     ADD     Y1,B                              ; Add prefix to MUX numbers
3142                                ; change to match gen-iii, as per June 30, #14
3143      P:000894 P:000894 000000            NOP
3144      P:000895 P:000895 21AE00            MOVE              B1,A
3145      P:000896 P:000896 0140C6            AND     #$F01FFF,A                        ; Just to be sure
                            F01FFF
3146      P:000898 P:000898 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
3147   
3148      P:000899 P:000899 0D0774            JSR     <PAL_DLY                          ; Delay for all this to happen
3149                                          SER_UTL                                   ; Return SSI to utility board communication
3151      P:00089B P:00089B 0C008F            JMP     <FINISH
3152      P:00089C P:00089C 56DB00  ERR_SM1   MOVE              X:(R3)+,A
3153                                ERR_SM2
3154                                          SER_UTL                                   ; Return SSI to utility board communication
3156      P:00089E P:00089E 0C008D            JMP     <ERROR
3157   
3158   
3159                                ; Set the video processor gain and integrator speed for all video boards
3160                                ; Now modified as per manual for ARC-47 (1E) video board and ARC-E2V57
3161                                ; sample code
3162                                ;  Command syntax is  SGN [ #BD]  #GAIN  #SPEED, #GAIN = 0-15 (1.0-4.75)
3163                                ;                                         #SPEED = 1-15
3164                                ;       Correct command ptr to R3 as per "Four Points" #2
3165                                ;  fixes to match gen-iii as per June 30, #15
3166                                ; replaced with ARC version for E2V57- except BD is set unconditionally
3167                                ; to 0 for backwards compatibility at the LOIS end.
3168                                ;
3169   
3170                                ST_GAIN
3171                                ;       MOVE    X:(R3)+,A       ; Board number
3172                                ;       LSL     #20,A
3173      P:00089F P:00089F 200013            CLR     A                                 ; Video bd must be at 0.
3174      P:0008A0 P:0008A0 240D00            MOVE              #$0D0000,X0
3175      P:0008A1 P:0008A1 218500            MOVE              A1,X1
3176      P:0008A2 P:0008A2 200042            OR      X0,A
3177      P:0008A3 P:0008A3 44DB00            MOVE              X:(R3)+,X0              ; Gain
3178      P:0008A4 P:0008A4 200042            OR      X0,A
3179      P:0008A5 P:0008A5 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
3180   
3181      P:0008A6 P:0008A6 56DB00            MOVE              X:(R3)+,A               ; Time constant (speed)
3182      P:0008A7 P:0008A7 0C1E88            LSL     #4,A
3183      P:0008A8 P:0008A8 200062            OR      X1,A1                             ; Board number is in bits #23-20
3184      P:0008A9 P:0008A9 44F400            MOVE              #$0C0100,X0
                            0C0100
3185      P:0008AB P:0008AB 200042            OR      X0,A
3186      P:0008AC P:0008AC 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
3187      P:0008AD P:0008AD 0C008F            JMP     <FINISH
3188   
3189   
3190                                ; traditional gain-speed code
3191                                        COMMENT *
3192   
3193                                ;       SER_ANA ; Set SSI to analog board communication
3194                                        MOVE    X:(R3)+,A       ; Gain value (1,2,5 or 10)
3195                                ; making this a no-op for now
3196                                        MOVE    X:(R3)+,A       ; Gain value (1,2,5 or 10)
3197                                        JMP     <FINISH
3198                                        MOVE    #>1,X0
3199                                        CMP     X0,A            ; Check for gain = x1
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timCCDmisc.s  Page 63



3200                                        JNE     <STG2
3201                                        MOVE    #>$77,B
3202                                        JMP     <STG_A
3203                                STG2    MOVE    #>2,X0          ; Check for gain = x2
3204                                        CMP     X0,A
3205                                        JNE     <STG5
3206                                        MOVE    #>$BB,B
3207                                        JMP     <STG_A
3208                                STG5    MOVE    #>5,X0          ; Check for gain = x5
3209                                        CMP     X0,A
3210                                        JNE     <STG10
3211                                        MOVE    #>$DD,B
3212                                        JMP     <STG_A
3213                                STG10   MOVE    #>10,X0         ; Check for gain = x10
3214                                        CMP     X0,A
3215                                        JNE     <ERROR
3216                                        MOVE    #>$EE,B
3217   
3218                                STG_A   MOVE    X:(R3)+,A       ; Integrator Speed (0 for slow, 1 for fast)
3219                                        NOP
3220                                        JCLR    #0,A1,STG_B
3221                                        BSET    #8,B1
3222                                        NOP
3223                                        BSET    #9,B1
3224                                STG_B   MOVE    #$0C3C00,X0
3225                                        OR      X0,B
3226                                        NOP
3227                                        MOVE    B,Y:<GAIN       ; Store the GAIN value for later us
3228   
3229                                ; Send this same value to 15 video processor boards whether they exist or not
3230                                        MOVE    #$100000,X0     ; Increment value
3231                                        DO      #15,STG_LOOP
3232                                        MOVE    B1,A1
3233                                        JSR     <XMIT_A_WORD    ; Transmit A to TIM-A-STD
3234   
3235                                ;       MOVE    B,X:SSITX       ; Transmit the SSI word
3236                                        JSR     <PAL_DLY        ; Wait for SSI and PAL to be empty
3237                                        ADD     X0,B            ; Increment the video processor board number
3238                                        NOP
3239                                STG_LOOP
3240   
3241                                        SER_UTL                 ; Return SSI to utility board communication
3242                                        JMP     <FINISH
3243                                        *
3244   
3245   
3246                                ; Specify subarray readout coordinates, one rectangle only
3247                                ; Call this subroutine BEFORE SET_SUBARRAY_POSITIONS since it
3248                                ; initializes NBOXES
3249                                ;       Correct command ptr to R3 as per "Four Points" #2
3250                                SET_SUBARRAY_SIZES
3251      P:0008AE P:0008AE 200013            CLR     A
3252      P:0008AF P:0008AF 44DB00            MOVE              X:(R3)+,X0
3253      P:0008B0 P:0008B0 5E1C00            MOVE                          A,Y:<NBOXES ; Number of subimage boxes = 0 to start
3254      P:0008B1 P:0008B1 4C1D00            MOVE                          X0,Y:<NR_BIAS ; Number of bias pixels to read
3255      P:0008B2 P:0008B2 44DB00            MOVE              X:(R3)+,X0
3256      P:0008B3 P:0008B3 4C1E00            MOVE                          X0,Y:<NS_READ ; Number of columns in subimage read
3257      P:0008B4 P:0008B4 44DB00            MOVE              X:(R3)+,X0
3258      P:0008B5 P:0008B5 4C1F00            MOVE                          X0,Y:<NP_READ ; Number of rows in subimage read
3259      P:0008B6 P:0008B6 0C008F            JMP     <FINISH
3260   
3261                                ; Call this routine once for every subarray to be added to the table
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timCCDmisc.s  Page 64



3262                                ; Note that the way the variables are arranged the subframes all are the
3263                                ; same dimensions.  They also cannot overlap in the row direction.
3264                                ; SET_SUBARRAY_SIZES must be called first to initialize NBOXES
3265                                SET_SUBARRAY_POSITIONS
3266      P:0008B7 P:0008B7 4C9C00            MOVE                          Y:<NBOXES,X0 ; Next available slot
3267      P:0008B8 P:0008B8 459400            MOVE              X:<THREE,X1
3268      P:0008B9 P:0008B9 2000A0            MPY     X0,X1,A
3269      P:0008BA P:0008BA 200022            ASR     A
3270      P:0008BB P:0008BB 210C00            MOVE              A0,A1
3271                                ; PARAMETERIZE
3272      P:0008BC P:0008BC 44F400            MOVE              #>21,X0
                            000015
3273      P:0008BE P:0008BE 200045            CMP     X0,A
3274      P:0008BF P:0008BF 0E708D            JGT     <ERROR                            ; Error if number of boxes > 9
3275      P:0008C0 P:0008C0 44F400            MOVE              #READ_TABLE,X0
                            000020
3276      P:0008C2 P:0008C2 200040            ADD     X0,A
3277      P:0008C3 P:0008C3 44DB00            MOVE              X:(R3)+,X0
3278      P:0008C4 P:0008C4 219700            MOVE              A1,R7
3279      P:0008C5 P:0008C5 000000            NOP
3280      P:0008C6 P:0008C6 000000            NOP
3281      P:0008C7 P:0008C7 000000            NOP
3282      P:0008C8 P:0008C8 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of rows (parallels) to clear
3283      P:0008C9 P:0008C9 44DB00            MOVE              X:(R3)+,X0
3284      P:0008CA P:0008CA 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears before
3285      P:0008CB P:0008CB 44DB00            MOVE              X:(R3)+,X0              ;  the box readout
3286      P:0008CC P:0008CC 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears after
3287      P:0008CD P:0008CD 5E9C00            MOVE                          Y:<NBOXES,A ;  the box readout
3288      P:0008CE P:0008CE 449200            MOVE              X:<ONE,X0
3289      P:0008CF P:0008CF 200040            ADD     X0,A                              ; Update the next available slot position
3290      P:0008D0 P:0008D0 000000            NOP
3291      P:0008D1 P:0008D1 5E1C00            MOVE                          A,Y:<NBOXES
3292      P:0008D2 P:0008D2 0C008F            JMP     <FINISH
3293   
3294                                ; Alert the PCI interface board that images are coming soon
3295                                ; This tells the PCI card how many pixels to expect for each SEX command
3296                                ; This is fairly complex.  The first value sent is NPR*IFRAMES (NAXIS2*NAXIS3).
3297                                ; The second value is NSR aka NAXIS1, but if NBOXES > 0, it is NSR*NBOXES
3298                                ; this matches nasa42, but since naxis1,2 for a full frame is > 2^12
3299                                ; there's a max of 1024 for IFRAMES. If we used an adaptive algorithm we
3300                                ; could do better.
3301                                ; Meantime LOIS will have to enforce these limits.
3302   
3303                                ; Correct XMT_FO to XMT_WRD in timboot.s and change the input arg to B1
3304                                ; as per "Four Points" #3
3305                                PCI_READ_IMAGE
3306      P:0008D3 P:0008D3 55F400            MOVE              #$020104,B1             ; Send header word to the FO transmitter
                            020104
3307      P:0008D5 P:0008D5 0D00EB            JSR     <XMT_WRD
3308      P:0008D6 P:0008D6 55F400            MOVE              #'RDA',B1
                            524441
3309      P:0008D8 P:0008D8 0D00EB            JSR     <XMT_WRD
3310      P:0008D9 P:0008D9 4CF000            MOVE                          Y:NPR,X0    ; NPR = NAXIS2
                            000002
3311      P:0008DB P:0008DB 4DF000            MOVE                          Y:IFRAMES,X1 ; IFRAMES = NAXIS3
                            00003A
3312      P:0008DD P:0008DD 2000A8            MPY     X0,X1,B
3313      P:0008DE P:0008DE 20002A            ASR     B                                 ; Correct for multiplication left shift
3314      P:0008DF P:0008DF 212D00            MOVE              B0,B1
3315      P:0008E0 P:0008E0 0D00EB            JSR     <XMT_WRD                          ; Send NPR*IFRAMES to PCI card
3316      P:0008E1 P:0008E1 4CF000            MOVE                          Y:NSR,X0    ; NSR = NAXIS1
                            000001
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  timCCDmisc.s  Page 65



3317      P:0008E3 P:0008E3 5E9C00            MOVE                          Y:<NBOXES,A ; If NBOXES = 0, transmit that to PCI
3318      P:0008E4 P:0008E4 208D00            MOVE              X0,B1
3319      P:0008E5 P:0008E5 200003            TST     A
3320      P:0008E6 P:0008E6 0AF0AA            JEQ     XMT
                            0008EC
3321      P:0008E8 P:0008E8 4D9C00            MOVE                          Y:<NBOXES,X1 ; If NBOXES = 0, transmit that to PCI
3322      P:0008E9 P:0008E9 2000A8            MPY     X0,X1,B                           ; If not, multiply by NBOXES, then send
3323      P:0008EA P:0008EA 20002A            ASR     B                                 ; Correct for multiplication left shift
3324      P:0008EB P:0008EB 212D00            MOVE              B0,B1                   ; Get only least significant 24 bits
3325      P:0008EC P:0008EC 000000  XMT       NOP
3326      P:0008ED P:0008ED 0D00EB            JSR     <XMT_WRD
3327      P:0008EE P:0008EE 00000C            RTS
3328   
3329                                 TIMBOOT_X_MEMORY
3330      0008EF                              EQU     @LCV(L)
3331   
3332                                ;  ****************  Setup memory tables in X: space ********************
3333   
3334                                ; Define the address in P: space where the table of constants begins
3335   
3336                                          IF      @SCP("HOST","HOST")
3337      X:000036 X:000036                   ORG     X:END_COMMAND_TABLE,X:END_COMMAND_TABLE
3338                                          ENDIF
3339   
3340                                          IF      @SCP("HOST","ROM")
3342                                          ENDIF
3343   
3344      X:000036 X:000036                   DC      'IDL',IDL                         ; Put CCD in IDLE mode
3345                                ; Remove for gen-iii since it is in timboot as per June 30 #9
3346                                ;       DC      'STP',STP               ; Exit IDLE mode
3347                                ;       DC      'SVR',SETVRDS           ; set VRD2,3
3348      X:000038 X:000038                   DC      'SBV',SETBIAS                     ; Set DC bias supply voltages
3349      X:00003A X:00003A                   DC      'RDC',RDCCD                       ; Begin CCD readout
3350      X:00003C X:00003C                   DC      'CLR',CLEAR                       ; Fast clear the CCD
3351      X:00003E X:00003E                   DC      'SGN',ST_GAIN                     ; Set video processor gain
3352      X:000040 X:000040                   DC      'SMX',SET_MUX                     ; Set clock driver MUX output
3353   
3354      X:000042 X:000042                   DC      'ABR',ABR_RDC                     ; Abort readout
3355      X:000044 X:000044                   DC      'CRD',CONT_RD                     ; Continue reading out
3356      X:000046 X:000046                   DC      'CSW',CLR_SWS                     ; Clear analog switches to lower power
3357      X:000048 X:000048                   DC      'SOS',SEL_OS                      ; Select output source
3358      X:00004A X:00004A                   DC      'RCC',READ_CONTROLLER_CONFIGURATION
3359      X:00004C X:00004C                   DC      'SSS',SET_SUBARRAY_SIZES
3360      X:00004E X:00004E                   DC      'SSP',SET_SUBARRAY_POSITIONS
3361      X:000050 X:000050                   DC      'DON',START                       ; Nothing special
3362      X:000052 X:000052                   DC      'OSH',OPEN_SHUTTER
3363      X:000054 X:000054                   DC      'CSH',CLOSE_SHUTTER
3364      X:000056 X:000056                   DC      'PON',PWR_ON                      ; Turn on all camera biases and clocks
3365      X:000058 X:000058                   DC      'POF',PWR_OFF                     ; Turn +/- 15V power supplies off
3366      X:00005A X:00005A                   DC      'SET',SET_EXP_TIME                ; Set exposure time
3367      X:00005C X:00005C                   DC      'SEX',START_FT_EXPOSURE           ; Goes to mode-dependent jump table
3368      X:00005E X:00005E                   DC      'AEX',ABORT_EXPOSURE
3369      X:000060 X:000060                   DC      'STG',SET_TRIGGER                 ;  Set Trigger Mode on or off
3370      X:000062 X:000062                   DC      'SIP',SET_IMAGE_PARAM
3371      X:000064 X:000064                   DC      'SRC',SET_ROWS_COLUMNS            ; Set NSR, NPR, and binning
3372      X:000066 X:000066                   DC      'INF',GET_INFO                    ; info command for versioning and more
3373   
3374                                 END_APPLICATON_COMMAND_TABLE
3375      000068                              EQU     @LCV(L)
3376   
3377                                          IF      @SCP("HOST","HOST")
3378      000020                    NUM_COM   EQU     (@LCV(R)-COM_TBL_R)/2             ; No. of boot & application commands
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  tim.s  Page 66



3379                                ;EXPOSING                EQU     CHK_TIM                 ; Address if exposing
3380                                ;CONTINUE_READING        EQU     RDCCD                   ; Address if reading out
3381                                          ENDIF
3382   
3383                                ; ***********  DATA AREAS - READOUT PARAMETERS AND WAVEFORMS  ************
3384                                          IF      @SCP("HOST","HOST")
3385      X:000080 X:000080                   ORG     X:IMGVAR_ADR,X:IMGVAR_ADR
3386      X:000080 X:000080         IMAGE_MODE DC     0
3387                                ; ISTATUS                       DC              0
3388                                ; bum an unused location in low X: for ISTATUS so JSETs work
3389                                ; as per Confluence July 5 #3
3390      000020                    ISTATUS   EQU     EXP_ADR                           ; dangerous!
3391   
3392                                ; some X: variables removed as per Confluence July 1 #4
3393                                ;DSP_VERS       DC      VERSION ; code version must stay in loc,n 102!!
3394                                ;DSP_FLAV       DC      FLAVOR ;  type of dsp support must stay in loc,n 103!!
3395                                ; The next three locations are for tracking the readout timing for gain
3396                                ; calculation, exp-int calculation, and greed factor calculation
3397                                ; They are locations 0x104, 105, and 106
3398                                ;INTTIM         DC      INT_TIM ; per-pixel integration in Leach units
3399                                ;RDELAY         DC      R_DELAY ; serial overlap in Leach units
3400                                ;SIDELAY                DC      SI_DELAY ; parallel overlap in Leach units
3401   
3402                                ;BINBIT         DC      2       ; Bit representation of bin factor, bits 1-5
3403                                                                                    ; 2 = bit 1 set. Bit zero not used.
3404                                ; bum a rarely used location in low X: for BINBIT so JSETs work
3405                                ; as per Confluence July 5 #5
3406      00001E                    BINBIT    EQU     C100K                             ; dangerous!
3407                                                                                    ; Bit representation of bin factor, bits 1-5
3408                                                                                    ; 2 = bit 1 set. Bit zero not used.
3409                                 END_APPLICATION_X_MEMORY
3410      000081                              EQU     @LCV(L)
3411                                          ENDIF
3412   
3413                                          IF      @SCP("HOST","HOST")
3414      Y:000000 Y:000000                   ORG     Y:0,Y:0                           ; Download address
3415                                          ELSE
3417                                          ENDIF
3418   
3419                                ; NSR, NPR, NSBIN, and NPBIN are set by SET_ROWS_COLUMNS
3420      Y:000000 Y:000000         GAIN      DC      0                                 ; Video processor gain and integrator speed
3421      Y:000001 Y:000001         NSR       DC      280                               ; Number Serial Read, prescan + image + bias
3422      Y:000002 Y:000002         NPR       DC      264                               ; Number Parallel Read
3423      Y:000003 Y:000003         NS_CLR    DC      280                               ; To clear serial register, twice
3424      Y:000004 Y:000004         NPCLR     DC      528                               ; To clear parallel register, twice
3425      Y:000005 Y:000005         NSBIN     DC      1                                 ; Serial binning parameter
3426      Y:000006 Y:000006         NPBIN     DC      1                                 ; Parallel binning parameter
3427      Y:000007 Y:000007         NROWS     DC      264                               ; Number of physical rows in CCD
3428      Y:000008 Y:000008         NCOLS     DC      280                               ; Number of physical columns in CCD
3429   
3430                                ; Miscellaneous definitions
3431                                ; Delete TST_DAT since it isn't used.  Need the space so S_SIZE doesn't barf.
3432                                ; TST_DAT       DC      0               ; Temporary definition for test images
3433      Y:000009 Y:000009         SH_DEL    DC      500                               ; Delay in milliseconds between shutter clos
ing
3434                                                                                    ;   and image readout.  Actual delay is 1.5x
3435                                                                                    ;   as long as advertised, e.g. 4.5 ms for 3
.
3436      Y:00000A Y:00000A         CONFIG    DC      CC                                ; Controller configuration
3437                                ; Readout peculiarity parameters
3438                                 SERIAL_SKIP
3439      Y:00000B Y:00000B                   DC      SERIAL_SKIP_SPLIT                 ; Serial skipping waveforms
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  tim.s  Page 67



3440      Y:00000C Y:00000C         SERWAVLEN DC      5                                 ; Serial read waveform table length
3441   
3442                                 SERIAL_CLOCK
3443      Y:00000D Y:00000D                   DC      SERIAL_CLOCK_SPLIT                ; Serial waveform table
3444                                 INITIAL_CLOCK
3445      Y:00000E Y:00000E                   DC      INITIAL_CLOCK_SPLIT               ; Serial waveform table
3446      Y:00000F Y:00000F         IS_PAR_CLK DC     ABCD_DOWN                         ; Addr. of ganged parallel clocking
3447      Y:000010 Y:000010         S_PAR_CLK DC      AB_DOWN                           ; Addr. of storage parallel clocking
3448      Y:000011 Y:000011         IS_PAR_CLR DC     ABCD_CLEAR_DOWN                   ; Addr. of ganged parallel clear
3449      Y:000012 Y:000012         S_PAR_CLR DC      AB_CLEAR_DOWN                     ; Addr. of storage parallel clear
3450   
3451   
3452                                 NSERIALS_READ
3453      Y:000013 Y:000013                   DC      0                                 ; Number of serials to read
3454      Y:000014 Y:000014         NSCLR     DC      0                                 ; Number of waveforms in fast mode
3455      Y:000015 Y:000015         NSKIP1    DC      0                                 ; Number of waveforms in fast mode
3456      Y:000016 Y:000016         NREAD     DC      0                                 ; Number of waveforms in fast mode
3457      Y:000017 Y:000017         NSKIP2    DC      0                                 ; Number of waveforms in fast mode
3458      Y:000018 Y:000018         NBIAS     DC      0                                 ; Number of waveforms in fast mode
3459   
3460                                ; These three parameters are read from the READ_TABLE when needed by the
3461                                ;   RDCCD routine as it loops through the required number of boxes
3462      Y:000019 Y:000019         NP_SKIP   DC      0                                 ; Number of rows to skip
3463      Y:00001A Y:00001A         NS_SKP1   DC      0                                 ; Number of serials to clear before read
3464      Y:00001B Y:00001B         NS_SKP2   DC      0                                 ; Number of serials to clear after read
3465   
3466                                ; Subimage readout parameters. Ten subimage boxes maximum.
3467                                ; All subimage boxes are the same size, NS_READ x NP_READ
3468                                ; NR_BIAS, NS_READ, and NP_READ are set by SET_SUBARRAY_SIZES
3469                                ; The READ_TABLE entries and implicitly NBOXES are set by SET_SUBARRAY_POSITIONS
3470      Y:00001C Y:00001C         NBOXES    DC      0                                 ; Number of boxes to read
3471      Y:00001D Y:00001D         NR_BIAS   DC      0                                 ; Number of bias pixels to read
3472      Y:00001E Y:00001E         NS_READ   DC      0                                 ; Number of columns per box
3473      Y:00001F Y:00001F         NP_READ   DC      0                                 ; Number of rows per box
3474      Y:000020 Y:000020         READ_TABLE DC     0,0,0                             ; #1 = Number of rows to clear,
3475      Y:000023 Y:000023                   DC      0,0,0                             ; #2 = Number of columns to skip before
3476      Y:000026 Y:000026                   DC      0,0,0                             ;   subimage read
3477      Y:000029 Y:000029                   DC      0,0,0                             ; #3 = Number of columns to clear after
3478      Y:00002C Y:00002C                   DC      0,0,0                             ;   subimage read to get to overscan area
3479      Y:00002F Y:00002F                   DC      0,0,0
3480      Y:000032 Y:000032                   DC      0,0,0
3481      Y:000035 Y:000035                   DC      0,0,0
3482                                ;       DC      0,0,0
3483   
3484                                ; IMAGE_MODE, SROWS, IFRAMES, and INTERVAL are set by SET_IMAGE_PARAM
3485                                ; UBSROWS is set later on by UB_CONV.  S_SIZE is hardwired.
3486      Y:000038 Y:000038         SROWS     DC      1                                 ; Number of Storage image rows to Loop over
3487      Y:000039 Y:000039         UBSROWS   DC      1                                 ; SROWS in unbinned pixels.  Set by UB_CONV
3488      Y:00003A Y:00003A         IFRAMES   DC      1                                 ; Number of Series frames to Loop over
3489                                ; MATCH nasa42 for now!
3490                                ;S_SIZE         DC      2056    ; Number of rows in the Storage Array
3491      Y:00003B Y:00003B         S_SIZE    DC      1000                              ; Number of rows in the Storage Array
3492                                ;S_SIZE         DC      10      ; Number of rows in the Storage Array
3493                                                                                    ; NOTE: Not equal to # rows in image area!
3494      Y:00003C Y:00003C         INTERVAL  DC      7                                 ; Interval to pause for soft trigger
3495      Y:00003D Y:00003D         AMPVAL    DC      0                                 ; Amplifier selected
3496      Y:00003E Y:00003E         IFLPCNT   DC      0                                 ; 24-bit IFRAMES loop counter for timmisc.s
3497      Y:00003F Y:00003F         TESTLOC1  DC      0                                 ; Test location
3498                                ; NOTE:  TESTLOC1 is address 63 in the Y memory.  There are addressing problems
3499                                ; starting at the next address (64).
3500   
3501                                ; Include the waveform table
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  tim.s  Page 68



3502                                          INCLUDE "lmi.waveforms.s"                 ; Readout and clocking waveforms
3503                                ; Waveform tables and definitions for the e2v CCD231 4K sq. frame
3504                                ; transfer CCD for the 42" camera.
3505   
3506                                ; CCD clock voltage definitions
3507      000000                    VIDEO     EQU     $000000                           ; Video processor board select = 0
3508      002000                    CLK2      EQU     $002000                           ; Clock driver board select = 2
3509      003000                    CLK3      EQU     $003000                           ; Clock driver board select = 3
3510                                ; nasa42 not used
3511                                ;CLK_ZERO       EQU     $000800 ; Zero volts on clock driver line
3512                                ;BIAS_ZERO      EQU     $000800 ; Zero volts on bias line
3513   
3514                                ; imported from GWAVES_CCD67
3515      200000                    CLKV      EQU     $200000                           ; Clock driver board DAC voltage selection a
ddress
3516      000000                    VID0      EQU     $000000                           ; Address of video board DACS
3517      0E0000                    DAC_ADDR  EQU     $0E0000                           ; DAC Channel Address
3518      0F4000                    DAC_RegM  EQU     $0F4000                           ; DAC m Register
3519      0F8000                    DAC_RegC  EQU     $0F8000                           ; DAC c Register
3520      0FC000                    DAC_RegD  EQU     $0FC000                           ; DAC X1 Register
3521      1.300000E+001             Vmax      EQU     13.0                              ; Maximum clock driver voltage
3522      0.000000E+000             ZERO      EQU     0.0                               ; Unused pins
3523   
3524   
3525                                ; For NASA42 we uncommented one of these lines at a time
3526                                ;INT_TIM        EQU     $080000 ; 1.0 us/px - use gain 9.5, clips at PRAM
3527                                ;INT_TIM        EQU     $130000 ; 1.4 us/px - use gain 4.75, clips at PRAM
3528                                ;INT_TIM                EQU     $1D0000 ; 1.8 us/px - use gain 2
3529                                ;INT_TIM        EQU     $2D0000 ; 2.5 us/px - use gain 2, doesn't clip
3530                                ;INT_TIM        EQU     $600000 ; 4.7 us/px - use gain 1; Doesn't clip
3531   
3532                                ; INT_TIM, controlled by Makefile def'n INTTIM_SETTING
3533                                ; as per Confluence July 1 end commentary
3534   
3535                                          IF      @SCP("1D","08")
3538                                          ENDIF
3539                                          IF      @SCP("1D","13")
3542                                          ENDIF
3543                                          IF      @SCP("1D","1D")
3544                                ; on nasa42, 1.8 us/pxl- use gain 2
3545                                ; this is in production at the 42"
3546      1D0000                    INT_TIM   EQU     $1D0000
3547                                          ENDIF
3548                                          IF      @SCP("1D","2D")
3551                                          ENDIF
3552                                          IF      @SCP("1D","60")
3555                                          ENDIF
3556   
3557   
3558   
3559                                ;ADC_TIM                EQU     $0C0000 ; Slow ADC TIME
3560      000000                    ADC_TIM   EQU     $000000                           ; Fast ADC TIME
3561   
3562   
3563                                ; Delay numbers in clocking
3564                                ; from nasa42
3565                                ;SI_DELAY       EQU     $BF0000 ; 10 microsecond parallel delay time
3566   
3567                                ; SI_DELAY, controlled by Makefile def'n SIDELAY_SETTING
3568                                ; as per Confluence July 1 end commentary
3569                                          IF      @SCP("BF","BF")
3570                                ; 10 us parallel delay time
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 69



3571      BF0000                    SI_DELAY  EQU     $BF0000                           ; Fast Storage/Image Delay
3572                                          ENDIF
3573   
3574   
3575      FC0000                    DG_DELAY  EQU     $FC0000                           ; 20 microsecond dump gate delay time
3576                                ;
3577                                ; from nasa42
3578                                ;R_DELAY                EQU     $000000 ; Fast serial regisiter transfer delay.  Set to $0x0000.
3579   
3580                                ; R_DELAY, controlled by Makefile def'n RDELAY_SETTING
3581                                ; as per Confluence July 1 end commentary
3582                                          IF      @SCP("00","00")
3583   
3584      000000                    R_DELAY   EQU     $000000                           ; Fast serial register transfer delay
3585                                          ENDIF
3586   
3587   
3588   
3589      030000                    CDS_TIM   EQU     $030000                           ; Delay for single clock between reset & dat
a
3590   
3591                                ; Clock voltages in volts
3592      3.000000E+000             RG_HI     EQU     +3.0                              ; Reset
3593      -8.000000E+000            RG_LO     EQU     -8.0                              ;
3594      1.000000E+000             R_HI      EQU     +1.0                              ; Serials
3595      -8.000000E+000            R_LO      EQU     -8.0                              ;
3596      1.000000E+000             SW_HI     EQU     +1.0                              ; Summing well, mode 1
3597      -8.000000E+000            SW_LO     EQU     -8.0                              ;
3598                                ; SW_HI EQU     -7.0    ; Summing well, mode 2
3599                                ; SW_LO EQU     -7.0    ;
3600      1.000000E+000             SI_HI     EQU     +1.0                              ; Parallels
3601      -9.000000E+000            SI_LO     EQU     -9.0                              ;
3602      1.000000E+000             TG_HI     EQU     +1.0                              ; Transfer Gate
3603      -9.000000E+000            TG_LO     EQU     -9.0                              ;
3604      3.000000E+000             DG_HI     EQU     +3.0                              ; Dump Gate
3605      -9.000000E+000            DG_LO     EQU     -9.0                              ;
3606   
3607                                ; DC Bias voltages in volts
3608      2.450000E+001             VOD       EQU     24.5                              ; Output Drain Left.  Best linearity at 24.5
/14
3609      1.400000E+001             VRD       EQU     14.0                              ; Reset Drain Left      on OD/RD.  See 20100
511 notes
3610      -7.000000E+000            VOG       EQU     -7.0                              ; Output Gate, mode 1
3611                                ; VOG   EQU     +10.0   ; Output Gate, mode 2
3612      2.000000E+001             VDD       EQU     +20.0                             ; Dump Drain
3613   
3614                                ; from gwaves_CCD67
3615      -6.000000E+000            VABG      EQU     -6.0                              ; Anti-blooming gate
3616      6.000000E+000             PWR       EQU     +6.0                              ; Preamp power - xxx Not used, keep as place
holder
3617   
3618   
3619      000700                    OFFSET    EQU     $700
3620      000700                    OFFSET0   EQU     $700                              ; e2v E, Peter's C, board 0, ch 0
3621      0006EF                    OFFSET1   EQU     $6EF                              ; e2v F, Peter's D, board 0, ch 1
3622      000700                    OFFSET2   EQU     $700                              ; e2v G, Peter's B, board 1, ch 0
3623      000700                    OFFSET3   EQU     $700                              ; e2v H, Peter's A, board 1, ch 1
3624   
3625                                ; Define switch state bits for the lower CCD clock driver bank CLK2
3626                                ; Pins 11-12, clocks 10 & 11, are not used
3627      000001                    SEH1      EQU     1                                 ; Serial #1 E & H registers, Pin 1 - clock 0
3628      000002                    SEH2      EQU     2                                 ; Serial #2 E & H registers, Pin 2 - clock 1
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 70



3629      000004                    SEH3      EQU     4                                 ; Serial #3 E & H registers, Pin 3 - clock 2
3630      000008                    SFG1      EQU     8                                 ; Serial #1 F & G registers, Pin 4 - clock 3
3631      000010                    SFG2      EQU     $10                               ; Serial #2 F & G registers, Pin 5 - clock 4
3632      000020                    SFG3      EQU     $20                               ; Serial #3 F & G registers, Pin 6 - clock 5
3633      000040                    SWEH      EQU     $40                               ; Summing well E & H registers, Pin 7 - cloc
k 6
3634      000080                    SWFG      EQU     $80                               ; Summing well F & G registers, Pin 8 - cloc
k 7
3635      000100                    REH       EQU     $100                              ; Reset Gate E & H registers, Pin 9 - clock 
8
3636      000200                    RFG       EQU     $200                              ; Reset Gate F & G registers, Pin 10 - clock
 9
3637   
3638                                ; Define switch state bits for the upper CCD clock driver bank CLK3
3639                                ; All 12 of these are used
3640      000001                    AB1       EQU     1                                 ; Parallel A & B, phase #1, Pin 13 - clock 1
2
3641      000002                    AB2       EQU     2                                 ; Parallel A & B, phase #2, Pin 14 - clock 1
3
3642      000004                    AB3       EQU     4                                 ; Parallel A & B, phase #3, Pin 15 - clock 1
4
3643      000008                    AB4       EQU     8                                 ; Parallel A & B, phase #4, Pin 16 - clock 1
5
3644      000010                    CD1       EQU     $10                               ; Parallel C & D, phase #1, Pin 17 - clock 1
6
3645      000020                    CD2       EQU     $20                               ; Parallel C & D, phase #2, Pin 18 - clock 1
7
3646      000040                    CD3       EQU     $40                               ; Parallel C & D, phase #3, Pin 19 - clock 1
8
3647      000080                    CD4       EQU     $80                               ; Parallel C & D, phase #4, Pin 33 - clock 1
9
3648      000100                    TGA       EQU     $100                              ; Transfer Gate A, Pin 34 - clock 20
3649      000200                    TGD       EQU     $200                              ; Transfer Gate D, Pin 35 - clock 21
3650      000400                    DGA       EQU     $400                              ; Dump Gate A, Pin 36 - clock 22
3651      000800                    DGD       EQU     $800                              ; Dump Gate D, Pin 37 - clock 23
3652   
3653                                ;                  EH Side                                            FG Side
3654                                ;       OG  SW  1  2  3  1 .... EH1  EH2  EH3  FG2  FG1  .....  1  3  2  1  SW  OG
3655   
3656                                ; Transfer gate dumps into serial 1 and 2.
3657                                ; Serial 1 & 2 are high between serial clock code lumps.
3658   
3659                                ; Video processor bit definition
3660                                ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3661   
3662                                SERIAL_IDLE                                         ; Split serial during idle
3663      Y:000040 Y:000040                   DC      END_SERIAL_IDLE-SERIAL_IDLE-1
3664      Y:000041 Y:000041                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3665      Y:000042 Y:000042                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
3666      Y:000043 Y:000043                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
3667      Y:000044 Y:000044                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3668      Y:000045 Y:000045                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3669      Y:000046 Y:000046                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3670      Y:000047 Y:000047                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
3671      Y:000048 Y:000048                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
3672      Y:000049 Y:000049                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
3673      Y:00004A Y:00004A                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
3674      Y:00004B Y:00004B                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
3675      Y:00004C Y:00004C                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
3676      Y:00004D Y:00004D                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3677                                END_SERIAL_IDLE
3678   
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 71



3679                                ; The following waveforms are for binned operation.  This is for mode 1, i.e.
3680                                ; using a summing well.  Mode 2 uses SW as a second OG and binning has to be
3681                                ; done on the output node like in HIPO.
3682   
3683                                INITIAL_CLOCK_SPLIT                                 ; Both amplifiers
3684      Y:00004E Y:00004E                   DC      END_INITIAL_CLOCK_SPLIT-INITIAL_CLOCK_SPLIT-1
3685      Y:00004F Y:00004F                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3686      Y:000050 Y:000050                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
3687      Y:000051 Y:000051                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
3688      Y:000052 Y:000052                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3689      Y:000053 Y:000053                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3690      Y:000054 Y:000054                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3691                                END_INITIAL_CLOCK_SPLIT
3692   
3693                                INITIAL_CLOCK_EH                                    ; Shift to E and H amplifiers
3694      Y:000055 Y:000055                   DC      END_INITIAL_CLOCK_EH-INITIAL_CLOCK_EH-1
3695      Y:000056 Y:000056                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3696      Y:000057 Y:000057                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
3697      Y:000058 Y:000058                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
3698      Y:000059 Y:000059                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
3699      Y:00005A Y:00005A                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
3700      Y:00005B Y:00005B                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
3701                                END_INITIAL_CLOCK_EH
3702   
3703                                INITIAL_CLOCK_FG                                    ; Shift to F and G amplifiers
3704      Y:00005C Y:00005C                   DC      END_INITIAL_CLOCK_FG-INITIAL_CLOCK_FG-1
3705      Y:00005D Y:00005D                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3706      Y:00005E Y:00005E                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
3707      Y:00005F Y:00005F                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
3708      Y:000060 Y:000060                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
3709      Y:000061 Y:000061                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
3710      Y:000062 Y:000062                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
3711                                END_INITIAL_CLOCK_FG
3712   
3713                                SERIAL_CLOCK_SPLIT                                  ; Both amplifiers
3714      Y:000063 Y:000063                   DC      END_SERIAL_CLOCK_SPLIT-SERIAL_CLOCK_SPLIT-1
3715      Y:000064 Y:000064                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
3716      Y:000065 Y:000065                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
3717      Y:000066 Y:000066                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
3718      Y:000067 Y:000067                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3719      Y:000068 Y:000068                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3720      Y:000069 Y:000069                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3721                                END_SERIAL_CLOCK_SPLIT
3722   
3723                                SERIAL_CLOCK_EH                                     ; Shift to E and H amplifiers
3724      Y:00006A Y:00006A                   DC      END_SERIAL_CLOCK_EH-SERIAL_CLOCK_EH-1
3725      Y:00006B Y:00006B                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
3726      Y:00006C Y:00006C                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
3727      Y:00006D Y:00006D                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
3728      Y:00006E Y:00006E                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
3729      Y:00006F Y:00006F                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
3730      Y:000070 Y:000070                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
3731                                END_SERIAL_CLOCK_EH
3732   
3733                                SERIAL_CLOCK_FG                                     ; Shift to F and G amplifiers
3734      Y:000071 Y:000071                   DC      END_SERIAL_CLOCK_FG-SERIAL_CLOCK_FG-1
3735      Y:000072 Y:000072                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
3736      Y:000073 Y:000073                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
3737      Y:000074 Y:000074                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
3738      Y:000075 Y:000075                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
3739      Y:000076 Y:000076                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
3740      Y:000077 Y:000077                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 72



3741                                END_SERIAL_CLOCK_FG
3742   
3743                                VIDEO_PROCESS
3744      Y:000078 Y:000078                   DC      END_VIDEO_PROCESS-VIDEO_PROCESS-1
3745                                SXMIT_VP
3746      Y:000079 Y:000079                   DC      $00F020                           ; Transmit A/D data to host; overwritten by 
SOS
3747      Y:00007A Y:00007A                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
3748      Y:00007B Y:00007B                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
3749      Y:00007C Y:00007C                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
3750                                CCLK_1                                              ; The following line is overwritten by timmi
sc.s
3751      Y:00007D Y:00007D                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
3752      Y:00007E Y:00007E                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
3753      Y:00007F Y:00007F                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
3754      Y:000080 Y:000080                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3755                                END_VIDEO_PROCESS
3756   
3757                                ; Starting Y: address of circular waveforms for no-overhead access
3758      0000C0                    STRT_CIR  EQU     $C0
3759                                ;ROM_DISP       EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+STRT_CIR
3760                                ;DAC_DISP       EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+$100
3761   
3762                                ; Check for Y: data memory overflow
3763                                          IF      @CVS(N,*)>STRT_CIR
3765                                          ENDIF                                     ;  will not overflow
3766   
3767                                ; The fast serial code with the circulating address register must start
3768                                ;   on a boundary that is a multiple of the address register modulus.
3769   
3770                                          IF      @SCP("HOST","HOST")
3771      Y:0000C0 Y:0000C0                   ORG     Y:STRT_CIR,Y:STRT_CIR             ; Download address
3772                                          ELSE
3774                                          ENDIF
3775   
3776                                ; This is an area to copy in the serial fast binned waveforms from high Y memory
3777                                ; It is 0x28 = 40 locations long, enough to put in a binned-by-four waveform
3778                                ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3779                                SERIAL_READ                                         ; Split serial during idle
3780      Y:0000C0 Y:0000C0                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3781      Y:0000C1 Y:0000C1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
3782      Y:0000C2 Y:0000C2                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
3783      Y:0000C3 Y:0000C3                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3784      Y:0000C4 Y:0000C4                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3785      Y:0000C5 Y:0000C5                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3786      Y:0000C6 Y:0000C6                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
3787      Y:0000C7 Y:0000C7                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
3788      Y:0000C8 Y:0000C8                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
3789      Y:0000C9 Y:0000C9                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3790      Y:0000CA Y:0000CA                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3791      Y:0000CB Y:0000CB                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3792      Y:0000CC Y:0000CC                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
3793      Y:0000CD Y:0000CD                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
3794      Y:0000CE Y:0000CE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
3795      Y:0000CF Y:0000CF                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3796      Y:0000D0 Y:0000D0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3797      Y:0000D1 Y:0000D1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3798      Y:0000D2 Y:0000D2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
3799      Y:0000D3 Y:0000D3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
3800      Y:0000D4 Y:0000D4                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
3801      Y:0000D5 Y:0000D5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3802      Y:0000D6 Y:0000D6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 73



3803      Y:0000D7 Y:0000D7                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3804                                SXMIT
3805      Y:0000D8 Y:0000D8                   DC      $00F000                           ; Transmit A/D data to host; overwritten by 
SOS
3806      Y:0000D9 Y:0000D9                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
3807      Y:0000DA Y:0000DA                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
3808      Y:0000DB Y:0000DB                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
3809      Y:0000DC Y:0000DC                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
3810      Y:0000DD Y:0000DD                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
3811      Y:0000DE Y:0000DE                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
3812      Y:0000DF Y:0000DF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3813                                END_SERIAL_READ
3814   
3815   
3816                                ; Serial clocking waveform for skipping
3817                                          IF      @SCP("HOST","HOST")
3818      Y:0000E8 Y:0000E8                   ORG     Y:STRT_CIR+$28,Y:STRT_CIR+$28     ; Download address
3819                                          ELSE
3821                                          ENDIF
3822   
3823                                ; There are three serial skip waveforms that must all be the same length
3824                                SERIAL_SKIP_EH
3825      Y:0000E8 Y:0000E8                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3826      Y:0000E9 Y:0000E9                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
3827      Y:0000EA Y:0000EA                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+0000
3828      Y:0000EB Y:0000EB                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+0000
3829      Y:0000EC Y:0000EC                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+0000
3830      Y:0000ED Y:0000ED                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
3831      Y:0000EE Y:0000EE                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3832                                END_SERIAL_SKIP_EH
3833   
3834                                          IF      @SCP("HOST","HOST")
3835      Y:0000F0 Y:0000F0                   ORG     Y:STRT_CIR+$30,Y:STRT_CIR+$30     ; Download address
3836                                          ELSE
3838                                          ENDIF
3839   
3840                                SERIAL_SKIP_FG
3841      Y:0000F0 Y:0000F0                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3842      Y:0000F1 Y:0000F1                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
3843      Y:0000F2 Y:0000F2                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+0000
3844      Y:0000F3 Y:0000F3                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+0000
3845      Y:0000F4 Y:0000F4                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+0000
3846      Y:0000F5 Y:0000F5                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
3847      Y:0000F6 Y:0000F6                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3848                                END_SERIAL_SKIP_FG
3849   
3850                                          IF      @SCP("HOST","HOST")
3851      Y:0000F8 Y:0000F8                   ORG     Y:STRT_CIR+$38,Y:STRT_CIR+$38     ; Download address
3852                                          ELSE
3854                                          ENDIF
3855   
3856                                SERIAL_SKIP_SPLIT
3857      Y:0000F8 Y:0000F8                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3858      Y:0000F9 Y:0000F9                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
3859      Y:0000FA Y:0000FA                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+SFG1+0000+SFG3+0000
3860      Y:0000FB Y:0000FB                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+0000
3861      Y:0000FC Y:0000FC                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+0000+SFG2+SFG3+0000
3862      Y:0000FD Y:0000FD                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
3863      Y:0000FE Y:0000FE                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3864                                END_SERIAL_SKIP_SPLIT
3865   
3866                                ; Put all the following code in SRAM.
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 74



3867                                          IF      @SCP("HOST","HOST")
3868      Y:000100 Y:000100                   ORG     Y:$100,Y:$100                     ; Download address
3869                                          ELSE
3871                                          ENDIF
3872   
3873                                ; original nasa42 dacs, all will change
3874                                        COMMENT |
3875   
3876                                ; Initialization of clock driver and video processor DACs and switches
3877                                DACS    DC      END_DACS-DACS-1
3878                                        DC      (CLK2<<8)+(0<<14)+@CVI((R_HI+10.0)/20.0*4095)           ; Serial EH1 High, pin 1
3879                                        DC      (CLK2<<8)+(1<<14)+@CVI((R_LO+10.0)/20.0*4095)           ; Serial EH1 Low
3880                                        DC      (CLK2<<8)+(2<<14)+@CVI((R_HI+10.0)/20.0*4095)           ; Serial EH2 High, pin 2
3881                                        DC      (CLK2<<8)+(3<<14)+@CVI((R_LO+10.0)/20.0*4095)           ; Serial EH2 Low
3882                                        DC      (CLK2<<8)+(4<<14)+@CVI((R_HI+10.0)/20.0*4095)           ; Serial EH3 High, pin 3
3883                                        DC      (CLK2<<8)+(5<<14)+@CVI((R_LO+10.0)/20.0*4095)           ; Serial EH3 Low
3884   
3885                                        DC      (CLK2<<8)+(6<<14)+@CVI((R_HI+10.0)/20.0*4095)           ; Serial FG1 High, pin 4
3886                                        DC      (CLK2<<8)+(7<<14)+@CVI((R_LO+10.0)/20.0*4095)           ; Serial FG1 Low
3887                                        DC      (CLK2<<8)+(8<<14)+@CVI((R_HI+10.0)/20.0*4095)           ; Serial FG2 High, pin 5
3888                                        DC      (CLK2<<8)+(9<<14)+@CVI((R_LO+10.0)/20.0*4095)           ; Serial FG2 Low
3889                                        DC      (CLK2<<8)+(10<<14)+@CVI((R_HI+10.0)/20.0*4095)          ; Serial FG3 High, pin 6
3890                                        DC      (CLK2<<8)+(11<<14)+@CVI((R_LO+10.0)/20.0*4095)          ; Serial FG3 Low
3891   
3892                                        DC      (CLK2<<8)+(12<<14)+@CVI((SW_HI+10.0)/20.0*4095)         ; Summing well EH High, 
pin 7
3893                                        DC      (CLK2<<8)+(13<<14)+@CVI((SW_LO+10.0)/20.0*4095)         ; Summing well EH Low
3894                                        DC      (CLK2<<8)+(14<<14)+@CVI((SW_HI+10.0)/20.0*4095)         ; Summing well FG High, 
pin 8
3895                                        DC      (CLK2<<8)+(15<<14)+@CVI((SW_LO+10.0)/20.0*4095)         ; Summing well FG Low
3896   
3897                                        DC      (CLK2<<8)+(16<<14)+@CVI((RG_HI+10.0)/20.0*4095)         ; Reset gate EH High, pi
n 9
3898                                        DC      (CLK2<<8)+(17<<14)+@CVI((RG_LO+10.0)/20.0*4095)         ; Reset gate EH Low
3899                                        DC      (CLK2<<8)+(18<<14)+@CVI((RG_HI+10.0)/20.0*4095)         ; Reset gate FG High, pi
n 10
3900                                        DC      (CLK2<<8)+(19<<14)+@CVI((RG_LO+10.0)/20.0*4095)         ; Reset gate FG Low
3901   
3902                                        DC      (CLK2<<8)+(20<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095)      ; Unused High, pin 11
3903                                        DC      (CLK2<<8)+(21<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095)      ; Unused Low
3904                                        DC      (CLK2<<8)+(22<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095)      ; Unused High, pin 12
3905                                        DC      (CLK2<<8)+(23<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095)      ; Unused Low
3906   
3907                                        DC      (CLK2<<8)+(24<<14)+@CVI((SI_HI+10.0)/20.0*4095)         ; Parallel AB1 High, pin
 13
3908                                        DC      (CLK2<<8)+(25<<14)+@CVI((SI_LO+10.0)/20.0*4095)         ; Parallel AB1 Low
3909                                        DC      (CLK2<<8)+(26<<14)+@CVI((SI_HI+10.0)/20.0*4095)         ; Parallel AB2 High, pin
 14
3910                                        DC      (CLK2<<8)+(27<<14)+@CVI((SI_LO+10.0)/20.0*4095)         ; Parallel AB2 Low
3911                                        DC      (CLK2<<8)+(28<<14)+@CVI((SI_HI+10.0)/20.0*4095)         ; Parallel AB3 High, pin
 15
3912                                        DC      (CLK2<<8)+(29<<14)+@CVI((SI_LO+10.0)/20.0*4095)         ; Parallel AB3 Low
3913                                        DC      (CLK2<<8)+(30<<14)+@CVI((SI_HI+10.0)/20.0*4095)         ; Parallel AB4 High, pin
 16
3914                                        DC      (CLK2<<8)+(31<<14)+@CVI((SI_LO+10.0)/20.0*4095)         ; Parallel AB4 Low
3915   
3916                                        DC      (CLK2<<8)+(32<<14)+@CVI((SI_HI+10.0)/20.0*4095)         ; Parallel CD1 High, pin
 17
3917                                        DC      (CLK2<<8)+(33<<14)+@CVI((SI_LO+10.0)/20.0*4095)         ; Parallel CD1 Low
3918                                        DC      (CLK2<<8)+(34<<14)+@CVI((SI_HI+10.0)/20.0*4095)         ; Parallel CD2 High, pin
 18
3919                                        DC      (CLK2<<8)+(35<<14)+@CVI((SI_LO+10.0)/20.0*4095)         ; Parallel CD2 Low
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 75



3920                                        DC      (CLK2<<8)+(36<<14)+@CVI((SI_HI+10.0)/20.0*4095)         ; Parallel CD3 High, pin
 19
3921                                        DC      (CLK2<<8)+(37<<14)+@CVI((SI_LO+10.0)/20.0*4095)         ; Parallel CD3 Low
3922                                        DC      (CLK2<<8)+(38<<14)+@CVI((SI_HI+10.0)/20.0*4095)         ; Parallel CD4 High, pin
 33
3923                                        DC      (CLK2<<8)+(39<<14)+@CVI((SI_LO+10.0)/20.0*4095)         ; Parallel CD4 Low
3924   
3925                                        DC      (CLK2<<8)+(40<<14)+@CVI((TG_HI+10.0)/20.0*4095)         ; Transfer gate A High, 
pin 34
3926                                        DC      (CLK2<<8)+(41<<14)+@CVI((TG_LO+10.0)/20.0*4095)         ; Transfer gate A Low
3927                                        DC      (CLK2<<8)+(42<<14)+@CVI((TG_HI+10.0)/20.0*4095)         ; Transfer gate D High, 
pin 35
3928                                        DC      (CLK2<<8)+(43<<14)+@CVI((TG_LO+10.0)/20.0*4095)         ; Transfer gate D Low
3929   
3930                                        DC      (CLK2<<8)+(44<<14)+@CVI((DG_HI+10.0)/20.0*4095)         ; Dump gate A High, pin 
36
3931                                        DC      (CLK2<<8)+(45<<14)+@CVI((DG_LO+10.0)/20.0*4095)         ; Dump gate A Low
3932                                        DC      (CLK2<<8)+(46<<14)+@CVI((DG_HI+10.0)/20.0*4095)         ; Dump gate D High, pin 
37
3933                                        DC      (CLK2<<8)+(47<<14)+@CVI((DG_LO+10.0)/20.0*4095)         ; Dump gate D Low
3934   
3935                                ; Set gain and integrator speed.  Uncomment the line pair you want
3936                                ;       DC      $0c3f77                 ; Gain x1, fast integ speed, board #0
3937                                ;       DC      $1c3f77                 ; Gain x1, fast integ speed, board #1
3938                                        DC      $0c3fbb                 ; Gain x2, fast integ speed, board #0
3939                                        DC      $1c3fbb                 ; Gain x2, fast integ speed, board #1
3940                                ;       DC      $0c3fdd                 ; Gain x4.75, fast integ speed, board #0
3941                                ;       DC      $1c3fdd                 ; Gain x4.75, fast integ speed, board #1
3942                                ;       DC      $0c3fee                 ; Gain x9.50, fast integ speed, board #0
3943                                ;       DC      $1c3fee                 ; Gain x9.50, fast integ speed, board #1
3944   
3945                                ;       DC      $0c3cee                 ; Gain x9.50, slow integ speed, board #0.  For reference
 only
3946                                ;       DC      $1c3cee                 ; Gain x9.50, slow integ speed, board #1.  We don't use 
slow integ.
3947   
3948                                ; Input offset voltages for DC coupling. Target is U4#6 = 24 volts.  We don't use these.
3949                                        DC      $0c0800                 ; Input offset, ch. 0, board 0
3950                                        DC      $0c8800                 ; Input offset, ch. 1, board 0
3951                                        DC      $1c0800                 ; Input offset, ch. 0, board 1
3952                                        DC      $1c8800                 ; Input offset, ch. 1, board 1
3953   
3954                                ; Output offset voltages
3955                                        DC      $0c4000+OFFSET0         ; Output video offset, ch. 0, board 0, e2v E, Peter's C
3956                                        DC      $0cc000+OFFSET1         ; Output video offset, ch. 1, board 0, e2v F, Peter's D
3957                                        DC      $1c4000+OFFSET2         ; Output video offset, ch. 0, board 1, e2v G, Peter's B
3958                                        DC      $1cc000+OFFSET3         ; Output video offset, ch. 1, board 1, e2v H, Peter's A
3959   
3960                                ; Output and reset drain DC bias voltages
3961                                        DC      $0d0000+@CVI((VOD-7.50)/22.5*4095)      ; VOD E pin #1, Board 0
3962                                        DC      $0d4000+@CVI((VOD-7.50)/22.5*4095)      ; VOD F pin #2
3963                                        DC      $0d8000+@CVI((VRD-5.00)/15.0*4095)      ; VRD E pin #3
3964                                        DC      $0dc000+@CVI((VRD-5.00)/15.0*4095)      ; VRD F pin #4
3965                                        DC      $1d0000+@CVI((VOD-7.50)/22.5*4095)      ; VOD G pin #1, Board 1
3966                                        DC      $1d4000+@CVI((VOD-7.50)/22.5*4095)      ; VOD H pin #2
3967                                        DC      $1d8000+@CVI((VRD-5.00)/15.0*4095)      ; VRD G pin #3
3968                                        DC      $1dc000+@CVI((VRD-5.00)/15.0*4095)      ; VRD H pin #4
3969   
3970                                ; Dump gates and output gates
3971                                        DC      $0e0000+@CVI((VDD-5.00)/15.0*4095)      ; Dump drain A, pin #5, Board 0
3972                                        DC      $0e4000+BIAS_ZERO                       ; Unused pin #6
3973                                        DC      $0e8000+BIAS_ZERO                       ; Unused pin #7
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 76



3974                                        DC      $0ec000+BIAS_ZERO                       ; Unused pin #8
3975                                        DC      $0f0000+BIAS_ZERO                       ; Unused pin #9
3976                                        DC      $0f4000+BIAS_ZERO                       ; Unused pin #10
3977                                        DC      $0f8000+@CVI((VOG+10.0)/20.0*4095)      ; Output Gate E pin #11
3978                                        DC      $0fc000+@CVI((VOG+10.0)/20.0*4095)      ; Output Gate F pin #12
3979   
3980                                        DC      $1e0000+@CVI((VDD-5.00)/15.0*4095)      ; Dump drain D, pin #5, Board 1
3981                                        DC      $1e4000+BIAS_ZERO                       ; Unused pin #6
3982                                        DC      $1e8000+BIAS_ZERO                       ; Unused pin #7
3983                                        DC      $1ec000+BIAS_ZERO                       ; Unused pin #8
3984                                        DC      $1f0000+BIAS_ZERO                       ; Unused pin #9
3985                                        DC      $1f4000+BIAS_ZERO                       ; Unused pin #10
3986                                        DC      $1f8000+@CVI((VOG+10.0)/20.0*4095)      ; Output Gate G pin #11
3987                                        DC      $1fc000+@CVI((VOG+10.0)/20.0*4095)      ; Output Gate H pin #12
3988                                END_DACS
3989                                        |
3990   
3991                                ; DACS from gwaves_CCD67 dropped in here
3992   
3993   
3994                                ; Initialization of clock driver and video processor DACs and switches
3995                                ; This is for the ARC 47 4-channel video board
3996      Y:000100 Y:000100         DACS      DC      END_DACS-DACS-1
3997      Y:000101 Y:000101                   DC      CLKV+$0A0080                      ; DAC = unbuffered mode
3998      Y:000102 Y:000102                   DC      CLKV+$000100+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #1, Unused
3999      Y:000103 Y:000103                   DC      CLKV+$000200+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4000      Y:000104 Y:000104                   DC      CLKV+$000400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #2, Unused
4001      Y:000105 Y:000105                   DC      CLKV+$000800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4002      Y:000106 Y:000106                   DC      CLKV+$002000+@CVI((RG_HI+Vmax)/(2*Vmax)*255) ; Pin #3, RG Left
4003      Y:000107 Y:000107                   DC      CLKV+$004000+@CVI((RG_LO+Vmax)/(2*Vmax)*255)
4004      Y:000108 Y:000108                   DC      CLKV+$008000+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #4, S3 Left
4005      Y:000109 Y:000109                   DC      CLKV+$010000+@CVI((R_LO+Vmax)/(2*Vmax)*255)
4006      Y:00010A Y:00010A                   DC      CLKV+$020100+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #5, S2 Left
4007      Y:00010B Y:00010B                   DC      CLKV+$020200+@CVI((R_LO+Vmax)/(2*Vmax)*255)
4008      Y:00010C Y:00010C                   DC      CLKV+$020400+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #6, S1 Left
4009      Y:00010D Y:00010D                   DC      CLKV+$020800+@CVI((R_LO+Vmax)/(2*Vmax)*255)
4010      Y:00010E Y:00010E                   DC      CLKV+$022000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #7, Unused
4011      Y:00010F Y:00010F                   DC      CLKV+$024000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4012      Y:000110 Y:000110                   DC      CLKV+$028000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #8, Unused
4013      Y:000111 Y:000111                   DC      CLKV+$030000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4014      Y:000112 Y:000112                   DC      CLKV+$040100+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #9, S1 Right
4015      Y:000113 Y:000113                   DC      CLKV+$040200+@CVI((R_LO+Vmax)/(2*Vmax)*255)
4016      Y:000114 Y:000114                   DC      CLKV+$040400+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #10, S2 Right
4017      Y:000115 Y:000115                   DC      CLKV+$040800+@CVI((R_LO+Vmax)/(2*Vmax)*255)
4018      Y:000116 Y:000116                   DC      CLKV+$042000+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #11, S3 Right
4019      Y:000117 Y:000117                   DC      CLKV+$044000+@CVI((R_LO+Vmax)/(2*Vmax)*255)
4020      Y:000118 Y:000118                   DC      CLKV+$048000+@CVI((RG_HI+Vmax)/(2*Vmax)*255) ; Pin #12, RG Right
4021      Y:000119 Y:000119                   DC      CLKV+$050000+@CVI((RG_LO+Vmax)/(2*Vmax)*255)
4022   
4023      Y:00011A Y:00011A                   DC      CLKV+$060100+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #13, I1
4024      Y:00011B Y:00011B                   DC      CLKV+$060200+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
4025      Y:00011C Y:00011C                   DC      CLKV+$060400+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #14, I2
4026      Y:00011D Y:00011D                   DC      CLKV+$060800+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
4027      Y:00011E Y:00011E                   DC      CLKV+$062000+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #15, I3
4028      Y:00011F Y:00011F                   DC      CLKV+$064000+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
4029      Y:000120 Y:000120                   DC      CLKV+$068000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #16, Unused
4030      Y:000121 Y:000121                   DC      CLKV+$070000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4031      Y:000122 Y:000122                   DC      CLKV+$080100+@CVI((DG_HI+Vmax)/(2*Vmax)*255) ; Pin #17, DG
4032      Y:000123 Y:000123                   DC      CLKV+$080200+@CVI((DG_LO+Vmax)/(2*Vmax)*255)
4033      Y:000124 Y:000124                   DC      CLKV+$080400+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #18, Unused
4034      Y:000125 Y:000125                   DC      CLKV+$080800+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4035      Y:000126 Y:000126                   DC      CLKV+$082000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #19, Unused
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 77



4036      Y:000127 Y:000127                   DC      CLKV+$084000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4037      Y:000128 Y:000128                   DC      CLKV+$088000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #33, Unused
4038      Y:000129 Y:000129                   DC      CLKV+$090000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4039      Y:00012A Y:00012A                   DC      CLKV+$0A0100+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #34, S3
4040      Y:00012B Y:00012B                   DC      CLKV+$0A0200+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
4041      Y:00012C Y:00012C                   DC      CLKV+$0A0400+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #35, S2
4042      Y:00012D Y:00012D                   DC      CLKV+$0A0800+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
4043      Y:00012E Y:00012E                   DC      CLKV+$0A2000+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #36, S1
4044      Y:00012F Y:00012F                   DC      CLKV+$0A4000+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
4045      Y:000130 Y:000130                   DC      CLKV+$0A8000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #37, Unused
4046      Y:000131 Y:000131                   DC      CLKV+$0B0000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
4047   
4048                                ; Commands for the ARC-47 video board
4049      Y:000132 Y:000132                   DC      VID0+$0C0000                      ; Normal Image data D17-D2
4050   
4051                                ; Gain : $0D000g, g = 0 to %1111, Gain = 4.75 to 1.0 in steps of 0.25
4052                                ; xxx I don't understand this PRAM arrangement.
4053                                ;       DC      VID0+$0D000F
4054      Y:000133 Y:000133                   DC      VID0+$0D0000                      ; fix for arc-47 gen-iii default gain 1
4055      Y:000134 Y:000134                   DC      VID0+$0C0180                      ; integrator parameter for 0.5 us
4056   
4057      3.045000E+001             VOD_MAX   EQU     30.45
4058      1.990000E+001             VRD_MAX   EQU     19.90
4059      8.700000E+000             VOG_MAX   EQU     8.70
4060      00337D                    DAC_VOD   EQU     @CVI((VOD/VOD_MAX)*16384-1)       ; Unipolar
4061      002D05                    DAC_VRD   EQU     @CVI((VRD/VRD_MAX)*16384-1)       ; Unipolar
4062      00063F                    DAC_VOG   EQU     @CVI(((VOG+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
4063      0009ED                    DAC_VABG  EQU     @CVI(((VABG+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
4064      002A08                    DAC_VDD   EQU     @CVI((VDD/VOD_MAX)*16384-1)       ; Unipolar
4065      003610                    DAC_PWR   EQU     @CVI(((PWR+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
4066      001FFF                    DAC_ZERO  EQU     $1FFF                             ; Bipolar
4067   
4068                                ; Initialize the ARC-47 DAC For DC_BIAS
4069                                ; xxx These need to be revisited with Rich - which is which?
4070      Y:000135 Y:000135                   DC      VID0+DAC_ADDR+$000000             ; Vod0, pin 52
4071      Y:000136 Y:000136                   DC      VID0+DAC_RegD+DAC_VOD
4072      Y:000137 Y:000137                   DC      VID0+DAC_ADDR+$000004             ; Vrd0, pin 13
4073      Y:000138 Y:000138                   DC      VID0+DAC_RegD+DAC_VRD
4074      Y:000139 Y:000139                   DC      VID0+DAC_ADDR+$000008             ; Vog0, pin 29
4075      Y:00013A Y:00013A                   DC      VID0+DAC_RegD+DAC_VOG
4076      Y:00013B Y:00013B                   DC      VID0+DAC_ADDR+$00000C             ; Vabg, pin 5, NC
4077      Y:00013C Y:00013C                   DC      VID0+DAC_RegD+DAC_ZERO
4078   
4079      Y:00013D Y:00013D                   DC      VID0+DAC_ADDR+$000001             ; Vod1, pin 32
4080      Y:00013E Y:00013E                   DC      VID0+DAC_RegD+DAC_VOD
4081      Y:00013F Y:00013F                   DC      VID0+DAC_ADDR+$000005             ; Vrd1, pin 55
4082      Y:000140 Y:000140                   DC      VID0+DAC_RegD+DAC_VRD
4083      Y:000141 Y:000141                   DC      VID0+DAC_ADDR+$000009             ; Vabg, pin 8
4084      Y:000142 Y:000142                   DC      VID0+DAC_RegD+DAC_VABG
4085      Y:000143 Y:000143                   DC      VID0+DAC_ADDR+$00000D             ; Vrsv1, pin 47, NC
4086      Y:000144 Y:000144                   DC      VID0+DAC_RegD+DAC_ZERO
4087   
4088      Y:000145 Y:000145                   DC      VID0+DAC_ADDR+$000002             ; Vod2, pin 11
4089      Y:000146 Y:000146                   DC      VID0+DAC_RegD+DAC_VOD
4090      Y:000147 Y:000147                   DC      VID0+DAC_ADDR+$000006             ; Vrd2, pin 35
4091      Y:000148 Y:000148                   DC      VID0+DAC_RegD+0
4092      Y:000149 Y:000149                   DC      VID0+DAC_ADDR+$00000A             ; Vog2, pin 50
4093      Y:00014A Y:00014A                   DC      VID0+DAC_RegD+DAC_VOG
4094      Y:00014B Y:00014B                   DC      VID0+DAC_ADDR+$00000E             ; Vrsv2, pin 27
4095      Y:00014C Y:00014C                   DC      VID0+DAC_RegD+DAC_ZERO
4096   
4097      Y:00014D Y:00014D                   DC      VID0+DAC_ADDR+$000003             ; Vod3, pin 53
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 78



4098      Y:00014E Y:00014E                   DC      VID0+DAC_RegD+DAC_VOD
4099      Y:00014F Y:00014F                   DC      VID0+DAC_ADDR+$000007             ; Vrd3, pin 14
4100      Y:000150 Y:000150                   DC      VID0+DAC_RegD+0
4101      Y:000151 Y:000151                   DC      VID0+DAC_ADDR+$00000B             ; Vog3, pin 30
4102      Y:000152 Y:000152                   DC      VID0+DAC_RegD+DAC_VOG
4103      Y:000153 Y:000153                   DC      VID0+DAC_ADDR+$00000F             ; Vrsv3, pin 6
4104      Y:000154 Y:000154                   DC      VID0+DAC_RegD+DAC_ZERO
4105   
4106      Y:000155 Y:000155                   DC      VID0+DAC_ADDR+$000010             ; Vod4, pin 33
4107      Y:000156 Y:000156                   DC      VID0+DAC_RegD+DAC_VDD
4108      Y:000157 Y:000157                   DC      VID0+DAC_ADDR+$000011             ; Vrd4, pin 56
4109      Y:000158 Y:000158                   DC      VID0+DAC_RegD+DAC_PWR
4110      Y:000159 Y:000159                   DC      VID0+DAC_ADDR+$000012             ; Vog4, pin 9
4111      Y:00015A Y:00015A                   DC      VID0+DAC_RegD+DAC_ZERO
4112      Y:00015B Y:00015B                   DC      VID0+DAC_ADDR+$000013             ; Vrsv4,pin 48
4113      Y:00015C Y:00015C                   DC      VID0+DAC_RegD+DAC_ZERO
4114   
4115                                ; Initialize the ARC-47 DAC For Video Offsets
4116      Y:00015D Y:00015D                   DC      VID0+DAC_ADDR+$000014
4117      Y:00015E Y:00015E                   DC      VID0+DAC_RegD+OFFSET0
4118      Y:00015F Y:00015F                   DC      VID0+DAC_ADDR+$000015
4119      Y:000160 Y:000160                   DC      VID0+DAC_RegD+OFFSET1
4120      Y:000161 Y:000161                   DC      VID0+DAC_ADDR+$000016
4121      Y:000162 Y:000162                   DC      VID0+DAC_RegD+OFFSET2
4122      Y:000163 Y:000163                   DC      VID0+DAC_ADDR+$000017
4123      Y:000164 Y:000164                   DC      VID0+DAC_RegD+OFFSET3
4124   
4125                                END_DACS
4126   
4127   
4128                                ;  ***  Definitions for Y: memory waveform tables  *****
4129                                ; Put the parallel clock waveforms in slow external Y memory since there isn't
4130                                ; enough room in the fast memory for everything we need.  The parallels are
4131                                ; way slow anyway so the slowness of the access can be tweaked with SI_DELAY.
4132                                ; Clock whole CCD up toward the GH serial register.  Serial phases 1 & 2 high.
4133                                ; CD goes 2-3-4-1, AB goes 3-2-1-4
4134                                ; Parallel phases 2 & 3 high during integration.
4135   
4136                                ; Serial clock convention:    REH SEH1 SEH2 SEH3 SWEH RFG SFG1 SFG2 SFG3 SWFG
4137                                ; Parallel clock convention:  AB1 AB2 AB3 AB4 TGA DGA CD1 CD2 CD3 CD4 TGD DGD
4138   
4139                                ; ADD DC RESTORE based on gwaves!
4140                                ABCD_UP
4141      Y:000165 Y:000165                   DC      END_ABCD_UP-ABCD_UP-1
4142      Y:000166 Y:000166                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
4143      Y:000167 Y:000167                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4144      Y:000168 Y:000168                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+000
4145      Y:000169 Y:000169                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+000+CD3+CD4+000+000
4146      Y:00016A Y:00016A                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+000+000+CD1+000+CD3+CD4+TGD+000
4147      Y:00016B Y:00016B                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+000+000+CD1+000+000+CD4+TGD+000
4148      Y:00016C Y:00016C                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+000+000+CD1+CD2+000+CD4+TGD+000
4149      Y:00016D Y:00016D                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+000+000+CD1+CD2+000+000+TGD+000
4150      Y:00016E Y:00016E                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+000+000+CD1+CD2+CD3+000+TGD+000
4151      Y:00016F Y:00016F                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4152                                END_ABCD_UP
4153   
4154                                ; Clock whole CCD down toward the EF serial register.  Serial phases 1 & 2 high.
4155                                ; AB goes 2-3-4-1, CD goes 3-2-1-4
4156                                ; Parallel phases 2 & 3 high during integration.
4157                                ; ADD DC RESTORE based on gwaves!
4158                                ABCD_DOWN
4159      Y:000170 Y:000170                   DC      END_ABCD_DOWN-ABCD_DOWN-1
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 79



4160      Y:000171 Y:000171                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
4161      Y:000172 Y:000172                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4162      Y:000173 Y:000173                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+000+CD1+CD2+CD3+000+000+000
4163      Y:000174 Y:000174                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+000+CD1+CD2+000+000+000+000
4164      Y:000175 Y:000175                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+000+CD1+CD2+000+CD4+000+000
4165      Y:000176 Y:000176                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+000+CD1+000+000+CD4+000+000
4166      Y:000177 Y:000177                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+000+CD1+000+CD3+CD4+000+000
4167      Y:000178 Y:000178                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+000+CD3+CD4+000+000
4168      Y:000179 Y:000179                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+000
4169      Y:00017A Y:00017A                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4170                                END_ABCD_DOWN
4171   
4172                                ; Clock whole CCD split.  Serial phases 1 & 2 high.
4173                                ; ABCD all go 2-3-4-1
4174                                ; Parallel phases 2 & 3 high during integration.
4175                                ; ADD DC RESTORE based on gwaves!
4176                                ABCD_SPLIT
4177      Y:00017B Y:00017B                   DC      END_ABCD_SPLIT-ABCD_SPLIT-1
4178      Y:00017C Y:00017C                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
4179      Y:00017D Y:00017D                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4180      Y:00017E Y:00017E                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+000+000+CD2+CD3+CD4+000+000
4181      Y:00017F Y:00017F                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+000+000+000+CD3+CD4+000+000
4182      Y:000180 Y:000180                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+000+CD1+000+CD3+CD4+TGD+000
4183      Y:000181 Y:000181                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+000+CD1+000+000+CD4+TGD+000
4184      Y:000182 Y:000182                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+000+CD1+CD2+000+CD4+TGD+000
4185      Y:000183 Y:000183                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+CD1+CD2+000+000+TGD+000
4186      Y:000184 Y:000184                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+CD1+CD2+CD3+000+TGD+000
4187      Y:000185 Y:000185                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4188                                END_ABCD_SPLIT
4189   
4190                                ; Clear whole CCD up toward the GH serial register.  Serial phases 1 & 2 high.
4191                                ; CD goes 2-3-4-1, AB goes 3-2-1-4
4192                                ; Parallel phases 2 & 3 high during integration.
4193                                ; ADD DC RESTORE based on gwaves!
4194                                ABCD_CLEAR_UP
4195      Y:000186 Y:000186                   DC      END_ABCD_CLEAR_UP-ABCD_CLEAR_UP-1
4196      Y:000187 Y:000187                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
4197      Y:000188 Y:000188                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4198      Y:000189 Y:000189                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+DGD
4199      Y:00018A Y:00018A                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+000+CD3+CD4+000+DGD
4200      Y:00018B Y:00018B                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+000+000+CD1+000+CD3+CD4+TGD+DGD
4201      Y:00018C Y:00018C                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+000+000+CD1+000+000+CD4+TGD+DGD
4202      Y:00018D Y:00018D                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+000+000+CD1+CD2+000+CD4+TGD+DGD
4203      Y:00018E Y:00018E                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+000+000+CD1+CD2+000+000+TGD+DGD
4204      Y:00018F Y:00018F                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+000+000+CD1+CD2+CD3+000+TGD+DGD
4205      Y:000190 Y:000190                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+DGD
4206      Y:000191 Y:000191                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4207      Y:000192 Y:000192                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4208      Y:000193 Y:000193                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4209                                END_ABCD_CLEAR_UP
4210   
4211                                ; Clear whole CCD down toward the EF serial register.  Serial phases 1 & 2 high.
4212                                ; AB goes 2-3-4-1, CD goes 3-2-1-4
4213                                ; Parallel phases 2 & 3 high during integration.
4214                                ; ADD DC RESTORE based on gwaves!
4215                                ABCD_CLEAR_DOWN
4216      Y:000194 Y:000194                   DC      END_ABCD_CLEAR_DOWN-ABCD_CLEAR_DOWN-1
4217      Y:000195 Y:000195                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
4218      Y:000196 Y:000196                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4219      Y:000197 Y:000197                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+DGA+CD1+CD2+CD3+000+000+000
4220      Y:000198 Y:000198                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+DGA+CD1+CD2+000+000+000+000
4221      Y:000199 Y:000199                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+DGA+CD1+CD2+000+CD4+000+000
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 80



4222      Y:00019A Y:00019A                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+DGA+CD1+000+000+CD4+000+000
4223      Y:00019B Y:00019B                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+DGA+CD1+000+CD3+CD4+000+000
4224      Y:00019C Y:00019C                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+DGA+000+000+CD3+CD4+000+000
4225      Y:00019D Y:00019D                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+DGA+000+CD2+CD3+CD4+000+000
4226      Y:00019E Y:00019E                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+000
4227      Y:00019F Y:00019F                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4228      Y:0001A0 Y:0001A0                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4229      Y:0001A1 Y:0001A1                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4230                                END_ABCD_CLEAR_DOWN
4231   
4232                                ; Clear whole CCD split.  Serial phases 1 & 2 high.
4233                                ; ABCD all go 2-3-4-1
4234                                ; Parallel phases 2 & 3 high during integration.
4235                                ; ADD DC RESTORE based on gwaves!
4236                                ABCD_CLEAR_SPLIT
4237      Y:0001A2 Y:0001A2                   DC      END_ABCD_CLEAR_SPLIT-ABCD_CLEAR_SPLIT-1
4238      Y:0001A3 Y:0001A3                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
4239      Y:0001A4 Y:0001A4                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4240      Y:0001A5 Y:0001A5                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+DGA+000+CD2+CD3+CD4+000+DGD
4241      Y:0001A6 Y:0001A6                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+DGA+000+000+CD3+CD4+000+DGD
4242      Y:0001A7 Y:0001A7                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+DGA+CD1+000+CD3+CD4+TGD+DGD
4243      Y:0001A8 Y:0001A8                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+DGA+CD1+000+000+CD4+TGD+DGD
4244      Y:0001A9 Y:0001A9                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+DGA+CD1+CD2+000+CD4+TGD+DGD
4245      Y:0001AA Y:0001AA                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+DGA+CD1+CD2+000+000+TGD+DGD
4246      Y:0001AB Y:0001AB                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+DGA+CD1+CD2+CD3+000+TGD+DGD
4247      Y:0001AC Y:0001AC                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+DGD
4248      Y:0001AD Y:0001AD                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4249      Y:0001AE Y:0001AE                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4250      Y:0001AF Y:0001AF                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4251                                END_ABCD_CLEAR_SPLIT
4252   
4253                                ; Clock CD section up toward the GH serial register; AB static.  Serial phases 1 & 2 high.
4254                                ; CD goes 2-3-4-1
4255                                ; Parallel phases 2 & 3 high during integration.
4256                                ; ADD DC RESTORE based on gwaves!
4257                                CD_UP
4258      Y:0001B0 Y:0001B0                   DC      END_CD_UP-CD_UP-1
4259      Y:0001B1 Y:0001B1                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
4260      Y:0001B2 Y:0001B2                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4261      Y:0001B3 Y:0001B3                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+000
4262      Y:0001B4 Y:0001B4                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+000+CD3+CD4+000+000
4263      Y:0001B5 Y:0001B5                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+CD3+CD4+TGD+000
4264      Y:0001B6 Y:0001B6                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+000+CD4+TGD+000
4265      Y:0001B7 Y:0001B7                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+CD4+TGD+000
4266      Y:0001B8 Y:0001B8                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+000+TGD+000
4267      Y:0001B9 Y:0001B9                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+CD3+000+TGD+000
4268      Y:0001BA Y:0001BA                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4269                                END_CD_UP
4270   
4271                                ; Clock AB section down toward the EF serial register; CD static.  Serial phases 1 & 2 high.
4272                                ; AB goes 2-3-4-1
4273                                ; Parallel phases 2 & 3 high during integration.
4274                                ; ADD DC RESTORE based on gwaves!
4275                                AB_DOWN
4276      Y:0001BB Y:0001BB                   DC      END_AB_DOWN-AB_DOWN-1
4277      Y:0001BC Y:0001BC                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
4278      Y:0001BD Y:0001BD                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4279      Y:0001BE Y:0001BE                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+000+000+CD2+CD3+000+000+000
4280      Y:0001BF Y:0001BF                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+000+000+CD2+CD3+000+000+000
4281      Y:0001C0 Y:0001C0                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+000+000+CD2+CD3+000+000+000
4282      Y:0001C1 Y:0001C1                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+000+000+CD2+CD3+000+000+000
4283      Y:0001C2 Y:0001C2                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+000+000+CD2+CD3+000+000+000
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 81



4284      Y:0001C3 Y:0001C3                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+CD2+CD3+000+000+000
4285      Y:0001C4 Y:0001C4                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4286      Y:0001C5 Y:0001C5                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4287                                END_AB_DOWN
4288   
4289                                ; Clear CD section up toward the GH serial register; AB static.  Serial phases 1 & 2 high.
4290                                ; CD goes 2-3-4-1
4291                                ; Parallel phases 2 & 3 high during integration.
4292                                ; ADD DC RESTORE based on gwaves!
4293                                CD_CLEAR_UP
4294      Y:0001C6 Y:0001C6                   DC      END_CD_CLEAR_UP-CD_CLEAR_UP-1
4295      Y:0001C7 Y:0001C7                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
4296      Y:0001C8 Y:0001C8                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4297      Y:0001C9 Y:0001C9                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+DGD
4298      Y:0001CA Y:0001CA                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+000+CD3+CD4+000+DGD
4299      Y:0001CB Y:0001CB                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+CD3+CD4+TGD+DGD
4300      Y:0001CC Y:0001CC                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+000+CD4+TGD+DGD
4301      Y:0001CD Y:0001CD                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+CD4+TGD+DGD
4302      Y:0001CE Y:0001CE                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+000+TGD+DGD
4303      Y:0001CF Y:0001CF                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+CD3+000+TGD+DGD
4304      Y:0001D0 Y:0001D0                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+DGD
4305      Y:0001D1 Y:0001D1                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4306      Y:0001D2 Y:0001D2                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4307      Y:0001D3 Y:0001D3                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4308                                END_CD_CLEAR_UP
4309   
4310                                ; Clear AB section down toward the EF serial register; CD static.  Serial phases 1 & 2 high.
4311                                ; AB goes 2-3-4-1
4312                                ; Parallel phases 2 & 3 high during integration.
4313                                ; ADD DC RESTORE based on gwaves!
4314                                AB_CLEAR_DOWN
4315      Y:0001D4 Y:0001D4                   DC      END_AB_CLEAR_DOWN-AB_CLEAR_DOWN-1
4316      Y:0001D5 Y:0001D5                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
4317      Y:0001D6 Y:0001D6                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4318      Y:0001D7 Y:0001D7                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4319      Y:0001D8 Y:0001D8                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4320      Y:0001D9 Y:0001D9                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4321      Y:0001DA Y:0001DA                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4322      Y:0001DB Y:0001DB                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4323      Y:0001DC Y:0001DC                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+DGA+000+CD2+CD3+000+000+000
4324      Y:0001DD Y:0001DD                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+000
4325      Y:0001DE Y:0001DE                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+000
4326      Y:0001DF Y:0001DF                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4327      Y:0001E0 Y:0001E0                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4328      Y:0001E1 Y:0001E1                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4329                                END_AB_CLEAR_DOWN
4330   
4331                                ; Dump both the EF and GH serial registers using DGA and DGD
4332                                DUMP_SERIAL
4333      Y:0001E2 Y:0001E2                   DC      END_DUMP_SERIAL-DUMP_SERIAL-1
4334      Y:0001E3 Y:0001E3                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4335      Y:0001E4 Y:0001E4                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+DGD
4336      Y:0001E5 Y:0001E5                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4337      Y:0001E6 Y:0001E6                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4338      Y:0001E7 Y:0001E7                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4339                                END_DUMP_SERIAL
4340   
4341                                ; Parallel waveforms done.  Move on to the layered serial ones.
4342   
4343                                ;       These are the 12 fast serial read waveforms for left, right,
4344                                ;       and split reads for serial binning factors from 1 to 4.
4345   
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 82



4346                                ;       Unbinned waveforms
4347                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4348                                SERIAL_READ_EH_1
4349      Y:0001E8 Y:0001E8                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4350      Y:0001E9 Y:0001E9                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
4351      Y:0001EA Y:0001EA                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4352      Y:0001EB Y:0001EB                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4353      Y:0001EC Y:0001EC                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4354      Y:0001ED Y:0001ED                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4355                                SXMIT_EH_1
4356      Y:0001EE Y:0001EE                   DC      $00F000                           ; Transmit A/D data to host
4357      Y:0001EF Y:0001EF                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
4358      Y:0001F0 Y:0001F0                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
4359      Y:0001F1 Y:0001F1                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
4360      Y:0001F2 Y:0001F2                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4361      Y:0001F3 Y:0001F3                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
4362      Y:0001F4 Y:0001F4                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
4363      Y:0001F5 Y:0001F5                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4364                                END_SERIAL_READ_EH_1
4365   
4366                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4367                                SERIAL_READ_FG_1
4368      Y:0001F6 Y:0001F6                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4369      Y:0001F7 Y:0001F7                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
4370      Y:0001F8 Y:0001F8                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4371      Y:0001F9 Y:0001F9                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4372      Y:0001FA Y:0001FA                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4373      Y:0001FB Y:0001FB                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4374                                SXMIT_FG_1
4375      Y:0001FC Y:0001FC                   DC      $00F021                           ; Transmit A/D data to host
4376      Y:0001FD Y:0001FD                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
4377      Y:0001FE Y:0001FE                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
4378      Y:0001FF Y:0001FF                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
4379      Y:000200 Y:000200                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4380      Y:000201 Y:000201                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
4381      Y:000202 Y:000202                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
4382      Y:000203 Y:000203                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4383                                END_SERIAL_READ_FG_1
4384   
4385                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4386                                SERIAL_READ_SPLIT_1
4387      Y:000204 Y:000204                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4388      Y:000205 Y:000205                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
4389      Y:000206 Y:000206                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4390      Y:000207 Y:000207                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4391      Y:000208 Y:000208                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4392      Y:000209 Y:000209                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4393                                SXMIT_SPLIT_1
4394      Y:00020A Y:00020A                   DC      $00F020                           ; Transmit A/D data to host
4395      Y:00020B Y:00020B                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
4396      Y:00020C Y:00020C                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
4397      Y:00020D Y:00020D                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
4398      Y:00020E Y:00020E                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4399      Y:00020F Y:00020F                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
4400      Y:000210 Y:000210                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
4401      Y:000211 Y:000211                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4402                                END_SERIAL_READ_SPLIT_1
4403   
4404                                ;       Bin by 2 waveforms
4405                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4406                                SERIAL_READ_EH_2
4407      Y:000212 Y:000212                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 83



4408      Y:000213 Y:000213                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
4409      Y:000214 Y:000214                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4410      Y:000215 Y:000215                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4411      Y:000216 Y:000216                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4412      Y:000217 Y:000217                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4413      Y:000218 Y:000218                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4414      Y:000219 Y:000219                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4415      Y:00021A Y:00021A                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4416      Y:00021B Y:00021B                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4417      Y:00021C Y:00021C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4418      Y:00021D Y:00021D                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4419                                SXMIT_EH_2
4420      Y:00021E Y:00021E                   DC      $00F000                           ; Transmit A/D data to host
4421      Y:00021F Y:00021F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
4422      Y:000220 Y:000220                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
4423      Y:000221 Y:000221                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
4424      Y:000222 Y:000222                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4425      Y:000223 Y:000223                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
4426      Y:000224 Y:000224                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
4427      Y:000225 Y:000225                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4428                                END_SERIAL_READ_EH_2
4429   
4430                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4431                                SERIAL_READ_FG_2
4432      Y:000226 Y:000226                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4433      Y:000227 Y:000227                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
4434      Y:000228 Y:000228                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4435      Y:000229 Y:000229                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4436      Y:00022A Y:00022A                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4437      Y:00022B Y:00022B                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4438      Y:00022C Y:00022C                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4439      Y:00022D Y:00022D                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4440      Y:00022E Y:00022E                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4441      Y:00022F Y:00022F                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4442      Y:000230 Y:000230                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4443      Y:000231 Y:000231                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4444                                SXMIT_FG_2
4445      Y:000232 Y:000232                   DC      $00F021                           ; Transmit A/D data to host
4446      Y:000233 Y:000233                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
4447      Y:000234 Y:000234                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
4448      Y:000235 Y:000235                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
4449      Y:000236 Y:000236                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4450      Y:000237 Y:000237                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
4451      Y:000238 Y:000238                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
4452      Y:000239 Y:000239                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4453                                END_SERIAL_READ_FG_2
4454   
4455                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4456                                SERIAL_READ_SPLIT_2
4457      Y:00023A Y:00023A                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4458      Y:00023B Y:00023B                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
4459      Y:00023C Y:00023C                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4460      Y:00023D Y:00023D                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4461      Y:00023E Y:00023E                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4462      Y:00023F Y:00023F                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4463      Y:000240 Y:000240                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4464      Y:000241 Y:000241                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4465      Y:000242 Y:000242                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4466      Y:000243 Y:000243                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4467      Y:000244 Y:000244                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4468      Y:000245 Y:000245                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4469                                SXMIT_SPLIT_2
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 84



4470      Y:000246 Y:000246                   DC      $00F020                           ; Transmit A/D data to host
4471      Y:000247 Y:000247                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
4472      Y:000248 Y:000248                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
4473      Y:000249 Y:000249                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
4474      Y:00024A Y:00024A                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4475      Y:00024B Y:00024B                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
4476      Y:00024C Y:00024C                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
4477      Y:00024D Y:00024D                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4478                                END_SERIAL_READ_SPLIT_2
4479   
4480                                ;       Bin by 3 waveforms
4481                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4482                                SERIAL_READ_EH_3
4483      Y:00024E Y:00024E                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4484      Y:00024F Y:00024F                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
4485      Y:000250 Y:000250                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4486      Y:000251 Y:000251                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4487      Y:000252 Y:000252                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4488      Y:000253 Y:000253                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4489      Y:000254 Y:000254                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4490      Y:000255 Y:000255                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4491      Y:000256 Y:000256                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4492      Y:000257 Y:000257                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4493      Y:000258 Y:000258                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4494      Y:000259 Y:000259                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4495      Y:00025A Y:00025A                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4496      Y:00025B Y:00025B                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4497      Y:00025C Y:00025C                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4498      Y:00025D Y:00025D                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4499      Y:00025E Y:00025E                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4500      Y:00025F Y:00025F                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4501                                SXMIT_EH_3
4502      Y:000260 Y:000260                   DC      $00F000                           ; Transmit A/D data to host
4503      Y:000261 Y:000261                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
4504      Y:000262 Y:000262                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
4505      Y:000263 Y:000263                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
4506      Y:000264 Y:000264                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4507      Y:000265 Y:000265                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
4508      Y:000266 Y:000266                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
4509      Y:000267 Y:000267                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4510                                END_SERIAL_READ_EH_3
4511   
4512                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4513                                SERIAL_READ_FG_3
4514      Y:000268 Y:000268                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4515      Y:000269 Y:000269                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
4516      Y:00026A Y:00026A                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4517      Y:00026B Y:00026B                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4518      Y:00026C Y:00026C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4519      Y:00026D Y:00026D                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4520      Y:00026E Y:00026E                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4521      Y:00026F Y:00026F                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4522      Y:000270 Y:000270                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4523      Y:000271 Y:000271                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4524      Y:000272 Y:000272                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4525      Y:000273 Y:000273                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4526      Y:000274 Y:000274                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4527      Y:000275 Y:000275                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4528      Y:000276 Y:000276                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4529      Y:000277 Y:000277                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4530      Y:000278 Y:000278                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4531      Y:000279 Y:000279                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 85



4532                                SXMIT_FG_3
4533      Y:00027A Y:00027A                   DC      $00F021                           ; Transmit A/D data to host
4534      Y:00027B Y:00027B                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
4535      Y:00027C Y:00027C                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
4536      Y:00027D Y:00027D                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
4537      Y:00027E Y:00027E                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4538      Y:00027F Y:00027F                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
4539      Y:000280 Y:000280                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
4540      Y:000281 Y:000281                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4541                                END_SERIAL_READ_FG_3
4542   
4543                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4544                                SERIAL_READ_SPLIT_3
4545      Y:000282 Y:000282                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4546      Y:000283 Y:000283                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
4547      Y:000284 Y:000284                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4548      Y:000285 Y:000285                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4549      Y:000286 Y:000286                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4550      Y:000287 Y:000287                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4551      Y:000288 Y:000288                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4552      Y:000289 Y:000289                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4553      Y:00028A Y:00028A                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4554      Y:00028B Y:00028B                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4555      Y:00028C Y:00028C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4556      Y:00028D Y:00028D                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4557      Y:00028E Y:00028E                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4558      Y:00028F Y:00028F                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4559      Y:000290 Y:000290                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4560      Y:000291 Y:000291                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4561      Y:000292 Y:000292                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4562      Y:000293 Y:000293                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4563                                SXMIT_SPLIT_3
4564      Y:000294 Y:000294                   DC      $00F020                           ; Transmit A/D data to host
4565      Y:000295 Y:000295                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
4566      Y:000296 Y:000296                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
4567      Y:000297 Y:000297                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
4568      Y:000298 Y:000298                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4569      Y:000299 Y:000299                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
4570      Y:00029A Y:00029A                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
4571      Y:00029B Y:00029B                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4572                                END_SERIAL_READ_SPLIT_3
4573   
4574                                ;       Bin by 4 waveforms
4575                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4576                                SERIAL_READ_EH_4
4577      Y:00029C Y:00029C                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4578      Y:00029D Y:00029D                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
4579      Y:00029E Y:00029E                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4580      Y:00029F Y:00029F                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4581      Y:0002A0 Y:0002A0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4582      Y:0002A1 Y:0002A1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4583      Y:0002A2 Y:0002A2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4584      Y:0002A3 Y:0002A3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4585      Y:0002A4 Y:0002A4                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4586      Y:0002A5 Y:0002A5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4587      Y:0002A6 Y:0002A6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4588      Y:0002A7 Y:0002A7                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4589      Y:0002A8 Y:0002A8                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4590      Y:0002A9 Y:0002A9                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4591      Y:0002AA Y:0002AA                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4592      Y:0002AB Y:0002AB                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4593      Y:0002AC Y:0002AC                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 86



4594      Y:0002AD Y:0002AD                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4595      Y:0002AE Y:0002AE                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4596      Y:0002AF Y:0002AF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4597      Y:0002B0 Y:0002B0                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4598      Y:0002B1 Y:0002B1                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4599      Y:0002B2 Y:0002B2                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4600      Y:0002B3 Y:0002B3                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4601                                SXMIT_EH_4
4602      Y:0002B4 Y:0002B4                   DC      $00F000                           ; Transmit A/D data to host
4603      Y:0002B5 Y:0002B5                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
4604      Y:0002B6 Y:0002B6                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
4605      Y:0002B7 Y:0002B7                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
4606      Y:0002B8 Y:0002B8                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4607      Y:0002B9 Y:0002B9                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
4608      Y:0002BA Y:0002BA                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
4609      Y:0002BB Y:0002BB                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4610                                END_SERIAL_READ_EH_4
4611   
4612                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4613                                SERIAL_READ_FG_4
4614      Y:0002BC Y:0002BC                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4615      Y:0002BD Y:0002BD                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
4616      Y:0002BE Y:0002BE                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4617      Y:0002BF Y:0002BF                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4618      Y:0002C0 Y:0002C0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4619      Y:0002C1 Y:0002C1                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4620      Y:0002C2 Y:0002C2                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4621      Y:0002C3 Y:0002C3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4622      Y:0002C4 Y:0002C4                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4623      Y:0002C5 Y:0002C5                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4624      Y:0002C6 Y:0002C6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4625      Y:0002C7 Y:0002C7                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4626      Y:0002C8 Y:0002C8                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4627      Y:0002C9 Y:0002C9                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4628      Y:0002CA Y:0002CA                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4629      Y:0002CB Y:0002CB                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4630      Y:0002CC Y:0002CC                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4631      Y:0002CD Y:0002CD                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4632      Y:0002CE Y:0002CE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4633      Y:0002CF Y:0002CF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4634      Y:0002D0 Y:0002D0                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4635      Y:0002D1 Y:0002D1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4636      Y:0002D2 Y:0002D2                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4637      Y:0002D3 Y:0002D3                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4638                                SXMIT_FG_4
4639      Y:0002D4 Y:0002D4                   DC      $00F021                           ; Transmit A/D data to host
4640      Y:0002D5 Y:0002D5                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
4641      Y:0002D6 Y:0002D6                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
4642      Y:0002D7 Y:0002D7                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
4643      Y:0002D8 Y:0002D8                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4644      Y:0002D9 Y:0002D9                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
4645      Y:0002DA Y:0002DA                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
4646      Y:0002DB Y:0002DB                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4647                                END_SERIAL_READ_FG_4
4648   
4649                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4650                                SERIAL_READ_SPLIT_4
4651      Y:0002DC Y:0002DC                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4652      Y:0002DD Y:0002DD                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
4653      Y:0002DE Y:0002DE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4654      Y:0002DF Y:0002DF                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4655      Y:0002E0 Y:0002E0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
Motorola DSP56300 Assembler  Version 6.2.23   112-07-02  22:13:26  lmi.waveforms.s  Page 87



4656      Y:0002E1 Y:0002E1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4657      Y:0002E2 Y:0002E2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4658      Y:0002E3 Y:0002E3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4659      Y:0002E4 Y:0002E4                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4660      Y:0002E5 Y:0002E5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4661      Y:0002E6 Y:0002E6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4662      Y:0002E7 Y:0002E7                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4663      Y:0002E8 Y:0002E8                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4664      Y:0002E9 Y:0002E9                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4665      Y:0002EA Y:0002EA                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4666      Y:0002EB Y:0002EB                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4667      Y:0002EC Y:0002EC                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4668      Y:0002ED Y:0002ED                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4669      Y:0002EE Y:0002EE                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4670      Y:0002EF Y:0002EF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4671      Y:0002F0 Y:0002F0                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4672      Y:0002F1 Y:0002F1                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4673      Y:0002F2 Y:0002F2                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4674      Y:0002F3 Y:0002F3                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4675                                SXMIT_SPLIT_4
4676      Y:0002F4 Y:0002F4                   DC      $00F020                           ; Transmit A/D data to host
4677      Y:0002F5 Y:0002F5                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
4678      Y:0002F6 Y:0002F6                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
4679      Y:0002F7 Y:0002F7                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
4680      Y:0002F8 Y:0002F8                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4681      Y:0002F9 Y:0002F9                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
4682      Y:0002FA Y:0002FA                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
4683      Y:0002FB Y:0002FB                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4684                                END_SERIAL_READ_SPLIT_4
4685   
4686                                 END_APPLICATON_Y_MEMORY
4687      0002FC                              EQU     @LCV(L)
4688   
4689                                ;  End of program
4690                                          END

0    Errors
0    Warnings


