Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  tim.s  Page 1



1                          ; This file is used to generate DSP code for the Gen III ARC-22/32/47
2                          ;    board set.
3                          ;
4                          ; This file contains two subroutines and X and Y data areas.  The two
5                          ; subroutines are RDCCD (with secondary entry point RCCD1) and CLOCK.
6                          ; These need to be in fast P memory.  The boot code and tim.s are there.
7                          ; tim.s includes timmisc.s, timCCDmisc.s and the waveforms file at the
8                          ; end.
9      
10                                   PAGE    132                               ; Printronix page width - 132 columns
11     
12                         ; Include a header file that defines global parameters
13     
14                                   INCLUDE "timboot.s"
15                         ;  This file is used to generate boot DSP code for the Gen III 250 MHz fiber
16                         ;       optic timing board = ARC22 using a DSP56303 as its main processor.
17     
18                         ; Various addressing control registers
19        FFFFFB           BCR       EQU     $FFFFFB                           ; Bus Control Register
20        FFFFF9           AAR0      EQU     $FFFFF9                           ; Address Attribute Register, channel 0
21        FFFFF8           AAR1      EQU     $FFFFF8                           ; Address Attribute Register, channel 1
22        FFFFF7           AAR2      EQU     $FFFFF7                           ; Address Attribute Register, channel 2
23        FFFFF6           AAR3      EQU     $FFFFF6                           ; Address Attribute Register, channel 3
24        FFFFFD           PCTL      EQU     $FFFFFD                           ; PLL control register
25        FFFFFE           IPRP      EQU     $FFFFFE                           ; Interrupt Priority register - Peripheral
26        FFFFFF           IPRC      EQU     $FFFFFF                           ; Interrupt Priority register - Core
27     
28                         ; Port E is the Synchronous Communications Interface (SCI) port
29        FFFF9F           PCRE      EQU     $FFFF9F                           ; Port Control Register
30        FFFF9E           PRRE      EQU     $FFFF9E                           ; Port Direction Register
31        FFFF9D           PDRE      EQU     $FFFF9D                           ; Port Data Register
32        FFFF9C           SCR       EQU     $FFFF9C                           ; SCI Control Register
33        FFFF9B           SCCR      EQU     $FFFF9B                           ; SCI Clock Control Register
34     
35        FFFF9A           SRXH      EQU     $FFFF9A                           ; SCI Receive Data Register, High byte
36        FFFF99           SRXM      EQU     $FFFF99                           ; SCI Receive Data Register, Middle byte
37        FFFF98           SRXL      EQU     $FFFF98                           ; SCI Receive Data Register, Low byte
38     
39        FFFF97           STXH      EQU     $FFFF97                           ; SCI Transmit Data register, High byte
40        FFFF96           STXM      EQU     $FFFF96                           ; SCI Transmit Data register, Middle byte
41        FFFF95           STXL      EQU     $FFFF95                           ; SCI Transmit Data register, Low byte
42     
43        FFFF94           STXA      EQU     $FFFF94                           ; SCI Transmit Address Register
44        FFFF93           SSR       EQU     $FFFF93                           ; SCI Status Register
45     
46        000009           SCITE     EQU     9                                 ; X:SCR bit set to enable the SCI transmitter
47        000008           SCIRE     EQU     8                                 ; X:SCR bit set to enable the SCI receiver
48        000000           TRNE      EQU     0                                 ; This is set in X:SSR when the transmitter
49                                                                             ;  shift and data registers are both empty
50        000001           TDRE      EQU     1                                 ; This is set in X:SSR when the transmitter
51                                                                             ;  data register is empty
52        000002           RDRF      EQU     2                                 ; X:SSR bit set when receiver register is full
53        00000F           SELSCI    EQU     15                                ; 1 for SCI to backplane, 0 to front connector
54     
55     
56                         ; ESSI Flags
57        000006           TDE       EQU     6                                 ; Set when transmitter data register is empty
58        000007           RDF       EQU     7                                 ; Set when receiver is full of data
59        000010           TE        EQU     16                                ; Transmitter enable
60     
61                         ; Phase Locked Loop initialization
62        050003           PLL_INIT  EQU     $050003                           ; PLL = 25 MHz x 2 = 100 MHz
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 2



63     
64                         ; Port B general purpose I/O
65        FFFFC4           HPCR      EQU     $FFFFC4                           ; Control register (bits 1-6 cleared for GPIO)
66        FFFFC9           HDR       EQU     $FFFFC9                           ; Data register
67        FFFFC8           HDDR      EQU     $FFFFC8                           ; Data Direction Register bits (=1 for output)
68     
69                         ; Port C is Enhanced Synchronous Serial Port 0 = ESSI0
70        FFFFBF           PCRC      EQU     $FFFFBF                           ; Port C Control Register
71        FFFFBE           PRRC      EQU     $FFFFBE                           ; Port C Data direction Register
72        FFFFBD           PDRC      EQU     $FFFFBD                           ; Port C GPIO Data Register
73        FFFFBC           TX00      EQU     $FFFFBC                           ; Transmit Data Register #0
74        FFFFB8           RX0       EQU     $FFFFB8                           ; Receive data register
75        FFFFB7           SSISR0    EQU     $FFFFB7                           ; Status Register
76        FFFFB6           CRB0      EQU     $FFFFB6                           ; Control Register B
77        FFFFB5           CRA0      EQU     $FFFFB5                           ; Control Register A
78     
79                         ; Port D is Enhanced Synchronous Serial Port 1 = ESSI1
80        FFFFAF           PCRD      EQU     $FFFFAF                           ; Port D Control Register
81        FFFFAE           PRRD      EQU     $FFFFAE                           ; Port D Data direction Register
82        FFFFAD           PDRD      EQU     $FFFFAD                           ; Port D GPIO Data Register
83        FFFFAC           TX10      EQU     $FFFFAC                           ; Transmit Data Register 0
84        FFFFA7           SSISR1    EQU     $FFFFA7                           ; Status Register
85        FFFFA6           CRB1      EQU     $FFFFA6                           ; Control Register B
86        FFFFA5           CRA1      EQU     $FFFFA5                           ; Control Register A
87     
88                         ; Timer module addresses
89        FFFF8F           TCSR0     EQU     $FFFF8F                           ; Timer control and status register
90        FFFF8E           TLR0      EQU     $FFFF8E                           ; Timer load register = 0
91        FFFF8D           TCPR0     EQU     $FFFF8D                           ; Timer compare register = exposure time
92        FFFF8C           TCR0      EQU     $FFFF8C                           ; Timer count register = elapsed time
93        FFFF83           TPLR      EQU     $FFFF83                           ; Timer prescaler load register => milliseconds
94        FFFF82           TPCR      EQU     $FFFF82                           ; Timer prescaler count register
95        000000           TIM_BIT   EQU     0                                 ; Set to enable the timer
96        000009           TRM       EQU     9                                 ; Set to enable the timer preloading
97        000015           TCF       EQU     21                                ; Set when timer counter = compare register
98     
99                         ; Board specific addresses and constants
100       FFFFF1           RDFO      EQU     $FFFFF1                           ; Read incoming fiber optic data byte
101       FFFFF2           WRFO      EQU     $FFFFF2                           ; Write fiber optic data replies
102       FFFFF3           WRSS      EQU     $FFFFF3                           ; Write switch state
103       FFFFF5           WRLATCH   EQU     $FFFFF5                           ; Write to a latch
104       010000           RDAD      EQU     $010000                           ; Read A/D values into the DSP
105       000009           EF        EQU     9                                 ; Serial receiver empty flag
106    
107                        ; DSP port A bit equates
108       000000           PWROK     EQU     0                                 ; Power control board says power is OK
109       000001           LED1      EQU     1                                 ; Control one of two LEDs
110       000002           LVEN      EQU     2                                 ; Low voltage power enable
111       000003           HVEN      EQU     3                                 ; High voltage power enable
112       00000E           SSFHF     EQU     14                                ; Switch state FIFO half full flag
113       00000A           EXT_IN0   EQU     10                                ; External digital I/O to the timing board
114       00000B           EXT_IN1   EQU     11
115       00000C           EXT_OUT0  EQU     12
116       00000D           EXT_OUT1  EQU     13
117    
118                        ; Port D equate
119       000001           SSFEF     EQU     1                                 ; Switch state FIFO empty flag
120    
121                        ; Other equates
122       000002           WRENA     EQU     2                                 ; Enable writing to the EEPROM
123    
124                        ; Latch U25 bit equates
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 3



125       000000           CDAC      EQU     0                                 ; Clear the analog board DACs
126       000002           ENCK      EQU     2                                 ; Enable the clock outputs
127       000004           SHUTTER   EQU     4                                 ; Control the shutter
128       000005           TIM_U_RST EQU     5                                 ; Reset the utility board
129    
130                        ; Software status bits, defined at X:<STATUS = X:0
131       000000           ST_RCV    EQU     0                                 ; Set to indicate word is from SCI = utility board
132       000002           IDLMODE   EQU     2                                 ; Set if need to idle after readout
133       000003           ST_SHUT   EQU     3                                 ; Set to indicate shutter is closed, clear for open
134       000004           ST_RDC    EQU     4                                 ; Set if executing 'RDC' command - reading out
135       000005           SPLIT_S   EQU     5                                 ; Set if split serial
136       000006           SPLIT_P   EQU     6                                 ; Set if split parallel
137       000007           MPP       EQU     7                                 ; Set if parallels are in MPP mode
138       000008           NOT_CLR   EQU     8                                 ; Set if not to clear CCD before exposure
139       00000A           TST_IMG   EQU     10                                ; Set if controller is to generate a test image
140       00000B           SHUT      EQU     11                                ; Set if opening shutter at beginning of exposure
141       00000C           ST_DITH   EQU     12                                ; Set if to dither during exposure
142       00000D           ST_SYNC   EQU     13                                ; Set if starting exposure on SYNC = high signal
143       00000E           ST_CNRD   EQU     14                                ; Set if in continous readout mode
144       00000F           ST_DIRTY  EQU     15                                ; Set if waveform tables need to be updated
145       000010           ST_SA     EQU     16                                ; Set if in subarray readout mode
146    
147                        ; Address for the table containing the incoming SCI words
148       000400           SCI_TABLE EQU     $400
149    
150    
151                        ; Specify controller configuration bits of the X:STATUS word
152                        ;   to describe the software capabilities of this application file
153                        ; The bit is set (=1) if the capability is supported by the controller
154    
155    
156                                COMMENT *
157    
158                        BIT #'s         FUNCTION
159                        2,1,0           Video Processor
160                                                000     ARC41, CCD Rev. 3
161                                                001     CCD Gen I
162                                                010     ARC42, dual readout CCD
163                                                011     ARC44, 4-readout IR coadder
164                                                100     ARC45. dual readout CCD
165                                                101     ARC46 = 8-channel IR
166                                                110     ARC48 = 8 channel CCD
167                                                111     ARC47 = 4-channel CCD
168    
169                        4,3             Timing Board
170                                                00      ARC20, Rev. 4, Gen II
171                                                01      Gen I
172                                                10      ARC22, Gen III, 250 MHz
173    
174                        6,5             Utility Board
175                                                00      No utility board
176                                                01      ARC50
177    
178                        7               Shutter
179                                                0       No shutter support
180                                                1       Yes shutter support
181    
182                        9,8             Temperature readout
183                                                00      No temperature readout
184                                                01      Polynomial Diode calibration
185                                                10      Linear temperature sensor calibration
186    
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 4



187                        10              Subarray readout
188                                                0       Not supported
189                                                1       Yes supported
190    
191                        11              Binning
192                                                0       Not supported
193                                                1       Yes supported
194    
195                        12              Split-Serial readout
196                                                0       Not supported
197                                                1       Yes supported
198    
199                        13              Split-Parallel readout
200                                                0       Not supported
201                                                1       Yes supported
202    
203                        14              MPP = Inverted parallel clocks
204                                                0       Not supported
205                                                1       Yes supported
206    
207                        16,15           Clock Driver Board
208                                                00      ARC30 or ARC31
209                                                01      ARC32, CCD and IR
210                                                11      No clock driver board (Gen I)
211    
212                        19,18,17                Special implementations
213                                                000     Somewhere else
214                                                001     Mount Laguna Observatory
215                                                010     NGST Aladdin
216                                                xxx     Other
217                                *
218    
219                        CCDVIDREV3B
220       000000                     EQU     $000000                           ; CCD Video Processor Rev. 3
221       000000           ARC41     EQU     $000000
222       000001           VIDGENI   EQU     $000001                           ; CCD Video Processor Gen I
223       000002           IRREV4    EQU     $000002                           ; IR Video Processor Rev. 4
224       000002           ARC42     EQU     $000002
225       000003           COADDER   EQU     $000003                           ; IR Coadder
226       000003           ARC44     EQU     $000003
227       000004           CCDVIDREV5 EQU    $000004                           ; Differential input CCD video Rev. 5
228       000004           ARC45     EQU     $000004
229       000005           ARC46     EQU     $000005                           ; 8-channel IR video board
230       000006           ARC48     EQU     $000006                           ; 8-channel CCD video board
231       000007           ARC47     EQU     $000007                           ; 4-channel CCD video board
232       000000           TIMREV4   EQU     $000000                           ; Timing Revision 4 = 50 MHz
233       000000           ARC20     EQU     $000000
234       000008           TIMGENI   EQU     $000008                           ; Timing Gen I = 40 MHz
235       000010           TIMREV5   EQU     $000010                           ; Timing Revision 5 = 250 MHz
236       000010           ARC22     EQU     $000010
237       008000           ARC32     EQU     $008000                           ; CCD & IR clock driver board
238       000020           UTILREV3  EQU     $000020                           ; Utility Rev. 3 supported
239       000020           ARC50     EQU     $000020
240       000080           SHUTTER_CC EQU    $000080                           ; Shutter supported
241       000100           TEMP_POLY EQU     $000100                           ; Polynomial calibration
242                        TEMP_LINEAR
243       000200                     EQU     $000200                           ; Linear calibration
244       000400           SUBARRAY  EQU     $000400                           ; Subarray readout supported
245       000800           BINNING   EQU     $000800                           ; Binning supported
246                        SPLIT_SERIAL
247       001000                     EQU     $001000                           ; Split serial supported
248                        SPLIT_PARALLEL
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 5



249       002000                     EQU     $002000                           ; Split parallel supported
250       004000           MPP_CC    EQU     $004000                           ; Inverted clocks supported
251       018000           CLKDRVGENI EQU    $018000                           ; No clock driver board - Gen I
252       020000           MLO       EQU     $020000                           ; Set if Mount Laguna Observatory
253       040000           NGST      EQU     $040000                           ; NGST Aladdin implementation
254       100000           CONT_RD   EQU     $100000                           ; Continuous readout implemented
255    
256                        ; Special address for two words for the DSP to bootstrap code from the EEPROM
257                                  IF      @SCP("HOST","ROM")
264                                  ENDIF
265    
266                                  IF      @SCP("HOST","HOST")
267       P:000000 P:000000                   ORG     P:0,P:0
268       P:000000 P:000000 0C0190            JMP     <INIT
269       P:000001 P:000001 000000            NOP
270                                           ENDIF
271    
272                                 ;  This ISR receives serial words a byte at a time over the asynchronous
273                                 ;    serial link (SCI) and squashes them into a single 24-bit word
274       P:000002 P:000002 602400  SCI_RCV   MOVE              R0,X:<SAVE_R0           ; Save R0
275       P:000003 P:000003 052139            MOVEC             SR,X:<SAVE_SR           ; Save Status Register
276       P:000004 P:000004 60A700            MOVE              X:<SCI_R0,R0            ; Restore R0 = pointer to SCI receive regist
er
277       P:000005 P:000005 542300            MOVE              A1,X:<SAVE_A1           ; Save A1
278       P:000006 P:000006 452200            MOVE              X1,X:<SAVE_X1           ; Save X1
279       P:000007 P:000007 54A600            MOVE              X:<SCI_A1,A1            ; Get SRX value of accumulator contents
280       P:000008 P:000008 45E000            MOVE              X:(R0),X1               ; Get the SCI byte
281       P:000009 P:000009 0AD041            BCLR    #1,R0                             ; Test for the address being $FFF6 = last by
te
282       P:00000A P:00000A 000000            NOP
283       P:00000B P:00000B 000000            NOP
284       P:00000C P:00000C 000000            NOP
285       P:00000D P:00000D 205862            OR      X1,A      (R0)+                   ; Add the byte into the 24-bit word
286       P:00000E P:00000E 0E0013            JCC     <MID_BYT                          ; Not the last byte => only restore register
s
287       P:00000F P:00000F 545C00  END_BYT   MOVE              A1,X:(R4)+              ; Put the 24-bit word into the SCI buffer
288       P:000010 P:000010 60F400            MOVE              #SRXL,R0                ; Re-establish first address of SCI interfac
e
                            FFFF98
289       P:000012 P:000012 2C0000            MOVE              #0,A1                   ; For zeroing out SCI_A1
290       P:000013 P:000013 602700  MID_BYT   MOVE              R0,X:<SCI_R0            ; Save the SCI receiver address
291       P:000014 P:000014 542600            MOVE              A1,X:<SCI_A1            ; Save A1 for next interrupt
292       P:000015 P:000015 05A139            MOVEC             X:<SAVE_SR,SR           ; Restore Status Register
293       P:000016 P:000016 54A300            MOVE              X:<SAVE_A1,A1           ; Restore A1
294       P:000017 P:000017 45A200            MOVE              X:<SAVE_X1,X1           ; Restore X1
295       P:000018 P:000018 60A400            MOVE              X:<SAVE_R0,R0           ; Restore R0
296       P:000019 P:000019 000004            RTI                                       ; Return from interrupt service
297    
298                                 ; Clear error condition and interrupt on SCI receiver
299       P:00001A P:00001A 077013  CLR_ERR   MOVEP             X:SSR,X:RCV_ERR         ; Read SCI status register
                            000025
300       P:00001C P:00001C 077018            MOVEP             X:SRXL,X:RCV_ERR        ; This clears any error
                            000025
301       P:00001E P:00001E 000004            RTI
302    
303       P:00001F P:00001F                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
304       P:000030 P:000030                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
305       P:000040 P:000040                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
306    
307                                 ; Tune the table so the following instruction is at P:$50 exactly.
308       P:000050 P:000050 0D0002            JSR     SCI_RCV                           ; SCI receive data interrupt
309       P:000051 P:000051 000000            NOP
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 6



310       P:000052 P:000052 0D001A            JSR     CLR_ERR                           ; SCI receive error interrupt
311       P:000053 P:000053 000000            NOP
312    
313                                 ; *******************  Command Processing  ******************
314    
315                                 ; Read the header and check it for self-consistency
316       P:000054 P:000054 609F00  START     MOVE              X:<IDL_ADR,R0
317       P:000055 P:000055 018FA0            JSET    #TIM_BIT,X:TCSR0,EXPOSING         ; If exposing go check the timer
                            00005A
318       P:000057 P:000057 0A00A4            JSET    #ST_RDC,X:<STATUS,CONTINUE_READING
                            00005A
319       P:000059 P:000059 0AE080            JMP     (R0)
320    
321       P:00005A P:00005A 330700  TST_RCV   MOVE              #<COM_BUF,R3
322       P:00005B P:00005B 0D00A5            JSR     <GET_RCV
323       P:00005C P:00005C 0E005B            JCC     *-1
324    
325                                 ; Check the header and read all the remaining words in the command
326       P:00005D P:00005D 0C00FF  PRC_RCV   JMP     <CHK_HDR                          ; Update HEADER and NWORDS
327       P:00005E P:00005E 578600  PR_RCV    MOVE              X:<NWORDS,B             ; Read this many words total in the command
328       P:00005F P:00005F 000000            NOP
329       P:000060 P:000060 01418C            SUB     #1,B                              ; We've already read the header
330       P:000061 P:000061 000000            NOP
331       P:000062 P:000062 06CF00            DO      B,RD_COM
                            00006A
332       P:000064 P:000064 205B00            MOVE              (R3)+                   ; Increment past what's been read already
333       P:000065 P:000065 0B0080  GET_WRD   JSCLR   #ST_RCV,X:STATUS,CHK_FO
                            0000A9
334       P:000067 P:000067 0B00A0            JSSET   #ST_RCV,X:STATUS,CHK_SCI
                            0000D5
335       P:000069 P:000069 0E0065            JCC     <GET_WRD
336       P:00006A P:00006A 000000            NOP
337       P:00006B P:00006B 330700  RD_COM    MOVE              #<COM_BUF,R3            ; Restore R3 = beginning of the command
338    
339                                 ; Is this command for the timing board?
340       P:00006C P:00006C 448500            MOVE              X:<HEADER,X0
341       P:00006D P:00006D 579B00            MOVE              X:<DMASK,B
342       P:00006E P:00006E 459A4E            AND     X0,B      X:<TIM_DRB,X1           ; Extract destination byte
343       P:00006F P:00006F 20006D            CMP     X1,B                              ; Does header = timing board number?
344       P:000070 P:000070 0EA080            JEQ     <COMMAND                          ; Yes, process it here
345       P:000071 P:000071 0E909D            JLT     <FO_XMT                           ; Send it to fiber optic transmitter
346    
347                                 ; Transmit the command to the utility board over the SCI port
348       P:000072 P:000072 060600            DO      X:<NWORDS,DON_XMT                 ; Transmit NWORDS
                            00007E
349       P:000074 P:000074 60F400            MOVE              #STXL,R0                ; SCI first byte address
                            FFFF95
350       P:000076 P:000076 44DB00            MOVE              X:(R3)+,X0              ; Get the 24-bit word to transmit
351       P:000077 P:000077 060380            DO      #3,SCI_SPT
                            00007D
352       P:000079 P:000079 019381            JCLR    #TDRE,X:SSR,*                     ; Continue ONLY if SCI XMT is empty
                            000079
353       P:00007B P:00007B 445800            MOVE              X0,X:(R0)+              ; Write to SCI, byte pointer + 1
354       P:00007C P:00007C 000000            NOP                                       ; Delay for the status flag to be set
355       P:00007D P:00007D 000000            NOP
356                                 SCI_SPT
357       P:00007E P:00007E 000000            NOP
358                                 DON_XMT
359       P:00007F P:00007F 0C0054            JMP     <START
360    
361                                 ; Process the receiver entry - is it in the command table ?
362       P:000080 P:000080 0203DF  COMMAND   MOVE              X:(R3+1),B              ; Get the command
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 7



363       P:000081 P:000081 205B00            MOVE              (R3)+
364       P:000082 P:000082 205B00            MOVE              (R3)+                   ; Point R3 to the first argument
365       P:000083 P:000083 302800            MOVE              #<COM_TBL,R0            ; Get the command table starting address
366       P:000084 P:000084 062080            DO      #NUM_COM,END_COM                  ; Loop over the command table
                            00008B
367       P:000086 P:000086 47D800            MOVE              X:(R0)+,Y1              ; Get the command table entry
368       P:000087 P:000087 62E07D            CMP     Y1,B      X:(R0),R2               ; Does receiver = table entries address?
369       P:000088 P:000088 0E208B            JNE     <NOT_COM                          ; No, keep looping
370       P:000089 P:000089 00008C            ENDDO                                     ; Restore the DO loop system registers
371       P:00008A P:00008A 0AE280            JMP     (R2)                              ; Jump execution to the command
372       P:00008B P:00008B 205800  NOT_COM   MOVE              (R0)+                   ; Increment the register past the table addr
ess
373                                 END_COM
374       P:00008C P:00008C 0C008D            JMP     <ERROR                            ; The command is not in the table
375    
376                                 ; It's not in the command table - send an error message
377       P:00008D P:00008D 479D00  ERROR     MOVE              X:<ERR,Y1               ; Send the message - there was an error
378       P:00008E P:00008E 0C0090            JMP     <FINISH1                          ; This protects against unknown commands
379    
380                                 ; Send a reply packet - header and reply
381       P:00008F P:00008F 479800  FINISH    MOVE              X:<DONE,Y1              ; Send 'DON' as the reply
382       P:000090 P:000090 578500  FINISH1   MOVE              X:<HEADER,B             ; Get header of incoming command
383       P:000091 P:000091 469C00            MOVE              X:<SMASK,Y0             ; This was the source byte, and is to
384       P:000092 P:000092 330700            MOVE              #<COM_BUF,R3            ;     become the destination byte
385       P:000093 P:000093 46935E            AND     Y0,B      X:<TWO,Y0
386       P:000094 P:000094 0C1ED1            LSR     #8,B                              ; Shift right eight bytes, add it to the
387       P:000095 P:000095 460600            MOVE              Y0,X:<NWORDS            ;     header, and put 2 as the number
388       P:000096 P:000096 469958            ADD     Y0,B      X:<SBRD,Y0              ;     of words in the string
389       P:000097 P:000097 200058            ADD     Y0,B                              ; Add source board's header, set Y1 for abov
e
390       P:000098 P:000098 000000            NOP
391       P:000099 P:000099 575B00            MOVE              B,X:(R3)+               ; Put the new header on the transmitter stac
k
392       P:00009A P:00009A 475B00            MOVE              Y1,X:(R3)+              ; Put the argument on the transmitter stack
393       P:00009B P:00009B 570500            MOVE              B,X:<HEADER
394       P:00009C P:00009C 0C006B            JMP     <RD_COM                           ; Decide where to send the reply, and do it
395    
396                                 ; Transmit words to the host computer over the fiber optics link
397       P:00009D P:00009D 63F400  FO_XMT    MOVE              #COM_BUF,R3
                            000007
398       P:00009F P:00009F 060600            DO      X:<NWORDS,DON_FFO                 ; Transmit all the words in the command
                            0000A3
399       P:0000A1 P:0000A1 57DB00            MOVE              X:(R3)+,B
400       P:0000A2 P:0000A2 0D00EB            JSR     <XMT_WRD
401       P:0000A3 P:0000A3 000000            NOP
402       P:0000A4 P:0000A4 0C0054  DON_FFO   JMP     <START
403    
404                                 ; Check for commands from the fiber optic FIFO and the utility board (SCI)
405       P:0000A5 P:0000A5 0D00A9  GET_RCV   JSR     <CHK_FO                           ; Check for fiber optic command from FIFO
406       P:0000A6 P:0000A6 0E80A8            JCS     <RCV_RTS                          ; If there's a command, check the header
407       P:0000A7 P:0000A7 0D00D5            JSR     <CHK_SCI                          ; Check for an SCI command
408       P:0000A8 P:0000A8 00000C  RCV_RTS   RTS
409    
410                                 ; Because of FIFO metastability require that EF be stable for two tests
411       P:0000A9 P:0000A9 0A8989  CHK_FO    JCLR    #EF,X:HDR,TST2                    ; EF = Low,  Low  => CLR SR, return
                            0000AC
412       P:0000AB P:0000AB 0C00AF            JMP     <TST3                             ;      High, Low  => try again
413       P:0000AC P:0000AC 0A8989  TST2      JCLR    #EF,X:HDR,CLR_CC                  ;      Low,  High => try again
                            0000D1
414       P:0000AE P:0000AE 0C00A9            JMP     <CHK_FO                           ;      High, High => read FIFO
415       P:0000AF P:0000AF 0A8989  TST3      JCLR    #EF,X:HDR,CHK_FO
                            0000A9
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 8



416    
417       P:0000B1 P:0000B1 08F4BB            MOVEP             #$028FE2,X:BCR          ; Slow down RDFO access
                            028FE2
418       P:0000B3 P:0000B3 000000            NOP
419       P:0000B4 P:0000B4 000000            NOP
420       P:0000B5 P:0000B5 5FF000            MOVE                          Y:RDFO,B
                            FFFFF1
421       P:0000B7 P:0000B7 2B0000            MOVE              #0,B2
422       P:0000B8 P:0000B8 0140CE            AND     #$FF,B
                            0000FF
423       P:0000BA P:0000BA 0140CD            CMP     #>$AC,B                           ; It must be $AC to be a valid word
                            0000AC
424       P:0000BC P:0000BC 0E20D1            JNE     <CLR_CC
425       P:0000BD P:0000BD 4EF000            MOVE                          Y:RDFO,Y0   ; Read the MS byte
                            FFFFF1
426       P:0000BF P:0000BF 0C1951            INSERT  #$008010,Y0,B
                            008010
427       P:0000C1 P:0000C1 4EF000            MOVE                          Y:RDFO,Y0   ; Read the middle byte
                            FFFFF1
428       P:0000C3 P:0000C3 0C1951            INSERT  #$008008,Y0,B
                            008008
429       P:0000C5 P:0000C5 4EF000            MOVE                          Y:RDFO,Y0   ; Read the LS byte
                            FFFFF1
430       P:0000C7 P:0000C7 0C1951            INSERT  #$008000,Y0,B
                            008000
431       P:0000C9 P:0000C9 000000            NOP
432       P:0000CA P:0000CA 516300            MOVE              B0,X:(R3)               ; Put the word into COM_BUF
433       P:0000CB P:0000CB 0A0000            BCLR    #ST_RCV,X:<STATUS                 ; Its a command from the host computer
434       P:0000CC P:0000CC 000000  SET_CC    NOP
435       P:0000CD P:0000CD 0AF960            BSET    #0,SR                             ; Valid word => SR carry bit = 1
436       P:0000CE P:0000CE 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
437       P:0000D0 P:0000D0 00000C            RTS
438       P:0000D1 P:0000D1 0AF940  CLR_CC    BCLR    #0,SR                             ; Not valid word => SR carry bit = 0
439       P:0000D2 P:0000D2 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
440       P:0000D4 P:0000D4 00000C            RTS
441    
442                                 ; Test the SCI (= synchronous communications interface) for new words
443       P:0000D5 P:0000D5 44F000  CHK_SCI   MOVE              X:(SCI_TABLE+33),X0
                            000421
444       P:0000D7 P:0000D7 228E00            MOVE              R4,A
445       P:0000D8 P:0000D8 209000            MOVE              X0,R0
446       P:0000D9 P:0000D9 200045            CMP     X0,A
447       P:0000DA P:0000DA 0EA0D1            JEQ     <CLR_CC                           ; There is no new SCI word
448       P:0000DB P:0000DB 44D800            MOVE              X:(R0)+,X0
449       P:0000DC P:0000DC 446300            MOVE              X0,X:(R3)
450       P:0000DD P:0000DD 220E00            MOVE              R0,A
451       P:0000DE P:0000DE 0140C5            CMP     #(SCI_TABLE+32),A                 ; Wrap it around the circular
                            000420
452       P:0000E0 P:0000E0 0EA0E4            JEQ     <INIT_PROCESSED_SCI               ;   buffer boundary
453       P:0000E1 P:0000E1 547000            MOVE              A1,X:(SCI_TABLE+33)
                            000421
454       P:0000E3 P:0000E3 0C00E9            JMP     <SCI_END
455                                 INIT_PROCESSED_SCI
456       P:0000E4 P:0000E4 56F400            MOVE              #SCI_TABLE,A
                            000400
457       P:0000E6 P:0000E6 000000            NOP
458       P:0000E7 P:0000E7 567000            MOVE              A,X:(SCI_TABLE+33)
                            000421
459       P:0000E9 P:0000E9 0A0020  SCI_END   BSET    #ST_RCV,X:<STATUS                 ; Its a utility board (SCI) word
460       P:0000EA P:0000EA 0C00CC            JMP     <SET_CC
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 9



461    
462                                 ; Transmit the word in B1 to the host computer over the fiber optic data link
463                                 XMT_WRD
464       P:0000EB P:0000EB 08F4BB            MOVEP             #$028FE2,X:BCR          ; Slow down RDFO access
                            028FE2
465       P:0000ED P:0000ED 60F400            MOVE              #FO_HDR+1,R0
                            000002
466       P:0000EF P:0000EF 060380            DO      #3,XMT_WRD1
                            0000F3
467       P:0000F1 P:0000F1 0C1D91            ASL     #8,B,B
468       P:0000F2 P:0000F2 000000            NOP
469       P:0000F3 P:0000F3 535800            MOVE              B2,X:(R0)+
470                                 XMT_WRD1
471       P:0000F4 P:0000F4 60F400            MOVE              #FO_HDR,R0
                            000001
472       P:0000F6 P:0000F6 61F400            MOVE              #WRFO,R1
                            FFFFF2
473       P:0000F8 P:0000F8 060480            DO      #4,XMT_WRD2
                            0000FB
474       P:0000FA P:0000FA 46D800            MOVE              X:(R0)+,Y0              ; Should be MOVEP  X:(R0)+,Y:WRFO
475       P:0000FB P:0000FB 4E6100            MOVE                          Y0,Y:(R1)
476                                 XMT_WRD2
477       P:0000FC P:0000FC 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
478       P:0000FE P:0000FE 00000C            RTS
479    
480                                 ; Check the command or reply header in X:(R3) for self-consistency
481       P:0000FF P:0000FF 46E300  CHK_HDR   MOVE              X:(R3),Y0
482       P:000100 P:000100 579600            MOVE              X:<MASK1,B              ; Test for S.LE.3 and D.LE.3 and N.LE.7
483       P:000101 P:000101 20005E            AND     Y0,B
484       P:000102 P:000102 0E208D            JNE     <ERROR                            ; Test failed
485       P:000103 P:000103 579700            MOVE              X:<MASK2,B              ; Test for either S.NE.0 or D.NE.0
486       P:000104 P:000104 20005E            AND     Y0,B
487       P:000105 P:000105 0EA08D            JEQ     <ERROR                            ; Test failed
488       P:000106 P:000106 579500            MOVE              X:<SEVEN,B
489       P:000107 P:000107 20005E            AND     Y0,B                              ; Extract NWORDS, must be > 0
490       P:000108 P:000108 0EA08D            JEQ     <ERROR
491       P:000109 P:000109 44E300            MOVE              X:(R3),X0
492       P:00010A P:00010A 440500            MOVE              X0,X:<HEADER            ; Its a correct header
493       P:00010B P:00010B 550600            MOVE              B1,X:<NWORDS            ; Number of words in the command
494       P:00010C P:00010C 0C005E            JMP     <PR_RCV
495    
496                                 ;  *****************  Boot Commands  *******************
497    
498                                 ; Test Data Link - simply return value received after 'TDL'
499       P:00010D P:00010D 47DB00  TDL       MOVE              X:(R3)+,Y1              ; Get the data value
500       P:00010E P:00010E 0C0090            JMP     <FINISH1                          ; Return from executing TDL command
501    
502                                 ; Read DSP or EEPROM memory ('RDM' address): read memory, reply with value
503       P:00010F P:00010F 47DB00  RDMEM     MOVE              X:(R3)+,Y1
504       P:000110 P:000110 20EF00            MOVE              Y1,B
505       P:000111 P:000111 0140CE            AND     #$0FFFFF,B                        ; Bits 23-20 need to be zeroed
                            0FFFFF
506       P:000113 P:000113 21B000            MOVE              B1,R0                   ; Need the address in an address register
507       P:000114 P:000114 20EF00            MOVE              Y1,B
508       P:000115 P:000115 000000            NOP
509       P:000116 P:000116 0ACF14            JCLR    #20,B,RDX                         ; Test address bit for Program memory
                            00011A
510       P:000118 P:000118 07E087            MOVE              P:(R0),Y1               ; Read from Program Memory
511       P:000119 P:000119 0C0090            JMP     <FINISH1                          ; Send out a header with the value
512       P:00011A P:00011A 0ACF15  RDX       JCLR    #21,B,RDY                         ; Test address bit for X: memory
                            00011E
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 10



513       P:00011C P:00011C 47E000            MOVE              X:(R0),Y1               ; Write to X data memory
514       P:00011D P:00011D 0C0090            JMP     <FINISH1                          ; Send out a header with the value
515       P:00011E P:00011E 0ACF16  RDY       JCLR    #22,B,RDR                         ; Test address bit for Y: memory
                            000122
516       P:000120 P:000120 4FE000            MOVE                          Y:(R0),Y1   ; Read from Y data memory
517       P:000121 P:000121 0C0090            JMP     <FINISH1                          ; Send out a header with the value
518       P:000122 P:000122 0ACF17  RDR       JCLR    #23,B,ERROR                       ; Test address bit for read from EEPROM memo
ry
                            00008D
519       P:000124 P:000124 479400            MOVE              X:<THREE,Y1             ; Convert to word address to a byte address
520       P:000125 P:000125 220600            MOVE              R0,Y0                   ; Get 16-bit address in a data register
521       P:000126 P:000126 2000B8            MPY     Y0,Y1,B                           ; Multiply
522       P:000127 P:000127 20002A            ASR     B                                 ; Eliminate zero fill of fractional multiply
523       P:000128 P:000128 213000            MOVE              B0,R0                   ; Need to address memory
524       P:000129 P:000129 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
525       P:00012A P:00012A 0D0178            JSR     <RD_WORD                          ; Read word from EEPROM
526       P:00012B P:00012B 21A700            MOVE              B1,Y1                   ; FINISH1 transmits Y1 as its reply
527       P:00012C P:00012C 0C0090            JMP     <FINISH1
528    
529                                 ; Program WRMEM ('WRM' address datum): write to memory, reply 'DON'.
530       P:00012D P:00012D 47DB00  WRMEM     MOVE              X:(R3)+,Y1              ; Get the address to be written to
531       P:00012E P:00012E 20EF00            MOVE              Y1,B
532       P:00012F P:00012F 0140CE            AND     #$0FFFFF,B                        ; Bits 23-20 need to be zeroed
                            0FFFFF
533       P:000131 P:000131 21B000            MOVE              B1,R0                   ; Need the address in an address register
534       P:000132 P:000132 20EF00            MOVE              Y1,B
535       P:000133 P:000133 46DB00            MOVE              X:(R3)+,Y0              ; Get datum into Y0 so MOVE works easily
536       P:000134 P:000134 0ACF14            JCLR    #20,B,WRX                         ; Test address bit for Program memory
                            000138
537       P:000136 P:000136 076086            MOVE              Y0,P:(R0)               ; Write to Program memory
538       P:000137 P:000137 0C008F            JMP     <FINISH
539       P:000138 P:000138 0ACF15  WRX       JCLR    #21,B,WRY                         ; Test address bit for X: memory
                            00013C
540       P:00013A P:00013A 466000            MOVE              Y0,X:(R0)               ; Write to X: memory
541       P:00013B P:00013B 0C008F            JMP     <FINISH
542       P:00013C P:00013C 0ACF16  WRY       JCLR    #22,B,WRR                         ; Test address bit for Y: memory
                            000140
543       P:00013E P:00013E 4E6000            MOVE                          Y0,Y:(R0)   ; Write to Y: memory
544       P:00013F P:00013F 0C008F            JMP     <FINISH
545       P:000140 P:000140 0ACF17  WRR       JCLR    #23,B,ERROR                       ; Test address bit for write to EEPROM
                            00008D
546       P:000142 P:000142 013D02            BCLR    #WRENA,X:PDRC                     ; WR_ENA* = 0 to enable EEPROM writing
547       P:000143 P:000143 460E00            MOVE              Y0,X:<SV_A1             ; Save the datum to be written
548       P:000144 P:000144 479400            MOVE              X:<THREE,Y1             ; Convert word address to a byte address
549       P:000145 P:000145 220600            MOVE              R0,Y0                   ; Get 16-bit address in a data register
550       P:000146 P:000146 2000B8            MPY     Y1,Y0,B                           ; Multiply
551       P:000147 P:000147 20002A            ASR     B                                 ; Eliminate zero fill of fractional multiply
552       P:000148 P:000148 213000            MOVE              B0,R0                   ; Need to address memory
553       P:000149 P:000149 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
554       P:00014A P:00014A 558E00            MOVE              X:<SV_A1,B1             ; Get the datum to be written
555       P:00014B P:00014B 060380            DO      #3,L1WRR                          ; Loop over three bytes of the word
                            000154
556       P:00014D P:00014D 07588D            MOVE              B1,P:(R0)+              ; Write each EEPROM byte
557       P:00014E P:00014E 0C1C91            ASR     #8,B,B
558       P:00014F P:00014F 469E00            MOVE              X:<C100K,Y0             ; Move right one byte, enter delay = 1 msec
559       P:000150 P:000150 06C600            DO      Y0,L2WRR                          ; Delay by 12 milliseconds for EEPROM write
                            000153
560       P:000152 P:000152 060CA0            REP     #12                               ; Assume 100 MHz DSP56303
561       P:000153 P:000153 000000            NOP
562                                 L2WRR
563       P:000154 P:000154 000000            NOP                                       ; DO loop nesting restriction
564                                 L1WRR
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 11



565       P:000155 P:000155 013D22            BSET    #WRENA,X:PDRC                     ; WR_ENA* = 1 to disable EEPROM writing
566       P:000156 P:000156 0C008F            JMP     <FINISH
567    
568                                 ; Load application code from P: memory into its proper locations
569       P:000157 P:000157 47DB00  LDAPPL    MOVE              X:(R3)+,Y1              ; Application number, not used yet
570       P:000158 P:000158 0D015A            JSR     <LOAD_APPLICATION
571       P:000159 P:000159 0C008F            JMP     <FINISH
572    
573                                 LOAD_APPLICATION
574       P:00015A P:00015A 60F400            MOVE              #$8000,R0               ; Starting EEPROM address
                            008000
575       P:00015C P:00015C 0D0178            JSR     <RD_WORD                          ; Number of words in boot code
576       P:00015D P:00015D 21A600            MOVE              B1,Y0
577       P:00015E P:00015E 479400            MOVE              X:<THREE,Y1
578       P:00015F P:00015F 2000B8            MPY     Y0,Y1,B
579       P:000160 P:000160 20002A            ASR     B
580       P:000161 P:000161 213000            MOVE              B0,R0                   ; EEPROM address of start of P: application
581       P:000162 P:000162 0AD06F            BSET    #15,R0                            ; To access EEPROM
582       P:000163 P:000163 0D0178            JSR     <RD_WORD                          ; Read number of words in application P:
583       P:000164 P:000164 61F400            MOVE              #(X_BOOT_START+1),R1    ; End of boot P: code that needs keeping
                            00022B
584       P:000166 P:000166 06CD00            DO      B1,RD_APPL_P
                            000169
585       P:000168 P:000168 0D0178            JSR     <RD_WORD
586       P:000169 P:000169 07598D            MOVE              B1,P:(R1)+
587                                 RD_APPL_P
588       P:00016A P:00016A 0D0178            JSR     <RD_WORD                          ; Read number of words in application X:
589       P:00016B P:00016B 61F400            MOVE              #END_COMMAND_TABLE,R1
                            000036
590       P:00016D P:00016D 06CD00            DO      B1,RD_APPL_X
                            000170
591       P:00016F P:00016F 0D0178            JSR     <RD_WORD
592       P:000170 P:000170 555900            MOVE              B1,X:(R1)+
593                                 RD_APPL_X
594       P:000171 P:000171 0D0178            JSR     <RD_WORD                          ; Read number of words in application Y:
595       P:000172 P:000172 310100            MOVE              #1,R1                   ; There is no Y: memory in the boot code
596       P:000173 P:000173 06CD00            DO      B1,RD_APPL_Y
                            000176
597       P:000175 P:000175 0D0178            JSR     <RD_WORD
598       P:000176 P:000176 5D5900            MOVE                          B1,Y:(R1)+
599                                 RD_APPL_Y
600       P:000177 P:000177 00000C            RTS
601    
602                                 ; Read one word from EEPROM location R0 into accumulator B1
603       P:000178 P:000178 060380  RD_WORD   DO      #3,L_RDBYTE
                            00017B
604       P:00017A P:00017A 07D88B            MOVE              P:(R0)+,B2
605       P:00017B P:00017B 0C1C91            ASR     #8,B,B
606                                 L_RDBYTE
607       P:00017C P:00017C 00000C            RTS
608    
609                                 ; Come to here on a 'STP' command so 'DON' can be sent
610                                 STOP_IDLE_CLOCKING
611       P:00017D P:00017D 305A00            MOVE              #<TST_RCV,R0            ; Execution address when idle => when not
612       P:00017E P:00017E 601F00            MOVE              R0,X:<IDL_ADR           ;   processing commands or reading out
613       P:00017F P:00017F 0A0002            BCLR    #IDLMODE,X:<STATUS                ; Don't idle after readout
614       P:000180 P:000180 0C008F            JMP     <FINISH
615    
616                                 ; Routines executed after the DSP boots and initializes
617       P:000181 P:000181 305A00  STARTUP   MOVE              #<TST_RCV,R0            ; Execution address when idle => when not
618       P:000182 P:000182 601F00            MOVE              R0,X:<IDL_ADR           ;   processing commands or reading out
619       P:000183 P:000183 44F400            MOVE              #50000,X0               ; Delay by 500 milliseconds
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 12



                            00C350
620       P:000185 P:000185 06C400            DO      X0,L_DELAY
                            000188
621       P:000187 P:000187 06E8A3            REP     #1000
622       P:000188 P:000188 000000            NOP
623                                 L_DELAY
624       P:000189 P:000189 57F400            MOVE              #$020002,B              ; Normal reply after booting is 'SYR'
                            020002
625       P:00018B P:00018B 0D00EB            JSR     <XMT_WRD
626       P:00018C P:00018C 57F400            MOVE              #'SYR',B
                            535952
627       P:00018E P:00018E 0D00EB            JSR     <XMT_WRD
628    
629       P:00018F P:00018F 0C0054            JMP     <START                            ; Start normal command processing
630    
631                                 ; *******************  DSP  INITIALIZATION  CODE  **********************
632                                 ; This code initializes the DSP right after booting, and is overwritten
633                                 ;   by application code
634       P:000190 P:000190 08F4BD  INIT      MOVEP             #PLL_INIT,X:PCTL        ; Initialize PLL to 100 MHz
                            050003
635       P:000192 P:000192 000000            NOP
636    
637                                 ; Set operation mode register OMR to normal expanded
638       P:000193 P:000193 0500BA            MOVEC             #$0000,OMR              ; Operating Mode Register = Normal Expanded
639       P:000194 P:000194 0500BB            MOVEC             #0,SP                   ; Reset the Stack Pointer SP
640    
641                                 ; Program the AA = address attribute pins
642       P:000195 P:000195 08F4B9            MOVEP             #$FFFC21,X:AAR0         ; Y = $FFF000 to $FFFFFF asserts commands
                            FFFC21
643       P:000197 P:000197 08F4B8            MOVEP             #$008909,X:AAR1         ; P = $008000 to $00FFFF accesses the EEPROM
                            008909
644       P:000199 P:000199 08F4B7            MOVEP             #$010C11,X:AAR2         ; X = $010000 to $010FFF reads A/D values
                            010C11
645       P:00019B P:00019B 08F4B6            MOVEP             #$080621,X:AAR3         ; Y = $080000 to $0BFFFF R/W from SRAM
                            080621
646    
647       P:00019D P:00019D 0A0F00            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
648       P:00019E P:00019E 0A0F02            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
649       P:00019F P:00019F 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                            00000F
650    
651                                 ; Program the DRAM memory access and addressing
652       P:0001A1 P:0001A1 08F4BB            MOVEP             #$028FE1,X:BCR          ; Bus Control Register
                            028FE1
653    
654                                 ; Program the Host port B for parallel I/O
655       P:0001A3 P:0001A3 08F484            MOVEP             #>1,X:HPCR              ; All pins enabled as GPIO
                            000001
656       P:0001A5 P:0001A5 08F489            MOVEP             #$810C,X:HDR
                            00810C
657       P:0001A7 P:0001A7 08F488            MOVEP             #$B10E,X:HDDR           ; Data Direction Register
                            00B10E
658                                                                                     ;  (1 for Output, 0 for Input)
659    
660                                 ; Port B conversion from software bits to schematic labels
661                                 ;       PB0 = PWROK             PB08 = PRSFIFO*
662                                 ;       PB1 = LED1              PB09 = EF*
663                                 ;       PB2 = LVEN              PB10 = EXT-IN0
664                                 ;       PB3 = HVEN              PB11 = EXT-IN1
665                                 ;       PB4 = STATUS0           PB12 = EXT-OUT0
666                                 ;       PB5 = STATUS1           PB13 = EXT-OUT1
667                                 ;       PB6 = STATUS2           PB14 = SSFHF*
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 13



668                                 ;       PB7 = STATUS3           PB15 = SELSCI
669    
670                                 ; Program the serial port ESSI0 = Port C for serial communication with
671                                 ;   the utility board
672       P:0001A9 P:0001A9 07F43F            MOVEP             #>0,X:PCRC              ; Software reset of ESSI0
                            000000
673       P:0001AB P:0001AB 07F435            MOVEP             #$180809,X:CRA0         ; Divide 100 MHz by 20 to get 5.0 MHz
                            180809
674                                                                                     ; DC[4:0] = 0 for non-network operation
675                                                                                     ; WL0-WL2 = 3 for 24-bit data words
676                                                                                     ; SSC1 = 0 for SC1 not used
677       P:0001AD P:0001AD 07F436            MOVEP             #$020020,X:CRB0         ; SCKD = 1 for internally generated clock
                            020020
678                                                                                     ; SCD2 = 0 so frame sync SC2 is an output
679                                                                                     ; SHFD = 0 for MSB shifted first
680                                                                                     ; FSL = 0, frame sync length not used
681                                                                                     ; CKP = 0 for rising clock edge transitions
682                                                                                     ; SYN = 0 for asynchronous
683                                                                                     ; TE0 = 1 to enable transmitter #0
684                                                                                     ; MOD = 0 for normal, non-networked mode
685                                                                                     ; TE0 = 0 to NOT enable transmitter #0 yet
686                                                                                     ; RE = 1 to enable receiver
687       P:0001AF P:0001AF 07F43F            MOVEP             #%111001,X:PCRC         ; Control Register (0 for GPIO, 1 for ESSI)
                            000039
688       P:0001B1 P:0001B1 07F43E            MOVEP             #%000110,X:PRRC         ; Data Direction Register (0 for In, 1 for O
ut)
                            000006
689       P:0001B3 P:0001B3 07F43D            MOVEP             #%000100,X:PDRC         ; Data Register - WR_ENA* = 1
                            000004
690    
691                                 ; Port C version = Analog boards
692                                 ;       MOVEP   #$000809,X:CRA0 ; Divide 100 MHz by 20 to get 5.0 MHz
693                                 ;       MOVEP   #$000030,X:CRB0 ; SCKD = 1 for internally generated clock
694                                 ;       MOVEP   #%100000,X:PCRC ; Control Register (0 for GPIO, 1 for ESSI)
695                                 ;       MOVEP   #%000100,X:PRRC ; Data Direction Register (0 for In, 1 for Out)
696                                 ;       MOVEP   #%000000,X:PDRC ; Data Register: 'not used' = 0 outputs
697    
698       P:0001B5 P:0001B5 07F43C            MOVEP             #0,X:TX00               ; Initialize the transmitter to zero
                            000000
699       P:0001B7 P:0001B7 000000            NOP
700       P:0001B8 P:0001B8 000000            NOP
701       P:0001B9 P:0001B9 013630            BSET    #TE,X:CRB0                        ; Enable the SSI transmitter
702    
703                                 ; Conversion from software bits to schematic labels for Port C
704                                 ;       PC0 = SC00 = UTL-T-SCK
705                                 ;       PC1 = SC01 = 2_XMT = SYNC on prototype
706                                 ;       PC2 = SC02 = WR_ENA*
707                                 ;       PC3 = SCK0 = TIM-U-SCK
708                                 ;       PC4 = SRD0 = UTL-T-STD
709                                 ;       PC5 = STD0 = TIM-U-STD
710    
711                                 ; Program the serial port ESSI1 = Port D for serial transmission to
712                                 ;   the analog boards and two parallel I/O input pins
713       P:0001BA P:0001BA 07F42F            MOVEP             #>0,X:PCRD              ; Software reset of ESSI0
                            000000
714       P:0001BC P:0001BC 07F425            MOVEP             #$000809,X:CRA1         ; Divide 100 MHz by 20 to get 5.0 MHz
                            000809
715                                                                                     ; DC[4:0] = 0
716                                                                                     ; WL[2:0] = ALC = 0 for 8-bit data words
717                                                                                     ; SSC1 = 0 for SC1 not used
718       P:0001BE P:0001BE 07F426            MOVEP             #$000030,X:CRB1         ; SCKD = 1 for internally generated clock
                            000030
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 14



719                                                                                     ; SCD2 = 1 so frame sync SC2 is an output
720                                                                                     ; SHFD = 0 for MSB shifted first
721                                                                                     ; CKP = 0 for rising clock edge transitions
722                                                                                     ; TE0 = 0 to NOT enable transmitter #0 yet
723                                                                                     ; MOD = 0 so its not networked mode
724       P:0001C0 P:0001C0 07F42F            MOVEP             #%100000,X:PCRD         ; Control Register (0 for GPIO, 1 for ESSI)
                            000020
725                                                                                     ; PD3 = SCK1, PD5 = STD1 for ESSI
726       P:0001C2 P:0001C2 07F42E            MOVEP             #%000100,X:PRRD         ; Data Direction Register (0 for In, 1 for O
ut)
                            000004
727       P:0001C4 P:0001C4 07F42D            MOVEP             #%000100,X:PDRD         ; Data Register: 'not used' = 0 outputs
                            000004
728       P:0001C6 P:0001C6 07F42C            MOVEP             #0,X:TX10               ; Initialize the transmitter to zero
                            000000
729       P:0001C8 P:0001C8 000000            NOP
730       P:0001C9 P:0001C9 000000            NOP
731       P:0001CA P:0001CA 012630            BSET    #TE,X:CRB1                        ; Enable the SSI transmitter
732    
733                                 ; Conversion from software bits to schematic labels for Port D
734                                 ; PD0 = SC10 = 2_XMT_? input
735                                 ; PD1 = SC11 = SSFEF* input
736                                 ; PD2 = SC12 = PWR_EN
737                                 ; PD3 = SCK1 = TIM-A-SCK
738                                 ; PD4 = SRD1 = PWRRST
739                                 ; PD5 = STD1 = TIM-A-STD
740    
741                                 ; Program the SCI port to communicate with the utility board
742       P:0001CB P:0001CB 07F41C            MOVEP             #$0B04,X:SCR            ; SCI programming: 11-bit asynchronous
                            000B04
743                                                                                     ;   protocol (1 start, 8 data, 1 even parity
,
744                                                                                     ;   1 stop); LSB before MSB; enable receiver
745                                                                                     ;   and its interrupts; transmitter interrup
ts
746                                                                                     ;   disabled.
747       P:0001CD P:0001CD 07F41B            MOVEP             #$0003,X:SCCR           ; SCI clock: utility board data rate =
                            000003
748                                                                                     ;   (390,625 kbits/sec); internal clock.
749       P:0001CF P:0001CF 07F41F            MOVEP             #%011,X:PCRE            ; Port Control Register = RXD, TXD enabled
                            000003
750       P:0001D1 P:0001D1 07F41E            MOVEP             #%000,X:PRRE            ; Port Direction Register (0 = Input)
                            000000
751    
752                                 ;       PE0 = RXD
753                                 ;       PE1 = TXD
754                                 ;       PE2 = SCLK
755    
756                                 ; Program one of the three timers as an exposure timer
757       P:0001D3 P:0001D3 07F403            MOVEP             #$C34F,X:TPLR           ; Prescaler to generate millisecond timer,
                            00C34F
758                                                                                     ;  counting from the system clock / 2 = 50 M
Hz
759       P:0001D5 P:0001D5 07F40F            MOVEP             #$208200,X:TCSR0        ; Clear timer complete bit and enable presca
ler
                            208200
760       P:0001D7 P:0001D7 07F40E            MOVEP             #0,X:TLR0               ; Timer load register
                            000000
761    
762                                 ; Enable interrupts for the SCI port only
763       P:0001D9 P:0001D9 08F4BF            MOVEP             #$000000,X:IPRC         ; No interrupts allowed
                            000000
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 15



764       P:0001DB P:0001DB 08F4BE            MOVEP             #>$80,X:IPRP            ; Enable SCI interrupt only, IPR = 1
                            000080
765       P:0001DD P:0001DD 00FCB8            ANDI    #$FC,MR                           ; Unmask all interrupt levels
766    
767                                 ; Initialize the fiber optic serial receiver circuitry
768       P:0001DE P:0001DE 061480            DO      #20,L_FO_INIT
                            0001E3
769       P:0001E0 P:0001E0 5FF000            MOVE                          Y:RDFO,B
                            FFFFF1
770       P:0001E2 P:0001E2 0605A0            REP     #5
771       P:0001E3 P:0001E3 000000            NOP
772                                 L_FO_INIT
773    
774                                 ; Pulse PRSFIFO* low to revive the CMDRST* instruction and reset the FIFO
775       P:0001E4 P:0001E4 44F400            MOVE              #1000000,X0             ; Delay by 10 milliseconds
                            0F4240
776       P:0001E6 P:0001E6 06C400            DO      X0,*+3
                            0001E8
777       P:0001E8 P:0001E8 000000            NOP
778       P:0001E9 P:0001E9 0A8908            BCLR    #8,X:HDR
779       P:0001EA P:0001EA 0614A0            REP     #20
780       P:0001EB P:0001EB 000000            NOP
781       P:0001EC P:0001EC 0A8928            BSET    #8,X:HDR
782    
783                                 ; Reset the utility board
784       P:0001ED P:0001ED 0A0F05            BCLR    #5,X:<LATCH
785       P:0001EE P:0001EE 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Clear reset utility board bit
                            00000F
786       P:0001F0 P:0001F0 06C8A0            REP     #200                              ; Delay by RESET* low time
787       P:0001F1 P:0001F1 000000            NOP
788       P:0001F2 P:0001F2 0A0F25            BSET    #5,X:<LATCH
789       P:0001F3 P:0001F3 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Clear reset utility board bit
                            00000F
790       P:0001F5 P:0001F5 56F400            MOVE              #200000,A               ; Delay 2 msec for utility boot
                            030D40
791       P:0001F7 P:0001F7 06CE00            DO      A,*+3
                            0001F9
792       P:0001F9 P:0001F9 000000            NOP
793    
794                                 ; Put all the analog switch inputs to low so they draw minimum current
795       P:0001FA P:0001FA 012F23            BSET    #3,X:PCRD                         ; Turn the serial clock on
796       P:0001FB P:0001FB 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                            0C3000
797       P:0001FD P:0001FD 20001B            CLR     B
798       P:0001FE P:0001FE 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC write
s
799       P:0001FF P:0001FF 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writ
es
                            001000
800       P:000201 P:000201 060F80            DO      #15,L_ANALOG                      ; Fifteen video processor boards maximum
                            000209
801       P:000203 P:000203 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
802       P:000204 P:000204 200040            ADD     X0,A
803       P:000205 P:000205 5F7000            MOVE                          B,Y:WRSS    ; This is for the fast analog switches
                            FFFFF3
804       P:000207 P:000207 0620A3            REP     #800                              ; Delay for the serial data transmission
805       P:000208 P:000208 000000            NOP
806       P:000209 P:000209 200068            ADD     X1,B                              ; Increment the video and clock driver numbe
rs
807                                 L_ANALOG
808       P:00020A P:00020A 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
809       P:00020B P:00020B 0C0223            JMP     <SKIP
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 16



810    
811                                 ; Transmit contents of accumulator A1 over the synchronous serial transmitter
812                                 XMIT_A_WORD
813       P:00020C P:00020C 07F42C            MOVEP             #0,X:TX10               ; This helps, don't know why
                            000000
814       P:00020E P:00020E 547000            MOVE              A1,X:SV_A1
                            00000E
815       P:000210 P:000210 000000            NOP
816       P:000211 P:000211 01A786            JCLR    #TDE,X:SSISR1,*                   ; Start bit
                            000211
817       P:000213 P:000213 07F42C            MOVEP             #$010000,X:TX10
                            010000
818       P:000215 P:000215 060380            DO      #3,L_X
                            00021B
819       P:000217 P:000217 01A786            JCLR    #TDE,X:SSISR1,*                   ; Three data bytes
                            000217
820       P:000219 P:000219 04CCCC            MOVEP             A1,X:TX10
821       P:00021A P:00021A 0C1E90            LSL     #8,A
822       P:00021B P:00021B 000000            NOP
823                                 L_X
824       P:00021C P:00021C 01A786            JCLR    #TDE,X:SSISR1,*                   ; Zeroes to bring transmitter low
                            00021C
825       P:00021E P:00021E 07F42C            MOVEP             #0,X:TX10
                            000000
826       P:000220 P:000220 54F000            MOVE              X:SV_A1,A1
                            00000E
827       P:000222 P:000222 00000C            RTS
828    
829                                 SKIP
830    
831                                 ; Set up the circular SCI buffer, 32 words in size
832       P:000223 P:000223 64F400            MOVE              #SCI_TABLE,R4
                            000400
833       P:000225 P:000225 051FA4            MOVE              #31,M4
834       P:000226 P:000226 647000            MOVE              R4,X:(SCI_TABLE+33)
                            000421
835    
836                                           IF      @SCP("HOST","ROM")
844                                           ENDIF
845    
846       P:000228 P:000228 44F400            MOVE              #>$AC,X0
                            0000AC
847       P:00022A P:00022A 440100            MOVE              X0,X:<FO_HDR
848    
849       P:00022B P:00022B 0C0181            JMP     <STARTUP
850    
851                                 ;  ****************  X: Memory tables  ********************
852    
853                                 ; Define the address in P: space where the table of constants begins
854    
855                                  X_BOOT_START
856       00022A                              EQU     @LCV(L)-2
857    
858                                           IF      @SCP("HOST","ROM")
860                                           ENDIF
861                                           IF      @SCP("HOST","HOST")
862       X:000000 X:000000                   ORG     X:0,X:0
863                                           ENDIF
864    
865                                 ; Special storage area - initialization constants and scratch space
866       X:000000 X:000000         STATUS    DC      $40004                            ; Controller status bits
867    
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 17



868       000001                    FO_HDR    EQU     STATUS+1                          ; Fiber optic write bytes
869       000005                    HEADER    EQU     FO_HDR+4                          ; Command header
870       000006                    NWORDS    EQU     HEADER+1                          ; Number of words in the command
871       000007                    COM_BUF   EQU     NWORDS+1                          ; Command buffer
872       00000E                    SV_A1     EQU     COM_BUF+7                         ; Save accumulator A1
873    
874                                           IF      @SCP("HOST","ROM")
879                                           ENDIF
880    
881                                           IF      @SCP("HOST","HOST")
882       X:00000F X:00000F                   ORG     X:$F,X:$F
883                                           ENDIF
884    
885                                 ; Parameter table in P: space to be copied into X: space during
886                                 ;   initialization, and is copied from ROM by the DSP boot
887       X:00000F X:00000F         LATCH     DC      $3A                               ; Starting value in latch chip U25
888                                  EXPOSURE_TIME
889       X:000010 X:000010                   DC      0                                 ; Exposure time in milliseconds
890                                  ELAPSED_TIME
891       X:000011 X:000011                   DC      0                                 ; Time elapsed so far in the exposure
892       X:000012 X:000012         ONE       DC      1                                 ; One
893       X:000013 X:000013         TWO       DC      2                                 ; Two
894       X:000014 X:000014         THREE     DC      3                                 ; Three
895       X:000015 X:000015         SEVEN     DC      7                                 ; Seven
896       X:000016 X:000016         MASK1     DC      $FCFCF8                           ; Mask for checking header
897       X:000017 X:000017         MASK2     DC      $030300                           ; Mask for checking header
898       X:000018 X:000018         DONE      DC      'DON'                             ; Standard reply
899       X:000019 X:000019         SBRD      DC      $020000                           ; Source Identification number
900       X:00001A X:00001A         TIM_DRB   DC      $000200                           ; Destination = timing board number
901       X:00001B X:00001B         DMASK     DC      $00FF00                           ; Mask to get destination board number
902       X:00001C X:00001C         SMASK     DC      $FF0000                           ; Mask to get source board number
903       X:00001D X:00001D         ERR       DC      'ERR'                             ; An error occurred
904       X:00001E X:00001E         C100K     DC      100000                            ; Delay for WRROM = 1 millisec
905       X:00001F X:00001F         IDL_ADR   DC      TST_RCV                           ; Address of idling routine
906       X:000020 X:000020         EXP_ADR   DC      0                                 ; Jump to this address during exposures
907    
908                                 ; Places for saving register values
909       X:000021 X:000021         SAVE_SR   DC      0                                 ; Status Register
910       X:000022 X:000022         SAVE_X1   DC      0
911       X:000023 X:000023         SAVE_A1   DC      0
912       X:000024 X:000024         SAVE_R0   DC      0
913       X:000025 X:000025         RCV_ERR   DC      0
914       X:000026 X:000026         SCI_A1    DC      0                                 ; Contents of accumulator A1 in RCV ISR
915       X:000027 X:000027         SCI_R0    DC      SRXL
916    
917                                 ; Command table
918       000028                    COM_TBL_R EQU     @LCV(R)
919       X:000028 X:000028         COM_TBL   DC      'TDL',TDL                         ; Test Data Link
920       X:00002A X:00002A                   DC      'RDM',RDMEM                       ; Read from DSP or EEPROM memory
921       X:00002C X:00002C                   DC      'WRM',WRMEM                       ; Write to DSP memory
922       X:00002E X:00002E                   DC      'LDA',LDAPPL                      ; Load application from EEPROM to DSP
923       X:000030 X:000030                   DC      'STP',STOP_IDLE_CLOCKING
924       X:000032 X:000032                   DC      'DON',START                       ; Nothing special
925       X:000034 X:000034                   DC      'ERR',START                       ; Nothing special
926    
927                                  END_COMMAND_TABLE
928       000036                              EQU     @LCV(R)
929    
930                                 ; The table at SCI_TABLE is for words received from the utility board, written by
931                                 ;   the interrupt service routine SCI_RCV. Note that it is 32 words long,
932                                 ;   hard coded, and the 33rd location contains the pointer to words that have
933                                 ;   been processed by moving them from the SCI_TABLE to the COM_BUF.
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timboot.s  Page 18



934    
935                                           IF      @SCP("HOST","ROM")
937                                           ENDIF
938    
939       000036                    END_ADR   EQU     @LCV(L)                           ; End address of P: code written to ROM
940                                           INCLUDE "timhdr.s"
941                                        COMMENT *
942    
943                                 This is a header file that has some HIPO-specific stuff in it.  It is
944                                 vastly stripped down compared to the original since most of the things in it
945                                 are now in timboot.asm.
946    
947                                 I believe that all the following stuff can be zapped out.  Comment out for now.
948    
949                                         PAGE    132     ; Printronix page width - 132 columns
950    
951                                 ; Some basic structural definitions
952                                 APL_ADR EQU     $130    ; P: memory location where application code begins
953                                 APL_LEN EQU     $200-APL_ADR ; Maximum length of application program
954    
955                                 ; CHANGING MISC_LEN FROM 0X280 TO A LARGER NUMBER BREAKS THE ROM COPY APPROACH!
956                                 ; However if all you do is download there is a lot more memory available.
957                                 MISC_LEN EQU    $450    ; Maximum length of "miscellanous" code
958                                 ;MISC_LEN EQU   $3F0    ; Maximum length of "miscellanous" code
959                                 ; MISC_LEN EQU  $280    ; Maximum length of "miscellanous" code
960    
961                                 COM_LEN EQU     $40     ; Length of memory for application commands
962                                 TIM_ISR EQU     $3C     ; DSP timer interrupt service routine address
963                                 PGM_CON EQU     $3E     ; Program continues on here
964                                 COM_TBL EQU     $80     ; Starting address of command table in X: memory
965                                 N_W_APL EQU     $500    ; Number of words in each application
966                                 NUM_COM EQU     40      ; Number of entries in command table
967    
968                                 RST_ISR EQU     $00     ; Hardware reset interrupt
969                                 ROM_ID  EQU     $06     ; Location of program Identification = SWI interrupt
970                                 START   EQU     $08     ; Starting address of program
971                                 RCV_BUF EQU     $60     ; Starting address of receiver buffer in X:
972                                 TBL_ADR EQU     $0F     ; (IR) Waveform tables starting address
973    
974                                 ROM_OFF EQU     $4000   ; Boot program offset address in EEPROM
975                                 LD_X    EQU     $4200   ; Assembler loads X: starting at this EEPROM address
976                                 RD_X    EQU     $C600   ; DSP reads X: from this EEPROM address
977    
978                                 ; Define DSP port addresses
979                                 WRSS    EQU     $FF80   ; Write clock driver and VP switch states
980                                 RDFO    EQU     $FFC0   ; Read serial receiver fiber optic contents
981                                 WRFO    EQU     $FFC0   ; Write to fiber optic serial transmitter
982                                 RDAD    EQU     $FFA0   ; Read A/D datum into DSP
983                                 RDAD0   EQU     $FFA0   ; Address for reading A/D #0
984                                 RDAD1   EQU     $FFA1   ; Address for reading A/D #1
985                                 WRLATCH EQU     $FFC1   ; Write to timing board latch
986                                 RSTWDT  EQU     $6000   ; Address to reset the timing board watchdog timer
987                                 BCR     EQU     $FFFE   ; Bus (=Port A) Control Register -> Wait States
988                                 PBC     EQU     $FFE0   ; Port B Control Register
989                                 PBDDR   EQU     $FFE2   ; Port B Data Direction Register
990                                 PBD     EQU     $FFE4   ; Port B Data Register
991                                 PCC     EQU     $FFE1   ; Port C Control Register
992                                 PCDDR   EQU     $FFE3   ; PortC Data Direction Register
993                                 PCD     EQU     $FFE5   ; Port C Data Register
994                                 IPR     EQU     $FFFF   ; Interrupt Priority Register
995                                 SSITX   EQU     $FFEF   ; SSI Transmit and Receive data register
996                                 SSIRX   EQU     $FFEF   ; SSI Transmit and Receive data register
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timhdr.s  Page 19



997                                 SSISR   EQU     $FFEE   ; SSI Status Register
998                                 CRA     EQU     $FFEC   ; SSI Control Register A
999                                 CRB     EQU     $FFED   ; SSI Control Regsiter B
1000                                TCSR    EQU     $FFDE   ; Timer control and status register
1001                                TCR     EQU     $FFDF   ; Timer count register
1002   
1003                                ; Hardware bit definitions all over the place
1004                                SSI_TDE EQU     6       ; SSI Transmitter data register empty
1005                                SSI_RDF EQU     7       ; SSI Receiver data register full
1006                                LVEN    EQU     2       ; Low voltage enable (+/-15 volt nominal)
1007                                HVEN    EQU     3       ; Enable high voltage (+32V nominal)
1008                                TIM_U_RST EQU   5       ; Timing to utility board reset bit number in U25
1009                                PWRST   EQU     13      ; Power control board reset
1010                                RST_FIFO EQU    7       ; Reset FIFO bit number in control latch U25
1011                                EF      EQU     9       ; FIFO empty flag, low true
1012                                TIM_BIT EQU     0       ; Timer status bit
1013                                WW      EQU     1       ; Word width = 1 for 16-bit image data, 0 for 24-bit
1014                                CDAC    EQU     0       ; Bit number in U25 for clearing DACs
1015                                ENCK    EQU     2       ; Bit number in U25 for enabling analog switches
1016                                DUALCLK EQU     1       ; Set to clock two halves of clock driver board together
1017   
1018                                ; Software status bits, defined at X:<STATUS = X:0
1019                                ST_RCV  EQU     0       ; Set if FO, cleared if SSI
1020                                TST_IMG EQU     10      ; Set if controller is to generate a test image
1021                                SHUT    EQU     11      ; Set if opening shutter at beginning of exposure
1022   
1023                                IDLMODE EQU     2       ; Set if need to idle after readout
1024                                ST_SHUT EQU     3       ; Set to indicate shutter is closed, clear for open
1025                                ST_RDC  EQU     4       ; Set if executing 'RDC' command - reading out
1026                                SPLIT_S EQU     5       ; Set if split serial
1027                                SPLIT_P EQU     6       ; Set if split parallel
1028                                MPP     EQU     7       ; Set if parallels are in MPP mode
1029   
1030                                END OF COMMENT HERE
1031                                        *
1032                                ; additional X:<STATUS bits
1033                                ; NOTE
1034                                ; NOTE
1035                                ; the NOT_CLR, and MPP X:<STATUS bits are pre-empted.
1036      000008                    ST_ABRT   EQU     8                                 ; Set if an abort (readout or exp) in progre
ss
1037      000007                    ST_EXP    EQU     7                                 ; Set if presently in EXPOSE or waiting for 
trigger
1038   
1039   
1040                                ; move IMGVAR down to $80 as per Confluence July 1 #1
1041                                ;IMGVAR_ADR EQU $100            ;  Special Image Mode variables Starting Address in X:
1042      000080                    IMGVAR_ADR EQU    $80                               ;  Special Image Mode variables Starting Add
ress in X:
1043   
1044                                ; Additional software status bit, defined at X:<STATUS = X:0
1045      000008                    TRIGGER   EQU     8                                 ; Set if a Hardware triggered exposure
1046   
1047                                ; add these HDR (port B) bits for thermo cool statuses
1048      000004                    STS0      EQU     4                                 ; STATUS 0, thermocool
1049      000005                    STS1      EQU     5                                 ; STATUS 1, thermocool
1050   
1051                                ; Image mode bits, defined at X:<IMAGE_MODE
1052   
1053      000000                    FDOTS     EQU     0                                 ; Fast Dots
1054      000001                    FIND      EQU     1                                 ; Find
1055      000002                    SDOTS     EQU     2                                 ; Slow Dots
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timhdr.s  Page 20



1056      000003                    SERIES    EQU     3                                 ; Series
1057      000004                    SINGLE    EQU     4                                 ; Single
1058      000005                    STRIP     EQU     5                                 ; Stripscan
1059      000006                    F_OCC     EQU     6                                 ; Fast occultation, keep as 6 for compatibil
ity
1060      000007                    B_OCC     EQU     7                                 ; Basic occultation
1061      000008                    P_OCC     EQU     8                                 ; Pipelined occultation
1062   
1063                                ; Image Status, define at X:<ISTATUS
1064      000000                    NO_SKIP   EQU     0                                 ; Set for slow dots, fast and pipelined occu
ltation mode
1065                                                                                    ; to avoid parallel skipping to the subframe
 boundary.
1066      000001                    OPEN_CLOSE EQU    1                                 ; Set if shutter opens/closes each image
1067                                                                                    ; Clear if shutter stays open for many image
s
1068      000002                    STORAGE   EQU     2                                 ; Set if storage area is to be clocked
1069                                          INCLUDE "infospec.s"
1070                                ; General DSP info field specifications.
1071                                ; These values are 'addresses' and used as the argument for the INF command.
1072   
1073                                 GET_VERSION
1074      000000                              EQU     0                                 ; IVERSION field
1075      000001                    GET_FLAVOR EQU    1                                 ; IFLAVOR field
1076      000002                    GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
1077      000003                    GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
1078      000004                    GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if availabl
e)
1079                                 GET_TEMP2STS
1080      000005                              EQU     5                                 ; two bits of thermo cool status for GWAVES
1081   
1082                                          INCLUDE "timinfospec.s"
1083                                ; TIM DSP info field specifications.
1084                                ; These values are 'addresses' and used as the argument for the INF command.
1085   
1086                                 GET_CAPABLE
1087      000100                              EQU     $100                              ; ICAPABLE field (what dsp supports).
1088                                 GET_INT_TIM
1089      000101                              EQU     $101                              ; Integration time per pixel in leach units
1090                                 GET_R_DELAY
1091      000102                              EQU     $102                              ; Serial overlap in leach units
1092                                 GET_SI_DELAY
1093      000103                              EQU     $103                              ; Parallel overlap in leach units
1094   
1095                                          INCLUDE "timinfo.s"
1096                                ; DSP Version
1097      04507F                    IVERSION  EQU     282751                            ; 1.5/1
1098   
1099      612020                    IFLAVOR   EQU     'a  '                             ; a
1100   
1101      0010E9                    ITIME0    EQU     4329                              ; lo order time: 2012 8 15  3:0:57 GMT
1102   
1103      00502B                    ITIME1    EQU     20523                             ; hi order time: 2012 8 15  3:0:57 GMT
1104   
1105      000000                    ISVNREV   EQU     0                                 ; most recent code svn rev
1106   
1107                                ; this need to be defined externally due to a problem in timboot.s
1108                                ; as per Confluence, July 6, #1
1109      00005A                    EXPOSING  EQU     TST_RCV                           ; Address if exposing
1110                                 CONTINUE_READING
1111      00005A                              EQU     TST_RCV                           ; Address if reading out
1112   
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  tim.s  Page 21



1113                                ; tim capability definitions
1114                                 FINDCAPABLE
1115      000001                              EQU     1                                 ; Find exposure mode
1116                                 SNGLCAPABLE
1117      000002                              EQU     2                                 ; Single exposure mode
1118                                 SERICAPABLE
1119      000004                              EQU     4                                 ; Series exposure mode
1120                                 BASCCAPABLE
1121      000008                              EQU     8                                 ; Basic occ exposure mode
1122                                 FASTCAPABLE
1123      000010                              EQU     16                                ; Fast occ exposure mode
1124                                 PIPECAPABLE
1125      000020                              EQU     32                                ; Pipeline occ exposure mode
1126                                 FDOTCAPABLE
1127      000040                              EQU     64                                ; Fast dots exposure mode
1128                                 SDOTCAPABLE
1129      000080                              EQU     128                               ; Slow dots exposure mode
1130                                 STRPCAPABLE
1131      000100                              EQU     256                               ; Slow dots exposure mode
1132      0001CB                    TIMCAPABLE EQU    FINDCAPABLE+SNGLCAPABLE+STRPCAPABLE+BASCCAPABLE+FDOTCAPABLE+SDOTCAPABLE
1133   
1134      P:00022C P:00022C                   ORG     P:,P:
1135   
1136                                ; Remove SHUTTER_CC advertisement as per Confluence July 4 #3
1137                                ;CC     EQU     ARC22+ARC47+SHUTTER_CC+SPLIT_SERIAL+SUBARRAY+BINNING
1138      003C97                    CC        EQU     ARC22+ARC47+SPLIT_SERIAL+SPLIT_PARALLEL+SUBARRAY+BINNING+SHUTTER_CC
1139   
1140                                ; Put number of words of application in P: for loading application from EEPROM
1141      P:00022C P:00022C                   DC      TIMBOOT_X_MEMORY-@LCV(L)-1
1142   
1143                                ;**************************************************************************
1144                                ;                                                                         *
1145                                ;    Permanent address register assignments                               *
1146                                ;        R1 - Address of SSI receiver contents                            *
1147                                ;        R2 - Address of SCI receiver contents                            *
1148                                ;        R3 - Pointer to current top of command buffer                    *
1149                                ;        R4 - Pointer to processed contents of command buffer             *
1150                                ;        R5 - Temporary register for processing SSI and SCI contents      *
1151                                ;        R6 - CCD clock driver address for CCD #0 = $FF80                 *
1152                                ;                It is also the A/D address of analog board #0            *
1153                                ;        R6 CURRENTLY UNUSED (geniii)
1154                                ;                                                                         *
1155                                ;    Other registers                                                      *
1156                                ;        R0, R7 - Temporary registers used all over the place.            *
1157                                ;        R5 - Can be used as a temporary register but is circular,        *
1158                                ;               modulo 32.                                                *
1159                                ;**************************************************************************
1160   
1161                                ;  ***********************   CCD  READOUT   ***********************
1162                                ; RDCCD is now a subroutine
1163                                ; Adding several CLOCK_WAITs as per Jun 29 #8.
1164   
1165                                RDCCD
1166      P:00022D P:00022D 0A20A2            JSET    #STORAGE,X:ISTATUS,RCCD1
                            000233
1167                                ; Do the frame transfer if STORAGE==0, else skip it.
1168      P:00022F P:00022F 4DB900            MOVE                          Y:<S_SIZE,X1
1169      P:000230 P:000230 0D077A            JSR     <CLOCK_WAIT
1170                                ; mitigation attempt 2- remove ishift
1171      P:000231 P:000231 0BF080            JSR     ISHIFT                            ; Do the frame transfer
                            00076C
1172                                ;       JSR     <CLOCK_WAIT  ; mitigation attempt 1
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  tim.s  Page 22



1173   
1174                                ; Calculate some readout parameters.
1175                                ; This is also an alternative entry point for skipping the frame transfer
1176                                ; STORAGE also selects ganged or storage only parallels during readout
1177                                ; NO_SKIP skips over the section that parallel skips to the subframe start
1178   
1179      P:000233 P:000233 5E9A00  RCCD1     MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1180      P:000234 P:000234 200003            TST     A
1181      P:000235 P:000235 0E2240            JNE     <SUB_IMG
1182      P:000236 P:000236 5C1700            MOVE                          A1,Y:<NP_SKIP ; Zero these all out.  Full frame
1183      P:000237 P:000237 5C1800            MOVE                          A1,Y:<NS_SKP1
1184      P:000238 P:000238 5C1900            MOVE                          A1,Y:<NS_SKP2
1185      P:000239 P:000239 5E8100            MOVE                          Y:<NSR,A    ; NSERIALS_READ = NSR
1186      P:00023A P:00023A 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            00023D
1187      P:00023C P:00023C 200022            ASR     A                                 ; Split serials require / 2
1188      P:00023D P:00023D 000000            NOP
1189      P:00023E P:00023E 5E1100            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1190      P:00023F P:00023F 0C0250            JMP     <SETUP
1191   
1192                                ; Loop over the required number of subimage boxes if NBOXES > 0
1193      P:000240 P:000240 67F400  SUB_IMG   MOVE              #READ_TABLE,R7          ; Parameter table for subimage readout
                            00001E
1194      P:000242 P:000242 061A40            DO      Y:<NBOXES,L_NBOXES                ; Loop over number of boxes
                            0002D9
1195      P:000244 P:000244 4CDF00            MOVE                          Y:(R7)+,X0
1196      P:000245 P:000245 4C1700            MOVE                          X0,Y:<NP_SKIP
1197      P:000246 P:000246 4CDF00            MOVE                          Y:(R7)+,X0
1198      P:000247 P:000247 4C1800            MOVE                          X0,Y:<NS_SKP1
1199      P:000248 P:000248 4CDF00            MOVE                          Y:(R7)+,X0
1200      P:000249 P:000249 4C1900            MOVE                          X0,Y:<NS_SKP2
1201      P:00024A P:00024A 5E9C00            MOVE                          Y:<NS_READ,A
1202      P:00024B P:00024B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                            00024E
1203      P:00024D P:00024D 200022            ASR     A
1204      P:00024E P:00024E 000000            NOP
1205      P:00024F P:00024F 5E1100            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1206   
1207                                ; Calculate the fast readout parameters
1208      P:000250 P:000250 0D0683  SETUP     JSR     <SETUP_SUBROUTINE
1209      P:000251 P:000251 0D077A            JSR     <CLOCK_WAIT
1210   
1211                                ; Skip over the required number of rows for subimage readout
1212                                ; If #NO_SKIP == 0 skip rows up to first subframe, storage clocks only
1213      P:000252 P:000252 0A20A0            JSET    #NO_SKIP,X:ISTATUS,CLR_SR
                            00025F
1214      P:000254 P:000254 5E9700            MOVE                          Y:<NP_SKIP,A ; Number of rows NP_SKIP to skip
1215      P:000255 P:000255 200003            TST     A
1216      P:000256 P:000256 0EA25F            JEQ     <CLR_SR                           ; If zero, skip this shift
1217      P:000257 P:000257 061740            DO      Y:<NP_SKIP,L_SKIP1                ; Clock number of rows to skip
                            00025E
1218      P:000259 P:000259 688F00            MOVE                          Y:<IS_PAR_CLR,R0 ; SR kept clear with DG
1219      P:00025A P:00025A 0A20A2            JSET    #STORAGE,X:ISTATUS,GANG_SK        ; if STORAGE == 0 store clocks only
                            00025D
1220                                ;        mitigation attempt 3- don't use S_PAR_CLR (but it was a full fr test)
1221      P:00025C P:00025C 689000            MOVE                          Y:<S_PAR_CLR,R0 ; SR kept clear with DG
1222                                GANG_SK
1223      P:00025D P:00025D 0D02E0            JSR     <CLOCK
1224      P:00025E P:00025E 000000            NOP
1225                                L_SKIP1
1226   
1227                                ; Clear out the accumulated charge from the serial shift register
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  tim.s  Page 23



1228                                ; Leave this commented-out code in until we can test it with a subframe
1229                                ; CLR_SR MOVE   #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1230                                ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1231                                ;       NOP
1232                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1233                                ;       DO      Y:<NSCLR,*+3            ; Number of waveform entries total
1234                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1235                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1236   
1237      P:00025F P:00025F 60F400  CLR_SR    MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel skip
                            0001E2
1238      P:000261 P:000261 0D02E0            JSR     <CLOCK
1239   
1240                                ; Parallel shift the image into the serial shift register
1241      P:000262 P:000262 4C8200            MOVE                          Y:<NPR,X0   ; Number of rows set by host computer
1242      P:000263 P:000263 5E9A00            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1243      P:000264 P:000264 200003            TST     A
1244      P:000265 P:000265 0EA267            JEQ     *+2
1245      P:000266 P:000266 4C9D00            MOVE                          Y:<NP_READ,X0 ; If NBOXES .NE. 0 use subimage table
1246   
1247                                ; Main loop over each line to be read out
1248                                ; If split parallels have to divide NPR by two to be loop counter
1249                                ; Subimages implicitly assumes that parallels are not split
1250      P:000267 P:000267 0A0086            JCLR    #SPLIT_P,X:STATUS,PLOOP           ; skip this if not split parallels
                            00026E
1251      P:000269 P:000269 5EF000            MOVE                          Y:NPR,A     ; Get NPR
                            000002
1252      P:00026B P:00026B 200022            ASR     A                                 ; Divide by 2
1253      P:00026C P:00026C 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1254      P:00026D P:00026D 21C400            MOVE              A,X0                    ; Overwrite loop counter in X0
1255   
1256                                ; Finally start the row loop
1257      P:00026E P:00026E 06C400  PLOOP     DO      X0,LPR                            ; Number of rows to read out
                            0002D8
1258   
1259                                ; Check for a command once per line. Only the ABORT command is allowed
1260                                ; NOT DONE- check for ABEXP in expose only
1261                                ;       JSR     <GET_RCV                ; Was a command received?
1262                                ;       JCC     <CONTINUE_RD            ; If no, continue reading out
1263                                ; as per Confluence July 5 #7
1264                                ;       JMP     <PRC_RCV                ; If yes, go process it
1265      P:000270 P:000270 0C0278            JMP     <CONTINUE_RD
1266   
1267                                ; Abort the readout currently underway (cmd destination)
1268                                ABR_RDC
1269      P:000271 P:000271 200013            CLR     A
1270      P:000272 P:000272 5EBD00            MOVE                          Y:<TESTLOC1,A
1271      P:000273 P:000273 014180            ADD     #1,A
1272      P:000274 P:000274 0A0028            BSET    #ST_ABRT,X:<STATUS
1273      P:000275 P:000275 5C3D00            MOVE                          A1,Y:<TESTLOC1
1274   
1275      P:000276 P:000276 0A0084            JCLR    #ST_RDC,X:<STATUS,ABORT_EXPOSURE
                            0007B7
1276                                ; "Can't happen"
1277                                ; already in readout- so just fall thru and continue,
1278                                ; having set the ST_ABRT flag.
1279                                ; currently we just let this readout segment run to the end and
1280                                ; handle the abort in the outer xxx_PROC code- this has
1281                                ; the advantage of ending the overall exposure on a frame boundary
1282                                ; in the case of 3-d images.
1283                                ; A more abrupt ending of the RDCCD code could be arranged if needed.
1284   
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  tim.s  Page 24



1285                                ;       ENDDO                           ; Properly terminate row loop
1286                                ;       MOVE    Y:<NBOXES,A             ; NBOXES = 0 => full image readout
1287                                ;       TST     A
1288                                ;       JEQ     *+2
1289                                ;       ENDDO                           ; Properly terminate box loop
1290                                ;       NOP
1291                                ;       CLR     A
1292                                ;       INC     A
1293                                ;       NOP
1294                                ;       MOVE    A0,Y:<IFLPCNT
1295                                ;       RTS                             ; Return early from subroutine
1296   
1297                                ; Move the row into the serial register.
1298                                 CONTINUE_RD
1299      P:000278 P:000278 060640            DO      Y:<NPBIN,LPR_I                    ; Transfer # of rows, with binning
                            00027F
1300      P:00027A P:00027A 688D00            MOVE                          Y:<IS_PAR_CLK,R0
1301      P:00027B P:00027B 0A20A2            JSET    #STORAGE,X:ISTATUS,GANGED         ; if STORAGE == 1 ganged parallels
                            00027E
1302                                ;       mitigation attempt 4- don't use S_PAR_CLK- seemed to work
1303      P:00027D P:00027D 688E00            MOVE                          Y:<S_PAR_CLK,R0 ; if STORAGE == 0 store clocks only
1304      P:00027E P:00027E 0D02E0  GANGED    JSR     <CLOCK                            ; Parallel clocking
1305      P:00027F P:00027F 000000            NOP
1306                                LPR_I
1307   
1308                                ; Skip over NS_SKP1 columns for subimage readout
1309                                ;       MOVE    Y:<NS_SKP1,A            ; Number of columns to skip
1310      P:000280 P:000280 5E9300            MOVE                          Y:<NSKIP1,A ; Number of waveforms for skip
1311      P:000281 P:000281 200003            TST     A
1312      P:000282 P:000282 0EA287            JEQ     <L_READ
1313                                ;       MOVE    #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1314      P:000283 P:000283 0506A1            MOVE              #<(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-1),M1 ; Modularity
1315   
1316                                ;       Fix for new interface CLOCKCT
1317                                ;       June 30 bottom "questions and comments" #2,3
1318      P:000284 P:000284 698900            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1319      P:000285 P:000285 218400            MOVE              A1,X0                   ; how many
1320      P:000286 P:000286 0D02E6            JSR     <CLOCKCT
1321                                ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1322                                ;       NOP
1323                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1324                                ;       DO      Y:<NSKIP1,LS_SKIP1      ; Number of waveform entries total
1325                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1326                                ;LS_SKIP1
1327                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1328   
1329                                ; Finally read some real pixels - this is the serial binning routine
1330      P:000287 P:000287 200013  L_READ    CLR     A
1331      P:000288 P:000288 20001B            CLR     B
1332      P:000289 P:000289 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1333      P:00028A P:00028A 50F400            MOVE              #>5,A0                  ; If binning > 4, do general binning
                            000005
1334      P:00028C P:00028C 200005            CMP     B,A                               ; else do special waveforms via NO_BIN
1335      P:00028D P:00028D 0E729F            JGT     <NO_BIN                           ; Skip over general serial binning software
1336      P:00028E P:00028E 00000B            DEC     B                                 ; serial binning factor minus 1
1337      P:00028F P:00028F 000000            NOP                                       ; 56300 pipeline as per July 5 #4
1338      P:000290 P:000290 212700            MOVE              B0,Y1
1339      P:000291 P:000291 061140            DO      Y:<NSERIALS_READ,LSR_BIN          ; Number of pixels to read out
                            00029D
1340      P:000293 P:000293 688C00            MOVE                          Y:<INITIAL_CLOCK,R0 ; (already /2 if split serials)
1341      P:000294 P:000294 0D02E0            JSR     <CLOCK
1342                                ;       DO      Y:<NSBIN,LSR_I          ; Bin serially NSBIN times
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  tim.s  Page 25



1343      P:000295 P:000295 06C700            DO      Y1,LSR_I                          ; Bin serially NSBIN times
                            000299
1344      P:000297 P:000297 688B00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1345      P:000298 P:000298 0D02E0            JSR     <CLOCK                            ;   shift register
1346      P:000299 P:000299 000000            NOP
1347                                LSR_I
1348      P:00029A P:00029A 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                            000078
1349      P:00029C P:00029C 0D02E0            JSR     <CLOCK
1350                                ;       MOVE    Y1,Y:<INTERVAL          ; HACK.  Use for debugging
1351      P:00029D P:00029D 000000            NOP
1352                                LSR_BIN
1353      P:00029E P:00029E 0C02A5            JMP     <OVER_RD                          ; All done binning
1354   
1355                                ; This is the routine for serial binning from 1 to 4 using hardwired waveforms
1356      P:00029F P:00029F 588A00  NO_BIN    MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1357      P:0002A0 P:0002A0 00000A            DEC     A                                 ; waveform - 1 into M1
1358      P:0002A1 P:0002A1 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1359      P:0002A2 P:0002A2 04C8A1            MOVE              A0,M1                   ; Modularity
1360                                ;       Fix for new interface CLOCKCT
1361                                ;       June 30 bottom "questions and comments" #2,3
1362      P:0002A3 P:0002A3 4C9400            MOVE                          Y:<NREAD,X0 ; how many
1363      P:0002A4 P:0002A4 0D02E6            JSR     <CLOCKCT
1364                                ;       NOP
1365                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1366                                ;       DO      Y:<NREAD,LSR            ; Number of waveform entries total
1367                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1368                                ;LSR
1369                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1370   
1371                                ; If NR_BIAS=0 clobber SR with DG and skip to end of row loop
1372      P:0002A5 P:0002A5 5E9B00  OVER_RD   MOVE                          Y:<NR_BIAS,A ; Is NR_BIAS zero?
1373      P:0002A6 P:0002A6 200003            TST     A
1374      P:0002A7 P:0002A7 0E22AD            JNE     <OVR_RD1                          ; no, go to the NS_SKP2 section
1375      P:0002A8 P:0002A8 60F400            MOVE              #DUMP_SERIAL,R0         ; yes, clobber SR with DG
                            0001E2
1376      P:0002AA P:0002AA 0D02E0            JSR     <CLOCK
1377      P:0002AB P:0002AB 0AF080            JMP     END_ROW                           ; and go to the end of the row loop
                            0002D8
1378                                ; Skip over NS_SKP2 columns for subimage readout to get to overscan region
1379      P:0002AD P:0002AD 5E9900  OVR_RD1   MOVE                          Y:<NS_SKP2,A ; Number of columns to skip
1380      P:0002AE P:0002AE 200003            TST     A
1381      P:0002AF P:0002AF 0EA2B4            JEQ     <L_BIAS
1382                                ;       MOVE    #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1383      P:0002B0 P:0002B0 0506A1            MOVE              #<(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-1),M1 ; Modularity
1384      P:0002B1 P:0002B1 698900            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1385                                ;       Fix for new interface CLOCKCT
1386                                ;       June 30 bottom "questions and comments" #2,3
1387      P:0002B2 P:0002B2 4C9500            MOVE                          Y:<NSKIP2,X0 ; how many
1388      P:0002B3 P:0002B3 0D02E6            JSR     <CLOCKCT
1389                                ;       NOP
1390                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1391                                ;       DO      Y:<NSKIP2,LS_SKIP2      ; Number of waveform entries total
1392                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1393                                ;LS_SKIP2
1394                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1395   
1396                                ; And read the bias pixels if in subimage readout mode
1397                                ; I think this means that if NBOXES==0 you have to have NSR include bias px.
1398      P:0002B4 P:0002B4 5E9A00  L_BIAS    MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1399      P:0002B5 P:0002B5 200003            TST     A
1400      P:0002B6 P:0002B6 0EA2D8            JEQ     <END_ROW
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  tim.s  Page 26



1401   
1402                                ; Finally read some real bias pixels
1403      P:0002B7 P:0002B7 200013            CLR     A
1404      P:0002B8 P:0002B8 20001B            CLR     B
1405      P:0002B9 P:0002B9 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1406      P:0002BA P:0002BA 50F400            MOVE              #>5,A0                  ; If binning > 4, do general binning
                            000005
1407      P:0002BC P:0002BC 200005            CMP     B,A                               ; else do special waveforms via NO_BIN_BIAS
1408      P:0002BD P:0002BD 0E72D2            JGT     <NO_BIN_BIAS                      ; Skip over general serial binning software
1409      P:0002BE P:0002BE 00000B            DEC     B                                 ; serial binning factor minus 1
1410      P:0002BF P:0002BF 5E9B00            MOVE                          Y:<NR_BIAS,A
1411      P:0002C0 P:0002C0 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            0002C3
1412      P:0002C2 P:0002C2 200022            ASR     A                                 ; Split serials require / 2
1413      P:0002C3 P:0002C3 212700            MOVE              B0,Y1
1414      P:0002C4 P:0002C4 06CE00            DO      A,LBIAS_BIN                       ; Number of pixels to read out
                            0002D0
1415      P:0002C6 P:0002C6 688C00            MOVE                          Y:<INITIAL_CLOCK,R0
1416      P:0002C7 P:0002C7 0D02E0            JSR     <CLOCK
1417      P:0002C8 P:0002C8 06C700            DO      Y1,LBIAS_I                        ; Bin serially NSBIN times
                            0002CC
1418                                ;       DO      Y:<NSBIN,LBIAS_I        ; Bin serially NSBIN times
1419      P:0002CA P:0002CA 688B00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1420      P:0002CB P:0002CB 0D02E0            JSR     <CLOCK                            ;   shift register
1421      P:0002CC P:0002CC 000000            NOP
1422                                LBIAS_I
1423      P:0002CD P:0002CD 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                            000078
1424      P:0002CF P:0002CF 0D02E0            JSR     <CLOCK
1425      P:0002D0 P:0002D0 000000            NOP
1426                                LBIAS_BIN
1427      P:0002D1 P:0002D1 0C02D8            JMP     <END_ROW                          ; All done binning
1428   
1429                                ; This is the routine for serial binning from 1 to 4 using hardwired waveforms
1430                                ; NBIAS is already divided by 2 in SETUP_SUBROUTINE if split serials.
1431                                NO_BIN_BIAS
1432      P:0002D2 P:0002D2 588A00            MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1433      P:0002D3 P:0002D3 00000A            DEC     A                                 ; waveform - 1 into M1
1434      P:0002D4 P:0002D4 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1435      P:0002D5 P:0002D5 04C8A1            MOVE              A0,M1                   ; Modularity
1436                                ;       Fix for new interface CLOCKCT
1437                                ;       June 30 bottom "questions and comments" #2,3
1438      P:0002D6 P:0002D6 4C9600            MOVE                          Y:<NBIAS,X0 ; how many
1439      P:0002D7 P:0002D7 0D02E6            JSR     <CLOCKCT
1440                                ;       NOP
1441                                ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1442                                ;       DO      Y:<NBIAS,*+3            ; Number of waveform entries total
1443                                ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1444                                ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1445      P:0002D8 P:0002D8 000000  END_ROW   NOP
1446      P:0002D9 P:0002D9 000000  LPR       NOP                                       ; End of parallel loop
1447      P:0002DA P:0002DA 000000  L_NBOXES  NOP                                       ; End of subimage boxes loop
1448      P:0002DB P:0002DB 000000            NOP
1449      P:0002DC P:0002DC 307600            MOVE              #<DCRST_LAST,R0         ; get DC Restore going
1450      P:0002DD P:0002DD 0D02E0            JSR     <CLOCK
1451      P:0002DE P:0002DE 0D077A            JSR     <CLOCK_WAIT
1452      P:0002DF P:0002DF 00000C            RTS
1453   
1454                                ; ***************** END OF CCD READOUT SUBROUTINE  ************
1455   
1456                                ; Core subroutine for clocking out CCD charge
1457                                ; Must keep in tim.s to insure that it is in fast P memory
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  tim.s  Page 27



1458                                ; Modified for FIFO magement and new processor as per
1459                                ; June 30 bottom "questions and comments" #2,3
1460   
1461                                ; CLOCK assumes waveform in R0, which begins with a count field
1462                                ; NOTE: in geniii, this count is 1 larger than genii because it
1463                                ; is a straight count of the # of points in the wave- gen-ii
1464                                ; needed a count 1 smaller since there was a pipeline that was
1465                                ; primed with a starter pixel.
1466                                CLOCK
1467      P:0002E0 P:0002E0 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002E0
1468      P:0002E2 P:0002E2 065860            REP     Y:(R0)+
1469      P:0002E3 P:0002E3 09D8F3            MOVEP             Y:(R0)+,Y:WRSS          ; next piece of the waveform
1470      P:0002E4 P:0002E4 000000            NOP                                       ; just in case
1471      P:0002E5 P:0002E5 00000C            RTS
1472   
1473                                ; CLOCKCT assumes waveform in R1, without a count field, and the
1474                                ; count in X0, and modulus counter in M1.
1475                                ; In order to manage the FIFO (SSFHF) we copy the wave out in a block of 16 pts
1476                                ; at a time. The SSFHF check happens at the start of each block.
1477                                ; Note that count in X0 is again a straight count requiring a fix to FASTSKP
1478                                ; CLOCKCT trashes A
1479                                CLOCKCT
1480      P:0002E6 P:0002E6 200013            CLR     A
1481      P:0002E7 P:0002E7 208E00            MOVE              X0,A
1482                                CLKBLKFULL
1483                                                                                    ; see if we can do a full block in the wavef
orm.
1484      P:0002E8 P:0002E8 015085            CMP     #16,A
1485      P:0002E9 P:0002E9 0E92F0            JLT     <CLKBLKREM
1486                                                                                    ; 16 or more points remain
1487      P:0002EA P:0002EA 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002EA
1488      P:0002EC P:0002EC 0610A0            REP     #16
1489      P:0002ED P:0002ED 09D9F3            MOVEP             Y:(R1)+,Y:WRSS          ; next modulo piece of the waveform
1490      P:0002EE P:0002EE 015084            SUB     #16,A
1491      P:0002EF P:0002EF 0C02E8            JMP     <CLKBLKFULL
1492                                CLKBLKREM
1493                                                                                    ; last little bit..
1494      P:0002F0 P:0002F0 200003            TST     A
1495      P:0002F1 P:0002F1 0EF2F7            JLE     <CLOCK1                           ; no it divided evenly so all done--
1496                                                                                    ; do the remainder of 1 to 15 pts.
1497      P:0002F2 P:0002F2 0A898E            JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
                            0002F2
1498      P:0002F4 P:0002F4 06CE00            DO      A,CLOCK1
                            0002F6
1499      P:0002F6 P:0002F6 09D9F3            MOVEP             Y:(R1)+,Y:WRSS          ; next modulo piece of the waveform
1500                                CLOCK1
1501      P:0002F7 P:0002F7 000000            NOP                                       ; just in case
1502      P:0002F8 P:0002F8 00000C            RTS
1503   
1504                                ;CLOCK   MOVE    Y:(R0)+,X0             ; # of waveform entries
1505                                ;        MOVE    Y:(R0)+,A              ; Start the pipeline
1506                                ;        DO      X0,CLK1                 ; Repeat X0 times
1507                                ;        MOVE    A,X:(R6) Y:(R0)+,A      ; Send out the waveform
1508                                ;CLK1
1509                                ;        MOVE    A,X:(R6)               ; Flush out the pipeline
1510                                ;        RTS                            ; Return from subroutine
1511   
1512                                ; Include miscellaneous timing commands
1513                                          INCLUDE "timmisc.s"                       ; Custom
1514                                ; This file is for utilities that are in common to all the timing board
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 28



1515                                ;   programs, located starting at P:$200 in external SRAM
1516   
1517                                          IF      @SCP("10","50")
1519                                          ENDIF
1520                                          IF      @SCP("10","200")
1522                                          ENDIF
1523                                          IF      @SCP("10","10")
1524      00000A                    SDELAY    EQU     10
1525                                          ENDIF
1526   
1527   
1528                                ;  ****************  PROGRAM CODE IN SRAM PROGRAM SPACE    *******************
1529                                ; Put all the following code in SRAM, starting at P:$200.
1530                                          IF      @SCP("HOST","HOST")
1531                                ; as per Confluence, July 9
1532                                ;       ORG     P:$200,P:$200   ; Download address
1533      P:0002F9 P:0002F9                   ORG     P:,P:                             ; Download address
1534                                          ELSE
1536                                          ENDIF
1537   
1538                                ; Fast clear of CCD, executed as a command
1539      P:0002F9 P:0002F9 0D02FB  CLEAR     JSR     <CLR_CCD
1540      P:0002FA P:0002FA 0C008F            JMP     <FINISH
1541   
1542                                ; Fast clear image before each exposure, executed as a subroutine.  Uses DG
1543      P:0002FB P:0002FB 060440  CLR_CCD   DO      Y:<NPCLR,LPCLR                    ; Loop over number of lines in image
                            000300
1544      P:0002FD P:0002FD 60F400            MOVE              #ABCD_CLEAR_SPLIT,R0    ; Address of parallel transfer waveform
                            0001A2
1545      P:0002FF P:0002FF 0D02E0            JSR     <CLOCK                            ; Go clock out the CCD charge
1546      P:000300 P:000300 000000            NOP                                       ; Do loop restriction
1547                                LPCLR
1548      P:000301 P:000301 60F400            MOVE              #DUMP_SERIAL,R0
                            0001E2
1549      P:000303 P:000303 0D02E0            JSR     <CLOCK                            ; and wipe out the dregs in the SR
1550      P:000304 P:000304 245A00            MOVE              #TST_RCV,X0             ; Wait for commands during exposure
1551      P:000305 P:000305 441F00            MOVE              X0,X:<IDL_ADR           ;  instead of idling
1552      P:000306 P:000306 00000C            RTS
1553   
1554                                ; Keep the CCD idling when not reading out
1555      P:000307 P:000307 060340  IDLE      DO      Y:<NS_CLR,IDL1                    ; Loop over number of pixels per line
                            000310
1556      P:000309 P:000309 303E00            MOVE              #<SERIAL_IDLE,R0        ; Serial transfer on pixel
1557      P:00030A P:00030A 0D02E0            JSR     <CLOCK                            ; Go to it
1558      P:00030B P:00030B 330700            MOVE              #COM_BUF,R3
1559      P:00030C P:00030C 0D00A5            JSR     <GET_RCV                          ; Check for FO or SSI commands
1560      P:00030D P:00030D 0E0310            JCC     <NO_COM                           ; Continue IDLE if no commands received
1561      P:00030E P:00030E 00008C            ENDDO
1562      P:00030F P:00030F 0C005D            JMP     <PRC_RCV                          ; Go process header and command
1563      P:000310 P:000310 000000  NO_COM    NOP
1564                                IDL1
1565      P:000311 P:000311 60F400            MOVE              #ABCD_CLEAR_SPLIT,R0    ; Address of parallel clocking waveform
                            0001A2
1566      P:000313 P:000313 0D02E0            JSR     <CLOCK                            ; Go clock out the CCD charge
1567      P:000314 P:000314 0C0307            JMP     <IDLE
1568   
1569                                ; Start the exposure timer and monitor its progress
1570      P:000315 P:000315 07F40E  EXPOSE    MOVEP             #0,X:TLR0               ; Load 0 into counter timer
                            000000
1571      P:000317 P:000317 240000            MOVE              #0,X0
1572      P:000318 P:000318 441100            MOVE              X0,X:<ELAPSED_TIME      ; Set elapsed exposure time to zero
1573                                ;       CLR     B                       ; possibly fix bug as per
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 29



1574      P:000319 P:000319 579000            MOVE              X:<EXPOSURE_TIME,B
1575      P:00031A P:00031A 20000B            TST     B                                 ; Special test for zero exposure time
1576      P:00031B P:00031B 0EA327            JEQ     <END_EXP                          ; Don't even start an exposure
1577      P:00031C P:00031C 01418C            SUB     #1,B                              ; Timer counts from X:TCPR0+1 to zero
1578      P:00031D P:00031D 010F20            BSET    #TIM_BIT,X:TCSR0                  ; Enable the timer #0
1579      P:00031E P:00031E 577000            MOVE              B,X:TCPR0
                            FFFF8D
1580      P:000320 P:000320 0A8989  CHK_RCV   JCLR    #EF,X:HDR,CHK_TIM                 ; Simple test for fast execution
                            000325
1581      P:000322 P:000322 330700            MOVE              #COM_BUF,R3             ; The beginning of the command buffer
1582      P:000323 P:000323 0D00A5            JSR     <GET_RCV                          ; Check for an incoming command
1583      P:000324 P:000324 0E805D            JCS     <PRC_RCV                          ; If command is received, go check it
1584      P:000325 P:000325 018F95  CHK_TIM   JCLR    #TCF,X:TCSR0,CHK_RCV              ; Wait for timer to equal compare value
                            000320
1585      P:000327 P:000327 010F00  END_EXP   BCLR    #TIM_BIT,X:TCSR0                  ; Disable the timer
1586      P:000328 P:000328 0AE780            JMP     (R7)                              ; This contains the return address
1587   
1588                                ; Select which readouts to process
1589                                ;   'SOS'  Amplifier_name
1590                                ;       Amplifier_names = '__A', '__B', '__C', '__D', '_AB', '_CD', '_BD', 'ALL'
1591   
1592                                ;       Correct command ptr to R3 as per "Four Points" #2
1593   
1594      P:000329 P:000329 44DB00  SEL_OS    MOVE              X:(R3)+,X0              ; Get amplifier(s) name
1595      P:00032A P:00032A 0D032C            JSR     <SELECT_OUTPUT_SOURCE
1596      P:00032B P:00032B 0C0090            JMP     <FINISH1
1597   
1598                                ; A massive subroutine for setting all the addresses depending on the
1599                                ; output source(s) selection and binning parameter.  Most of the
1600                                ; waveforms are in fast Y memory (< 0xFF) but there isn't enough
1601                                ; space for the fast serial binning waveforms for binning factors
1602                                ; 1 through 4.  These are in high Y memory and have to be copied in.
1603   
1604                                SELECT_OUTPUT_SOURCE
1605                                ;  a little bit of aliasing
1606      P:00032C P:00032C 56F400            MOVE              #'__L',A
                            5F5F4C
1607      P:00032E P:00032E 200045            CMP     X0,A
1608      P:00032F P:00032F 0AF0AA            JEQ     ALIAS_A
                            00033F
1609      P:000331 P:000331 56F400            MOVE              #'__R',A
                            5F5F52
1610      P:000333 P:000333 200045            CMP     X0,A
1611      P:000334 P:000334 0AF0AA            JEQ     ALIAS_B
                            0003A1
1612      P:000336 P:000336 56F400            MOVE              #'_LR',A
                            5F4C52
1613      P:000338 P:000338 200045            CMP     X0,A
1614      P:000339 P:000339 0AF0AA            JEQ     ALIAS_AB
                            0004C7
1615   
1616                                ; Set all the waveform addresses depending on which readout/binning mode
1617      P:00033B P:00033B 56F400            MOVE              #'__A',A                ; LEFT Amplifier = readout #0
                            5F5F41
1618      P:00033D P:00033D 200045            CMP     X0,A
1619      P:00033E P:00033E 0E239D            JNE     <CMP_B
1620                                ALIAS_A
1621      P:00033F P:00033F 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1622      P:000340 P:000340 46F400            MOVE              #ABCD_UP,Y0
                            000165
1623      P:000342 P:000342 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 30



1624      P:000344 P:000344 46F400            MOVE              #CD_UP,Y0
                            0001B0
1625      P:000346 P:000346 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1626      P:000348 P:000348 46F400            MOVE              #ABCD_CLEAR_UP,Y0
                            000186
1627      P:00034A P:00034A 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1628      P:00034C P:00034C 46F400            MOVE              #CD_CLEAR_UP,Y0
                            0001C6
1629      P:00034E P:00034E 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1630   
1631                                                                                    ; serials for general binning
1632      P:000350 P:000350 46F400            MOVE              #SERIAL_SKIP_EH,Y0
                            0000E8
1633      P:000352 P:000352 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
1634      P:000354 P:000354 46F400            MOVE              #INITIAL_CLOCK_EH,Y0
                            000053
1635      P:000356 P:000356 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
1636      P:000358 P:000358 46F400            MOVE              #SERIAL_CLOCK_EH,Y0
                            000068
1637      P:00035A P:00035A 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
1638      P:00035C P:00035C 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000),Y0 ;
42
                            03200A
1639                                ;       MOVE    #(CLK2+$030000+000+000+000+000+H2L+H2R+000+000),Y0
1640      P:00035E P:00035E 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
1641                                ; 42
1642                                ;        MOVE    #$00F063,Y0             ; Channel 3 only
1643      P:000360 P:000360 46F400            MOVE              #$00F0C3,Y0             ; Channel 3 only
                            00F0C3
1644      P:000362 P:000362 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
1645      P:000364 P:000364 4E7000            MOVE                          Y0,Y:SXMIT_EH_1 ; and into all the hard-coded binned cas
es in high Y
                            0001EE
1646      P:000366 P:000366 4E7000            MOVE                          Y0,Y:SXMIT_EH_2
                            00021E
1647      P:000368 P:000368 4E7000            MOVE                          Y0,Y:SXMIT_EH_3
                            000260
1648      P:00036A P:00036A 4E7000            MOVE                          Y0,Y:SXMIT_EH_4
                            0002B4
1649   
1650      P:00036C P:00036C 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1651      P:00036D P:00036D 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1652                                ; Now go through copying in the serial read waveform if binning more than 4.
1653      P:00036E P:00036E 200013            CLR     A
1654      P:00036F P:00036F 20001B            CLR     B
1655      P:000370 P:000370 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1656      P:000372 P:000372 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1657      P:000373 P:000373 50F400            MOVE              #>4,A0
                            000004
1658      P:000375 P:000375 200005            CMP     B,A
1659      P:000376 P:000376 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1660      P:000377 P:000377 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 31



1661      P:000378 P:000378 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1662      P:000379 P:000379 0A1E81  TRY_1_A   JCLR    #1,X:BINBIT,TRY_2_A
                            000382
1663                                ;       MOVE    #1,A0                   ; HACK
1664                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1665      P:00037B P:00037B 51F400            MOVE              #(END_SERIAL_READ_EH_1-SERIAL_READ_EH_1),B0
                            00000E
1666      P:00037D P:00037D 60F400            MOVE              #SERIAL_READ_EH_1,R0    ; Here if H amp, bin by 1
                            0001E8
1667      P:00037F P:00037F 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1668      P:000380 P:000380 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1669      P:000381 P:000381 0C064B            JMP     <CMP_END
1670      P:000382 P:000382 0A1E82  TRY_2_A   JCLR    #2,X:BINBIT,TRY_3_A
                            00038B
1671      P:000384 P:000384 51F400            MOVE              #(END_SERIAL_READ_EH_2-SERIAL_READ_EH_2),B0
                            000014
1672      P:000386 P:000386 60F400            MOVE              #SERIAL_READ_EH_2,R0    ; Here if H amp, bin by 2
                            000212
1673      P:000388 P:000388 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1674      P:000389 P:000389 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1675      P:00038A P:00038A 0C064B            JMP     <CMP_END
1676      P:00038B P:00038B 0A1E83  TRY_3_A   JCLR    #3,X:<BINBIT,TRY_4_A
                            000394
1677      P:00038D P:00038D 51F400            MOVE              #(END_SERIAL_READ_EH_3-SERIAL_READ_EH_3),B0
                            00001A
1678      P:00038F P:00038F 60F400            MOVE              #SERIAL_READ_EH_3,R0    ; Here if H amp, bin by 3
                            00024E
1679      P:000391 P:000391 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1680      P:000392 P:000392 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1681      P:000393 P:000393 0C064B            JMP     <CMP_END
1682      P:000394 P:000394 0A1E84  TRY_4_A   JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
1683      P:000396 P:000396 51F400            MOVE              #(END_SERIAL_READ_EH_4-SERIAL_READ_EH_4),B0
                            000020
1684      P:000398 P:000398 60F400            MOVE              #SERIAL_READ_EH_4,R0    ; Here if H amp, bin by 4
                            00029C
1685      P:00039A P:00039A 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1686      P:00039B P:00039B 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1687      P:00039C P:00039C 0C064B            JMP     <CMP_END
1688   
1689      P:00039D P:00039D 56F400  CMP_B     MOVE              #'__B',A                ;  B Amplifier = e2v G amp = Leach channel #
2
                            5F5F42
1690      P:00039F P:00039F 200045            CMP     X0,A
1691      P:0003A0 P:0003A0 0E23FF            JNE     <CMP_C
1692                                ALIAS_B
1693      P:0003A1 P:0003A1 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1694      P:0003A2 P:0003A2 46F400            MOVE              #ABCD_UP,Y0
                            000165
1695      P:0003A4 P:0003A4 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
1696      P:0003A6 P:0003A6 46F400            MOVE              #CD_UP,Y0
                            0001B0
1697      P:0003A8 P:0003A8 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1698      P:0003AA P:0003AA 46F400            MOVE              #ABCD_CLEAR_UP,Y0
                            000186
1699      P:0003AC P:0003AC 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1700      P:0003AE P:0003AE 46F400            MOVE              #CD_CLEAR_UP,Y0
                            0001C6
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 32



1701      P:0003B0 P:0003B0 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1702   
1703                                                                                    ; serials for general binning
1704      P:0003B2 P:0003B2 46F400            MOVE              #SERIAL_SKIP_FG,Y0
                            0000F0
1705      P:0003B4 P:0003B4 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
1706      P:0003B6 P:0003B6 46F400            MOVE              #INITIAL_CLOCK_FG,Y0
                            00005A
1707      P:0003B8 P:0003B8 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
1708      P:0003BA P:0003BA 46F400            MOVE              #SERIAL_CLOCK_FG,Y0
                            00006F
1709      P:0003BC P:0003BC 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
1710                                                                                    ; 42
1711      P:0003BE P:0003BE 46F400            MOVE              #(CLK2+$030000+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032011
1712                                ;       MOVE    #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),Y0
1713      P:0003C0 P:0003C0 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
1714                                ;        MOVE    #$00F042,Y0             ; Channel 2 only
1715      P:0003C2 P:0003C2 46F400            MOVE              #$00F082,Y0             ; Channel 2 only
                            00F082
1716      P:0003C4 P:0003C4 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
1717      P:0003C6 P:0003C6 4E7000            MOVE                          Y0,Y:SXMIT_FG_1 ; and into all the hard-coded binned cas
es in high Y
                            0001FC
1718      P:0003C8 P:0003C8 4E7000            MOVE                          Y0,Y:SXMIT_FG_2
                            000232
1719      P:0003CA P:0003CA 4E7000            MOVE                          Y0,Y:SXMIT_FG_3
                            00027A
1720      P:0003CC P:0003CC 4E7000            MOVE                          Y0,Y:SXMIT_FG_4
                            0002D4
1721   
1722      P:0003CE P:0003CE 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1723      P:0003CF P:0003CF 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1724                                ; Now go through copying in the serial read waveform if binning more than 4.
1725      P:0003D0 P:0003D0 200013            CLR     A
1726      P:0003D1 P:0003D1 20001B            CLR     B
1727      P:0003D2 P:0003D2 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1728      P:0003D4 P:0003D4 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1729      P:0003D5 P:0003D5 50F400            MOVE              #>4,A0
                            000004
1730      P:0003D7 P:0003D7 200005            CMP     B,A
1731      P:0003D8 P:0003D8 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1732      P:0003D9 P:0003D9 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
1733      P:0003DA P:0003DA 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1734      P:0003DB P:0003DB 0A1E81  TRY_1_B   JCLR    #1,X:BINBIT,TRY_2_B
                            0003E4
1735                                ;       MOVE    #2,A0                   ; HACK
1736                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1737      P:0003DD P:0003DD 51F400            MOVE              #(END_SERIAL_READ_FG_1-SERIAL_READ_FG_1),B0
                            00000E
1738      P:0003DF P:0003DF 60F400            MOVE              #SERIAL_READ_FG_1,R0    ; Here if G amp, bin by 1
                            0001F6
1739      P:0003E1 P:0003E1 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 33



1740      P:0003E2 P:0003E2 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1741      P:0003E3 P:0003E3 0C064B            JMP     <CMP_END
1742      P:0003E4 P:0003E4 0A1E82  TRY_2_B   JCLR    #2,X:BINBIT,TRY_3_B
                            0003ED
1743      P:0003E6 P:0003E6 51F400            MOVE              #(END_SERIAL_READ_FG_2-SERIAL_READ_FG_2),B0
                            000014
1744      P:0003E8 P:0003E8 60F400            MOVE              #SERIAL_READ_FG_2,R0    ; Here if G amp, bin by 2
                            000226
1745      P:0003EA P:0003EA 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1746      P:0003EB P:0003EB 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1747      P:0003EC P:0003EC 0C064B            JMP     <CMP_END
1748      P:0003ED P:0003ED 0A1E83  TRY_3_B   JCLR    #3,X:BINBIT,TRY_4_B
                            0003F6
1749      P:0003EF P:0003EF 51F400            MOVE              #(END_SERIAL_READ_FG_3-SERIAL_READ_FG_3),B0
                            00001A
1750      P:0003F1 P:0003F1 60F400            MOVE              #SERIAL_READ_FG_3,R0    ; Here if G amp, bin by 3
                            000268
1751      P:0003F3 P:0003F3 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1752      P:0003F4 P:0003F4 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1753      P:0003F5 P:0003F5 0C064B            JMP     <CMP_END
1754      P:0003F6 P:0003F6 0A1E84  TRY_4_B   JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
1755      P:0003F8 P:0003F8 51F400            MOVE              #(END_SERIAL_READ_FG_4-SERIAL_READ_FG_4),B0
                            000020
1756      P:0003FA P:0003FA 60F400            MOVE              #SERIAL_READ_FG_4,R0    ; Here if G amp, bin by 4
                            0002BC
1757      P:0003FC P:0003FC 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1758      P:0003FD P:0003FD 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1759      P:0003FE P:0003FE 0C064B            JMP     <CMP_END
1760   
1761      P:0003FF P:0003FF 56F400  CMP_C     MOVE              #'__C',A                ;  C Amplifier = e2v E amp = Leach channel #
0
                            5F5F43
1762      P:000401 P:000401 200045            CMP     X0,A
1763      P:000402 P:000402 0E2461            JNE     <CMP_D
1764      P:000403 P:000403 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1765      P:000404 P:000404 46F400            MOVE              #ABCD_DOWN,Y0
                            000170
1766      P:000406 P:000406 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
1767      P:000408 P:000408 46F400            MOVE              #AB_DOWN,Y0
                            0001BB
1768      P:00040A P:00040A 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1769      P:00040C P:00040C 46F400            MOVE              #ABCD_CLEAR_DOWN,Y0
                            000194
1770      P:00040E P:00040E 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1771      P:000410 P:000410 46F400            MOVE              #AB_CLEAR_DOWN,Y0
                            0001D4
1772      P:000412 P:000412 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1773   
1774                                                                                    ; serials for general binning
1775      P:000414 P:000414 46F400            MOVE              #SERIAL_SKIP_EH,Y0
                            0000E8
1776      P:000416 P:000416 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
1777      P:000418 P:000418 46F400            MOVE              #INITIAL_CLOCK_EH,Y0
                            000053
1778      P:00041A P:00041A 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 34



1779      P:00041C P:00041C 46F400            MOVE              #SERIAL_CLOCK_EH,Y0
                            000068
1780      P:00041E P:00041E 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
1781                                                                                    ; 42
1782      P:000420 P:000420 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000),Y0
                            03200A
1783                                ;       MOVE    #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),Y0
1784      P:000422 P:000422 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
1785                                ;        MOVE    #$00F000,Y0             ; Channel 0 only
1786      P:000424 P:000424 46F400            MOVE              #$00F000,Y0             ; Channel 0 only
                            00F000
1787      P:000426 P:000426 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
1788      P:000428 P:000428 4E7000            MOVE                          Y0,Y:SXMIT_EH_1 ; and into all the hard-coded binned cas
es in high Y
                            0001EE
1789      P:00042A P:00042A 4E7000            MOVE                          Y0,Y:SXMIT_EH_2
                            00021E
1790      P:00042C P:00042C 4E7000            MOVE                          Y0,Y:SXMIT_EH_3
                            000260
1791      P:00042E P:00042E 4E7000            MOVE                          Y0,Y:SXMIT_EH_4
                            0002B4
1792   
1793      P:000430 P:000430 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1794      P:000431 P:000431 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1795                                ; Now go through copying in the serial read waveform if binning more than 4.
1796      P:000432 P:000432 200013            CLR     A
1797      P:000433 P:000433 20001B            CLR     B
1798      P:000434 P:000434 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1799      P:000436 P:000436 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1800      P:000437 P:000437 50F400            MOVE              #>4,A0
                            000004
1801      P:000439 P:000439 200005            CMP     B,A
1802      P:00043A P:00043A 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1803      P:00043B P:00043B 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
1804      P:00043C P:00043C 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1805      P:00043D P:00043D 0A1E81  TRY_1_C   JCLR    #1,X:BINBIT,TRY_2_C
                            000446
1806                                ;       MOVE    #2,A0                   ; HACK
1807                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1808      P:00043F P:00043F 51F400            MOVE              #(END_SERIAL_READ_EH_1-SERIAL_READ_EH_1),B0
                            00000E
1809      P:000441 P:000441 60F400            MOVE              #SERIAL_READ_EH_1,R0    ; Here if E amp, bin by 1
                            0001E8
1810      P:000443 P:000443 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1811      P:000444 P:000444 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1812      P:000445 P:000445 0C064B            JMP     <CMP_END
1813      P:000446 P:000446 0A1E82  TRY_2_C   JCLR    #2,X:BINBIT,TRY_3_C
                            00044F
1814      P:000448 P:000448 51F400            MOVE              #(END_SERIAL_READ_EH_2-SERIAL_READ_EH_2),B0
                            000014
1815      P:00044A P:00044A 60F400            MOVE              #SERIAL_READ_EH_2,R0    ; Here if E amp, bin by 2
                            000212
1816      P:00044C P:00044C 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1817      P:00044D P:00044D 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1818      P:00044E P:00044E 0C064B            JMP     <CMP_END
1819      P:00044F P:00044F 0A1E83  TRY_3_C   JCLR    #3,X:BINBIT,TRY_4_C
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 35



                            000458
1820      P:000451 P:000451 51F400            MOVE              #(END_SERIAL_READ_EH_3-SERIAL_READ_EH_3),B0
                            00001A
1821      P:000453 P:000453 60F400            MOVE              #SERIAL_READ_EH_3,R0    ; Here if E amp, bin by 3
                            00024E
1822      P:000455 P:000455 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1823      P:000456 P:000456 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1824      P:000457 P:000457 0C064B            JMP     <CMP_END
1825      P:000458 P:000458 0A1E84  TRY_4_C   JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
1826      P:00045A P:00045A 51F400            MOVE              #(END_SERIAL_READ_EH_4-SERIAL_READ_EH_4),B0
                            000020
1827      P:00045C P:00045C 60F400            MOVE              #SERIAL_READ_EH_4,R0    ; Here if E amp, bin by 4
                            00029C
1828      P:00045E P:00045E 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1829      P:00045F P:00045F 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1830      P:000460 P:000460 0C064B            JMP     <CMP_END
1831   
1832      P:000461 P:000461 56F400  CMP_D     MOVE              #'__D',A                ;  D Amplifier = e2v F amp = Leach channel #
1
                            5F5F44
1833      P:000463 P:000463 200045            CMP     X0,A
1834      P:000464 P:000464 0E24C3            JNE     <CMP_AB
1835      P:000465 P:000465 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1836      P:000466 P:000466 46F400            MOVE              #ABCD_DOWN,Y0
                            000170
1837      P:000468 P:000468 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
1838      P:00046A P:00046A 46F400            MOVE              #AB_DOWN,Y0
                            0001BB
1839      P:00046C P:00046C 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1840      P:00046E P:00046E 46F400            MOVE              #ABCD_CLEAR_DOWN,Y0
                            000194
1841      P:000470 P:000470 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1842      P:000472 P:000472 46F400            MOVE              #AB_CLEAR_DOWN,Y0
                            0001D4
1843      P:000474 P:000474 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1844   
1845                                                                                    ; serials for general binning
1846      P:000476 P:000476 46F400            MOVE              #SERIAL_SKIP_FG,Y0
                            0000F0
1847      P:000478 P:000478 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
1848      P:00047A P:00047A 46F400            MOVE              #INITIAL_CLOCK_FG,Y0
                            00005A
1849      P:00047C P:00047C 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
1850      P:00047E P:00047E 46F400            MOVE              #SERIAL_CLOCK_FG,Y0
                            00006F
1851      P:000480 P:000480 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
1852                                                                                    ; 42
1853      P:000482 P:000482 46F400            MOVE              #(CLK2+$030000+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032011
1854                                ;       MOVE    #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),Y0
1855      P:000484 P:000484 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
1856                                ;        MOVE    #$00F021,Y0             ; Channel 1 only
1857      P:000486 P:000486 46F400            MOVE              #$00F041,Y0             ; Channel 1 only
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 36



                            00F041
1858      P:000488 P:000488 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
1859      P:00048A P:00048A 4E7000            MOVE                          Y0,Y:SXMIT_FG_1 ; and into all the hard-coded binned cas
es in high Y
                            0001FC
1860      P:00048C P:00048C 4E7000            MOVE                          Y0,Y:SXMIT_FG_2
                            000232
1861      P:00048E P:00048E 4E7000            MOVE                          Y0,Y:SXMIT_FG_3
                            00027A
1862      P:000490 P:000490 4E7000            MOVE                          Y0,Y:SXMIT_FG_4
                            0002D4
1863   
1864      P:000492 P:000492 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; no split, single amp
1865      P:000493 P:000493 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; no split, single amp
1866                                ; Now go through copying in the serial read waveform if binning more than 4.
1867      P:000494 P:000494 200013            CLR     A
1868      P:000495 P:000495 20001B            CLR     B
1869      P:000496 P:000496 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1870      P:000498 P:000498 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1871      P:000499 P:000499 50F400            MOVE              #>4,A0
                            000004
1872      P:00049B P:00049B 200005            CMP     B,A
1873      P:00049C P:00049C 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1874      P:00049D P:00049D 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
1875      P:00049E P:00049E 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1876      P:00049F P:00049F 0A1E81  TRY_1_D   JCLR    #1,X:BINBIT,TRY_2_D
                            0004A8
1877                                ;       MOVE    #2,A0                   ; HACK
1878                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1879      P:0004A1 P:0004A1 51F400            MOVE              #(END_SERIAL_READ_FG_1-SERIAL_READ_FG_1),B0
                            00000E
1880      P:0004A3 P:0004A3 60F400            MOVE              #SERIAL_READ_FG_1,R0    ; Here if F amp, bin by 1
                            0001F6
1881      P:0004A5 P:0004A5 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1882      P:0004A6 P:0004A6 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1883      P:0004A7 P:0004A7 0C064B            JMP     <CMP_END
1884      P:0004A8 P:0004A8 0A1E82  TRY_2_D   JCLR    #2,X:BINBIT,TRY_3_D
                            0004B1
1885      P:0004AA P:0004AA 51F400            MOVE              #(END_SERIAL_READ_FG_2-SERIAL_READ_FG_2),B0
                            000014
1886      P:0004AC P:0004AC 60F400            MOVE              #SERIAL_READ_FG_2,R0    ; Here if F amp, bin by 2
                            000226
1887      P:0004AE P:0004AE 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1888      P:0004AF P:0004AF 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1889      P:0004B0 P:0004B0 0C064B            JMP     <CMP_END
1890      P:0004B1 P:0004B1 0A1E83  TRY_3_D   JCLR    #3,X:BINBIT,TRY_4_D
                            0004BA
1891      P:0004B3 P:0004B3 51F400            MOVE              #(END_SERIAL_READ_FG_3-SERIAL_READ_FG_3),B0
                            00001A
1892      P:0004B5 P:0004B5 60F400            MOVE              #SERIAL_READ_FG_3,R0    ; Here if F amp, bin by 3
                            000268
1893      P:0004B7 P:0004B7 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1894      P:0004B8 P:0004B8 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1895      P:0004B9 P:0004B9 0C064B            JMP     <CMP_END
1896      P:0004BA P:0004BA 0A1E84  TRY_4_D   JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
1897      P:0004BC P:0004BC 51F400            MOVE              #(END_SERIAL_READ_FG_4-SERIAL_READ_FG_4),B0
                            000020
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 37



1898      P:0004BE P:0004BE 60F400            MOVE              #SERIAL_READ_FG_4,R0    ; Here if F amp, bin by 4
                            0002BC
1899      P:0004C0 P:0004C0 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1900      P:0004C1 P:0004C1 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1901      P:0004C2 P:0004C2 0C064B            JMP     <CMP_END
1902   
1903      P:0004C3 P:0004C3 56F400  CMP_AB    MOVE              #'_AB',A                ;  AB Amplifier = e2v HG amp = Leach channel
s 2-3
                            5F4142
1904      P:0004C5 P:0004C5 200045            CMP     X0,A
1905      P:0004C6 P:0004C6 0E2525            JNE     <CMP_CD
1906                                ALIAS_AB
1907      P:0004C7 P:0004C7 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1908      P:0004C8 P:0004C8 46F400            MOVE              #ABCD_UP,Y0
                            000165
1909      P:0004CA P:0004CA 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
1910      P:0004CC P:0004CC 46F400            MOVE              #CD_UP,Y0
                            0001B0
1911      P:0004CE P:0004CE 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1912      P:0004D0 P:0004D0 46F400            MOVE              #ABCD_CLEAR_UP,Y0
                            000186
1913      P:0004D2 P:0004D2 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1914      P:0004D4 P:0004D4 46F400            MOVE              #CD_CLEAR_UP,Y0
                            0001C6
1915      P:0004D6 P:0004D6 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1916   
1917      P:0004D8 P:0004D8 46F400            MOVE              #SERIAL_SKIP_SPLIT,Y0
                            0000F8
1918      P:0004DA P:0004DA 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
1919      P:0004DC P:0004DC 46F400            MOVE              #INITIAL_CLOCK_SPLIT,Y0
                            00004C
1920      P:0004DE P:0004DE 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
1921      P:0004E0 P:0004E0 46F400            MOVE              #SERIAL_CLOCK_SPLIT,Y0
                            000061
1922      P:0004E2 P:0004E2 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
1923                                ;       42
1924                                ;       MOVE    #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),Y0
1925      P:0004E4 P:0004E4 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032012
1926   
1927      P:0004E6 P:0004E6 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
1928                                ; MOVE    #$00F062,Y0             ; Channels 2-3
1929      P:0004E8 P:0004E8 46F400            MOVE              #$00F0C2,Y0             ; Channels 2-3
                            00F0C2
1930      P:0004EA P:0004EA 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
1931      P:0004EC P:0004EC 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_1 ; and into all the hard-coded binned 
cases in high Y
                            00020A
1932      P:0004EE P:0004EE 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_2
                            000246
1933      P:0004F0 P:0004F0 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_3
                            000294
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 38



1934      P:0004F2 P:0004F2 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_4
                            0002F4
1935   
1936   
1937      P:0004F4 P:0004F4 0A0025            BSET    #SPLIT_S,X:STATUS                 ; Serials split
1938      P:0004F5 P:0004F5 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; Parallels not split
1939   
1940                                ; Now go through copying in the serial read waveform if binning more than 4.
1941      P:0004F6 P:0004F6 200013            CLR     A
1942      P:0004F7 P:0004F7 20001B            CLR     B
1943      P:0004F8 P:0004F8 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
1944      P:0004FA P:0004FA 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
1945      P:0004FB P:0004FB 50F400            MOVE              #>4,A0
                            000004
1946      P:0004FD P:0004FD 200005            CMP     B,A
1947      P:0004FE P:0004FE 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
1948      P:0004FF P:0004FF 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
1949      P:000500 P:000500 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
1950      P:000501 P:000501 0A1E81  TRY_1_AB  JCLR    #1,X:BINBIT,TRY_2_AB
                            00050A
1951                                ;       MOVE    #3,A0                   ; HACK
1952                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
1953      P:000503 P:000503 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                            00000E
1954      P:000505 P:000505 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if HG amp, bin by 1
                            000204
1955      P:000507 P:000507 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1956      P:000508 P:000508 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1957      P:000509 P:000509 0C064B            JMP     <CMP_END
1958      P:00050A P:00050A 0A1E82  TRY_2_AB  JCLR    #2,X:BINBIT,TRY_3_AB
                            000513
1959      P:00050C P:00050C 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                            000014
1960      P:00050E P:00050E 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if HG amp, bin by 2
                            00023A
1961      P:000510 P:000510 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1962      P:000511 P:000511 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1963      P:000512 P:000512 0C064B            JMP     <CMP_END
1964      P:000513 P:000513 0A1E83  TRY_3_AB  JCLR    #3,X:BINBIT,TRY_4_AB
                            00051C
1965      P:000515 P:000515 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                            00001A
1966      P:000517 P:000517 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if HG amp, bin by 3
                            000282
1967      P:000519 P:000519 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1968      P:00051A P:00051A 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1969      P:00051B P:00051B 0C064B            JMP     <CMP_END
1970      P:00051C P:00051C 0A1E84  TRY_4_AB  JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
1971      P:00051E P:00051E 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                            000020
1972      P:000520 P:000520 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if HG amp, bin by 4
                            0002DC
1973      P:000522 P:000522 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
1974      P:000523 P:000523 0D0651            JSR     <WAVECPY                          ; Copy the waveform
1975      P:000524 P:000524 0C064B            JMP     <CMP_END
1976   
1977      P:000525 P:000525 56F400  CMP_CD    MOVE              #'_CD',A                ;  CD Amplifier = e2v EF amp = Leach channel
s 0-1
                            5F4344
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 39



1978      P:000527 P:000527 200045            CMP     X0,A
1979      P:000528 P:000528 0E2587            JNE     <CMP_BD
1980      P:000529 P:000529 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
1981      P:00052A P:00052A 46F400            MOVE              #ABCD_DOWN,Y0
                            000170
1982      P:00052C P:00052C 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
1983      P:00052E P:00052E 46F400            MOVE              #AB_DOWN,Y0
                            0001BB
1984      P:000530 P:000530 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
1985      P:000532 P:000532 46F400            MOVE              #ABCD_CLEAR_DOWN,Y0
                            000194
1986      P:000534 P:000534 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
1987      P:000536 P:000536 46F400            MOVE              #AB_CLEAR_DOWN,Y0
                            0001D4
1988      P:000538 P:000538 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
1989   
1990      P:00053A P:00053A 46F400            MOVE              #SERIAL_SKIP_SPLIT,Y0
                            0000F8
1991      P:00053C P:00053C 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
1992      P:00053E P:00053E 46F400            MOVE              #INITIAL_CLOCK_SPLIT,Y0
                            00004C
1993      P:000540 P:000540 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
1994      P:000542 P:000542 46F400            MOVE              #SERIAL_CLOCK_SPLIT,Y0
                            000061
1995      P:000544 P:000544 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
1996                                ;       42
1997                                ;       MOVE    #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),Y0
1998      P:000546 P:000546 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032012
1999      P:000548 P:000548 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
2000   
2001                                ;        MOVE    #$00F020,Y0             ; Channels 0-1
2002      P:00054A P:00054A 46F400            MOVE              #$00F040,Y0             ; Channels 0-1
                            00F040
2003      P:00054C P:00054C 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
2004      P:00054E P:00054E 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_1 ; and into all the hard-coded binned 
cases in high Y
                            00020A
2005      P:000550 P:000550 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_2
                            000246
2006      P:000552 P:000552 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_3
                            000294
2007      P:000554 P:000554 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_4
                            0002F4
2008   
2009   
2010      P:000556 P:000556 0A0025            BSET    #SPLIT_S,X:STATUS                 ; Serials split
2011      P:000557 P:000557 0A0006            BCLR    #SPLIT_P,X:STATUS                 ; Parallels not split
2012   
2013                                ; Now go through copying in the serial read waveform if binning more than 4.
2014      P:000558 P:000558 200013            CLR     A
2015      P:000559 P:000559 20001B            CLR     B
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 40



2016      P:00055A P:00055A 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
2017      P:00055C P:00055C 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
2018      P:00055D P:00055D 50F400            MOVE              #>4,A0
                            000004
2019      P:00055F P:00055F 200005            CMP     B,A
2020      P:000560 P:000560 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
2021      P:000561 P:000561 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
2022      P:000562 P:000562 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
2023      P:000563 P:000563 0A1E81  TRY_1_CD  JCLR    #1,X:BINBIT,TRY_2_CD
                            00056C
2024                                ;       MOVE    #3,A0                   ; HACK
2025                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
2026      P:000565 P:000565 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                            00000E
2027      P:000567 P:000567 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if EF amp, bin by 1
                            000204
2028      P:000569 P:000569 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2029      P:00056A P:00056A 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2030      P:00056B P:00056B 0C064B            JMP     <CMP_END
2031      P:00056C P:00056C 0A1E82  TRY_2_CD  JCLR    #2,X:BINBIT,TRY_3_CD
                            000575
2032      P:00056E P:00056E 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                            000014
2033      P:000570 P:000570 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if EF amp, bin by 2
                            00023A
2034      P:000572 P:000572 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2035      P:000573 P:000573 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2036      P:000574 P:000574 0C064B            JMP     <CMP_END
2037      P:000575 P:000575 0A1E83  TRY_3_CD  JCLR    #3,X:BINBIT,TRY_4_CD
                            00057E
2038      P:000577 P:000577 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                            00001A
2039      P:000579 P:000579 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if EF amp, bin by 3
                            000282
2040      P:00057B P:00057B 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2041      P:00057C P:00057C 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2042      P:00057D P:00057D 0C064B            JMP     <CMP_END
2043      P:00057E P:00057E 0A1E84  TRY_4_CD  JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
2044      P:000580 P:000580 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                            000020
2045      P:000582 P:000582 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if EF amp, bin by 4
                            0002DC
2046      P:000584 P:000584 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2047      P:000585 P:000585 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2048      P:000586 P:000586 0C064B            JMP     <CMP_END
2049   
2050      P:000587 P:000587 56F400  CMP_BD    MOVE              #'_BD',A                ;  BD Amplifier = e2v FG amp = Leach channel
s 1-2
                            5F4244
2051      P:000589 P:000589 200045            CMP     X0,A                              ; Note that EH amplifier isn't possible - Le
ach channels 0 & 3
2052      P:00058A P:00058A 0E25E9            JNE     <CMP_ALL                          ; are not adjacent so SXMIT doesn't work.
2053      P:00058B P:00058B 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
2054      P:00058C P:00058C 46F400            MOVE              #ABCD_SPLIT,Y0
                            00017B
2055      P:00058E P:00058E 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
2056      P:000590 P:000590 46F400            MOVE              #CD_UP,Y0
                            0001B0
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 41



2057      P:000592 P:000592 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels
                            00000E
2058      P:000594 P:000594 46F400            MOVE              #ABCD_CLEAR_SPLIT,Y0
                            0001A2
2059      P:000596 P:000596 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
2060      P:000598 P:000598 46F400            MOVE              #CD_CLEAR_UP,Y0
                            0001C6
2061      P:00059A P:00059A 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only
                            000010
2062   
2063      P:00059C P:00059C 46F400            MOVE              #SERIAL_SKIP_FG,Y0
                            0000F0
2064      P:00059E P:00059E 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
2065      P:0005A0 P:0005A0 46F400            MOVE              #INITIAL_CLOCK_FG,Y0
                            00005A
2066      P:0005A2 P:0005A2 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
2067      P:0005A4 P:0005A4 46F400            MOVE              #SERIAL_CLOCK_FG,Y0
                            00006F
2068      P:0005A6 P:0005A6 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
2069                                ;       42
2070                                ;       MOVE    #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),Y0
2071      P:0005A8 P:0005A8 46F400            MOVE              #(CLK2+$030000+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032011
2072      P:0005AA P:0005AA 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
2073   
2074      P:0005AC P:0005AC 0A0005            BCLR    #SPLIT_S,X:STATUS                 ; Serials not split
2075                                                                                    ;MOVE    #$00F041,Y0             ; Channels 
1-2
2076      P:0005AD P:0005AD 46F400            MOVE              #$00F081,Y0             ; Channels 1-2
                            00F081
2077      P:0005AF P:0005AF 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
2078      P:0005B1 P:0005B1 4E7000            MOVE                          Y0,Y:SXMIT_FG_1 ; and into all the hard-coded binned cas
es in high Y
                            0001FC
2079      P:0005B3 P:0005B3 4E7000            MOVE                          Y0,Y:SXMIT_FG_2
                            000232
2080      P:0005B5 P:0005B5 4E7000            MOVE                          Y0,Y:SXMIT_FG_3
                            00027A
2081      P:0005B7 P:0005B7 4E7000            MOVE                          Y0,Y:SXMIT_FG_4
                            0002D4
2082   
2083   
2084      P:0005B9 P:0005B9 0A0026            BSET    #SPLIT_P,X:STATUS                 ; Parallels split
2085   
2086                                ; Now go through copying in the serial read waveform if binning more than 4.
2087      P:0005BA P:0005BA 200013            CLR     A
2088      P:0005BB P:0005BB 20001B            CLR     B
2089      P:0005BC P:0005BC 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
2090      P:0005BE P:0005BE 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
2091      P:0005BF P:0005BF 50F400            MOVE              #>4,A0
                            000004
2092      P:0005C1 P:0005C1 200005            CMP     B,A
2093      P:0005C2 P:0005C2 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
2094      P:0005C3 P:0005C3 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 42



2095      P:0005C4 P:0005C4 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
2096      P:0005C5 P:0005C5 0A1E81  TRY_1_BD  JCLR    #1,X:BINBIT,TRY_2_BD
                            0005CE
2097                                ;       MOVE    #3,A0                   ; HACK
2098                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
2099      P:0005C7 P:0005C7 51F400            MOVE              #(END_SERIAL_READ_FG_1-SERIAL_READ_FG_1),B0
                            00000E
2100      P:0005C9 P:0005C9 60F400            MOVE              #SERIAL_READ_FG_1,R0    ; Here if FG amp, bin by 1
                            0001F6
2101      P:0005CB P:0005CB 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2102      P:0005CC P:0005CC 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2103      P:0005CD P:0005CD 0C064B            JMP     <CMP_END
2104      P:0005CE P:0005CE 0A1E82  TRY_2_BD  JCLR    #2,X:BINBIT,TRY_3_BD
                            0005D7
2105      P:0005D0 P:0005D0 51F400            MOVE              #(END_SERIAL_READ_FG_2-SERIAL_READ_FG_2),B0
                            000014
2106      P:0005D2 P:0005D2 60F400            MOVE              #SERIAL_READ_FG_2,R0    ; Here if FG amp, bin by 2
                            000226
2107      P:0005D4 P:0005D4 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2108      P:0005D5 P:0005D5 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2109      P:0005D6 P:0005D6 0C064B            JMP     <CMP_END
2110      P:0005D7 P:0005D7 0A1E83  TRY_3_BD  JCLR    #3,X:BINBIT,TRY_4_BD
                            0005E0
2111      P:0005D9 P:0005D9 51F400            MOVE              #(END_SERIAL_READ_FG_3-SERIAL_READ_FG_3),B0
                            00001A
2112      P:0005DB P:0005DB 60F400            MOVE              #SERIAL_READ_FG_3,R0    ; Here if FG amp, bin by 3
                            000268
2113      P:0005DD P:0005DD 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2114      P:0005DE P:0005DE 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2115      P:0005DF P:0005DF 0C064B            JMP     <CMP_END
2116      P:0005E0 P:0005E0 0A1E84  TRY_4_BD  JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
2117      P:0005E2 P:0005E2 51F400            MOVE              #(END_SERIAL_READ_FG_4-SERIAL_READ_FG_4),B0
                            000020
2118      P:0005E4 P:0005E4 60F400            MOVE              #SERIAL_READ_FG_4,R0    ; Here if FG amp, bin by 4
                            0002BC
2119      P:0005E6 P:0005E6 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2120      P:0005E7 P:0005E7 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2121      P:0005E8 P:0005E8 0C064B            JMP     <CMP_END
2122   
2123      P:0005E9 P:0005E9 56F400  CMP_ALL   MOVE              #'ALL',A                ;  ABCD Amplifier = e2v EFGH amp = Leach cha
nnels 0-3
                            414C4C
2124      P:0005EB P:0005EB 200045            CMP     X0,A
2125      P:0005EC P:0005EC 0E264E            JNE     <CMP_ERROR
2126      P:0005ED P:0005ED 4C3B00            MOVE                          X0,Y:<AMPVAL ; save the amp value
2127      P:0005EE P:0005EE 46F400            MOVE              #ABCD_SPLIT,Y0
                            00017B
2128      P:0005F0 P:0005F0 4E7000            MOVE                          Y0,Y:IS_PAR_CLK ; ganged parallels
                            00000D
2129      P:0005F2 P:0005F2 46F400            MOVE              #CD_UP,Y0
                            0001B0
2130      P:0005F4 P:0005F4 4E7000            MOVE                          Y0,Y:S_PAR_CLK ; storage area parallels; NA for split pa
rallels
                            00000E
2131      P:0005F6 P:0005F6 46F400            MOVE              #ABCD_CLEAR_SPLIT,Y0
                            0001A2
2132      P:0005F8 P:0005F8 4E7000            MOVE                          Y0,Y:IS_PAR_CLR ; Clear full CCD
                            00000F
2133      P:0005FA P:0005FA 46F400            MOVE              #CD_CLEAR_UP,Y0
                            0001C6
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 43



2134      P:0005FC P:0005FC 4E7000            MOVE                          Y0,Y:S_PAR_CLR ; Clear storage area only; NA for split p
arallels
                            000010
2135   
2136      P:0005FE P:0005FE 46F400            MOVE              #SERIAL_SKIP_SPLIT,Y0
                            0000F8
2137      P:000600 P:000600 4E7000            MOVE                          Y0,Y:SERIAL_SKIP
                            000009
2138      P:000602 P:000602 46F400            MOVE              #INITIAL_CLOCK_SPLIT,Y0
                            00004C
2139      P:000604 P:000604 4E7000            MOVE                          Y0,Y:INITIAL_CLOCK
                            00000C
2140      P:000606 P:000606 46F400            MOVE              #SERIAL_CLOCK_SPLIT,Y0
                            000061
2141      P:000608 P:000608 4E7000            MOVE                          Y0,Y:SERIAL_CLOCK
                            00000B
2142                                ;       42
2143                                ;       MOVE    #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),Y0
2144      P:00060A P:00060A 46F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000),Y0
                            032012
2145   
2146      P:00060C P:00060C 4E7000            MOVE                          Y0,Y:CCLK_1
                            00007D
2147                                ;        MOVE    #$00F060,Y0             ; All four channels
2148      P:00060E P:00060E 46F400            MOVE              #$00F0C0,Y0             ; All four channels
                            00F0C0
2149      P:000610 P:000610 4E7000            MOVE                          Y0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary bin
ning
                            000079
2150      P:000612 P:000612 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_1 ; and into all the hard-coded binned 
cases in high Y
                            00020A
2151      P:000614 P:000614 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_2
                            000246
2152      P:000616 P:000616 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_3
                            000294
2153      P:000618 P:000618 4E7000            MOVE                          Y0,Y:SXMIT_SPLIT_4
                            0002F4
2154   
2155   
2156      P:00061A P:00061A 0A0025            BSET    #SPLIT_S,X:<STATUS                ; Serials split
2157      P:00061B P:00061B 0A0026            BSET    #SPLIT_P,X:<STATUS                ; Parallels split
2158   
2159                                ; Now go through copying in the serial read waveform if binning more than 4.
2160      P:00061C P:00061C 200013            CLR     A
2161      P:00061D P:00061D 20001B            CLR     B
2162      P:00061E P:00061E 567000            MOVE              A,X:BINBIT              ; Clear BINBIT.  This is for 5 or greater
                            00001E
2163      P:000620 P:000620 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
2164      P:000621 P:000621 50F400            MOVE              #>4,A0
                            000004
2165      P:000623 P:000623 200005            CMP     B,A
2166      P:000624 P:000624 0E964B            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
2167      P:000625 P:000625 0D0658            JSR     <SET_BINBIT                       ; else set BINBIT
2168      P:000626 P:000626 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copi
es
2169      P:000627 P:000627 0A1E81  TRY_1_ALL JCLR    #1,X:BINBIT,TRY_2_ALL
                            000630
2170                                ;       MOVE    #3,A0                   ; HACK
2171                                ;       MOVE    A0,Y:<INTERVAL          ; HACK
2172      P:000629 P:000629 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                            00000E
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 44



2173      P:00062B P:00062B 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if ALL amp, bin by 1
                            000204
2174      P:00062D P:00062D 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2175      P:00062E P:00062E 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2176      P:00062F P:00062F 0C064B            JMP     <CMP_END
2177      P:000630 P:000630 0A1E82  TRY_2_ALL JCLR    #2,X:BINBIT,TRY_3_ALL
                            000639
2178      P:000632 P:000632 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                            000014
2179      P:000634 P:000634 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if ALL amp, bin by 2
                            00023A
2180      P:000636 P:000636 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2181      P:000637 P:000637 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2182      P:000638 P:000638 0C064B            JMP     <CMP_END
2183      P:000639 P:000639 0A1E83  TRY_3_ALL JCLR    #3,X:BINBIT,TRY_4_ALL
                            000642
2184      P:00063B P:00063B 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                            00001A
2185      P:00063D P:00063D 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if ALL amp, bin by 3
                            000282
2186      P:00063F P:00063F 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2187      P:000640 P:000640 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2188      P:000641 P:000641 0C064B            JMP     <CMP_END
2189      P:000642 P:000642 0A1E84  TRY_4_ALL JCLR    #4,X:BINBIT,CMP_ERROR
                            00064E
2190      P:000644 P:000644 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                            000020
2191      P:000646 P:000646 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if ALL amp, bin by 4
                            0002DC
2192      P:000648 P:000648 590A00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
2193      P:000649 P:000649 0D0651            JSR     <WAVECPY                          ; Copy the waveform
2194      P:00064A P:00064A 0C064B            JMP     <CMP_END
2195   
2196   
2197                                ;       returns modified as per "Four points", #1
2198      P:00064B P:00064B 47F400  CMP_END   MOVE              #'DON',Y1
                            444F4E
2199      P:00064D P:00064D 00000C            RTS
2200                                CMP_ERROR
2201      P:00064E P:00064E 47F400            MOVE              #'ERR',Y1
                            455252
2202      P:000650 P:000650 00000C            RTS
2203   
2204                                ; Short function to copy in waveforms from high Y to fast Y memory.
2205                                ; R0 is the source address, R7 the destination, and X0 is intermediary reg.
2206                                WAVECPY
2207      P:000651 P:000651 06C900            DO      B0,WAVELP                         ; Copy the waveform; B0 is SERWAVLEN already
                            000655
2208      P:000653 P:000653 4CD800            MOVE                          Y:(R0)+,X0
2209      P:000654 P:000654 4C5F00            MOVE                          X0,Y:(R7)+
2210      P:000655 P:000655 000000            NOP
2211                                WAVELP
2212      P:000656 P:000656 000000            NOP
2213      P:000657 P:000657 00000C            RTS
2214   
2215                                ; Short function to set the correct bit in BINBIT based on NSBIN
2216                                ; Called only if NSBIN is less than 6.
2217   
2218                                SET_BINBIT
2219                                ;       MOVE    Y:<TESTLOC1,A0                  ; HACK - test if this code is executed
2220                                ;       INC     A                               ; HACK
2221                                ;       MOVE    A0,Y:<TESTLOC1                  ; HACK
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 45



2222      P:000658 P:000658 50F400            MOVE              #>1,A0                  ; Put a bit in A and shift to right spot
                            000001
2223      P:00065A P:00065A 060540            DO      Y:<NSBIN,BINLOOP                  ; Bit zero position not used, 1-5 used
                            00065C
2224      P:00065C P:00065C 200032            ASL     A
2225                                BINLOOP
2226      P:00065D P:00065D 507000            MOVE              A0,X:BINBIT             ; set bit 1-5 for SELECT_OUTPUT_SOURCE jump 
table
                            00001E
2227      P:00065F P:00065F 00000C            RTS
2228   
2229   
2230                                ; Set the number of rows and columns and binning factors
2231                                ;       Correct command ptr to R3 as per "Four Points" #2
2232                                SET_ROWS_COLUMNS
2233      P:000660 P:000660 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NSR = NAXIS1
2234      P:000661 P:000661 4C7000            MOVE                          X0,Y:NSR
                            000001
2235      P:000663 P:000663 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NPR = NAXIS2
2236      P:000664 P:000664 4C7000            MOVE                          X0,Y:NPR
                            000002
2237      P:000666 P:000666 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NSBIN
2238      P:000667 P:000667 4C7000            MOVE                          X0,Y:NSBIN
                            000005
2239      P:000669 P:000669 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the NPBIN
2240      P:00066A P:00066A 4C7000            MOVE                          X0,Y:NPBIN
                            000006
2241      P:00066C P:00066C 4CBB00            MOVE                          Y:<AMPVAL,X0 ; Get ampval in X0 for SOS call
2242      P:00066D P:00066D 0D032C            JSR     <SELECT_OUTPUT_SOURCE             ; Update serial read waveform in case binnin
g changed
2243      P:00066E P:00066E 0C008F            JMP     <FINISH                           ; no error return possible
2244   
2245                                ; Set the variables for the time-resolved modes
2246                                ;       Correct command ptr to R3 as per "Four Points" #2
2247                                SET_IMAGE_PARAM
2248      P:00066F P:00066F 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Image mode
2249      P:000670 P:000670 447000            MOVE              X0,X:IMAGE_MODE
                            000080
2250      P:000672 P:000672 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Iframes = NAXIS3
2251      P:000673 P:000673 4C7000            MOVE                          X0,Y:IFRAMES
                            000038
2252      P:000675 P:000675 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Srows
2253      P:000676 P:000676 4C7000            MOVE                          X0,Y:SROWS
                            000036
2254      P:000678 P:000678 44DB00            MOVE              X:(R3)+,X0              ; Set the value of the Interval
2255                                ;       MOVE    X0,Y:INTERVAL           ; HACK - Using Interval as a test location
2256      P:000679 P:000679 0C008F            JMP     <FINISH
2257   
2258   
2259                                ; Set the hardware trigger bit, executed as a command
2260                                ;       Correct command ptr to R3 as per "Four Points" #2
2261                                ; Disable h/w trigger and return error (for now) as per June 30, #8
2262                                ; Disabled temporarily for LMI as well.
2263                                SET_TRIGGER
2264      P:00067A P:00067A 44DB00            MOVE              X:(R3)+,X0              ; Get the trigger value
2265      P:00067B P:00067B 56F400            MOVE              #'_ON',A
                            5F4F4E
2266      P:00067D P:00067D 200045            CMP     X0,A
2267      P:00067E P:00067E 0AF0A2            JNE     NO_TRIGGER
                            000681
2268                                ;       JSET    #11,X:PBD,TRIG_CLR      ; Is Trigger running?
2269      P:000680 P:000680 0C008D            JMP     <ERROR                            ; Yes! report Error!  Why do this?
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 46



2270                                ;TRIG_CLR
2271                                ;       BSET    #TRIGGER,X:<STATUS      ; Set status bit, hardware trigger
2272                                ;       JMP     <FINISH
2273                                NO_TRIGGER
2274      P:000681 P:000681 0A0008            BCLR    #TRIGGER,X:<STATUS                ; Clear Status bit, software timing
2275      P:000682 P:000682 0C008F            JMP     <FINISH
2276   
2277                                ; Calculate the fast read parameters for each readout box
2278                                SETUP_SUBROUTINE
2279      P:000683 P:000683 4C8A00            MOVE                          Y:<SERWAVLEN,X0 ; # of waveforms
2280      P:000684 P:000684 4D9100            MOVE                          Y:<NSERIALS_READ,X1 ; Number of pixels to read
2281      P:000685 P:000685 0D0785            JSR     <FASTSKP                          ; Compute number of clocks required
2282      P:000686 P:000686 4D1400            MOVE                          X1,Y:<NREAD ; Number of waveforms per line
2283      P:000687 P:000687 5E9B00            MOVE                          Y:<NR_BIAS,A ; Number of pixels to read
2284      P:000688 P:000688 0A0085            JCLR    #SPLIT_S,X:STATUS,USPLS           ; Split serials require / 2
                            00068C
2285      P:00068A P:00068A 200022            ASR     A
2286      P:00068B P:00068B 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2287                                USPLS
2288      P:00068C P:00068C 21C500            MOVE              A,X1                    ; Number of waveforms per line
2289      P:00068D P:00068D 0D0785            JSR     <FASTSKP                          ; Compute number of clocks required
2290      P:00068E P:00068E 4D1600            MOVE                          X1,Y:<NBIAS ; Number of waveforms per line
2291      P:00068F P:00068F 44F400            MOVE              #(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT),X0 ; # of waveforms
                            000007
2292      P:000691 P:000691 4D8300            MOVE                          Y:<NS_CLR,X1 ; Number of pixels to skip
2293      P:000692 P:000692 0D0785            JSR     <FASTSKP                          ; Compute number of clocks required
2294      P:000693 P:000693 4D1200            MOVE                          X1,Y:<NSCLR ; Number of waveforms per line
2295      P:000694 P:000694 4D9800            MOVE                          Y:<NS_SKP1,X1 ; Number of pixels to skip
2296      P:000695 P:000695 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
2297      P:000696 P:000696 2000F0            MPY     Y1,X1,A
2298      P:000697 P:000697 200022            ASR     A
2299      P:000698 P:000698 210500            MOVE              A0,X1
2300      P:000699 P:000699 0D0785            JSR     <FASTSKP                          ; Compute number of clocks required
2301      P:00069A P:00069A 4D1300            MOVE                          X1,Y:<NSKIP1 ; Number of waveforms per line
2302      P:00069B P:00069B 4D9900            MOVE                          Y:<NS_SKP2,X1 ; Number of pixels to skip
2303      P:00069C P:00069C 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
2304      P:00069D P:00069D 2000F0            MPY     Y1,X1,A
2305      P:00069E P:00069E 200022            ASR     A
2306      P:00069F P:00069F 210500            MOVE              A0,X1
2307      P:0006A0 P:0006A0 0D0785            JSR     <FASTSKP                          ; Compute number of clocks required
2308      P:0006A1 P:0006A1 4D1500            MOVE                          X1,Y:<NSKIP2 ; Number of waveforms per line
2309      P:0006A2 P:0006A2 4D9700            MOVE                          Y:<NP_SKIP,X1
2310      P:0006A3 P:0006A3 4F8600            MOVE                          Y:<NPBIN,Y1
2311      P:0006A4 P:0006A4 2000F0            MPY     X1,Y1,A
2312      P:0006A5 P:0006A5 200022            ASR     A
2313      P:0006A6 P:0006A6 581700            MOVE                          A0,Y:<NP_SKIP
2314      P:0006A7 P:0006A7 00000C            RTS
2315   
2316                                ; Returns immediately if hardware triggering is not being used
2317                                ; Blocks until the trigger is found to be high twice in a row.
2318                                ; Waits until the trigger goes high
2319                                ; Trigger support disabled temporarily for LMI as well.
2320                                WAIT_UNTIL_TRIGGER
2321      P:0006A8 P:0006A8 0A0088            JCLR    #TRIGGER,X:STATUS,UNTIL_TRIGGER_RETURN
                            0006AD
2322      P:0006AA P:0006AA 000000            NOP
2323                                ;       JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER       ; Is Trigger Low?
2324      P:0006AB P:0006AB 000000            NOP                                       ; Pause
2325                                ;       JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER       ; Is Trigger still Low?
2326      P:0006AC P:0006AC 000000            NOP
2327                                UNTIL_TRIGGER_RETURN
2328      P:0006AD P:0006AD 00000C            RTS
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 47



2329   
2330                                ; Returns immediately if hardware triggering is not being used
2331                                ; Blocks until the trigger is found to be low twice in a row.
2332                                ; Waits while the trigger is high
2333                                ; Trigger support disabled temporarily for LMI as well.
2334                                WAIT_WHILE_TRIGGER
2335      P:0006AE P:0006AE 0A0088            JCLR    #TRIGGER,X:STATUS,WHILE_TRIGGER_RETURN
                            0006B3
2336      P:0006B0 P:0006B0 000000            NOP
2337                                ;       JSET    #11,X:PBD,WAIT_WHILE_TRIGGER       ; Is Trigger High?
2338      P:0006B1 P:0006B1 000000            NOP                                       ; Pause
2339                                ;       JSET    #11,X:PBD,WAIT_WHILE_TRIGGER       ; Is Trigger still High?
2340      P:0006B2 P:0006B2 000000            NOP
2341                                WHILE_TRIGGER_RETURN
2342      P:0006B3 P:0006B3 00000C            RTS
2343   
2344                                ; Like WAIT_WHILE_TRIGGER but clears the CCD while waiting
2345                                ; Pro:  Clears CCD while waiting.  Con: timing rattiness of 1 parallel time
2346                                ; Returns immediately if hardware triggering is not being used
2347                                ; Blocks until the trigger is found to be low twice in a row.
2348                                ; Waits while the trigger is high
2349                                ; Trigger support disabled temporarily for LMI as well.
2350                                CLEAR_WHILE_TRIGGER
2351      P:0006B4 P:0006B4 0A0088            JCLR    #TRIGGER,X:STATUS,CLEAR_TRIG_RETURN
                            0006B8
2352                                ;       MOVE    #IS_PAR_CLR,R0          ; Address of parallel transfer waveform
2353                                ;       JSR     <CLOCK                  ; Go clock out the CCD charge
2354                                ;       JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER       ; Is Trigger High?
2355      P:0006B6 P:0006B6 000000            NOP                                       ; Pause
2356                                ;       JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER      ; Is Trigger still High?
2357      P:0006B7 P:0006B7 000000            NOP
2358                                CLEAR_TRIG_RETURN
2359      P:0006B8 P:0006B8 00000C            RTS
2360   
2361                                ; Subroutine to compute SROWS in unbinned pixels and store in UBSROWS
2362   
2363                                UB_CONV
2364      P:0006B9 P:0006B9 4CB600            MOVE                          Y:<SROWS,X0
2365      P:0006BA P:0006BA 4D8600            MOVE                          Y:<NPBIN,X1 ; Adjust for for parallel binning factor
2366      P:0006BB P:0006BB 2000A0            MPY     X0,X1,A
2367      P:0006BC P:0006BC 200022            ASR     A
2368      P:0006BD P:0006BD 583700            MOVE                          A0,Y:<UBSROWS ; Put unbinned number in UBSROWS
2369      P:0006BE P:0006BE 00000C            RTS
2370   
2371                                ; Key code segments for the HIPO modes.
2372                                ; Jump table to the various modes - see also timhdr.s
2373                                START_FT_EXPOSURE
2374      P:0006BF P:0006BF 0A0008            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of lingering abort flag
2375      P:0006C0 P:0006C0 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2376      P:0006C2 P:0006C2 0AC421            JSET    #FIND,X0,SINGLE_PROC
                            0006F7
2377      P:0006C4 P:0006C4 0AC424            JSET    #SINGLE,X0,SINGLE_PROC
                            0006F7
2378                                ;       JSET    #SERIES,X0,SERIES_PROC        ; defunct.  Use basic occ.
2379      P:0006C6 P:0006C6 0AC420            JSET    #FDOTS,X0,FDOT_PROC
                            0006D1
2380      P:0006C8 P:0006C8 0AC422            JSET    #SDOTS,X0,SDOT_PROC               ; slow dots & strips use sdot_proc
                            00072F
2381      P:0006CA P:0006CA 0AC425            JSET    #STRIP,X0,SDOT_PROC
                            00072F
2382      P:0006CC P:0006CC 0AC427            JSET    #B_OCC,X0,SINGLE_PROC             ; basic occ uses single_proc
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 48



                            0006F7
2383                                ;        JSET    #F_OCC,X0,FPO_PROC             ; fast & pipelined occ use occ_proc
2384                                ;        JSET    #P_OCC,X0,FPO_PROC
2385      P:0006CE P:0006CE 44F400            MOVE              #'ERR',X0               ; error if not a valid mode
                            455252
2386      P:0006D0 P:0006D0 0C008D            JMP     <ERROR
2387   
2388                                FDOT_PROC                                           ; used by fdots only
2389                                ; Start by replacing SROWS (binned rows) with unbinned rows.  Will get rewritten on next SEX com
mand
2390                                ; Leave the DO loop in here - no reason to change it - won't exceed 65535 dots, for sure!
2391      P:0006D1 P:0006D1 0D06B9            JSR     UB_CONV                           ; Fill in unbinned SROWS
2392      P:0006D2 P:0006D2 4C8200            MOVE                          Y:<NPR,X0
2393      P:0006D3 P:0006D3 4C1D00            MOVE                          X0,Y:<NP_READ ; Make sure that NP_READ=NPR in case of su
bframe
2394      P:0006D4 P:0006D4 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
2395      P:0006D5 P:0006D5 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for FDOTS
2396      P:0006D6 P:0006D6 0A2020            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe bou
ndary
2397      P:0006D7 P:0006D7 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            000759
2398      P:0006D9 P:0006D9 0D02FB            JSR     <CLR_CCD                          ; Clear out the CCD
2399      P:0006DA P:0006DA 0D06AE            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2400                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2401      P:0006DB P:0006DB 0D079B            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2402      P:0006DC P:0006DC 063840            DO      Y:<IFRAMES,FDOT_LOOP              ; Loop over the number of FDOTS
                            0006ED
2403      P:0006DE P:0006DE 0A00A8            JSET    #TRIGGER,X:STATUS,FDX_END         ; If no triggering jump to expose image func
tion
                            0006E4
2404      P:0006E0 P:0006E0 67F400            MOVE              #FDX_END,R7             ; Store the Address into R7
                            0006E4
2405      P:0006E2 P:0006E2 0A0027            BSET    #ST_EXP,X:<STATUS
2406      P:0006E3 P:0006E3 0C0315            JMP     <EXPOSE                           ; Delay for specified exposure time
2407                                FDX_END
2408      P:0006E4 P:0006E4 0A0007            BCLR    #ST_EXP,X:<STATUS
2409      P:0006E5 P:0006E5 0A0088            JCLR    #ST_ABRT,X:<STATUS,FDX_NXT        ; got abort underway?
                            0006E9
2410      P:0006E7 P:0006E7 00008C            ENDDO
2411      P:0006E8 P:0006E8 0C06F5            JMP     <FDOT_FINI
2412                                FDX_NXT
2413      P:0006E9 P:0006E9 0D06A8            JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2414      P:0006EA P:0006EA 4DB700            MOVE                          Y:<UBSROWS,X1 ; Number of unbinned rows per shift
2415      P:0006EB P:0006EB 0D076C            JSR     <ISHIFT                           ; Clock out the waveforms
2416      P:0006EC P:0006EC 0D06AE            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2417      P:0006ED P:0006ED 000000            NOP
2418                                FDOT_LOOP
2419      P:0006EE P:0006EE 0D07A1            JSR     <C_CSHUT                          ; Conditionally close shutter
2420      P:0006EF P:0006EF 063840            DO      Y:<IFRAMES,FDOT_LP1               ; Loop over the number of FDOTS during reado
ut
                            0006F4
2421      P:0006F1 P:0006F1 0A0024            BSET    #ST_RDC,X:<STATUS
2422      P:0006F2 P:0006F2 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD
2423      P:0006F3 P:0006F3 0A0004            BCLR    #ST_RDC,X:<STATUS
2424      P:0006F4 P:0006F4 000000            NOP
2425                                FDOT_LP1
2426                                FDOT_FINI
2427                                ;       CLOSE SHUTTER if abt??
2428                                ;       JSR     <WAIT_UNTIL_TRIGGER             ; If taking more than one set of dots sync. trig
ger.  Vestigial?
2429      P:0006F5 P:0006F5 0AF080            JMP     CLEANUP                           ; clean up after command.
                            000761
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 49



2430   
2431                                SINGLE_PROC                                         ; Used by find, single, and basic occ
2432      P:0006F7 P:0006F7 0A2001            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for find & basic occ
2433      P:0006F8 P:0006F8 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2434      P:0006FA P:0006FA 0AC404            JCLR    #SINGLE,X0,NOT_SINGM              ; But if single mode,
                            0006FD
2435      P:0006FC P:0006FC 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
2436                                NOT_SINGM
2437   
2438                                ; Note: LMI uses both storage and img area for singles for maximum frame.
2439      P:0006FD P:0006FD 0A2002            BCLR    #STORAGE,X:<ISTATUS               ; Do the FT, no storage clocks only during r
eadout
2440      P:0006FE P:0006FE 0AC427            JSET    #B_OCC,X0,AN_OCC                  ; STORAGE=0 for basic, 1 otherwise
                            000701
2441      P:000700 P:000700 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't do the FT, ganged clocks only during
 readout
2442                                AN_OCC
2443   
2444      P:000701 P:000701 0A2000            BCLR    #NO_SKIP,X:<ISTATUS               ; Do parallel skip up to the subframe bounda
ry
2445                                          IF      @SCP("10","0")
2446                                          ELSE
2447      P:000702 P:000702 060A80            DO      #SDELAY,SNGL_DELAY1
                            000709
2448      P:000704 P:000704 44F400            MOVE              #25000,X0
                            0061A8
2449      P:000706 P:000706 06C400            DO      X0,SNGL_DELAY0
                            000708
2450      P:000708 P:000708 000000            NOP
2451                                 SNGL_DELAY0
2452      P:000709 P:000709 000000            NOP
2453                                 SNGL_DELAY1
2454      P:00070A P:00070A 000000            NOP
2455                                          ENDIF
2456   
2457      P:00070B P:00070B 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            000759
2458      P:00070D P:00070D 0D02FB            JSR     <CLR_CCD                          ; Clear out the CCD
2459      P:00070E P:00070E 0D06AE            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2460                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2461      P:00070F P:00070F 4CB800            MOVE                          Y:<IFRAMES,X0
2462      P:000710 P:000710 4C3C00            MOVE                          X0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
2463      P:000711 P:000711 0D079B  SN_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2464                                ;        JSET    #TRIGGER,X:STATUS,SNX_END       ; If no triggering jump to expose image functio
n
2465      P:000712 P:000712 67F400            MOVE              #SNX_END,R7             ; Store the Address into R7
                            000716
2466      P:000714 P:000714 0A0027            BSET    #ST_EXP,X:<STATUS
2467      P:000715 P:000715 0C0315            JMP     <EXPOSE                           ; Delay for specified exposure time
2468                                SNX_END
2469      P:000716 P:000716 0A0007            BCLR    #ST_EXP,X:<STATUS
2470      P:000717 P:000717 0A00A8            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                            000728
2471   
2472      P:000719 P:000719 0D06A8            JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2473      P:00071A P:00071A 0D07A1            JSR     <C_CSHUT                          ; Close shutter if open-close bit is set
2474      P:00071B P:00071B 0A0024            BSET    #ST_RDC,X:<STATUS
2475      P:00071C P:00071C 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD
2476      P:00071D P:00071D 0A0004            BCLR    #ST_RDC,X:<STATUS
2477      P:00071E P:00071E 0D06AE            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2478      P:00071F P:00071F 0A00A8            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 50



                            000728
2479      P:000721 P:000721 200013            CLR     A
2480      P:000722 P:000722 58BC00            MOVE                          Y:<IFLPCNT,A0
2481      P:000723 P:000723 00000A            DEC     A                                 ; Get loop count, decrement, and loop till z
ero
2482      P:000724 P:000724 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2483      P:000725 P:000725 583C00            MOVE                          A0,Y:<IFLPCNT
2484      P:000726 P:000726 200003            TST     A
2485      P:000727 P:000727 0E2711            JNE     SN_LP                             ; End of IFRAMES loop
2486                                SNX_FINI
2487      P:000728 P:000728 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2488                                                                                    ; if you abort a find does the shutter close
?
2489      P:00072A P:00072A 0AC421            JSET    #FIND,X0,SNX_DONE
                            00072D
2490      P:00072C P:00072C 0D07A3            JSR     <CSHUT                            ; Close the shutter unless in find mode
2491                                SNX_DONE
2492      P:00072D P:00072D 0AF080            JMP     CLEANUP                           ; clean up after command.
                            000761
2493   
2494                                ; NO abort support
2495                                SDOT_PROC                                           ; Used by slow dots and strips
2496      P:00072F P:00072F 4CB600            MOVE                          Y:<SROWS,X0
2497      P:000730 P:000730 4C1D00            MOVE                          X0,Y:<NP_READ ; Make sure that NP_READ=SROWS
2498      P:000731 P:000731 0A2001            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for strips
2499      P:000732 P:000732 44F000            MOVE              X:IMAGE_MODE,X0
                            000080
2500      P:000734 P:000734 0AC402            JCLR    #SDOTS,X0,SDOT_STORE              ; But if sdots mode,
                            000737
2501      P:000736 P:000736 0A2021            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
2502                                SDOT_STORE
2503      P:000737 P:000737 0A2022            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for SDOTS an
d strips
2504      P:000738 P:000738 0A2020            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe bou
ndary
2505      P:000739 P:000739 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                            000759
2506      P:00073B P:00073B 0D02FB            JSR     <CLR_CCD                          ; Clear out the CCD
2507      P:00073C P:00073C 0D06AE            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
2508                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2509      P:00073D P:00073D 4CB800            MOVE                          Y:<IFRAMES,X0
2510      P:00073E P:00073E 4C3C00            MOVE                          X0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
2511      P:00073F P:00073F 0D079B  SD_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
2512      P:000740 P:000740 0A00A8            JSET    #TRIGGER,X:STATUS,SDX_END         ; If no triggering jump to expose image func
tion
                            000749
2513      P:000742 P:000742 67F400            MOVE              #SDX_END,R7             ; Store the Address into R7
                            000749
2514      P:000744 P:000744 0A0027            BSET    #ST_EXP,X:<STATUS
2515      P:000745 P:000745 0C0315            JMP     <EXPOSE                           ; Delay for specified exposure time
2516      P:000746 P:000746 0A0007            BCLR    #ST_EXP,X:<STATUS
2517      P:000747 P:000747 0A00A8            JSET    #ST_ABRT,X:<STATUS,SDX_FINI       ; got abort underway?
                            000756
2518      P:000749 P:000749 0D06A8  SDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
2519      P:00074A P:00074A 0D07A1            JSR     <C_CSHUT                          ; Close shutter if open-close is set
2520      P:00074B P:00074B 0A0024            BSET    #ST_RDC,X:<STATUS
2521      P:00074C P:00074C 0D022D            JSR     <RDCCD                            ; Finally, read out the CCD.
2522      P:00074D P:00074D 0A0004            BCLR    #ST_RDC,X:<STATUS
2523                                                                                    ; No FT or parallel skip since STORAGE=1
2524      P:00074E P:00074E 0D06AE            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
2525      P:00074F P:00074F 200013            CLR     A
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 51



2526      P:000750 P:000750 58BC00            MOVE                          Y:<IFLPCNT,A0
2527      P:000751 P:000751 00000A            DEC     A                                 ; Get loop count, decrement, and loop till z
ero
2528      P:000752 P:000752 000000            NOP
2529      P:000753 P:000753 583C00            MOVE                          A0,Y:<IFLPCNT
2530      P:000754 P:000754 200003            TST     A
2531      P:000755 P:000755 0E273F            JNE     SD_LP                             ; End of IFRAMES loop
2532                                SDX_FINI
2533      P:000756 P:000756 0D07A3            JSR     <CSHUT                            ; Unconditionally close shutter
2534      P:000757 P:000757 0AF080            JMP     CLEANUP                           ; clean up after command.
                            000761
2535   
2536                                ; Fast/Pipeline Occultations NOT supported- LMI isn't a fast camera
2537                                        COMMENT *
2538   
2539                                FPO_PROC                                        ; Used by fast and pipelined occultation modes
2540                                        MOVE    Y:<NP_READ,X0
2541                                        MOVE    X0,Y:<SROWS                     ; Make sure that SROWS=NP_READ
2542                                        JSR     UB_CONV                         ; Fill in unbinned SROWS in UBSROWS
2543                                        BCLR    #OPEN_CLOSE,X:<ISTATUS          ; clear open-close for both of these modes
2544                                        BCLR    #STORAGE,X:<ISTATUS             ; Storage clocks only during readout
2545                                        BSET    #NO_SKIP,X:<ISTATUS             ; Don't parallel skip up to the subframe boundar
y
2546                                        JSR     IMG_INI                         ; Set up the status bits and PCI card
2547                                        JSR     <CLR_CCD                        ; Clear out the CCD
2548                                        JSR     <WAIT_WHILE_TRIGGER             ; wait for low trigger, or
2549                                ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
2550                                        JSR     <C_OSHUT                        ; Open shutter if not a dark frame
2551                                        MOVE    Y:<IFRAMES,X0
2552                                        MOVE    X0,Y:<IFLPCNT                   ; Set up 24-bit loop counter in IFLPCNT
2553                                FP_LP   JSET    #TRIGGER,X:STATUS,FPO_END       ; If no triggering jump to expose image function
2554                                        MOVE    #FPO_END,R7                     ; Store the Address into R7
2555                                        BSET    #ST_EXP,X:<STATUS
2556                                        JMP     <EXPOSE                         ; Delay for specified exposure time
2557                                        BCLR    #ST_EXP,X:<STATUS
2558                                        JSET    #ST_ABRT,X:<STATUS,FPO_FINI     ; got abort underway?
2559                                FPO_END JSR     <WAIT_UNTIL_TRIGGER             ; wait for high trigger or fall through
2560                                        MOVE    Y:<UBSROWS,X1                   ; Shift down UBSROWS unbinned rows
2561                                        JSR     ISHIFT                          ; Clock down subframe height
2562                                        MOVE    X:IMAGE_MODE,X0
2563                                        JSET    #P_OCC,X0,FPO_RD        ; Shift the rest of the way for F_OCC
2564                                                                                ; Go straight to readout if P_OCC
2565                                        MOVE    Y:S_SIZE,X0
2566                                        MOVE    X0,A                            ; Get only least significant 24 bits
2567                                        MOVE    Y:<UBSROWS,X0
2568                                        SUB     X0,A                            ;
2569                                        NOP                                     ; 56300 pipeline as per July 5 #4
2570                                        MOVE    A,X1                            ; X1 = S_SIZE - UBSROWS
2571                                        JSR     SSHIFT                          ; Clock storage the rest of the way
2572                                        BSET    #ST_RDC,X:<STATUS
2573                                FPO_RD  JSR     <RCCD1                          ; Finally, read out the CCD.  Skip the FT
2574                                        BCLR    #ST_RDC,X:<STATUS
2575                                        MOVE    X:IMAGE_MODE,X0
2576                                        JSET    #F_OCC,X0,FPO_SK        ; Shift back up by UBSROWS if P_OCC
2577                                        MOVE    Y:<UBSROWS,X1                   ; Shift UBSROWS unbinned rows back up
2578                                        JSR     RSHIFT                          ; Clock subframe height back up
2579                                FPO_SK  JSR     <WAIT_WHILE_TRIGGER             ; wait for low trigger
2580                                        CLR     A
2581                                        MOVE    Y:<IFLPCNT,A0
2582                                        DEC     A                               ; Get loop count, decrement, and loop till zero
2583                                        NOP                                     ; 56300 pipeline as per July 5 #4
2584                                        MOVE    A0,Y:<IFLPCNT
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 52



2585                                        TST     A
2586                                        JNE     FP_LP                           ; End of IFRAMES loop
2587                                FPO_FINI
2588                                        JSR     <CSHUT                          ; Unconditionally close shutter
2589                                        JMP     CLEANUP                         ; clean up after command.
2590                                        *
2591   
2592                                ; Support subroutines and code fragments used in the various mode code
2593                                ; IMG_INI, CLEANUP, ISHIFT, SSHIFT, RSHIFT
2594                                ;  Image initialization subroutine.  Sets up status bits & PCI card
2595                                ; Correct XMT_FO to XMT_WRD in timboot.s and change the input arg to B1
2596                                ; as per "Four Points" #3
2597   
2598      P:000759 P:000759 55F400  IMG_INI   MOVE              #$020102,B1             ; Transmit header word
                            020102
2599      P:00075B P:00075B 0D00EB            JSR     <XMT_WRD
2600      P:00075C P:00075C 55F400            MOVE              #'IIA',B1               ; Initialize Image Address
                            494941
2601      P:00075E P:00075E 0D00EB            JSR     <XMT_WRD
2602                                ;        BSET    #ST_RDC,X:<STATUS       ; Set status to reading out
2603      P:00075F P:00075F 0D08DB            JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
2604      P:000760 P:000760 00000C            RTS
2605   
2606                                ; Cleanup code fragment (not a subroutine) for the end all modes.  JMP to it.
2607                                ; remove WW mode reference and also do a CLOCK wait.
2608                                ; support no idling mode as per MLO code.
2609                                ; all as per July 4 confluence #1
2610   
2611                                ;CLEANUP BCLR    #WW,X:PBD               ; Clear WW to 0 for 32-bit commands
2612                                CLEANUP
2613   
2614                                ; Restore the controller to non-image data transfer and idling if necessary
2615      P:000761 P:000761 0A0082            JCLR    #IDLMODE,X:<STATUS,NO_IDL         ; Don't idle after readout
                            000766
2616      P:000763 P:000763 60F400            MOVE              #IDLE,R0
                            000307
2617      P:000765 P:000765 0C0767            JMP     <CLEAN1
2618      P:000766 P:000766 305A00  NO_IDL    MOVE              #TST_RCV,R0
2619                                CLEAN1
2620      P:000767 P:000767 0BF080            JSR     CLOCK_WAIT                        ; so everything is transferred
                            00077A
2621      P:000769 P:000769 601F00            MOVE              R0,X:<IDL_ADR
2622   
2623                                ;        BCLR    #ST_RDC,X:<STATUS       ; Clear status to NOT reading out
2624      P:00076A P:00076A 0A0008            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of any abort flag
2625      P:00076B P:00076B 0C0054            JMP     <START                            ; Wait for a new command
2626   
2627                                ; Shift image and storage areas down by the number of rows in X1
2628                                ISHIFT
2629                                ; NO IMO for LMI
2630                                ;       IF      @SCP("IMOMODE","IMO")
2631                                ;       MOVE    #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2632                                ;       JSR     <CLOCK                  ; IMO
2633                                ;       NOP                             ; IMO
2634                                ;       ENDIF
2635   
2636      P:00076C P:00076C 06C500            DO      X1,ISH_LOOP                       ; Number of rows to shift is in X1
                            000771
2637      P:00076E P:00076E 68F000            MOVE                          Y:IS_PAR_CLR,R0 ; Ganged clocks with DG running
                            00000F
2638                                ; mitigation 5
2639                                ;        JSET    #STORAGE,X:ISTATUS,GANG_SF  ; if STORAGE == 0 store clocks only
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timmisc.s  Page 53



2640                                ;GANG_SF
2641   
2642      P:000770 P:000770 0D02E0            JSR     <CLOCK                            ; Parallel clocking
2643      P:000771 P:000771 000000            NOP
2644                                ISH_LOOP
2645      P:000772 P:000772 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                            0001E2
2646      P:000774 P:000774 0D02E0            JSR     <CLOCK
2647                                ;       MOVE    #<IMO_LAST_CLOCK,R0             ; set clocks to 0
2648                                ;       JSR     <CLOCK
2649      P:000775 P:000775 00000C            RTS                                       ; End of ISHIFT
2650   
2651                                        COMMENT *
2652                                ; Shift storage area only down by the number of rows in X1
2653                                SSHIFT
2654                                ; NO IMO for LMI
2655                                ;       IF      @SCP("IMOMODE","IMO")
2656                                ;       MOVE    #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2657                                ;       JSR     <CLOCK                  ; IMO
2658                                ;       NOP                             ; IMO
2659                                ;       ENDIF
2660                                        DO      X1,SSH_LOOP             ; Number of rows to shift is in X1
2661                                        MOVE    Y:<S_PAR_CLR,R0         ; Storage clocks only with DG running
2662                                        JSR     <CLOCK                  ; Parallel clocking
2663                                        NOP
2664                                SSH_LOOP
2665                                        MOVE    #DUMP_SERIAL,R0         ; clear the SR after parallel clear
2666                                        JSR     <CLOCK
2667                                        RTS                     ; End of SSHIFT
2668   
2669                                ; Used by pipelined occultation mode to move the storage area back up to
2670                                ; the seam following read of a subframe
2671                                RSHIFT
2672                                        IF      @SCP("IMOMODE","IMO")
2673                                        MOVE    #<IMO_FIRST_CLOCK,R0    ; IMO initial long clock here
2674                                        JSR     <CLOCK                  ; IMO
2675                                        NOP                             ; IMO
2676                                        ENDIF
2677                                        DO      X1,RVS_SHIFT            ; Number of rows to read out
2678                                        MOVE    #<R_S_PARALLEL,R0       ; Reverse parallel waveform
2679                                        JSR     <CLOCK                  ; Parallel clocking
2680                                        NOP
2681                                RVS_SHIFT
2682                                        RTS                     ; End of RSHIFT
2683                                        *
2684                                          INCLUDE "timCCDmisc.s"                    ; Generic
2685                                ; This file is for utilities that are in common to all the timing board
2686                                ;   programs, located starting at P:$200 in external SRAM
2687   
2688                                        COMMENT *
2689   
2690                                The following commands are supported in this "timmisc.s" file
2691                                PAL_DLY                 Subroutine to delay by about 8 microseconds
2692                                SET_DAC                 Transfer DAC values in (R0) table to the DACs
2693                                FASTSKP                 Compute number of waveform table entries in a readout
2694                                                                for fast clocking
2695                                OSHUT                   Subroutine call for opening the shutter
2696                                CSHUT                   Subroutine call for closing the shutter
2697                                OPEN_SHUTTER            Command for opening the shutter
2698                                CLOSE_SHUTTER           Command for closing the shutter
2699                                SET_EXP_TIME            Write desired exposure time to timing board variable
2700                                RD_EXP_TIME             Read elapsed exposure time
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timCCDmisc.s  Page 54



2701                                START_EXPOSURE          Start an exposure - 'DON' reply, clear FPA, open
2702                                                        shutter, expose, close shutter, delay Y:SH_DLY, readout
2703                                PAUSE_EXPOSURE          Close shutter, stop exposure timer
2704                                RESUME_EXPOSURE         Open shutter if necessary, resume exposure timer
2705                                ABORT_EXPOSURE          Close shutter, stop exposure timer
2706                                INF                     Return version and timing information
2707                                IDL                     Put FPA to clocking when not processing commands or
2708                                                        reading out
2709                                READ_CONTROLLER_CONFIGURATION
2710   
2711                                PWR_OFF                 Turn off ananlog power supply voltages to backplane
2712                                PWR_ON                  Turn on analog power supply voltages to backplane
2713                                SETBIAS                 Command to call SET_BIASES and reply 'DON'
2714                                SET_BIASES              Subroutine to turn on all bias and clock voltages
2715                                                        by reading them from the waveform tables and writing
2716                                                        them to the DACs
2717                                SER_ANA                 Direct the timing board DSP's synchronous serial
2718                                                        transmitter to the analog boards (clock driver, video)
2719                                SER_UTL                 Direct the timing board DSP's synchronous serial
2720                                                        transmitter to the utility board
2721                                CLR_SWS                 Clear the analog switches in the clock driver and
2722                                                        video boards to lower their power consumption, as a
2723                                                        command with a 'DON' reply
2724                                CLEAR_SWITCHES          A subroutine call for CLR_WSW
2725                                ST_GAIN                 Set the video processor gain to one of four values
2726                                WR_CNTRL
2727                                SET_DC
2728                                SET_BIAS_NUMBER
2729                                SET_MUX
2730   
2731                                        *
2732   
2733                                ; These become a single line macros, as per June 30 #12
2734                                ; Enable serial communication to the analog boards
2735                                SER_ANA   MACRO
2736 m                                        BSET    #3,X:PCRD                         ; Turn on the serial clock
2737 m                                        ENDM
2738                                ; Enable serial communication to the utility board
2739                                SER_UTL   MACRO
2740 m                                        BCLR    #3,X:PCRD                         ; Turn off the serial clock
2741 m                                        ENDM
2742   
2743   
2744                                ; Delay for serial writes to the PALs and DACs by 8 microsec
2745                                ; Conformed to gen-iii MLO as per CCDmisc comments June 30 #1
2746      P:000776 P:000776 062083  PAL_DLY   DO      #800,*+3                          ; Wait 8 usec for serial data transmission
                            000778
2747      P:000778 P:000778 000000            NOP
2748      P:000779 P:000779 00000C            RTS
2749   
2750                                ; Wait for clocking to be complete before proceeding
2751                                ; Code added as per June 29 #5
2752                                CLOCK_WAIT
2753      P:00077A P:00077A 01ADA1            JSET    #SSFEF,X:PDRD,*                   ; Wait for the SS FIFO to be empty
                            00077A
2754      P:00077C P:00077C 00000C            RTS
2755   
2756   
2757   
2758                                ;  Update the DACs
2759                                ; Remove cruft as per June 30 #2
2760      P:00077D P:00077D 4CD800  SET_DAC   MOVE                          Y:(R0)+,X0  ; Get the number of table entries
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timCCDmisc.s  Page 55



2761      P:00077E P:00077E 06C400            DO      X0,SET_L0                         ; Repeat X0 times
                            000783
2762      P:000780 P:000780 5ED800            MOVE                          Y:(R0)+,A   ; Send out the waveform
2763      P:000781 P:000781 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
2764      P:000782 P:000782 0D0776            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
2765      P:000783 P:000783 000000            NOP                                       ; Do loop restriction
2766                                SET_L0
2767      P:000784 P:000784 00000C            RTS                                       ; Return from subroutine
2768   
2769                                ; Subroutine for computing number of fast clocks needed
2770                                ; remove the offset for gen-iii, as per June 30 general comment #3
2771      P:000785 P:000785 2000A8  FASTSKP   MPY     X0,X1,B                           ; X1 = number of pixels to skip,
2772                                                                                    ; X0 = number of waveform table entries
2773      P:000786 P:000786 20002A            ASR     B                                 ; Correct for multiplication left shift
2774      P:000787 P:000787 000000            NOP                                       ; 56300 pipeline as per July 5 #4
2775      P:000788 P:000788 212500            MOVE              B0,X1                   ; Get only least significant 24 bits
2776      P:000789 P:000789 00000C            RTS
2777   
2778                                ; open (X0 = 0) or close (X0=10) shutter, h/w only.
2779                                SET_SHUTTER_STATE
2780      P:00078A P:00078A 568F00            MOVE              X:LATCH,A
2781      P:00078B P:00078B 0140C6            AND     #$FFEF,A
                            00FFEF
2782      P:00078D P:00078D 200042            OR      X0,A
2783      P:00078E P:00078E 000000            NOP
2784      P:00078F P:00078F 540F00            MOVE              A1,X:LATCH
2785      P:000790 P:000790 09CC35            MOVEP             A1,Y:WRLATCH
2786      P:000791 P:000791 00000C            RTS
2787   
2788                                ; Open the shutter from the timing board, executed as a command
2789                                OPEN_SHUTTER
2790      P:000792 P:000792 0A0023            BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
2791      P:000793 P:000793 240000            MOVE              #0,X0
2792      P:000794 P:000794 0D078A            JSR     <SET_SHUTTER_STATE
2793      P:000795 P:000795 0C008F            JMP     <FINISH
2794   
2795                                ; Close the shutter from the timing board, executed as a command
2796                                CLOSE_SHUTTER
2797      P:000796 P:000796 0A0003            BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
2798      P:000797 P:000797 44F400            MOVE              #>$10,X0
                            000010
2799      P:000799 P:000799 0D078A            JSR     <SET_SHUTTER_STATE
2800      P:00079A P:00079A 0C008F            JMP     <FINISH
2801   
2802                                ; Subroutine with two entry points.  C_OSHUT is conditional on SHUT
2803                                ; Open the shutter conditionally based on the shutter status bit #SHUT
2804                                ; This is set by the host using dspwrm to the X:<STATUS unless the frame
2805                                ; is a dark
2806                                ; Open the shutter by calling SET_SHUTTER_STATE
2807                                C_OSHUT
2808      P:00079B P:00079B 0A008B            JCLR    #SHUT,X:STATUS,OSH_RTN
                            0007A0
2809                                OSHUT
2810      P:00079D P:00079D 0A0023            BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
2811      P:00079E P:00079E 240000            MOVE              #0,X0
2812      P:00079F P:00079F 0D078A            JSR     <SET_SHUTTER_STATE
2813      P:0007A0 P:0007A0 00000C  OSH_RTN   RTS
2814   
2815                                ; Subroutine with two entry points.  C_CSHUT is conditional on OPEN_CLOSE
2816                                ; Close the shutter conditionally based on the open-close ISTATUS bit
2817                                ; Close the shutter by calling SET_SHUTTER_STATE
2818      P:0007A1 P:0007A1 0A2081  C_CSHUT   JCLR    #OPEN_CLOSE,X:ISTATUS,CSH_RTN     ; Don't close if always open
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timCCDmisc.s  Page 56



                            0007B3
2819      P:0007A3 P:0007A3 0A0003  CSHUT     BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
2820      P:0007A4 P:0007A4 44F400            MOVE              #>$10,X0
                            000010
2821      P:0007A6 P:0007A6 0D078A            JSR     <SET_SHUTTER_STATE
2822   
2823                                ; after closing shutter be sure to wait SH_DEL msec to let the blades close
2824                                ; before shifting the CCD array for readout.
2825      P:0007A7 P:0007A7 5E8700            MOVE                          Y:<SH_DEL,A
2826      P:0007A8 P:0007A8 200003            TST     A
2827      P:0007A9 P:0007A9 0EF7B2            JLE     <S_DEL0
2828      P:0007AA P:0007AA 44F400            MOVE              #25000,X0
                            0061A8
2829      P:0007AC P:0007AC 06CE00            DO      A,S_DEL0                          ; Delay by Y:SH_DEL milliseconds
                            0007B1
2830      P:0007AE P:0007AE 06C400            DO      X0,S_DEL1
                            0007B0
2831      P:0007B0 P:0007B0 000000            NOP
2832      P:0007B1 P:0007B1 000000  S_DEL1    NOP
2833      P:0007B2 P:0007B2 000000  S_DEL0    NOP
2834   
2835      P:0007B3 P:0007B3 00000C  CSH_RTN   RTS
2836   
2837                                ; Set the desired exposure time
2838                                ;       Correct command ptr to R3 as per "Four Points" #2
2839                                ;       Modify exposure time var name as per June 30 #5
2840                                SET_EXP_TIME
2841      P:0007B4 P:0007B4 44DB00            MOVE              X:(R3)+,X0
2842      P:0007B5 P:0007B5 441000            MOVE              X0,X:<EXPOSURE_TIME
2843                                ;       MOVE    X0,X:<TGT_TIM
2844      P:0007B6 P:0007B6 0C008F            JMP     <FINISH
2845   
2846   
2847                                ; Abort exposure - close the shutter, stop the timer and resume idle mode
2848                                ; Modified to match gen-iii MLO code- as per June 30 #6
2849                                ABORT_EXPOSURE
2850      P:0007B7 P:0007B7 0A00A7            JSET    #ST_EXP,X:<STATUS,DO_ABEXP
                            0007BA
2851                                ; assume we got here via the idle rcv loop
2852                                ; not currently exposing, so this is a no-op.
2853      P:0007B9 P:0007B9 0C008F            JMP     <FINISH
2854                                DO_ABEXP
2855   
2856      P:0007BA P:0007BA 0D07A3            JSR     <CSHUT                            ; Close the shutter
2857      P:0007BB P:0007BB 010F00            BCLR    #TIM_BIT,X:TCSR0                  ; Disable the DSP exposure timer
2858   
2859                                ; The place to return must be in R7-
2860      P:0007BC P:0007BC 0AE780            JMP     (R7)                              ; 'return' from EXPOSE
2861   
2862   
2863   
2864                                ;       Process INF according to the single addressing parameter
2865                                ;       Correct FINISH1 datum as per "Four Points" #1
2866                                ;       Correct command ptr to R3 as per "Four Points" #2
2867                                GET_INFO
2868      P:0007BD P:0007BD 56DB00            MOVE              X:(R3)+,A               ; 0-4 is generic, >= 0x100 tim specific
2869                                ; Remove for gen-iii per June 6 #2
2870      P:0007BE P:0007BE 47F400            MOVE              #IVERSION,Y1
                            04507F
2871      P:0007C0 P:0007C0 46F400            MOVE              #>GET_VERSION,Y0
                            000000
2872      P:0007C2 P:0007C2 200055            CMP     Y0,A
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timCCDmisc.s  Page 57



2873      P:0007C3 P:0007C3 0EA090            JEQ     <FINISH1
2874                                ; Remove for gen-iii per June 6 #2
2875      P:0007C4 P:0007C4 47F400            MOVE              #IFLAVOR,Y1
                            612020
2876      P:0007C6 P:0007C6 46F400            MOVE              #>GET_FLAVOR,Y0
                            000001
2877      P:0007C8 P:0007C8 200055            CMP     Y0,A
2878      P:0007C9 P:0007C9 0EA090            JEQ     <FINISH1
2879      P:0007CA P:0007CA 47F400            MOVE              #ITIME0,Y1
                            0010E9
2880      P:0007CC P:0007CC 46F400            MOVE              #>GET_TIME0,Y0
                            000002
2881      P:0007CE P:0007CE 200055            CMP     Y0,A
2882      P:0007CF P:0007CF 0EA090            JEQ     <FINISH1                          ; Is it Time0?
2883      P:0007D0 P:0007D0 47F400            MOVE              #ITIME1,Y1
                            00502B
2884      P:0007D2 P:0007D2 46F400            MOVE              #>GET_TIME1,Y0
                            000003
2885      P:0007D4 P:0007D4 200055            CMP     Y0,A
2886      P:0007D5 P:0007D5 0EA090            JEQ     <FINISH1                          ; Is it Time1?
2887      P:0007D6 P:0007D6 270000            MOVE              #ISVNREV,Y1
2888      P:0007D7 P:0007D7 46F400            MOVE              #>GET_SVNREV,Y0
                            000004
2889      P:0007D9 P:0007D9 200055            CMP     Y0,A
2890      P:0007DA P:0007DA 0EA090            JEQ     <FINISH1                          ; Is it Svn rev?
2891      P:0007DB P:0007DB 47F400            MOVE              #TIMCAPABLE,Y1
                            0001CB
2892      P:0007DD P:0007DD 46F400            MOVE              #>GET_CAPABLE,Y0
                            000100
2893      P:0007DF P:0007DF 200055            CMP     Y0,A
2894      P:0007E0 P:0007E0 0EA090            JEQ     <FINISH1                          ; Is it Tim Capabilities?
2895      P:0007E1 P:0007E1 47F400            MOVE              #INT_TIM,Y1
                            0E0000
2896      P:0007E3 P:0007E3 46F400            MOVE              #>GET_INT_TIM,Y0
                            000101
2897      P:0007E5 P:0007E5 200055            CMP     Y0,A
2898      P:0007E6 P:0007E6 0EA090            JEQ     <FINISH1                          ; Is it Integration time?
2899      P:0007E7 P:0007E7 47F400            MOVE              #R_DELAY,Y1
                            000000
2900      P:0007E9 P:0007E9 46F400            MOVE              #>GET_R_DELAY,Y0
                            000102
2901      P:0007EB P:0007EB 200055            CMP     Y0,A
2902      P:0007EC P:0007EC 0EA090            JEQ     <FINISH1                          ; Is it Serial time?
2903      P:0007ED P:0007ED 47F400            MOVE              #SI_DELAY,Y1
                            A70000
2904      P:0007EF P:0007EF 46F400            MOVE              #>GET_SI_DELAY,Y0
                            000103
2905      P:0007F1 P:0007F1 200055            CMP     Y0,A
2906      P:0007F2 P:0007F2 0EA090            JEQ     <FINISH1                          ; Is it Parallel time?
2907      P:0007F3 P:0007F3 0C008D            JMP     ERROR                             ; unknown info argument
2908   
2909                                ; LMI does not use the thermocooler status bits
2910                                        COMMENT *
2911                                        MOVE    #>GET_TEMP2STS,Y0       ; Is it 2 bit temp status
2912                                        CMP     Y0,A
2913                                        JNE     <ERROR
2914                                        CLR     A
2915                                        JSET    #STS1,X:HDR,GET_STS0
2916                                        ADD     #<2,A
2917                                GET_STS0
2918                                        JSET    #STS0,X:HDR,RES_TEMPS
2919                                        ADD     #<1,A
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timCCDmisc.s  Page 58



2920                                RES_TEMPS
2921                                        NOP
2922                                        MOVE    A1,Y1
2923                                        JMP     <FINISH1
2924                                        *
2925   
2926   
2927                                ; Set software to IDLE mode
2928      P:0007F4 P:0007F4 44F400  IDL       MOVE              #IDLE,X0                ; Exercise clocks when idling
                            000307
2929      P:0007F6 P:0007F6 441F00            MOVE              X0,X:<IDL_ADR
2930      P:0007F7 P:0007F7 0A0022            BSET    #IDLMODE,X:<STATUS                ; Idle after readout
2931      P:0007F8 P:0007F8 0C008F            JMP     <FINISH                           ; Need to send header and 'DON'
2932   
2933                                ; Come to here on a 'STP' command so 'DON' can be sent
2934   
2935                                ; Let the host computer read the controller configuration
2936                                ;       Correct FINISH1 datum as per "Four Points" #1
2937                                READ_CONTROLLER_CONFIGURATION
2938      P:0007F9 P:0007F9 4F8800            MOVE                          Y:<CONFIG,Y1 ; Just transmit the configuration
2939      P:0007FA P:0007FA 0C0090            JMP     <FINISH1
2940   
2941                                ; Power off
2942      P:0007FB P:0007FB 0D0839  PWR_OFF   JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
2943      P:0007FC P:0007FC 0A8922            BSET    #LVEN,X:HDR
2944      P:0007FD P:0007FD 0A8923            BSET    #HVEN,X:HDR
2945      P:0007FE P:0007FE 0C008F            JMP     <FINISH
2946   
2947                                ; Start power-on cycle
2948                                PWR_ON
2949      P:0007FF P:0007FF 0D0839            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
2950      P:000800 P:000800 0D0811            JSR     <PON                              ; Turn on the power control board
2951      P:000801 P:000801 0A8980            JCLR    #PWROK,X:HDR,PWR_ERR              ; Test if the power turned on properly
                            00080E
2952      P:000803 P:000803 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                            000100
2953      P:000805 P:000805 0D0822            JSR     <SET_BIASES                       ; Turn on the DC bias supplies
2954      P:000806 P:000806 60F400            MOVE              #IDLE,R0                ; Put controller in IDLE state
                            000307
2955      P:000808 P:000808 601F00            MOVE              R0,X:<IDL_ADR
2956   
2957                                ;       as per Confluence July 4 2010 #5
2958      P:000809 P:000809 312400            MOVE              #$24,R1
2959      P:00080A P:00080A 610000            MOVE              R1,X:<STATUS
2960                                ;       as per Confluence July 4 2010 #4 and July 21 note
2961      P:00080B P:00080B 4CBB00            MOVE                          Y:<AMPVAL,X0
2962      P:00080C P:00080C 0D032C            JSR     <SELECT_OUTPUT_SOURCE
2963      P:00080D P:00080D 0C008F            JMP     <FINISH
2964   
2965                                ; The power failed to turn on because of an error on the power control board
2966      P:00080E P:00080E 0A8922  PWR_ERR   BSET    #LVEN,X:HDR                       ; Turn off the low voltage emable line
2967      P:00080F P:00080F 0A8923            BSET    #HVEN,X:HDR                       ; Turn off the high voltage emable line
2968      P:000810 P:000810 0C008D            JMP     <ERROR
2969   
2970                                ; As a subroutine, turn on the low voltages (+/- 6.5V, +/- 16.5V) and delay
2971      P:000811 P:000811 0A8902  PON       BCLR    #LVEN,X:HDR                       ; Set these signals to DSP outputs
2972      P:000812 P:000812 44F400            MOVE              #2000000,X0
                            1E8480
2973      P:000814 P:000814 06C400            DO      X0,*+3                            ; Wait 20 millisec for settling
                            000816
2974      P:000816 P:000816 000000            NOP
2975   
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timCCDmisc.s  Page 59



2976                                ; Turn on the high +36 volt power line and then delay
2977      P:000817 P:000817 0A8903            BCLR    #HVEN,X:HDR                       ; HVEN = Low => Turn on +36V
2978      P:000818 P:000818 44F400            MOVE              #2000000,X0
                            1E8480
2979      P:00081A P:00081A 06C400            DO      X0,*+3                            ; Wait 20 millisec for settling
                            00081C
2980      P:00081C P:00081C 000000            NOP
2981      P:00081D P:00081D 00000C            RTS
2982   
2983                                ; LMI does not need to set VRD2 or VRD3
2984                                        COMMENT *
2985                                ;prototype code- to set leds on gwaves
2986                                SETVRDS
2987                                        MOVE    X:(R3)+,X0
2988                                        CLR     A
2989                                        MOVE    X0,A
2990                                        AND     #$3FFF,A
2991                                        ADD     #VID0+DAC_RegD,A
2992                                        MOVE    X:(R3)+,X0
2993                                        MOVE    A1,Y:VRD2_V
2994                                        MOVE    X0,A
2995                                        AND     #$3FFF,A
2996                                        ADD     #VID0+DAC_RegD,A
2997                                        MOVE    #SET_VRD2_3,R0
2998                                        MOVE    A1,Y:VRD3_V
2999                                        JSR     <SET_BIASES
3000                                        JMP     <FINISH
3001                                        *
3002   
3003                                SETBIAS
3004      P:00081E P:00081E 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                            000100
3005      P:000820 P:000820 0D0822            JSR     <SET_BIASES
3006      P:000821 P:000821 0C008F            JMP     <FINISH
3007   
3008                                ; Set all the DC bias voltages and video processor offset values, reading
3009                                ;   them from the 'DACS' table provided in R0
3010                                SET_BIASES
3011                                          SER_ANA
3013      P:000823 P:000823 0A0F01            BCLR    #1,X:<LATCH                       ; Separate updates of clock driver
3014      P:000824 P:000824 0A0F20            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
3015      P:000825 P:000825 0A0F22            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
3016      P:000826 P:000826 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                            00000F
3017      P:000828 P:000828 0D0776            JSR     <PAL_DLY                          ; Delay for all this to happen
3018   
3019                                ; Read DAC values from a table, and write them to the DACs
3020      P:000829 P:000829 000000            NOP
3021      P:00082A P:00082A 065840            DO      Y:(R0)+,L_DAC                     ; Repeat Y:(R0)+ times
                            00082E
3022      P:00082C P:00082C 5ED800            MOVE                          Y:(R0)+,A   ; Read the table entry
3023      P:00082D P:00082D 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
3024      P:00082E P:00082E 000000            NOP
3025                                L_DAC
3026      P:00082F P:00082F 5E3D00            MOVE                          A,Y:<TESTLOC1 ; debug
3027   
3028                                ; Let the DAC voltages all ramp up before exiting
3029      P:000830 P:000830 44F400            MOVE              #400000,X0
                            061A80
3030      P:000832 P:000832 06C400            DO      X0,*+3                            ; 4 millisec delay
                            000834
3031      P:000834 P:000834 000000            NOP
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timCCDmisc.s  Page 60



3032                                          SER_UTL
3034      P:000836 P:000836 00000C            RTS
3035   
3036                                ; Enable serial communication to the analog boards
3037                                ; This becomes a single line macro above, as per June 30 #12
3038   
3039                                ;SER_ANA        BSET    #0,X:PBD                ; Set H0 for analog boards SSI
3040                                ;       MOVEP   #$0000,X:PCC            ; Software reset of SSI
3041                                ;       BCLR    #10,X:CRB               ; SSI -> continuous clock for analog
3042                                ;       MOVEP   #$0160,X:PCC            ; Re-enable the SSI
3043                                ;       RTS
3044   
3045                                ; Enable serial communication to the utility board
3046                                ; This becomes a single line macro above, as per June 30 #12
3047   
3048                                ;SER_UTL        MOVEP   #$0000,X:PCC            ; Software reset of SSI
3049                                ;       BSET    #10,X:CRB               ; SSI -> gated clock for util board
3050                                ;       MOVEP   #$0160,X:PCC            ; Enable the SSI
3051                                ;       BCLR    #0,X:PBD                ; Clear H0 for utility board SSI
3052                                ;       RTS
3053   
3054      P:000837 P:000837 0D0839  CLR_SWS   JSR     <CLEAR_SWITCHES
3055      P:000838 P:000838 0C008F            JMP     <FINISH
3056   
3057                                ; Clear all video processor analog switches to lower their power dissipation
3058                                CLEAR_SWITCHES
3059                                          SER_ANA
3061      P:00083A P:00083A 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                            0C3000
3062      P:00083C P:00083C 20001B            CLR     B
3063      P:00083D P:00083D 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC write
s
3064      P:00083E P:00083E 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writ
es
                            001000
3065      P:000840 P:000840 060F80            DO      #15,L_VIDEO                       ; Fifteen video processor boards maximum
                            000847
3066      P:000842 P:000842 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
3067      P:000843 P:000843 200040            ADD     X0,A
3068      P:000844 P:000844 5F7000            MOVE                          B,Y:WRSS
                            FFFFF3
3069      P:000846 P:000846 0D0776            JSR     <PAL_DLY                          ; Delay for the serial data transmission
3070      P:000847 P:000847 200068            ADD     X1,B
3071                                L_VIDEO
3072      P:000848 P:000848 0A0F00            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
3073      P:000849 P:000849 0A0F02            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
3074      P:00084A P:00084A 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                            00000F
3075                                          SER_UTL
3077      P:00084D P:00084D 00000C            RTS
3078   
3079                                ; Set the clock multiplexers
3080                                ;       Correct command ptr to R3 as per "Four Points" #2
3081                                SET_MUX
3082                                          SER_ANA                                   ; Set SSI to analog board communication
3084      P:00084F P:00084F 56DB00            MOVE              X:(R3)+,A               ; Clock driver board number
3085      P:000850 P:000850 0614A0            REP     #20
3086      P:000851 P:000851 200033            LSL     A
3087      P:000852 P:000852 44F400            MOVE              #$003000,X0
                            003000
3088      P:000854 P:000854 200042            OR      X0,A
3089      P:000855 P:000855 000000            NOP                                       ; 56300 pipeline as per July 5 #4
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timCCDmisc.s  Page 61



3090      P:000856 P:000856 21C500            MOVE              A,X1                    ; Move here for storage
3091   
3092                                ; Get the first MUX number
3093      P:000857 P:000857 56DB00            MOVE              X:(R3)+,A               ; Get the first MUX number
3094      P:000858 P:000858 0AF0A9            JLT     ERR_SM1
                            00089F
3095      P:00085A P:00085A 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                            000018
3096      P:00085C P:00085C 200045            CMP     X0,A
3097      P:00085D P:00085D 0AF0A1            JGE     ERR_SM1
                            00089F
3098      P:00085F P:00085F 21CF00            MOVE              A,B
3099      P:000860 P:000860 44F400            MOVE              #>7,X0
                            000007
3100      P:000862 P:000862 20004E            AND     X0,B
3101      P:000863 P:000863 44F400            MOVE              #>$18,X0
                            000018
3102      P:000865 P:000865 200046            AND     X0,A
3103      P:000866 P:000866 0E2869            JNE     <SMX_1                            ; Test for 0 <= MUX number <= 7
3104      P:000867 P:000867 0ACD63            BSET    #3,B1
3105      P:000868 P:000868 0C0874            JMP     <SMX_A
3106      P:000869 P:000869 44F400  SMX_1     MOVE              #>$08,X0
                            000008
3107      P:00086B P:00086B 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
3108      P:00086C P:00086C 0E286F            JNE     <SMX_2
3109      P:00086D P:00086D 0ACD64            BSET    #4,B1
3110      P:00086E P:00086E 0C0874            JMP     <SMX_A
3111      P:00086F P:00086F 44F400  SMX_2     MOVE              #>$10,X0
                            000010
3112      P:000871 P:000871 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
3113      P:000872 P:000872 0E289F            JNE     <ERR_SM1
3114      P:000873 P:000873 0ACD65            BSET    #5,B1
3115      P:000874 P:000874 20006A  SMX_A     OR      X1,B1                             ; Add prefix to MUX numbers
3116      P:000875 P:000875 000000            NOP                                       ; 56300 pipeline as per July 5 #4
3117      P:000876 P:000876 21A700            MOVE              B1,Y1
3118   
3119                                ; Add on the second MUX number
3120      P:000877 P:000877 56DB00            MOVE              X:(R3)+,A               ; Get the next MUX number
3121      P:000878 P:000878 0AF0A9            JLT     ERR_SM2
                            0008A0
3122      P:00087A P:00087A 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                            000018
3123      P:00087C P:00087C 200045            CMP     X0,A
3124      P:00087D P:00087D 0AF0A1            JGE     ERR_SM2
                            0008A0
3125      P:00087F P:00087F 0606A0            REP     #6
3126      P:000880 P:000880 200033            LSL     A
3127      P:000881 P:000881 44F400            MOVE              #$1C0,X0
                            0001C0
3128      P:000883 P:000883 21CF00            MOVE              A,B
3129      P:000884 P:000884 20004E            AND     X0,B
3130      P:000885 P:000885 44F400            MOVE              #>$600,X0
                            000600
3131      P:000887 P:000887 200046            AND     X0,A
3132      P:000888 P:000888 0E288B            JNE     <SMX_3                            ; Test for 0 <= MUX number <= 7
3133      P:000889 P:000889 0ACD69            BSET    #9,B1
3134      P:00088A P:00088A 0C0896            JMP     <SMX_B
3135      P:00088B P:00088B 44F400  SMX_3     MOVE              #>$200,X0
                            000200
3136      P:00088D P:00088D 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
3137      P:00088E P:00088E 0E2891            JNE     <SMX_4
3138      P:00088F P:00088F 0ACD6A            BSET    #10,B1
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timCCDmisc.s  Page 62



3139      P:000890 P:000890 0C0896            JMP     <SMX_B
3140      P:000891 P:000891 44F400  SMX_4     MOVE              #>$400,X0
                            000400
3141      P:000893 P:000893 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
3142      P:000894 P:000894 0E28A0            JNE     <ERR_SM2
3143      P:000895 P:000895 0ACD6B            BSET    #11,B1
3144      P:000896 P:000896 200078  SMX_B     ADD     Y1,B                              ; Add prefix to MUX numbers
3145                                ; change to match gen-iii, as per June 30, #14
3146      P:000897 P:000897 000000            NOP
3147      P:000898 P:000898 21AE00            MOVE              B1,A
3148      P:000899 P:000899 0140C6            AND     #$F01FFF,A                        ; Just to be sure
                            F01FFF
3149      P:00089B P:00089B 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
3150   
3151      P:00089C P:00089C 0D0776            JSR     <PAL_DLY                          ; Delay for all this to happen
3152                                          SER_UTL                                   ; Return SSI to utility board communication
3154      P:00089E P:00089E 0C008F            JMP     <FINISH
3155      P:00089F P:00089F 56DB00  ERR_SM1   MOVE              X:(R3)+,A
3156                                ERR_SM2
3157                                          SER_UTL                                   ; Return SSI to utility board communication
3159      P:0008A1 P:0008A1 0C008D            JMP     <ERROR
3160   
3161   
3162                                ; Set the video processor gain and integrator speed for all video boards
3163                                ; Now modified as per manual for ARC-47 (1E) video board and ARC-E2V57
3164                                ; sample code
3165                                ;  Command syntax is  SGN [ #BD]  #GAIN  #SPEED, #GAIN = 0-15 (1.0-4.75)
3166                                ;                                         #SPEED = 1-15
3167                                ;       Correct command ptr to R3 as per "Four Points" #2
3168                                ;  fixes to match gen-iii as per June 30, #15
3169                                ; replaced with ARC version for E2V57- except BD is set unconditionally
3170                                ; to 0 for backwards compatibility at the LOIS end.
3171                                ;
3172   
3173                                ST_GAIN
3174                                ;       MOVE    X:(R3)+,A       ; Board number
3175                                ;       LSL     #20,A
3176      P:0008A2 P:0008A2 200013            CLR     A                                 ; Video bd must be at 0.
3177      P:0008A3 P:0008A3 240D00            MOVE              #$0D0000,X0
3178      P:0008A4 P:0008A4 218500            MOVE              A1,X1
3179      P:0008A5 P:0008A5 200042            OR      X0,A
3180      P:0008A6 P:0008A6 44DB00            MOVE              X:(R3)+,X0              ; Gain
3181      P:0008A7 P:0008A7 200042            OR      X0,A
3182                                ;
3183      P:0008A8 P:0008A8 000000            NOP
3184      P:0008A9 P:0008A9 5E7000            MOVE                          A,Y:DAC_GNSPD
                            000133
3185                                ;        JSR     <XMIT_A_WORD    ; Transmit A to TIM-A-STD
3186   
3187      P:0008AB P:0008AB 56DB00            MOVE              X:(R3)+,A               ; Time constant (speed)
3188      P:0008AC P:0008AC 0C1E88            LSL     #4,A
3189      P:0008AD P:0008AD 200062            OR      X1,A1                             ; Board number is in bits #23-20
3190      P:0008AE P:0008AE 44F400            MOVE              #$0C0100,X0
                            0C0100
3191      P:0008B0 P:0008B0 200042            OR      X0,A
3192      P:0008B1 P:0008B1 000000            NOP
3193      P:0008B2 P:0008B2 5E3D00            MOVE                          A,Y:<TESTLOC1 ; debug
3194      P:0008B3 P:0008B3 5E7000            MOVE                          A,Y:DAC_GNSPD+1
                            000134
3195                                ;        JSR     <XMIT_A_WORD    ; Transmit A to TIM-A-STD
3196      P:0008B5 P:0008B5 0C008F            JMP     <FINISH
3197   
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timCCDmisc.s  Page 63



3198   
3199                                ; traditional gain-speed code
3200                                        COMMENT *
3201   
3202                                ;       SER_ANA ; Set SSI to analog board communication
3203                                        MOVE    X:(R3)+,A       ; Gain value (1,2,5 or 10)
3204                                ; making this a no-op for now
3205                                        MOVE    X:(R3)+,A       ; Gain value (1,2,5 or 10)
3206                                        JMP     <FINISH
3207                                        MOVE    #>1,X0
3208                                        CMP     X0,A            ; Check for gain = x1
3209                                        JNE     <STG2
3210                                        MOVE    #>$77,B
3211                                        JMP     <STG_A
3212                                STG2    MOVE    #>2,X0          ; Check for gain = x2
3213                                        CMP     X0,A
3214                                        JNE     <STG5
3215                                        MOVE    #>$BB,B
3216                                        JMP     <STG_A
3217                                STG5    MOVE    #>5,X0          ; Check for gain = x5
3218                                        CMP     X0,A
3219                                        JNE     <STG10
3220                                        MOVE    #>$DD,B
3221                                        JMP     <STG_A
3222                                STG10   MOVE    #>10,X0         ; Check for gain = x10
3223                                        CMP     X0,A
3224                                        JNE     <ERROR
3225                                        MOVE    #>$EE,B
3226   
3227                                STG_A   MOVE    X:(R3)+,A       ; Integrator Speed (0 for slow, 1 for fast)
3228                                        NOP
3229                                        JCLR    #0,A1,STG_B
3230                                        BSET    #8,B1
3231                                        NOP
3232                                        BSET    #9,B1
3233                                STG_B   MOVE    #$0C3C00,X0
3234                                        OR      X0,B
3235                                        NOP
3236                                        MOVE    B,Y:<GAIN       ; Store the GAIN value for later us
3237   
3238                                ; Send this same value to 15 video processor boards whether they exist or not
3239                                        MOVE    #$100000,X0     ; Increment value
3240                                        DO      #15,STG_LOOP
3241                                        MOVE    B1,A1
3242                                        JSR     <XMIT_A_WORD    ; Transmit A to TIM-A-STD
3243   
3244                                ;       MOVE    B,X:SSITX       ; Transmit the SSI word
3245                                        JSR     <PAL_DLY        ; Wait for SSI and PAL to be empty
3246                                        ADD     X0,B            ; Increment the video processor board number
3247                                        NOP
3248                                STG_LOOP
3249   
3250                                        SER_UTL                 ; Return SSI to utility board communication
3251                                        JMP     <FINISH
3252                                        *
3253   
3254   
3255                                ; Specify subarray readout coordinates, one rectangle only
3256                                ; Call this subroutine BEFORE SET_SUBARRAY_POSITIONS since it
3257                                ; initializes NBOXES
3258                                ;       Correct command ptr to R3 as per "Four Points" #2
3259                                SET_SUBARRAY_SIZES
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timCCDmisc.s  Page 64



3260      P:0008B6 P:0008B6 200013            CLR     A
3261      P:0008B7 P:0008B7 44DB00            MOVE              X:(R3)+,X0
3262      P:0008B8 P:0008B8 5E1A00            MOVE                          A,Y:<NBOXES ; Number of subimage boxes = 0 to start
3263      P:0008B9 P:0008B9 4C1B00            MOVE                          X0,Y:<NR_BIAS ; Number of bias pixels to read
3264      P:0008BA P:0008BA 44DB00            MOVE              X:(R3)+,X0
3265      P:0008BB P:0008BB 4C1C00            MOVE                          X0,Y:<NS_READ ; Number of columns in subimage read
3266      P:0008BC P:0008BC 44DB00            MOVE              X:(R3)+,X0
3267      P:0008BD P:0008BD 4C1D00            MOVE                          X0,Y:<NP_READ ; Number of rows in subimage read
3268      P:0008BE P:0008BE 0C008F            JMP     <FINISH
3269   
3270                                ; Call this routine once for every subarray to be added to the table
3271                                ; Note that the way the variables are arranged the subframes all are the
3272                                ; same dimensions.  They also cannot overlap in the row direction.
3273                                ; SET_SUBARRAY_SIZES must be called first to initialize NBOXES
3274                                SET_SUBARRAY_POSITIONS
3275      P:0008BF P:0008BF 4C9A00            MOVE                          Y:<NBOXES,X0 ; Next available slot
3276      P:0008C0 P:0008C0 459400            MOVE              X:<THREE,X1
3277      P:0008C1 P:0008C1 2000A0            MPY     X0,X1,A
3278      P:0008C2 P:0008C2 200022            ASR     A
3279      P:0008C3 P:0008C3 210C00            MOVE              A0,A1
3280                                ; PARAMETERIZE
3281      P:0008C4 P:0008C4 44F400            MOVE              #>21,X0
                            000015
3282      P:0008C6 P:0008C6 200045            CMP     X0,A
3283      P:0008C7 P:0008C7 0E708D            JGT     <ERROR                            ; Error if number of boxes > 9
3284      P:0008C8 P:0008C8 44F400            MOVE              #READ_TABLE,X0
                            00001E
3285      P:0008CA P:0008CA 200040            ADD     X0,A
3286      P:0008CB P:0008CB 44DB00            MOVE              X:(R3)+,X0
3287      P:0008CC P:0008CC 219700            MOVE              A1,R7
3288      P:0008CD P:0008CD 000000            NOP
3289      P:0008CE P:0008CE 000000            NOP
3290      P:0008CF P:0008CF 000000            NOP
3291      P:0008D0 P:0008D0 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of rows (parallels) to clear
3292      P:0008D1 P:0008D1 44DB00            MOVE              X:(R3)+,X0
3293      P:0008D2 P:0008D2 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears before
3294      P:0008D3 P:0008D3 44DB00            MOVE              X:(R3)+,X0              ;  the box readout
3295      P:0008D4 P:0008D4 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears after
3296      P:0008D5 P:0008D5 5E9A00            MOVE                          Y:<NBOXES,A ;  the box readout
3297      P:0008D6 P:0008D6 449200            MOVE              X:<ONE,X0
3298      P:0008D7 P:0008D7 200040            ADD     X0,A                              ; Update the next available slot position
3299      P:0008D8 P:0008D8 000000            NOP
3300      P:0008D9 P:0008D9 5E1A00            MOVE                          A,Y:<NBOXES
3301      P:0008DA P:0008DA 0C008F            JMP     <FINISH
3302   
3303                                ; Alert the PCI interface board that images are coming soon
3304                                ; This tells the PCI card how many pixels to expect for each SEX command
3305                                ; This is fairly complex.  The first value sent is NPR*IFRAMES (NAXIS2*NAXIS3).
3306                                ; The second value is NSR aka NAXIS1, but if NBOXES > 0, it is NSR*NBOXES
3307                                ; this matches nasa42, but since naxis1,2 for a full frame is > 2^12
3308                                ; there's a max of 1024 for IFRAMES. If we used an adaptive algorithm we
3309                                ; could do better.
3310                                ; Meantime LOIS will have to enforce these limits.
3311   
3312                                ; Correct XMT_FO to XMT_WRD in timboot.s and change the input arg to B1
3313                                ; as per "Four Points" #3
3314                                PCI_READ_IMAGE
3315      P:0008DB P:0008DB 55F400            MOVE              #$020104,B1             ; Send header word to the FO transmitter
                            020104
3316      P:0008DD P:0008DD 0D00EB            JSR     <XMT_WRD
3317      P:0008DE P:0008DE 55F400            MOVE              #'RDA',B1
                            524441
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  timCCDmisc.s  Page 65



3318      P:0008E0 P:0008E0 0D00EB            JSR     <XMT_WRD
3319      P:0008E1 P:0008E1 4CF000            MOVE                          Y:NPR,X0    ; NPR = NAXIS2
                            000002
3320      P:0008E3 P:0008E3 4DF000            MOVE                          Y:IFRAMES,X1 ; IFRAMES = NAXIS3
                            000038
3321      P:0008E5 P:0008E5 2000A8            MPY     X0,X1,B
3322      P:0008E6 P:0008E6 20002A            ASR     B                                 ; Correct for multiplication left shift
3323      P:0008E7 P:0008E7 212D00            MOVE              B0,B1
3324      P:0008E8 P:0008E8 0D00EB            JSR     <XMT_WRD                          ; Send NPR*IFRAMES to PCI card
3325      P:0008E9 P:0008E9 4CF000            MOVE                          Y:NSR,X0    ; NSR = NAXIS1
                            000001
3326      P:0008EB P:0008EB 5E9A00            MOVE                          Y:<NBOXES,A ; If NBOXES = 0, transmit that to PCI
3327      P:0008EC P:0008EC 208D00            MOVE              X0,B1
3328      P:0008ED P:0008ED 200003            TST     A
3329      P:0008EE P:0008EE 0AF0AA            JEQ     XMT
                            0008F4
3330      P:0008F0 P:0008F0 4D9A00            MOVE                          Y:<NBOXES,X1 ; If NBOXES = 0, transmit that to PCI
3331      P:0008F1 P:0008F1 2000A8            MPY     X0,X1,B                           ; If not, multiply by NBOXES, then send
3332      P:0008F2 P:0008F2 20002A            ASR     B                                 ; Correct for multiplication left shift
3333      P:0008F3 P:0008F3 212D00            MOVE              B0,B1                   ; Get only least significant 24 bits
3334      P:0008F4 P:0008F4 000000  XMT       NOP
3335      P:0008F5 P:0008F5 0D00EB            JSR     <XMT_WRD
3336      P:0008F6 P:0008F6 00000C            RTS
3337   
3338                                 TIMBOOT_X_MEMORY
3339      0008F7                              EQU     @LCV(L)
3340   
3341                                ;  ****************  Setup memory tables in X: space ********************
3342   
3343                                ; Define the address in P: space where the table of constants begins
3344   
3345                                          IF      @SCP("HOST","HOST")
3346      X:000036 X:000036                   ORG     X:END_COMMAND_TABLE,X:END_COMMAND_TABLE
3347                                          ENDIF
3348   
3349                                          IF      @SCP("HOST","ROM")
3351                                          ENDIF
3352   
3353      X:000036 X:000036                   DC      'IDL',IDL                         ; Put CCD in IDLE mode
3354                                ; Remove for gen-iii since it is in timboot as per June 30 #9
3355                                ;       DC      'STP',STP               ; Exit IDLE mode
3356                                ;       DC      'SVR',SETVRDS           ; set VRD2,3
3357      X:000038 X:000038                   DC      'SBV',SETBIAS                     ; Set DC bias supply voltages
3358      X:00003A X:00003A                   DC      'RDC',RDCCD                       ; Begin CCD readout
3359      X:00003C X:00003C                   DC      'CLR',CLEAR                       ; Fast clear the CCD
3360      X:00003E X:00003E                   DC      'SGN',ST_GAIN                     ; Set video processor gain
3361      X:000040 X:000040                   DC      'SMX',SET_MUX                     ; Set clock driver MUX output
3362   
3363      X:000042 X:000042                   DC      'ABR',ABR_RDC                     ; Abort readout
3364      X:000044 X:000044                   DC      'CRD',CONT_RD                     ; Continue reading out
3365      X:000046 X:000046                   DC      'CSW',CLR_SWS                     ; Clear analog switches to lower power
3366      X:000048 X:000048                   DC      'SOS',SEL_OS                      ; Select output source
3367      X:00004A X:00004A                   DC      'RCC',READ_CONTROLLER_CONFIGURATION
3368      X:00004C X:00004C                   DC      'SSS',SET_SUBARRAY_SIZES
3369      X:00004E X:00004E                   DC      'SSP',SET_SUBARRAY_POSITIONS
3370      X:000050 X:000050                   DC      'DON',START                       ; Nothing special
3371      X:000052 X:000052                   DC      'OSH',OPEN_SHUTTER
3372      X:000054 X:000054                   DC      'CSH',CLOSE_SHUTTER
3373      X:000056 X:000056                   DC      'PON',PWR_ON                      ; Turn on all camera biases and clocks
3374      X:000058 X:000058                   DC      'POF',PWR_OFF                     ; Turn +/- 15V power supplies off
3375      X:00005A X:00005A                   DC      'SET',SET_EXP_TIME                ; Set exposure time
3376      X:00005C X:00005C                   DC      'SEX',START_FT_EXPOSURE           ; Goes to mode-dependent jump table
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  tim.s  Page 66



3377      X:00005E X:00005E                   DC      'AEX',ABORT_EXPOSURE
3378      X:000060 X:000060                   DC      'STG',SET_TRIGGER                 ;  Set Trigger Mode on or off
3379      X:000062 X:000062                   DC      'SIP',SET_IMAGE_PARAM
3380      X:000064 X:000064                   DC      'SRC',SET_ROWS_COLUMNS            ; Set NSR, NPR, and binning
3381      X:000066 X:000066                   DC      'INF',GET_INFO                    ; info command for versioning and more
3382   
3383                                 END_APPLICATON_COMMAND_TABLE
3384      000068                              EQU     @LCV(L)
3385   
3386                                          IF      @SCP("HOST","HOST")
3387      000020                    NUM_COM   EQU     (@LCV(R)-COM_TBL_R)/2             ; No. of boot & application commands
3388                                ;EXPOSING                EQU     CHK_TIM                 ; Address if exposing
3389                                ;CONTINUE_READING        EQU     RDCCD                   ; Address if reading out
3390                                          ENDIF
3391   
3392                                ; ***********  DATA AREAS - READOUT PARAMETERS AND WAVEFORMS  ************
3393                                          IF      @SCP("HOST","HOST")
3394      X:000080 X:000080                   ORG     X:IMGVAR_ADR,X:IMGVAR_ADR
3395      X:000080 X:000080         IMAGE_MODE DC     0
3396                                ; ISTATUS                       DC              0
3397                                ; bum an unused location in low X: for ISTATUS so JSETs work
3398                                ; as per Confluence July 5 #3
3399      000020                    ISTATUS   EQU     EXP_ADR                           ; dangerous!
3400   
3401                                ; some X: variables removed as per Confluence July 1 #4
3402                                ;DSP_VERS       DC      VERSION ; code version must stay in loc,n 102!!
3403                                ;DSP_FLAV       DC      FLAVOR ;  type of dsp support must stay in loc,n 103!!
3404                                ; The next three locations are for tracking the readout timing for gain
3405                                ; calculation, exp-int calculation, and greed factor calculation
3406                                ; They are locations 0x104, 105, and 106
3407                                ;INTTIM         DC      INT_TIM ; per-pixel integration in Leach units
3408                                ;RDELAY         DC      R_DELAY ; serial overlap in Leach units
3409                                ;SIDELAY                DC      SI_DELAY ; parallel overlap in Leach units
3410   
3411                                ;BINBIT         DC      2       ; Bit representation of bin factor, bits 1-5
3412                                                                                    ; 2 = bit 1 set. Bit zero not used.
3413                                ; bum a rarely used location in low X: for BINBIT so JSETs work
3414                                ; as per Confluence July 5 #5
3415      00001E                    BINBIT    EQU     C100K                             ; dangerous!
3416                                                                                    ; Bit representation of bin factor, bits 1-5
3417                                                                                    ; 2 = bit 1 set. Bit zero not used.
3418                                 END_APPLICATION_X_MEMORY
3419      000081                              EQU     @LCV(L)
3420                                          ENDIF
3421   
3422                                          IF      @SCP("HOST","HOST")
3423      Y:000000 Y:000000                   ORG     Y:0,Y:0                           ; Download address
3424                                          ELSE
3426                                          ENDIF
3427   
3428                                ; NSR, NPR, NSBIN, and NPBIN are set by SET_ROWS_COLUMNS
3429      Y:000000 Y:000000         GAIN      DC      0                                 ; Video processor gain and integrator speed
3430      Y:000001 Y:000001         NSR       DC      280                               ; Number Serial Read, prescan + image + bias
3431      Y:000002 Y:000002         NPR       DC      264                               ; Number Parallel Read
3432                                ;NS_CLR DC      280             ; To clear serial register, twice
3433                                          IF      @SCP("6144","2000")
3435                                          ENDIF
3436                                          IF      @SCP("6144","6144")
3437      Y:000003 Y:000003         NS_CLR    DC      6144                              ; To clear serial register, twice
3438                                          ENDIF
3439                                          IF      @SCP("6160","2000")
3441                                          ENDIF
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  tim.s  Page 67



3442                                          IF      @SCP("6160","6160")
3443      Y:000004 Y:000004         NPCLR     DC      12320                             ; To clear parallel register, twice
3444                                          ENDIF
3445                                ;NPCLR   DC      528            ; To clear parallel register, twice
3446      Y:000005 Y:000005         NSBIN     DC      1                                 ; Serial binning parameter
3447      Y:000006 Y:000006         NPBIN     DC      1                                 ; Parallel binning parameter
3448                                ;NROWS  DC      264             ; Number of physical rows in CCD
3449                                ;NCOLS  DC      280             ; Number of physical columns in CCD
3450   
3451                                ; Miscellaneous definitions
3452                                ; Delete TST_DAT since it isn't used.  Need the space so S_SIZE doesn't barf.
3453                                ; TST_DAT       DC      0               ; Temporary definition for test images
3454      Y:000007 Y:000007         SH_DEL    DC      500                               ; Delay in milliseconds between shutter clos
ing
3455                                                                                    ;   and image readout.  Actual delay is 1.5x
3456                                                                                    ;   as long as advertised, e.g. 4.5 ms for 3
.
3457      Y:000008 Y:000008         CONFIG    DC      CC                                ; Controller configuration
3458                                ; Readout peculiarity parameters
3459                                 SERIAL_SKIP
3460      Y:000009 Y:000009                   DC      SERIAL_SKIP_SPLIT                 ; Serial skipping waveforms
3461      Y:00000A Y:00000A         SERWAVLEN DC      5                                 ; Serial read waveform table length
3462   
3463                                 SERIAL_CLOCK
3464      Y:00000B Y:00000B                   DC      SERIAL_CLOCK_SPLIT                ; Serial waveform table
3465                                 INITIAL_CLOCK
3466      Y:00000C Y:00000C                   DC      INITIAL_CLOCK_SPLIT               ; Serial waveform table
3467      Y:00000D Y:00000D         IS_PAR_CLK DC     ABCD_DOWN                         ; Addr. of ganged parallel clocking
3468      Y:00000E Y:00000E         S_PAR_CLK DC      AB_DOWN                           ; Addr. of storage parallel clocking
3469      Y:00000F Y:00000F         IS_PAR_CLR DC     ABCD_CLEAR_DOWN                   ; Addr. of ganged parallel clear
3470      Y:000010 Y:000010         S_PAR_CLR DC      AB_CLEAR_DOWN                     ; Addr. of storage parallel clear
3471   
3472   
3473                                 NSERIALS_READ
3474      Y:000011 Y:000011                   DC      0                                 ; Number of serials to read
3475      Y:000012 Y:000012         NSCLR     DC      0                                 ; Number of waveforms in fast mode
3476      Y:000013 Y:000013         NSKIP1    DC      0                                 ; Number of waveforms in fast mode
3477      Y:000014 Y:000014         NREAD     DC      0                                 ; Number of waveforms in fast mode
3478      Y:000015 Y:000015         NSKIP2    DC      0                                 ; Number of waveforms in fast mode
3479      Y:000016 Y:000016         NBIAS     DC      0                                 ; Number of waveforms in fast mode
3480   
3481                                ; These three parameters are read from the READ_TABLE when needed by the
3482                                ;   RDCCD routine as it loops through the required number of boxes
3483      Y:000017 Y:000017         NP_SKIP   DC      0                                 ; Number of rows to skip
3484      Y:000018 Y:000018         NS_SKP1   DC      0                                 ; Number of serials to clear before read
3485      Y:000019 Y:000019         NS_SKP2   DC      0                                 ; Number of serials to clear after read
3486   
3487                                ; Subimage readout parameters. Ten subimage boxes maximum.
3488                                ; All subimage boxes are the same size, NS_READ x NP_READ
3489                                ; NR_BIAS, NS_READ, and NP_READ are set by SET_SUBARRAY_SIZES
3490                                ; The READ_TABLE entries and implicitly NBOXES are set by SET_SUBARRAY_POSITIONS
3491      Y:00001A Y:00001A         NBOXES    DC      0                                 ; Number of boxes to read
3492      Y:00001B Y:00001B         NR_BIAS   DC      0                                 ; Number of bias pixels to read
3493      Y:00001C Y:00001C         NS_READ   DC      0                                 ; Number of columns per box
3494      Y:00001D Y:00001D         NP_READ   DC      0                                 ; Number of rows per box
3495      Y:00001E Y:00001E         READ_TABLE DC     0,0,0                             ; #1 = Number of rows to clear,
3496      Y:000021 Y:000021                   DC      0,0,0                             ; #2 = Number of columns to skip before
3497      Y:000024 Y:000024                   DC      0,0,0                             ;   subimage read
3498      Y:000027 Y:000027                   DC      0,0,0                             ; #3 = Number of columns to clear after
3499      Y:00002A Y:00002A                   DC      0,0,0                             ;   subimage read to get to overscan area
3500      Y:00002D Y:00002D                   DC      0,0,0
3501      Y:000030 Y:000030                   DC      0,0,0
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  tim.s  Page 68



3502      Y:000033 Y:000033                   DC      0,0,0
3503                                ;       DC      0,0,0
3504   
3505                                ; IMAGE_MODE, SROWS, IFRAMES, and INTERVAL are set by SET_IMAGE_PARAM
3506                                ; UBSROWS is set later on by UB_CONV.  S_SIZE is hardwired.
3507      Y:000036 Y:000036         SROWS     DC      1                                 ; Number of Storage image rows to Loop over
3508      Y:000037 Y:000037         UBSROWS   DC      1                                 ; SROWS in unbinned pixels.  Set by UB_CONV
3509      Y:000038 Y:000038         IFRAMES   DC      1                                 ; Number of Series frames to Loop over
3510                                          IF      @SCP("6160","2000")
3512                                          ENDIF
3513                                          IF      @SCP("6160","6160")
3514      Y:000039 Y:000039         S_SIZE    DC      3080                              ; storage area =  half of total rows
3515                                          ENDIF
3516                                ;S_SIZE         DC      1000    ; Number of rows in the Storage Array
3517      Y:00003A Y:00003A         INTERVAL  DC      7                                 ; Interval to pause for soft trigger
3518      Y:00003B Y:00003B         AMPVAL    DC      0                                 ; Amplifier selected
3519      Y:00003C Y:00003C         IFLPCNT   DC      0                                 ; 24-bit IFRAMES loop counter for timmisc.s
3520      Y:00003D Y:00003D         TESTLOC1  DC      0                                 ; Test location
3521                                ; NOTE:  TESTLOC1 is address 63 in the Y memory.  There are addressing problems
3522                                ; starting at the next address (64).
3523   
3524                                ; Include the waveform table
3525                                          INCLUDE "lmi.waveforms.s"                 ; Readout and clocking waveforms
3526                                ; Waveform tables and definitions for the e2v CCD231 6K sq. frame
3527                                ; transfer CCD for LMI.
3528   
3529                                ; CCD clock voltage definitions
3530      000000                    VIDEO     EQU     $000000                           ; Video processor board select = 0
3531      002000                    CLK2      EQU     $002000                           ; Clock driver board select = 2
3532      003000                    CLK3      EQU     $003000                           ; Clock driver board select = 3
3533      200000                    CLKV      EQU     $200000                           ; Clock driver board DAC voltage selection a
ddress
3534      000000                    VID0      EQU     $000000                           ; Address of video board DACS
3535      0E0000                    DAC_ADDR  EQU     $0E0000                           ; DAC Channel Address
3536      0F4000                    DAC_RegM  EQU     $0F4000                           ; DAC m Register
3537      0F8000                    DAC_RegC  EQU     $0F8000                           ; DAC c Register
3538      0FC000                    DAC_RegD  EQU     $0FC000                           ; DAC X1 Register
3539      1.300000E+001             Vmax      EQU     13.0                              ; Maximum clock driver voltage
3540      0.000000E+000             ZERO      EQU     0.0                               ; Unused pins
3541   
3542   
3543                                ; For NASA42 we uncommented one of these lines at a time
3544                                ;INT_TIM        EQU     $080000 ; 1.0 us/px - use gain 9.5, clips at PRAM
3545                                ;INT_TIM        EQU     $130000 ; 1.4 us/px - use gain 4.75, clips at PRAM
3546                                ;INT_TIM                EQU     $1D0000 ; 1.8 us/px - use gain 2
3547                                ;INT_TIM        EQU     $2D0000 ; 2.5 us/px - use gain 2, doesn't clip
3548                                ;INT_TIM        EQU     $600000 ; 4.7 us/px - use gain 1; Doesn't clip
3549   
3550                                ; INT_TIM, controlled by Makefile def'n INTTIM_SETTING
3551                                ; as per Confluence July 1 2010 end commentary
3552   
3553                                          IF      @SCP("E","08")
3556                                          ENDIF
3557                                          IF      @SCP("E","13")
3560                                          ENDIF
3561                                          IF      @SCP("E","1D")
3565                                          ENDIF
3566                                          IF      @SCP("E","2D")
3569                                          ENDIF
3570                                          IF      @SCP("E","E")
3571                                ; on limi, 2.5 us/pxl
3572      0E0000                    INT_TIM   EQU     $0E0000
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 69



3573                                          ENDIF
3574                                          IF      @SCP("E","60")
3577                                          ENDIF
3578   
3579   
3580   
3581                                ;ADC_TIM                EQU     $0C0000 ; Slow ADC TIME
3582      000000                    ADC_TIM   EQU     $000000                           ; Fast ADC TIME
3583   
3584   
3585                                ; Delay numbers in clocking
3586                                ;SI_DELAY       EQU     $A70000 ; 25 microsecond parallel delay time
3587   
3588                                ; SI_DELAY, controlled by Makefile def'n SIDELAY_SETTING
3589                                ; as per Confluence July 1 2010 end commentary
3590                                          IF      @SCP("A7","BF")
3593                                          ENDIF
3594                                          IF      @SCP("A7","A7")
3595                                ; 25 us parallel delay time
3596      A70000                    SI_DELAY  EQU     $A70000                           ; 25 microsecond parallel delay time
3597                                          ENDIF
3598   
3599   
3600      A70000                    DG_DELAY  EQU     $A70000                           ; 25 microsecond dump gate delay time
3601                                ;
3602                                ;R_DELAY                EQU     $060000 ; Fast serial regisiter transfer delay.  Set to $0x06000
0.
3603   
3604                                ; R_DELAY, controlled by Makefile def'n RDELAY_SETTING
3605                                ; as per Confluence July 1 2010 end commentary
3606                                          IF      @SCP("00","00")
3607   
3608      000000                    R_DELAY   EQU     $000000                           ; Fast serial register transfer delay
3609                                          ENDIF
3610                                          IF      @SCP("00","06")
3612                                          ENDIF
3613   
3614   
3615   
3616      030000                    CDS_TIM   EQU     $030000                           ; Delay for single clock between reset & dat
a
3617   
3618   
3619                                ; bitwise symbols for integrator manipulation.
3620                                ; Video processor bit definition
3621                                ;             6     5    4     3      2        1         0
3622                                ;            xfer, A/D, integ, Pol-, fixed 0, DCrestore, rst (1 => switch open)
3623                                ; for the ARC-47 1C (incl. all of gen-ii) it was
3624                                ;            xfer, A/D, integ, Pol+, Pol-,    DCrestore, rst (1 => switch open)
3625   
3626                                ; goes with VIDEO
3627      000078                    INT_INIT  EQU     %1111000                          ; Change nearly everything
3628                                ; goes with VIDEO
3629      00007B                    INT_RSTOFF EQU    %1111011                          ; Stop resetting integrator
3630                                ; goes with VIDEO and INT_TIM
3631      00000B                    INT_MINUS EQU     %0001011                          ; Integrate reset level
3632                                ; goes with VIDEO
3633      000013                    INT_STOP  EQU     %0010011                          ; Stop Integrate
3634                                ; goes with VIDEO and INT_TIM
3635      000003                    INT_PLUS  EQU     %0000011                          ; Integrate signal level
3636                                ; goes with VIDEO and ADC_TIM
3637      000013                    INT_SMPL  EQU     %0010011                          ; Stop integrate, A/D is sampling
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 70



3638                                ; goes with VIDEO
3639      000010                    INT_DCR   EQU     %0010000                          ; Reset integ. and DC restore
3640   
3641   
3642                                ; Clock voltages in volts
3643      1.200000E+001             RG_HI     EQU     +12.0                             ; Reset
3644      1.000000E+000             RG_LO     EQU     +1.0                              ;
3645      1.000000E+001             R_HI      EQU     +10.0                             ; Serials
3646      1.300000E+000             R_LO      EQU     +1.3                              ; TWEAKED
3647      1.000000E+001             SW_HI     EQU     +10.0                             ; Summing well, mode 1
3648      1.300000E+000             SW_LO     EQU     +1.3                              ; TWEAKED
3649                                ; SW_HI EQU     +2.0    ; Summing well, mode 2
3650                                ; SW_LO EQU     +2.0    ;
3651      1.000000E+001             SI_HI     EQU     +10.0                             ; Parallels
3652      0.000000E+000             SI_LO     EQU     0.0                               ;
3653      1.000000E+001             TG_HI     EQU     +10.0                             ; Transfer Gate
3654      0.000000E+000             TG_LO     EQU     0.0                               ;
3655      1.200000E+001             DG_HI     EQU     +12.0                             ; Dump Gate
3656      0.000000E+000             DG_LO     EQU     0.0                               ;
3657   
3658                                ; DC Bias voltages in volts
3659      3.045000E+001             VOD       EQU     30.45                             ; Output Drain Left. TWEAKED
3660                                ; VOD is 1 volt lower than specified because of IR drop in lopass filts.
3661      1.750000E+001             VRD       EQU     17.5                              ; Reset Drain Left TWEAKED
3662                                ;VRD     EQU     18.0    ; Reset Drain Left
3663   
3664      1.700000E+000             VOG       EQU     1.7                               ; output Gate, mode 1 TWEAKED
3665                                ; VOG   EQU     +18.0   ; Output Gate, mode 2
3666      2.950000E+001             VDD       EQU     +29.5                             ; Dump Drain TWEAKED
3667   
3668                                ; from gwaves_CCD67.  Not used in this DSP.
3669      -6.000000E+000            VABG      EQU     -6.0                              ; Anti-blooming gate
3670      6.000000E+000             PWR       EQU     +6.0                              ; Preamp power - xxx Not used, keep as place
holder
3671   
3672   
3673      002640                    OFFSET    EQU     $2640
3674                                ;OFFSET0        EQU     $2CB2   ; e2v E, Peter's C, board 0, ch 0
3675      0028B2                    OFFSET0   EQU     $28B2                             ; e2v E, Peter's C, board 0, ch 0
3676                                ;OFFSET1        EQU     $2A17   ; e2v F, Peter's D, board 0, ch 1
3677      002617                    OFFSET1   EQU     $2617                             ; e2v F, Peter's D, board 0, ch 1
3678                                ;OFFSET2        EQU     $2F3C   ; e2v G, Peter's B, board 1, ch 0
3679      002B3C                    OFFSET2   EQU     $2B3C                             ; e2v G, Peter's B, board 1, ch 0
3680                                ;OFFSET3        EQU     $2640   ; e2v H, Peter's A, board 1, ch 1
3681      002240                    OFFSET3   EQU     $2240                             ; e2v H, Peter's A, board 1, ch 1
3682   
3683                                ; Define switch state bits for the lower CCD clock driver bank CLK2
3684                                ; In the LMI CCD serial 3 on E/F is on a single pin and serial 3 on G/H is too.
3685                                ; As it happens serial 3 on all four go up and down together so this doesn't
3686                                ; have any effect.  To save effort I've left the symbols the same as they
3687                                ; were (SEH3 now really runs serial 3 on E&F and SFG3 runs serial 3 on G&H).
3688                                ; Pins 11-12, clocks 10 & 11, are not used
3689      000001                    SEH1      EQU     1                                 ; Serial #1 E & H registers, Pin 1 - clock 0
3690      000002                    SEH2      EQU     2                                 ; Serial #2 E & H registers, Pin 2 - clock 1
3691      000004                    SEH3      EQU     4                                 ; Serial #3 E & F registers, Pin 3 - clock 2
3692      000008                    SFG1      EQU     8                                 ; Serial #1 F & G registers, Pin 4 - clock 3
3693      000010                    SFG2      EQU     $10                               ; Serial #2 F & G registers, Pin 5 - clock 4
3694      000020                    SFG3      EQU     $20                               ; Serial #3 G & H registers, Pin 6 - clock 5
3695      000040                    SWEH      EQU     $40                               ; Summing well E & H registers, Pin 7 - cloc
k 6
3696      000080                    SWFG      EQU     $80                               ; Summing well F & G registers, Pin 8 - cloc
k 7
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 71



3697      000100                    REH       EQU     $100                              ; Reset Gate E & H registers, Pin 9 - clock 
8
3698      000200                    RFG       EQU     $200                              ; Reset Gate F & G registers, Pin 10 - clock
 9
3699   
3700                                ; Define switch state bits for the upper CCD clock driver bank CLK3
3701                                ; All 12 of these are used
3702      000001                    AB1       EQU     1                                 ; Parallel A & B, phase #1, Pin 13 - clock 1
2
3703      000002                    AB2       EQU     2                                 ; Parallel A & B, phase #2, Pin 14 - clock 1
3
3704      000004                    AB3       EQU     4                                 ; Parallel A & B, phase #3, Pin 15 - clock 1
4
3705      000008                    AB4       EQU     8                                 ; Parallel A & B, phase #4, Pin 16 - clock 1
5
3706      000010                    CD1       EQU     $10                               ; Parallel C & D, phase #1, Pin 17 - clock 1
6
3707      000020                    CD2       EQU     $20                               ; Parallel C & D, phase #2, Pin 18 - clock 1
7
3708      000040                    CD3       EQU     $40                               ; Parallel C & D, phase #3, Pin 19 - clock 1
8
3709      000080                    CD4       EQU     $80                               ; Parallel C & D, phase #4, Pin 33 - clock 1
9
3710      000100                    TGA       EQU     $100                              ; Transfer Gate A, Pin 34 - clock 20
3711      000200                    TGD       EQU     $200                              ; Transfer Gate D, Pin 35 - clock 21
3712      000400                    DGA       EQU     $400                              ; Dump Gate A, Pin 36 - clock 22
3713      000800                    DGD       EQU     $800                              ; Dump Gate D, Pin 37 - clock 23
3714   
3715                                ;                  EH Side                                            FG Side
3716                                ;  OG  SW  1  2  3  1 .... EH1  EH2  EH3  FG2  FG1  .....  1  3  2  1  SW  OG
3717   
3718                                ; Transfer gate dumps into serial 1 and 2.
3719                                ; Serial 1 & 2 are high between serial clock code lumps.
3720   
3721                                ; Video processor bit definition
3722                                ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3723   
3724                                SERIAL_IDLE                                         ; Split serial during idle
3725      Y:00003E Y:00003E                   DC      END_SERIAL_IDLE-SERIAL_IDLE-1
3726      Y:00003F Y:00003F                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3727      Y:000040 Y:000040                   DC      VIDEO+INT_INIT                    ; Change nearly everything
3728      Y:000041 Y:000041                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
3729      Y:000042 Y:000042                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3730      Y:000043 Y:000043                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3731      Y:000044 Y:000044                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3732      Y:000045 Y:000045                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
3733      Y:000046 Y:000046                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3734      Y:000047 Y:000047                   DC      VIDEO+INT_STOP                    ; Stop Integrate
3735      Y:000048 Y:000048                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
3736      Y:000049 Y:000049                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3737      Y:00004A Y:00004A                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
3738      Y:00004B Y:00004B                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3739                                END_SERIAL_IDLE
3740   
3741                                ; The following waveforms are for binned operation.  This is for mode 1, i.e.
3742                                ; using a summing well.  Mode 2 uses SW as a second OG and binning has to be
3743                                ; done on the output node like in HIPO.
3744   
3745                                INITIAL_CLOCK_SPLIT                                 ; Both amplifiers
3746      Y:00004C Y:00004C                   DC      END_INITIAL_CLOCK_SPLIT-INITIAL_CLOCK_SPLIT-1
3747      Y:00004D Y:00004D                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3748      Y:00004E Y:00004E                   DC      VIDEO+INT_INIT                    ; Change nearly everything
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 72



3749      Y:00004F Y:00004F                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
3750      Y:000050 Y:000050                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3751      Y:000051 Y:000051                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3752      Y:000052 Y:000052                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3753                                END_INITIAL_CLOCK_SPLIT
3754   
3755                                INITIAL_CLOCK_EH                                    ; Shift to E and H amplifiers
3756      Y:000053 Y:000053                   DC      END_INITIAL_CLOCK_EH-INITIAL_CLOCK_EH-1
3757      Y:000054 Y:000054                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3758      Y:000055 Y:000055                   DC      VIDEO+INT_INIT                    ; Change nearly everything
3759      Y:000056 Y:000056                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
3760      Y:000057 Y:000057                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
3761      Y:000058 Y:000058                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
3762      Y:000059 Y:000059                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
3763                                END_INITIAL_CLOCK_EH
3764   
3765                                INITIAL_CLOCK_FG                                    ; Shift to F and G amplifiers
3766      Y:00005A Y:00005A                   DC      END_INITIAL_CLOCK_FG-INITIAL_CLOCK_FG-1
3767      Y:00005B Y:00005B                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3768      Y:00005C Y:00005C                   DC      VIDEO+INT_INIT                    ; Change nearly everything
3769      Y:00005D Y:00005D                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
3770      Y:00005E Y:00005E                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
3771      Y:00005F Y:00005F                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
3772      Y:000060 Y:000060                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
3773                                END_INITIAL_CLOCK_FG
3774   
3775                                SERIAL_CLOCK_SPLIT                                  ; Both amplifiers
3776      Y:000061 Y:000061                   DC      END_SERIAL_CLOCK_SPLIT-SERIAL_CLOCK_SPLIT-1
3777      Y:000062 Y:000062                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
3778      Y:000063 Y:000063                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
3779      Y:000064 Y:000064                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
3780      Y:000065 Y:000065                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3781      Y:000066 Y:000066                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3782      Y:000067 Y:000067                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3783                                END_SERIAL_CLOCK_SPLIT
3784   
3785                                SERIAL_CLOCK_EH                                     ; Shift to E and H amplifiers
3786      Y:000068 Y:000068                   DC      END_SERIAL_CLOCK_EH-SERIAL_CLOCK_EH-1
3787      Y:000069 Y:000069                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
3788      Y:00006A Y:00006A                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
3789      Y:00006B Y:00006B                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
3790      Y:00006C Y:00006C                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
3791      Y:00006D Y:00006D                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
3792      Y:00006E Y:00006E                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
3793                                END_SERIAL_CLOCK_EH
3794   
3795                                SERIAL_CLOCK_FG                                     ; Shift to F and G amplifiers
3796      Y:00006F Y:00006F                   DC      END_SERIAL_CLOCK_FG-SERIAL_CLOCK_FG-1
3797      Y:000070 Y:000070                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
3798      Y:000071 Y:000071                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
3799      Y:000072 Y:000072                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
3800      Y:000073 Y:000073                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
3801      Y:000074 Y:000074                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
3802      Y:000075 Y:000075                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
3803                                END_SERIAL_CLOCK_FG
3804   
3805                                DCRST_LAST
3806      Y:000076 Y:000076                   DC      DCRST_LAST_END-DCRST_LAST-1
3807      Y:000077 Y:000077                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
3808                                DCRST_LAST_END
3809   
3810                                VIDEO_PROCESS
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 73



3811      Y:000078 Y:000078                   DC      END_VIDEO_PROCESS-VIDEO_PROCESS-1
3812                                SXMIT_VP
3813      Y:000079 Y:000079                   DC      $00F020                           ; A/D data to fiber; overwritten by SOS
3814      Y:00007A Y:00007A                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
3815      Y:00007B Y:00007B                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3816      Y:00007C Y:00007C                   DC      VIDEO+INT_STOP                    ; Stop Integrate
3817                                CCLK_1                                              ; The following line is overwritten by timmi
sc.s
3818      Y:00007D Y:00007D                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
3819      Y:00007E Y:00007E                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3820      Y:00007F Y:00007F                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
3821      Y:000080 Y:000080                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3822                                END_VIDEO_PROCESS
3823   
3824                                ; Starting Y: address of circular waveforms for no-overhead access
3825      0000C0                    STRT_CIR  EQU     $C0
3826                                ;ROM_DISP       EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+STRT_CIR
3827                                ;DAC_DISP       EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+$100
3828   
3829                                ; Check for Y: data memory overflow
3830                                          IF      @CVS(N,*)>STRT_CIR
3832                                          ENDIF                                     ;  will not overflow
3833   
3834                                ; The fast serial code with the circulating address register must start
3835                                ;   on a boundary that is a multiple of the address register modulus.
3836   
3837                                          IF      @SCP("HOST","HOST")
3838      Y:0000C0 Y:0000C0                   ORG     Y:STRT_CIR,Y:STRT_CIR             ; Download address
3839                                          ELSE
3841                                          ENDIF
3842   
3843                                ; This is an area to copy in the serial fast binned waveforms from high Y memory
3844                                ; It is 0x28 = 40 locations long, enough to put in a binned-by-four waveform
3845                                ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3846                                SERIAL_READ                                         ; Split serial during idle
3847      Y:0000C0 Y:0000C0                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3848      Y:0000C1 Y:0000C1                   DC      VIDEO+INT_INIT                    ; Change nearly everything
3849      Y:0000C2 Y:0000C2                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
3850      Y:0000C3 Y:0000C3                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3851      Y:0000C4 Y:0000C4                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3852      Y:0000C5 Y:0000C5                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3853      Y:0000C6 Y:0000C6                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
3854      Y:0000C7 Y:0000C7                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
3855      Y:0000C8 Y:0000C8                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
3856      Y:0000C9 Y:0000C9                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3857      Y:0000CA Y:0000CA                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3858      Y:0000CB Y:0000CB                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3859      Y:0000CC Y:0000CC                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
3860      Y:0000CD Y:0000CD                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
3861      Y:0000CE Y:0000CE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
3862      Y:0000CF Y:0000CF                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3863      Y:0000D0 Y:0000D0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3864      Y:0000D1 Y:0000D1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3865      Y:0000D2 Y:0000D2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
3866      Y:0000D3 Y:0000D3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
3867      Y:0000D4 Y:0000D4                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
3868      Y:0000D5 Y:0000D5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3869      Y:0000D6 Y:0000D6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3870      Y:0000D7 Y:0000D7                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3871                                SXMIT
3872      Y:0000D8 Y:0000D8                   DC      $00F000                           ; Transmit A/D data to host; overwritten by 
SOS
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 74



3873      Y:0000D9 Y:0000D9                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
3874      Y:0000DA Y:0000DA                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
3875      Y:0000DB Y:0000DB                   DC      VIDEO+INT_STOP                    ; Stop Integrate
3876      Y:0000DC Y:0000DC                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
3877      Y:0000DD Y:0000DD                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
3878      Y:0000DE Y:0000DE                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
3879      Y:0000DF Y:0000DF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3880                                END_SERIAL_READ
3881   
3882   
3883                                ; Serial clocking waveform for skipping
3884                                          IF      @SCP("HOST","HOST")
3885      Y:0000E8 Y:0000E8                   ORG     Y:STRT_CIR+$28,Y:STRT_CIR+$28     ; Download address
3886                                          ELSE
3888                                          ENDIF
3889   
3890                                ; There are three serial skip waveforms that must all be the same length
3891                                SERIAL_SKIP_EH
3892      Y:0000E8 Y:0000E8                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3893      Y:0000E9 Y:0000E9                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
3894      Y:0000EA Y:0000EA                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+0000
3895      Y:0000EB Y:0000EB                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+0000
3896      Y:0000EC Y:0000EC                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+0000
3897      Y:0000ED Y:0000ED                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
3898      Y:0000EE Y:0000EE                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3899                                END_SERIAL_SKIP_EH
3900   
3901                                          IF      @SCP("HOST","HOST")
3902      Y:0000F0 Y:0000F0                   ORG     Y:STRT_CIR+$30,Y:STRT_CIR+$30     ; Download address
3903                                          ELSE
3905                                          ENDIF
3906   
3907                                SERIAL_SKIP_FG
3908      Y:0000F0 Y:0000F0                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3909      Y:0000F1 Y:0000F1                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
3910      Y:0000F2 Y:0000F2                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+0000
3911      Y:0000F3 Y:0000F3                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+0000
3912      Y:0000F4 Y:0000F4                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+0000
3913      Y:0000F5 Y:0000F5                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
3914      Y:0000F6 Y:0000F6                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3915                                END_SERIAL_SKIP_FG
3916   
3917                                          IF      @SCP("HOST","HOST")
3918      Y:0000F8 Y:0000F8                   ORG     Y:STRT_CIR+$38,Y:STRT_CIR+$38     ; Download address
3919                                          ELSE
3921                                          ENDIF
3922   
3923                                SERIAL_SKIP_SPLIT
3924      Y:0000F8 Y:0000F8                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3925      Y:0000F9 Y:0000F9                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
3926      Y:0000FA Y:0000FA                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+SFG1+0000+SFG3+0000
3927      Y:0000FB Y:0000FB                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+0000
3928      Y:0000FC Y:0000FC                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+0000+SFG2+SFG3+0000
3929      Y:0000FD Y:0000FD                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
3930      Y:0000FE Y:0000FE                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3931                                END_SERIAL_SKIP_SPLIT
3932   
3933   
3934                                ; Put all the following code in SRAM.
3935                                          IF      @SCP("HOST","HOST")
3936      Y:000100 Y:000100                   ORG     Y:$100,Y:$100                     ; Download address
3937                                          ELSE
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 75



3939                                          ENDIF
3940   
3941                                ; DACS from gwaves_CCD67 dropped in here
3942                                ; Initialization of clock driver and video processor DACs and switches
3943                                ; This is for the ARC 47 4-channel video board
3944      Y:000100 Y:000100         DACS      DC      END_DACS-DACS-1
3945      Y:000101 Y:000101                   DC      CLKV+$0A0080                      ; DAC = unbuffered mode
3946      Y:000102 Y:000102                   DC      CLKV+$000100+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #1, S1 EH
3947      Y:000103 Y:000103                   DC      CLKV+$000200+@CVI((R_LO+Vmax)/(2*Vmax)*255)
3948      Y:000104 Y:000104                   DC      CLKV+$000400+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #2, S2 EH
3949      Y:000105 Y:000105                   DC      CLKV+$000800+@CVI((R_LO+Vmax)/(2*Vmax)*255)
3950      Y:000106 Y:000106                   DC      CLKV+$002000+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #3, S3 EF
3951      Y:000107 Y:000107                   DC      CLKV+$004000+@CVI((R_LO+Vmax)/(2*Vmax)*255)
3952      Y:000108 Y:000108                   DC      CLKV+$008000+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #4, S1 FG
3953      Y:000109 Y:000109                   DC      CLKV+$010000+@CVI((R_LO+Vmax)/(2*Vmax)*255)
3954      Y:00010A Y:00010A                   DC      CLKV+$020100+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #5, S2 FG
3955      Y:00010B Y:00010B                   DC      CLKV+$020200+@CVI((R_LO+Vmax)/(2*Vmax)*255)
3956      Y:00010C Y:00010C                   DC      CLKV+$020400+@CVI((R_HI+Vmax)/(2*Vmax)*255) ; Pin #6, S3 GH
3957      Y:00010D Y:00010D                   DC      CLKV+$020800+@CVI((R_LO+Vmax)/(2*Vmax)*255)
3958      Y:00010E Y:00010E                   DC      CLKV+$022000+@CVI((SW_HI+Vmax)/(2*Vmax)*255) ; Pin #7, SW EH
3959      Y:00010F Y:00010F                   DC      CLKV+$024000+@CVI((SW_LO+Vmax)/(2*Vmax)*255)
3960      Y:000110 Y:000110                   DC      CLKV+$028000+@CVI((SW_HI+Vmax)/(2*Vmax)*255) ; Pin #8, SW FG
3961      Y:000111 Y:000111                   DC      CLKV+$030000+@CVI((SW_LO+Vmax)/(2*Vmax)*255)
3962      Y:000112 Y:000112                   DC      CLKV+$040100+@CVI((RG_HI+Vmax)/(2*Vmax)*255) ; Pin #9, RG EH outputs
3963      Y:000113 Y:000113                   DC      CLKV+$040200+@CVI((RG_LO+Vmax)/(2*Vmax)*255)
3964      Y:000114 Y:000114                   DC      CLKV+$040400+@CVI((RG_HI+Vmax)/(2*Vmax)*255) ; Pin #10, RG FG outputs
3965      Y:000115 Y:000115                   DC      CLKV+$040800+@CVI((RG_LO+Vmax)/(2*Vmax)*255)
3966      Y:000116 Y:000116                   DC      CLKV+$042000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #11, Unused
3967      Y:000117 Y:000117                   DC      CLKV+$044000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3968      Y:000118 Y:000118                   DC      CLKV+$048000+@CVI((ZERO+Vmax)/(2*Vmax)*255) ; Pin #12, Unused
3969      Y:000119 Y:000119                   DC      CLKV+$050000+@CVI((ZERO+Vmax)/(2*Vmax)*255)
3970   
3971      Y:00011A Y:00011A                   DC      CLKV+$060100+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #13, AB1
3972      Y:00011B Y:00011B                   DC      CLKV+$060200+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3973      Y:00011C Y:00011C                   DC      CLKV+$060400+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #14, AB2
3974      Y:00011D Y:00011D                   DC      CLKV+$060800+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3975      Y:00011E Y:00011E                   DC      CLKV+$062000+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #15, AB3
3976      Y:00011F Y:00011F                   DC      CLKV+$064000+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3977      Y:000120 Y:000120                   DC      CLKV+$068000+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #16, AB4
3978      Y:000121 Y:000121                   DC      CLKV+$070000+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3979      Y:000122 Y:000122                   DC      CLKV+$080100+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #17, CD1
3980      Y:000123 Y:000123                   DC      CLKV+$080200+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3981      Y:000124 Y:000124                   DC      CLKV+$080400+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #18, CD2
3982      Y:000125 Y:000125                   DC      CLKV+$080800+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3983      Y:000126 Y:000126                   DC      CLKV+$082000+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #19, CD3
3984      Y:000127 Y:000127                   DC      CLKV+$084000+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3985      Y:000128 Y:000128                   DC      CLKV+$088000+@CVI((SI_HI+Vmax)/(2*Vmax)*255) ; Pin #33, CD4
3986      Y:000129 Y:000129                   DC      CLKV+$090000+@CVI((SI_LO+Vmax)/(2*Vmax)*255)
3987      Y:00012A Y:00012A                   DC      CLKV+$0A0100+@CVI((TG_HI+Vmax)/(2*Vmax)*255) ; Pin #34, TGA
3988      Y:00012B Y:00012B                   DC      CLKV+$0A0200+@CVI((TG_LO+Vmax)/(2*Vmax)*255)
3989      Y:00012C Y:00012C                   DC      CLKV+$0A0400+@CVI((TG_HI+Vmax)/(2*Vmax)*255) ; Pin #35, TGD
3990      Y:00012D Y:00012D                   DC      CLKV+$0A0800+@CVI((TG_LO+Vmax)/(2*Vmax)*255)
3991      Y:00012E Y:00012E                   DC      CLKV+$0A2000+@CVI((DG_HI+Vmax)/(2*Vmax)*255) ; Pin #36, DGA
3992      Y:00012F Y:00012F                   DC      CLKV+$0A4000+@CVI((DG_LO+Vmax)/(2*Vmax)*255)
3993      Y:000130 Y:000130                   DC      CLKV+$0A8000+@CVI((DG_HI+Vmax)/(2*Vmax)*255) ; Pin #37, DGD
3994      Y:000131 Y:000131                   DC      CLKV+$0B0000+@CVI((DG_LO+Vmax)/(2*Vmax)*255)
3995   
3996                                ; Commands for the ARC-47 video board
3997      Y:000132 Y:000132                   DC      VID0+$0C0000                      ; Normal Image data D17-D2
3998   
3999                                ; Gain : $0D000g, g = 0 to %1111, Gain = 1.00 to 4.75 in steps of 0.25
4000                                ; See Bob's ARC47 manual for the gain table.
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 76



4001                                DAC_GNSPD
4002      Y:000133 Y:000133                   DC      VID0+$0D000F                      ; This is for 4.75 gain
4003                                ;       DC      VID0+$0D0000    ; fix for arc-47 gen-iii default gain 1
4004   
4005                                ; Integrator time constant: $0C01t0, t = 0 to %1111.
4006                                ; See Bob's ARC47 manual for integration time constant table.
4007      Y:000134 Y:000134                   DC      VID0+$0C0180                      ; integrator parameter for 0.5 us (integrato
r gain = 1.0)
4008   
4009      3.045000E+001             VOD_MAX   EQU     30.45
4010      1.990000E+001             VRD_MAX   EQU     19.90
4011      8.700000E+000             VOG_MAX   EQU     8.70
4012      003FFF                    DAC_VOD   EQU     @CVI((VOD/VOD_MAX)*16384-1)       ; Unipolar
4013      003847                    DAC_VRD   EQU     @CVI((VRD/VRD_MAX)*16384-1)       ; Unipolar
4014      00263F                    DAC_VOG   EQU     @CVI(((VOG+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
4015      0009ED                    DAC_VABG  EQU     @CVI(((VABG+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
4016      003DFF                    DAC_VDD   EQU     @CVI((VDD/VOD_MAX)*16384-1)       ; Unipolar
4017      003610                    DAC_PWR   EQU     @CVI(((PWR+VOG_MAX)/VOG_MAX)*8192-1) ; Bipolar
4018      001FFF                    DAC_ZERO  EQU     $1FFF                             ; Bipolar
4019   
4020                                ; Initialize the ARC-47 DAC For DC_BIAS
4021      Y:000135 Y:000135                   DC      VID0+DAC_ADDR+$000000             ; Vod0, pin 52
4022      Y:000136 Y:000136                   DC      VID0+DAC_RegD+DAC_VOD
4023      Y:000137 Y:000137                   DC      VID0+DAC_ADDR+$000004             ; Vrd0, pin 13
4024      Y:000138 Y:000138                   DC      VID0+DAC_RegD+DAC_VRD
4025      Y:000139 Y:000139                   DC      VID0+DAC_ADDR+$000008             ; Vog0, pin 29
4026      Y:00013A Y:00013A                   DC      VID0+DAC_RegD+DAC_VOG
4027      Y:00013B Y:00013B                   DC      VID0+DAC_ADDR+$00000C             ; NC, pin 5, NC
4028      Y:00013C Y:00013C                   DC      VID0+DAC_RegD+DAC_ZERO
4029   
4030      Y:00013D Y:00013D                   DC      VID0+DAC_ADDR+$000001             ; Vod1, pin 32
4031      Y:00013E Y:00013E                   DC      VID0+DAC_RegD+DAC_VOD
4032      Y:00013F Y:00013F                   DC      VID0+DAC_ADDR+$000005             ; Vrd1, pin 55
4033      Y:000140 Y:000140                   DC      VID0+DAC_RegD+DAC_VRD
4034      Y:000141 Y:000141                   DC      VID0+DAC_ADDR+$000009             ; Vabg, pin 8
4035      Y:000142 Y:000142                   DC      VID0+DAC_RegD+DAC_VOG
4036      Y:000143 Y:000143                   DC      VID0+DAC_ADDR+$00000D             ; NC, pin 47, NC
4037      Y:000144 Y:000144                   DC      VID0+DAC_RegD+DAC_ZERO
4038   
4039      Y:000145 Y:000145                   DC      VID0+DAC_ADDR+$000002             ; Vod2, pin 11
4040      Y:000146 Y:000146                   DC      VID0+DAC_RegD+DAC_VOD
4041      Y:000147 Y:000147                   DC      VID0+DAC_ADDR+$000006             ; Vrd2, pin 35
4042      Y:000148 Y:000148                   DC      VID0+DAC_RegD+DAC_VRD
4043      Y:000149 Y:000149                   DC      VID0+DAC_ADDR+$00000A             ; Vog2, pin 50
4044      Y:00014A Y:00014A                   DC      VID0+DAC_RegD+DAC_VOG
4045      Y:00014B Y:00014B                   DC      VID0+DAC_ADDR+$00000E             ; NC, pin 27, NC
4046      Y:00014C Y:00014C                   DC      VID0+DAC_RegD+DAC_ZERO
4047   
4048      Y:00014D Y:00014D                   DC      VID0+DAC_ADDR+$000003             ; Vod3, pin 53
4049      Y:00014E Y:00014E                   DC      VID0+DAC_RegD+DAC_VOD
4050      Y:00014F Y:00014F                   DC      VID0+DAC_ADDR+$000007             ; Vrd3, pin 14
4051      Y:000150 Y:000150                   DC      VID0+DAC_RegD+DAC_VRD
4052      Y:000151 Y:000151                   DC      VID0+DAC_ADDR+$00000B             ; Vog3, pin 30
4053      Y:000152 Y:000152                   DC      VID0+DAC_RegD+DAC_VOG
4054      Y:000153 Y:000153                   DC      VID0+DAC_ADDR+$00000F             ; NC, pin 6, NC
4055      Y:000154 Y:000154                   DC      VID0+DAC_RegD+DAC_ZERO
4056   
4057      Y:000155 Y:000155                   DC      VID0+DAC_ADDR+$000010             ; Vod4, pin 33, VDD
4058      Y:000156 Y:000156                   DC      VID0+DAC_RegD+DAC_VDD
4059      Y:000157 Y:000157                   DC      VID0+DAC_ADDR+$000011             ; Vrd4, pin 56, NC
4060      Y:000158 Y:000158                   DC      VID0+DAC_RegD+DAC_PWR
4061      Y:000159 Y:000159                   DC      VID0+DAC_ADDR+$000012             ; Vog4, pin 9, NC
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 77



4062      Y:00015A Y:00015A                   DC      VID0+DAC_RegD+DAC_ZERO
4063      Y:00015B Y:00015B                   DC      VID0+DAC_ADDR+$000013             ; Vrsv4,pin 48, NC
4064      Y:00015C Y:00015C                   DC      VID0+DAC_RegD+DAC_ZERO
4065   
4066                                ; Initialize the ARC-47 DAC For Video Offsets
4067      Y:00015D Y:00015D                   DC      VID0+DAC_ADDR+$000014
4068      Y:00015E Y:00015E                   DC      VID0+DAC_RegD+OFFSET0
4069      Y:00015F Y:00015F                   DC      VID0+DAC_ADDR+$000015
4070      Y:000160 Y:000160                   DC      VID0+DAC_RegD+OFFSET1
4071      Y:000161 Y:000161                   DC      VID0+DAC_ADDR+$000016
4072      Y:000162 Y:000162                   DC      VID0+DAC_RegD+OFFSET2
4073      Y:000163 Y:000163                   DC      VID0+DAC_ADDR+$000017
4074      Y:000164 Y:000164                   DC      VID0+DAC_RegD+OFFSET3
4075   
4076                                END_DACS
4077   
4078   
4079                                ;  ***  Definitions for Y: memory waveform tables  *****
4080                                ; Put the parallel clock waveforms in slow external Y memory since there isn't
4081                                ; enough room in the fast memory for everything we need.  The parallels are
4082                                ; way slow anyway so the slowness of the access can be tweaked with SI_DELAY.
4083                                ; Clock whole CCD up toward the GH serial register.  Serial phases 1 & 2 high.
4084                                ; CD goes 2-3-4-1, AB goes 3-2-1-4
4085                                ; Parallel phases 2 & 3 high during integration.
4086   
4087                                ; Serial clock convention:    REH SEH1 SEH2 SEH3 SWEH RFG SFG1 SFG2 SFG3 SWFG
4088                                ; Parallel clock convention:  AB1 AB2 AB3 AB4 TGA DGA CD1 CD2 CD3 CD4 TGD DGD
4089   
4090                                ; ADD DC RESTORE based on gwaves!
4091                                ABCD_UP
4092      Y:000165 Y:000165                   DC      END_ABCD_UP-ABCD_UP-1
4093      Y:000166 Y:000166                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4094      Y:000167 Y:000167                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4095      Y:000168 Y:000168                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+000
4096      Y:000169 Y:000169                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+000+CD3+CD4+000+000
4097      Y:00016A Y:00016A                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+000+000+CD1+000+CD3+CD4+TGD+000
4098      Y:00016B Y:00016B                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+000+000+CD1+000+000+CD4+TGD+000
4099      Y:00016C Y:00016C                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+000+000+CD1+CD2+000+CD4+TGD+000
4100      Y:00016D Y:00016D                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+000+000+CD1+CD2+000+000+TGD+000
4101      Y:00016E Y:00016E                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+000+000+CD1+CD2+CD3+000+TGD+000
4102      Y:00016F Y:00016F                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4103                                END_ABCD_UP
4104   
4105                                ; Clock whole CCD down toward the EF serial register.  Serial phases 1 & 2 high.
4106                                ; AB goes 2-3-4-1, CD goes 3-2-1-4
4107                                ; Parallel phases 2 & 3 high during integration.
4108                                ; ADD DC RESTORE based on gwaves!
4109                                ABCD_DOWN
4110      Y:000170 Y:000170                   DC      END_ABCD_DOWN-ABCD_DOWN-1
4111      Y:000171 Y:000171                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4112      Y:000172 Y:000172                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4113      Y:000173 Y:000173                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+000+CD1+CD2+CD3+000+000+000
4114      Y:000174 Y:000174                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+000+CD1+CD2+000+000+000+000
4115      Y:000175 Y:000175                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+000+CD1+CD2+000+CD4+000+000
4116      Y:000176 Y:000176                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+000+CD1+000+000+CD4+000+000
4117      Y:000177 Y:000177                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+000+CD1+000+CD3+CD4+000+000
4118      Y:000178 Y:000178                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+000+CD3+CD4+000+000
4119      Y:000179 Y:000179                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+000
4120      Y:00017A Y:00017A                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4121                                END_ABCD_DOWN
4122   
4123                                ; Clock whole CCD split.  Serial phases 1 & 2 high.
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 78



4124                                ; ABCD all go 2-3-4-1
4125                                ; Parallel phases 2 & 3 high during integration.
4126                                ; ADD DC RESTORE based on gwaves!
4127                                ABCD_SPLIT
4128      Y:00017B Y:00017B                   DC      END_ABCD_SPLIT-ABCD_SPLIT-1
4129      Y:00017C Y:00017C                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4130      Y:00017D Y:00017D                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4131      Y:00017E Y:00017E                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+000+000+CD2+CD3+CD4+000+000
4132      Y:00017F Y:00017F                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+000+000+000+CD3+CD4+000+000
4133      Y:000180 Y:000180                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+000+CD1+000+CD3+CD4+TGD+000
4134      Y:000181 Y:000181                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+000+CD1+000+000+CD4+TGD+000
4135      Y:000182 Y:000182                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+000+CD1+CD2+000+CD4+TGD+000
4136      Y:000183 Y:000183                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+CD1+CD2+000+000+TGD+000
4137      Y:000184 Y:000184                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+CD1+CD2+CD3+000+TGD+000
4138      Y:000185 Y:000185                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4139                                END_ABCD_SPLIT
4140   
4141                                ; Clear whole CCD up toward the GH serial register.  Serial phases 1 & 2 high.
4142                                ; CD goes 2-3-4-1, AB goes 3-2-1-4
4143                                ; Parallel phases 2 & 3 high during integration.
4144                                ; ADD DC RESTORE based on gwaves!
4145                                ABCD_CLEAR_UP
4146      Y:000186 Y:000186                   DC      END_ABCD_CLEAR_UP-ABCD_CLEAR_UP-1
4147      Y:000187 Y:000187                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4148      Y:000188 Y:000188                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4149      Y:000189 Y:000189                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+DGD
4150      Y:00018A Y:00018A                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+000+CD3+CD4+000+DGD
4151      Y:00018B Y:00018B                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+000+000+CD1+000+CD3+CD4+TGD+DGD
4152      Y:00018C Y:00018C                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+000+000+CD1+000+000+CD4+TGD+DGD
4153      Y:00018D Y:00018D                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+000+000+CD1+CD2+000+CD4+TGD+DGD
4154      Y:00018E Y:00018E                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+000+000+CD1+CD2+000+000+TGD+DGD
4155      Y:00018F Y:00018F                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+000+000+CD1+CD2+CD3+000+TGD+DGD
4156      Y:000190 Y:000190                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+DGD
4157      Y:000191 Y:000191                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4158      Y:000192 Y:000192                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4159      Y:000193 Y:000193                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4160                                END_ABCD_CLEAR_UP
4161   
4162                                ; Clear whole CCD down toward the EF serial register.  Serial phases 1 & 2 high.
4163                                ; AB goes 2-3-4-1, CD goes 3-2-1-4
4164                                ; Parallel phases 2 & 3 high during integration.
4165                                ; ADD DC RESTORE based on gwaves!
4166                                ABCD_CLEAR_DOWN
4167      Y:000194 Y:000194                   DC      END_ABCD_CLEAR_DOWN-ABCD_CLEAR_DOWN-1
4168      Y:000195 Y:000195                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4169      Y:000196 Y:000196                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4170      Y:000197 Y:000197                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+DGA+CD1+CD2+CD3+000+000+000
4171      Y:000198 Y:000198                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+DGA+CD1+CD2+000+000+000+000
4172      Y:000199 Y:000199                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+DGA+CD1+CD2+000+CD4+000+000
4173      Y:00019A Y:00019A                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+DGA+CD1+000+000+CD4+000+000
4174      Y:00019B Y:00019B                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+DGA+CD1+000+CD3+CD4+000+000
4175      Y:00019C Y:00019C                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+DGA+000+000+CD3+CD4+000+000
4176      Y:00019D Y:00019D                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+DGA+000+CD2+CD3+CD4+000+000
4177      Y:00019E Y:00019E                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+000
4178      Y:00019F Y:00019F                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4179      Y:0001A0 Y:0001A0                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4180      Y:0001A1 Y:0001A1                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4181                                END_ABCD_CLEAR_DOWN
4182   
4183                                ; Clear whole CCD split.  Serial phases 1 & 2 high.
4184                                ; ABCD all go 2-3-4-1
4185                                ; Parallel phases 2 & 3 high during integration.
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 79



4186                                ; ADD DC RESTORE based on gwaves!
4187                                ABCD_CLEAR_SPLIT
4188      Y:0001A2 Y:0001A2                   DC      END_ABCD_CLEAR_SPLIT-ABCD_CLEAR_SPLIT-1
4189      Y:0001A3 Y:0001A3                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4190      Y:0001A4 Y:0001A4                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4191      Y:0001A5 Y:0001A5                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+DGA+000+CD2+CD3+CD4+000+DGD
4192      Y:0001A6 Y:0001A6                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+DGA+000+000+CD3+CD4+000+DGD
4193      Y:0001A7 Y:0001A7                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+DGA+CD1+000+CD3+CD4+TGD+DGD
4194      Y:0001A8 Y:0001A8                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+DGA+CD1+000+000+CD4+TGD+DGD
4195      Y:0001A9 Y:0001A9                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+DGA+CD1+CD2+000+CD4+TGD+DGD
4196      Y:0001AA Y:0001AA                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+DGA+CD1+CD2+000+000+TGD+DGD
4197      Y:0001AB Y:0001AB                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+DGA+CD1+CD2+CD3+000+TGD+DGD
4198      Y:0001AC Y:0001AC                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+DGD
4199      Y:0001AD Y:0001AD                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4200      Y:0001AE Y:0001AE                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4201      Y:0001AF Y:0001AF                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4202                                END_ABCD_CLEAR_SPLIT
4203   
4204                                ; Clock CD section up toward the GH serial register; AB static.  Serial phases 1 & 2 high.
4205                                ; CD goes 2-3-4-1
4206                                ; Parallel phases 2 & 3 high during integration.
4207                                ; ADD DC RESTORE based on gwaves!
4208                                CD_UP
4209      Y:0001B0 Y:0001B0                   DC      END_CD_UP-CD_UP-1
4210      Y:0001B1 Y:0001B1                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4211      Y:0001B2 Y:0001B2                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4212      Y:0001B3 Y:0001B3                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+000
4213      Y:0001B4 Y:0001B4                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+000+CD3+CD4+000+000
4214      Y:0001B5 Y:0001B5                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+CD3+CD4+TGD+000
4215      Y:0001B6 Y:0001B6                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+000+CD4+TGD+000
4216      Y:0001B7 Y:0001B7                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+CD4+TGD+000
4217      Y:0001B8 Y:0001B8                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+000+TGD+000
4218      Y:0001B9 Y:0001B9                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+CD3+000+TGD+000
4219      Y:0001BA Y:0001BA                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4220                                END_CD_UP
4221   
4222                                ; Clock AB section down toward the EF serial register; CD static.  Serial phases 1 & 2 high.
4223                                ; AB goes 2-3-4-1
4224                                ; Parallel phases 2 & 3 high during integration.
4225                                ; ADD DC RESTORE based on gwaves!
4226                                AB_DOWN
4227      Y:0001BB Y:0001BB                   DC      END_AB_DOWN-AB_DOWN-1
4228      Y:0001BC Y:0001BC                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4229      Y:0001BD Y:0001BD                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4230      Y:0001BE Y:0001BE                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+000+000+CD2+CD3+000+000+000
4231      Y:0001BF Y:0001BF                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+000+000+CD2+CD3+000+000+000
4232      Y:0001C0 Y:0001C0                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+000+000+CD2+CD3+000+000+000
4233      Y:0001C1 Y:0001C1                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+000+000+CD2+CD3+000+000+000
4234      Y:0001C2 Y:0001C2                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+000+000+CD2+CD3+000+000+000
4235      Y:0001C3 Y:0001C3                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+CD2+CD3+000+000+000
4236      Y:0001C4 Y:0001C4                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4237      Y:0001C5 Y:0001C5                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4238                                END_AB_DOWN
4239   
4240                                ; Clear CD section up toward the GH serial register; AB static.  Serial phases 1 & 2 high.
4241                                ; CD goes 2-3-4-1
4242                                ; Parallel phases 2 & 3 high during integration.
4243                                ; ADD DC RESTORE based on gwaves!
4244                                CD_CLEAR_UP
4245      Y:0001C6 Y:0001C6                   DC      END_CD_CLEAR_UP-CD_CLEAR_UP-1
4246      Y:0001C7 Y:0001C7                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4247      Y:0001C8 Y:0001C8                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 80



4248      Y:0001C9 Y:0001C9                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+DGD
4249      Y:0001CA Y:0001CA                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+000+CD3+CD4+000+DGD
4250      Y:0001CB Y:0001CB                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+CD3+CD4+TGD+DGD
4251      Y:0001CC Y:0001CC                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+000+CD4+TGD+DGD
4252      Y:0001CD Y:0001CD                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+CD4+TGD+DGD
4253      Y:0001CE Y:0001CE                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+000+TGD+DGD
4254      Y:0001CF Y:0001CF                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+CD3+000+TGD+DGD
4255      Y:0001D0 Y:0001D0                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+DGD
4256      Y:0001D1 Y:0001D1                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4257      Y:0001D2 Y:0001D2                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4258      Y:0001D3 Y:0001D3                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4259                                END_CD_CLEAR_UP
4260   
4261                                ; Clear AB section down toward the EF serial register; CD static.  Serial phases 1 & 2 high.
4262                                ; AB goes 2-3-4-1
4263                                ; Parallel phases 2 & 3 high during integration.
4264                                ; ADD DC RESTORE based on gwaves!
4265                                AB_CLEAR_DOWN
4266      Y:0001D4 Y:0001D4                   DC      END_AB_CLEAR_DOWN-AB_CLEAR_DOWN-1
4267      Y:0001D5 Y:0001D5                   DC      VIDEO+INT_DCR                     ; Reset integ. and DC restore
4268      Y:0001D6 Y:0001D6                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4269      Y:0001D7 Y:0001D7                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4270      Y:0001D8 Y:0001D8                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4271      Y:0001D9 Y:0001D9                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4272      Y:0001DA Y:0001DA                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4273      Y:0001DB Y:0001DB                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+DGA+000+CD2+CD3+000+000+000
4274      Y:0001DC Y:0001DC                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+DGA+000+CD2+CD3+000+000+000
4275      Y:0001DD Y:0001DD                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+000
4276      Y:0001DE Y:0001DE                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+000
4277      Y:0001DF Y:0001DF                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4278      Y:0001E0 Y:0001E0                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4279      Y:0001E1 Y:0001E1                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4280                                END_AB_CLEAR_DOWN
4281   
4282                                ; Dump both the EF and GH serial registers using DGA and DGD
4283                                DUMP_SERIAL
4284      Y:0001E2 Y:0001E2                   DC      END_DUMP_SERIAL-DUMP_SERIAL-1
4285      Y:0001E3 Y:0001E3                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4286      Y:0001E4 Y:0001E4                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+DGD
4287      Y:0001E5 Y:0001E5                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
4288      Y:0001E6 Y:0001E6                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
4289      Y:0001E7 Y:0001E7                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4290                                END_DUMP_SERIAL
4291   
4292   
4293   
4294   
4295                                ; Parallel waveforms done.  Move on to the layered serial ones.
4296   
4297                                ;       These are the 12 fast serial read waveforms for left, right,
4298                                ;       and split reads for serial binning factors from 1 to 4.
4299   
4300                                ;       Unbinned waveforms
4301                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4302                                SERIAL_READ_EH_1
4303      Y:0001E8 Y:0001E8                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4304      Y:0001E9 Y:0001E9                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4305      Y:0001EA Y:0001EA                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4306      Y:0001EB Y:0001EB                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4307      Y:0001EC Y:0001EC                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4308      Y:0001ED Y:0001ED                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4309                                SXMIT_EH_1
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 81



4310      Y:0001EE Y:0001EE                   DC      $00F000                           ; Transmit A/D data to host
4311      Y:0001EF Y:0001EF                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4312      Y:0001F0 Y:0001F0                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4313      Y:0001F1 Y:0001F1                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4314      Y:0001F2 Y:0001F2                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4315      Y:0001F3 Y:0001F3                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4316      Y:0001F4 Y:0001F4                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4317      Y:0001F5 Y:0001F5                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4318                                END_SERIAL_READ_EH_1
4319   
4320                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4321                                SERIAL_READ_FG_1
4322      Y:0001F6 Y:0001F6                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4323      Y:0001F7 Y:0001F7                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4324      Y:0001F8 Y:0001F8                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4325      Y:0001F9 Y:0001F9                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4326      Y:0001FA Y:0001FA                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4327      Y:0001FB Y:0001FB                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4328                                SXMIT_FG_1
4329      Y:0001FC Y:0001FC                   DC      $00F021                           ; Transmit A/D data to host
4330      Y:0001FD Y:0001FD                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4331      Y:0001FE Y:0001FE                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4332      Y:0001FF Y:0001FF                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4333      Y:000200 Y:000200                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4334      Y:000201 Y:000201                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4335      Y:000202 Y:000202                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4336      Y:000203 Y:000203                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4337                                END_SERIAL_READ_FG_1
4338   
4339                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4340                                SERIAL_READ_SPLIT_1
4341      Y:000204 Y:000204                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4342      Y:000205 Y:000205                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4343      Y:000206 Y:000206                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4344      Y:000207 Y:000207                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4345      Y:000208 Y:000208                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4346      Y:000209 Y:000209                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4347                                SXMIT_SPLIT_1
4348      Y:00020A Y:00020A                   DC      $00F020                           ; Transmit A/D data to host
4349      Y:00020B Y:00020B                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4350      Y:00020C Y:00020C                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4351      Y:00020D Y:00020D                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4352      Y:00020E Y:00020E                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4353      Y:00020F Y:00020F                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4354      Y:000210 Y:000210                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4355      Y:000211 Y:000211                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4356                                END_SERIAL_READ_SPLIT_1
4357   
4358                                ;       Bin by 2 waveforms
4359                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4360                                SERIAL_READ_EH_2
4361      Y:000212 Y:000212                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4362      Y:000213 Y:000213                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4363      Y:000214 Y:000214                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4364      Y:000215 Y:000215                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4365      Y:000216 Y:000216                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4366      Y:000217 Y:000217                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4367      Y:000218 Y:000218                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4368      Y:000219 Y:000219                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4369      Y:00021A Y:00021A                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4370      Y:00021B Y:00021B                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4371      Y:00021C Y:00021C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 82



4372      Y:00021D Y:00021D                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4373                                SXMIT_EH_2
4374      Y:00021E Y:00021E                   DC      $00F000                           ; Transmit A/D data to host
4375      Y:00021F Y:00021F                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4376      Y:000220 Y:000220                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4377      Y:000221 Y:000221                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4378      Y:000222 Y:000222                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4379      Y:000223 Y:000223                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4380      Y:000224 Y:000224                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4381      Y:000225 Y:000225                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4382                                END_SERIAL_READ_EH_2
4383   
4384                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4385                                SERIAL_READ_FG_2
4386      Y:000226 Y:000226                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4387      Y:000227 Y:000227                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4388      Y:000228 Y:000228                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4389      Y:000229 Y:000229                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4390      Y:00022A Y:00022A                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4391      Y:00022B Y:00022B                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4392      Y:00022C Y:00022C                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4393      Y:00022D Y:00022D                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4394      Y:00022E Y:00022E                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4395      Y:00022F Y:00022F                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4396      Y:000230 Y:000230                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4397      Y:000231 Y:000231                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4398                                SXMIT_FG_2
4399      Y:000232 Y:000232                   DC      $00F021                           ; Transmit A/D data to host
4400      Y:000233 Y:000233                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4401      Y:000234 Y:000234                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4402      Y:000235 Y:000235                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4403      Y:000236 Y:000236                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4404      Y:000237 Y:000237                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4405      Y:000238 Y:000238                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4406      Y:000239 Y:000239                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4407                                END_SERIAL_READ_FG_2
4408   
4409                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4410                                SERIAL_READ_SPLIT_2
4411      Y:00023A Y:00023A                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4412      Y:00023B Y:00023B                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4413      Y:00023C Y:00023C                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4414      Y:00023D Y:00023D                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4415      Y:00023E Y:00023E                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4416      Y:00023F Y:00023F                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4417      Y:000240 Y:000240                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4418      Y:000241 Y:000241                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4419      Y:000242 Y:000242                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4420      Y:000243 Y:000243                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4421      Y:000244 Y:000244                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4422      Y:000245 Y:000245                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4423                                SXMIT_SPLIT_2
4424      Y:000246 Y:000246                   DC      $00F020                           ; Transmit A/D data to host
4425      Y:000247 Y:000247                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4426      Y:000248 Y:000248                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4427      Y:000249 Y:000249                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4428      Y:00024A Y:00024A                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4429      Y:00024B Y:00024B                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4430      Y:00024C Y:00024C                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4431      Y:00024D Y:00024D                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4432                                END_SERIAL_READ_SPLIT_2
4433   
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 83



4434                                ;       Bin by 3 waveforms
4435                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4436                                SERIAL_READ_EH_3
4437      Y:00024E Y:00024E                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4438      Y:00024F Y:00024F                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4439      Y:000250 Y:000250                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4440      Y:000251 Y:000251                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4441      Y:000252 Y:000252                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4442      Y:000253 Y:000253                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4443      Y:000254 Y:000254                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4444      Y:000255 Y:000255                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4445      Y:000256 Y:000256                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4446      Y:000257 Y:000257                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4447      Y:000258 Y:000258                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4448      Y:000259 Y:000259                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4449      Y:00025A Y:00025A                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4450      Y:00025B Y:00025B                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4451      Y:00025C Y:00025C                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4452      Y:00025D Y:00025D                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4453      Y:00025E Y:00025E                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4454      Y:00025F Y:00025F                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4455                                SXMIT_EH_3
4456      Y:000260 Y:000260                   DC      $00F000                           ; Transmit A/D data to host
4457      Y:000261 Y:000261                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4458      Y:000262 Y:000262                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4459      Y:000263 Y:000263                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4460      Y:000264 Y:000264                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4461      Y:000265 Y:000265                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4462      Y:000266 Y:000266                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4463      Y:000267 Y:000267                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4464                                END_SERIAL_READ_EH_3
4465   
4466                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4467                                SERIAL_READ_FG_3
4468      Y:000268 Y:000268                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4469      Y:000269 Y:000269                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4470      Y:00026A Y:00026A                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4471      Y:00026B Y:00026B                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4472      Y:00026C Y:00026C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4473      Y:00026D Y:00026D                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4474      Y:00026E Y:00026E                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4475      Y:00026F Y:00026F                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4476      Y:000270 Y:000270                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4477      Y:000271 Y:000271                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4478      Y:000272 Y:000272                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4479      Y:000273 Y:000273                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4480      Y:000274 Y:000274                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4481      Y:000275 Y:000275                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4482      Y:000276 Y:000276                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4483      Y:000277 Y:000277                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4484      Y:000278 Y:000278                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4485      Y:000279 Y:000279                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4486                                SXMIT_FG_3
4487      Y:00027A Y:00027A                   DC      $00F021                           ; Transmit A/D data to host
4488      Y:00027B Y:00027B                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4489      Y:00027C Y:00027C                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4490      Y:00027D Y:00027D                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4491      Y:00027E Y:00027E                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4492      Y:00027F Y:00027F                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4493      Y:000280 Y:000280                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4494      Y:000281 Y:000281                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4495                                END_SERIAL_READ_FG_3
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 84



4496   
4497                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4498                                SERIAL_READ_SPLIT_3
4499      Y:000282 Y:000282                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4500      Y:000283 Y:000283                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4501      Y:000284 Y:000284                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4502      Y:000285 Y:000285                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4503      Y:000286 Y:000286                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4504      Y:000287 Y:000287                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4505      Y:000288 Y:000288                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4506      Y:000289 Y:000289                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4507      Y:00028A Y:00028A                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4508      Y:00028B Y:00028B                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4509      Y:00028C Y:00028C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4510      Y:00028D Y:00028D                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4511      Y:00028E Y:00028E                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4512      Y:00028F Y:00028F                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4513      Y:000290 Y:000290                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4514      Y:000291 Y:000291                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4515      Y:000292 Y:000292                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4516      Y:000293 Y:000293                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4517                                SXMIT_SPLIT_3
4518      Y:000294 Y:000294                   DC      $00F020                           ; Transmit A/D data to host
4519      Y:000295 Y:000295                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4520      Y:000296 Y:000296                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4521      Y:000297 Y:000297                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4522      Y:000298 Y:000298                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4523      Y:000299 Y:000299                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4524      Y:00029A Y:00029A                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4525      Y:00029B Y:00029B                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4526                                END_SERIAL_READ_SPLIT_3
4527   
4528                                ;       Bin by 4 waveforms
4529                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4530                                SERIAL_READ_EH_4
4531      Y:00029C Y:00029C                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4532      Y:00029D Y:00029D                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4533      Y:00029E Y:00029E                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4534      Y:00029F Y:00029F                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4535      Y:0002A0 Y:0002A0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4536      Y:0002A1 Y:0002A1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4537      Y:0002A2 Y:0002A2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4538      Y:0002A3 Y:0002A3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4539      Y:0002A4 Y:0002A4                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4540      Y:0002A5 Y:0002A5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4541      Y:0002A6 Y:0002A6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4542      Y:0002A7 Y:0002A7                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4543      Y:0002A8 Y:0002A8                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4544      Y:0002A9 Y:0002A9                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4545      Y:0002AA Y:0002AA                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4546      Y:0002AB Y:0002AB                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4547      Y:0002AC Y:0002AC                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4548      Y:0002AD Y:0002AD                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4549      Y:0002AE Y:0002AE                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
4550      Y:0002AF Y:0002AF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
4551      Y:0002B0 Y:0002B0                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
4552      Y:0002B1 Y:0002B1                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
4553      Y:0002B2 Y:0002B2                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
4554      Y:0002B3 Y:0002B3                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
4555                                SXMIT_EH_4
4556      Y:0002B4 Y:0002B4                   DC      $00F000                           ; Transmit A/D data to host
4557      Y:0002B5 Y:0002B5                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 85



4558      Y:0002B6 Y:0002B6                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4559      Y:0002B7 Y:0002B7                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4560      Y:0002B8 Y:0002B8                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4561      Y:0002B9 Y:0002B9                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4562      Y:0002BA Y:0002BA                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4563      Y:0002BB Y:0002BB                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4564                                END_SERIAL_READ_EH_4
4565   
4566                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4567                                SERIAL_READ_FG_4
4568      Y:0002BC Y:0002BC                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4569      Y:0002BD Y:0002BD                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4570      Y:0002BE Y:0002BE                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
4571      Y:0002BF Y:0002BF                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4572      Y:0002C0 Y:0002C0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4573      Y:0002C1 Y:0002C1                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4574      Y:0002C2 Y:0002C2                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4575      Y:0002C3 Y:0002C3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4576      Y:0002C4 Y:0002C4                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4577      Y:0002C5 Y:0002C5                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4578      Y:0002C6 Y:0002C6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4579      Y:0002C7 Y:0002C7                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4580      Y:0002C8 Y:0002C8                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4581      Y:0002C9 Y:0002C9                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4582      Y:0002CA Y:0002CA                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4583      Y:0002CB Y:0002CB                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4584      Y:0002CC Y:0002CC                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4585      Y:0002CD Y:0002CD                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4586      Y:0002CE Y:0002CE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
4587      Y:0002CF Y:0002CF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
4588      Y:0002D0 Y:0002D0                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
4589      Y:0002D1 Y:0002D1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
4590      Y:0002D2 Y:0002D2                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
4591      Y:0002D3 Y:0002D3                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
4592                                SXMIT_FG_4
4593      Y:0002D4 Y:0002D4                   DC      $00F021                           ; Transmit A/D data to host
4594      Y:0002D5 Y:0002D5                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4595      Y:0002D6 Y:0002D6                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4596      Y:0002D7 Y:0002D7                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4597      Y:0002D8 Y:0002D8                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
4598      Y:0002D9 Y:0002D9                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4599      Y:0002DA Y:0002DA                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4600      Y:0002DB Y:0002DB                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4601                                END_SERIAL_READ_FG_4
4602   
4603                                ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
4604                                SERIAL_READ_SPLIT_4
4605      Y:0002DC Y:0002DC                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
4606      Y:0002DD Y:0002DD                   DC      VIDEO+INT_INIT                    ; Change nearly everything
4607      Y:0002DE Y:0002DE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
4608      Y:0002DF Y:0002DF                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4609      Y:0002E0 Y:0002E0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4610      Y:0002E1 Y:0002E1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4611      Y:0002E2 Y:0002E2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4612      Y:0002E3 Y:0002E3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4613      Y:0002E4 Y:0002E4                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4614      Y:0002E5 Y:0002E5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4615      Y:0002E6 Y:0002E6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4616      Y:0002E7 Y:0002E7                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4617      Y:0002E8 Y:0002E8                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4618      Y:0002E9 Y:0002E9                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4619      Y:0002EA Y:0002EA                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
Motorola DSP56300 Assembler  Version 6.2.23   112-08-14  20:00:59  lmi.waveforms.s  Page 86



4620      Y:0002EB Y:0002EB                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4621      Y:0002EC Y:0002EC                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4622      Y:0002ED Y:0002ED                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4623      Y:0002EE Y:0002EE                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
4624      Y:0002EF Y:0002EF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
4625      Y:0002F0 Y:0002F0                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
4626      Y:0002F1 Y:0002F1                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
4627      Y:0002F2 Y:0002F2                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
4628      Y:0002F3 Y:0002F3                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
4629                                SXMIT_SPLIT_4
4630      Y:0002F4 Y:0002F4                   DC      $00F020                           ; Transmit A/D data to host
4631      Y:0002F5 Y:0002F5                   DC      VIDEO+INT_RSTOFF                  ; Stop resetting integrator
4632      Y:0002F6 Y:0002F6                   DC      VIDEO+INT_TIM+INT_MINUS           ; Integrate reset level
4633      Y:0002F7 Y:0002F7                   DC      VIDEO+INT_STOP                    ; Stop Integrate
4634      Y:0002F8 Y:0002F8                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
4635      Y:0002F9 Y:0002F9                   DC      VIDEO+INT_TIM+INT_PLUS            ; Integrate signal level
4636      Y:0002FA Y:0002FA                   DC      VIDEO+ADC_TIM+INT_SMPL            ; Stop integrate, A/D is sampling
4637      Y:0002FB Y:0002FB                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
4638                                END_SERIAL_READ_SPLIT_4
4639   
4640                                 END_APPLICATON_Y_MEMORY
4641      0002FC                              EQU     @LCV(L)
4642   
4643                                ;  End of program
4644                                          END

0    Errors
0    Warnings


