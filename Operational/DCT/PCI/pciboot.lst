Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 1



1                                  COMMENT *
2      
3                          This file is used to generate DSP code for the PCI interface
4                                  board using a DSP56301 as its main processor.
5      
6                          April,2010    Peter L. Collins (Lowell Observatory)
7                                      Modified to run on gen-iii.
8      
9                          Version 1.7_3/2 Added conditional code for interaction history log.
10                         Version 1.7_3/1 Added conditional code for hardware timer, test point.
11                         Version 1.7_3   Revised PCI Error handling and versioning support.
12     
13                         Version 1.7_2 - PCI DMA writes like the gen-III code with fiber optic and DMA
14                                         transfer concurrency for still better performance.
15                                         Fill ptr and wrap counter for circular buffer support.
16     
17                         Version 1.7_1 - PCI DMA writes like the gen-III code for better performance.
18     
19                         Version 1.7 -   Replies to commands with polling only, no interrupts
20                                         Number of 16-bit pixels returned to host during image readout
21     
22                         Some Rules -
23                                 Commands executed only by the PCI board end with a jump to FINISH,
24                                         FINISH1 or ERROR, since these will assert the reply flags
25                                         and return from interrupt.
26                                 Commands passed along to the timing board end only with RTI since
27                                         the reply from the timing board will generate its own call
28                                         to FINISH1 or ERROR.
29                                 PCI -> commands are received as 24-bit words, with
30                                 Communication of commands and replies over the PCI bus is all at
31                                         24 bits per word. PCI address that need to be passed are
32                                         split into two 16-bit words.
33     
34                         CHANGES, Feb,March,2009 (Peter L. Collins, Lowell Observatory)
35                                  fixed race between READ_NUMBER_OF_PIXELS_READ (interrupt for pxl cntr)
36                                  and C_RPXLS- problem coming from non-atomic update of the two counter
37                                  locations, causing apparent pixel counter to occasionally 'back up'-
38                                  this was OK in earlier LOIS versions where the pixel counter was a
39                                  linear counter polled for completion- however, the circular buffering
40                                  mode used (now) on MAGIC and HIPO blows up. The fix involves several Y
41                                  locations to save an old copy of the pixel counter locations during
42                                  the critical section, and marking the critical state using bit 0 in
43                                  X:<R_PXLS_CRIT.
44     
45     
46                         March,2007 (Peter L. Collins, Lowell Observatory)
47                                 -The "long form" unused PCI retry/handler previously following WR_ERR
48                                  was slightly modified and made to work. The immediate effect was
49                                  to remove a large volume of secondary PCI retries (factor of 2).
50     
51                         February, 2007   (Peter L. Collins, Lowell Observatory)
52                                 -change pixel count returned in GET_PROGRESS ioctl to
53                                  6 bits bits of wrap and 26 bits of FILL.
54     
55                                 -Keep error counts regardless of error logging switch.
56     
57                                 -Prevent error logging in Y memory from overrunning Y memory- it
58                                  is bounded by PCIERRLOGSIZE.
59     
60                                 -Error buffer logging in Y memory controlled by X:PCIERRLOG switch.
61                                  Further modification to DMA to flush PCI transmit fifo before each
62                                  burst transfer. Error buffer added in Y memory following
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 2



63                                  the 512 pixel image buffer.
64     
65                                 -Interleave copy from RDFIFO to IMAGE_BUFER with pci transfer
66                                  using FILL and EMPTY. It is still tied to the 512 pixel block
67                                  concept (and use of the  half full flag on the fiber optic fifo.)
68     
69                         January, 2007   (Peter L. Collins, Lowell Observatory)
70                                 - put in geniii "DMA" to write to pci bus.
71                                 - add loop statistics and oscilloscope check points.
72                                 - fix to update DSR0 register for a pci retry. Prior
73                                   code seemed to be writing the next burst where the
74                                   last should have been- in the case of retry- ultimately
75                                   causing bad pixels off the end of the image bufer to appear
76                                   in the image in the case of retries (as engendered by heavy
77                                   concurrent host pci activity, such as an ftp).
78     
79                         February to March 2001
80                                 - Get rid of Number of Bytes per pixel in images. Assume 2.
81                                 - Get rid of $80A7 = read image command.
82                                 - Process 'RDA' timing board command to start the readout
83                                 - Jump to error if receiver FIFO is empty on vector commands
84                                 - Replace GET_FO mess with calls to RD_FO
85                                 - Implement a timeout on fiber optic words, called RD_FO_TIMEOUT
86                                 - Number of bytes per image replaces NCOLS x NROWS
87                                 - Interrupt levels set as folllows -
88                                         New vector command locations for more order
89                                         NMI for read PCI image address, reset PCI, abort readout
90                                         IPL = 2 for reset button, FIFO HF, enabled during readout
91                                         IPL = 1 for all host commands
92                                         Host commands disabled during image readout
93                                 - Host flags = 5 if reading out image
94                                 - Commands from the PCI host follow the fiber optic protocol,
95                                         header, command, arg1 - arg4
96                                     with command words written to $10020 and then vector $B1
97                                 - A BUSY host flag was introduced =6 for the case where a command
98                                         takes longer than the voodoo TIMEOUT to execute
99                                 - The non-maskable reboot from EEPROM command = $807B is implemented
100                                - RDM and WRM were changed to abide by the timing board convention
101                                        of embedding the memory type in the address' most significant
102                                        nibble. This limits memory accesses to 64k on this board.
103                                - Eliminate Scatter/Gather image processing in favor of direct
104                                        FIFO to PCI bus transfers.
105                        April 25 - Change PCI write handshaking to MARQ and MDT, eliminating the
106                                        special writing of 8 pixels at the beginning of each image.
107    
108                        Version 1.7 as follows:
109                                - Slaved READ IMAGE to the controller for the number of pixels
110                                        to be read, not just the starting time.
111                                - Introduced the 'IIA' = Initialize Image Address command sent by
112                                        the timing board as a reply to the 'SEX' command to set
113                                        PCI_ADDR = BASE_ADDR at the start of an image instead of
114                                        having the host computer issue it.
115                                - Took out the WRITE_NUMBER_OF_BYTES_IN_IMAGE and
116                                        INITIALIZE_NUMBER_OF_PIXELS command because the
117                                        timing board now does this.
118                                - Introduced the local variable X:<HOST_FLAG that is set to
119                                        the value of the DCTR register bits 5,4,3 to inform
120                                        this program what state the controller is in.
121                                - Separately process commands from the controller to the PCI board,
122                                        distinguished by Destination = 1. Host commands or replies
123                                        have Destination = 0.
124                                - Introduced RDI = 'Reading Image ON' and RDO = 'Reading Image Off'
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 3



125                                        commands from the timing board to set host flags indicating
126                                        that the controller is readout out.
127                                *
128                                  PAGE    132                               ; Printronix page width - 132 columns
129    
130                        ; Equates to define the X: memory tables
131       000000           VAR_TBL   EQU     0                                 ; Variables and constants table
132       000030           ARG_TBL   EQU     $30                               ; Command arguments and addresses
133       000060           VAR2_TBL  EQU     $60                               ; Another variable and constants table
134    
135                        ; Various addressing control registers
136       FFFFFB           BCR       EQU     $FFFFFB                           ; Bus Control Register
137       FFFFFA           DCR       EQU     $FFFFFA                           ; DRAM Control Register
138       FFFFF9           AAR0      EQU     $FFFFF9                           ; Address Attribute Register, channel 0
139       FFFFF8           AAR1      EQU     $FFFFF8                           ; Address Attribute Register, channel 1
140       FFFFF7           AAR2      EQU     $FFFFF7                           ; Address Attribute Register, channel 2
141       FFFFF6           AAR3      EQU     $FFFFF6                           ; Address Attribute Register, channel 3
142       FFFFFD           PCTL      EQU     $FFFFFD                           ; PLL control register
143       FFFFFE           IPRP      EQU     $FFFFFE                           ; Interrupt Priority register - Peripheral
144       FFFFFF           IPRC      EQU     $FFFFFF                           ; Interrupt Priority register - Core
145    
146                        ; PCI control register
147       FFFFCD           DTXS      EQU     $FFFFCD                           ; DSP Slave transmit data FIFO
148       FFFFCC           DTXM      EQU     $FFFFCC                           ; DSP Master transmit data FIFO
149       FFFFCB           DRXR      EQU     $FFFFCB                           ; DSP Receive data FIFO
150       FFFFCA           DPSR      EQU     $FFFFCA                           ; DSP PCI Status Register
151       FFFFC9           DSR       EQU     $FFFFC9                           ; DSP Status Register
152       FFFFC8           DPAR      EQU     $FFFFC8                           ; DSP PCI Address Register
153       FFFFC7           DPMC      EQU     $FFFFC7                           ; DSP PCI Master Control Register
154       FFFFC6           DPCR      EQU     $FFFFC6                           ; DSP PCI Control Register
155       FFFFC5           DCTR      EQU     $FFFFC5                           ; DSP Control Register
156    
157                        ; Port E is the Synchronous Communications Interface (SCI) port
158       FFFF9F           PCRE      EQU     $FFFF9F                           ; Port Control Register
159       FFFF9E           PRRE      EQU     $FFFF9E                           ; Port Direction Register
160       FFFF9D           PDRE      EQU     $FFFF9D                           ; Port Data Register
161    
162                        ; Various PCI register bit equates
163       000001           STRQ      EQU     1                                 ; Slave transmit data request (DSR)
164       000002           SRRQ      EQU     2                                 ; Slave receive data request (DSR)
165       000017           HACT      EQU     23                                ; Host active, low true (DSR)
166       000001           MTRQ      EQU     1                                 ; Set whem master transmitter is not full (DPSR)
167       000004           MARQ      EQU     4                                 ; Master address request (DPSR)
168       00000A           TRTY      EQU     10                                ; PCI Target Retry (DPSR)
169       000000           HCIE      EQU     0                                 ; Host command interrupt enable (DCTR)
170       000006           INTA      EQU     6                                 ; Request PCI interrupt (DCTR)
171       000005           APER      EQU     5                                 ; Address parity error
172       000006           DPER      EQU     6                                 ; Data parity error
173       000007           MAB       EQU     7                                 ; Master Abort
174       000008           TAB       EQU     8                                 ; Target Abort
175       000009           TDIS      EQU     9                                 ; Target Disconnect
176       00000B           TO        EQU     11                                ; Timeout
177       00000E           MDT       EQU     14                                ; Master Data Transfer complete
178       00000F           RDCQ      EQU     15                                ; Remaining Data Count Qualifier
179       000002           SCLK      EQU     2                                 ; SCLK = transmitter special code
180    
181                        ; DPCR bit definitions
182       00000E           CLRT      EQU     14                                ; Clear the master transmitter DTXM
183       000012           MACE      EQU     18                                ; Master access counter enable
184       000015           IAE       EQU     21                                ; Insert Address Enable
185    
186                        ; DMA register definitions
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 4



187       FFFFEF           DSR0      EQU     $FFFFEF                           ; Source address register
188       FFFFEE           DDR0      EQU     $FFFFEE                           ; Destination address register
189       FFFFED           DCO0      EQU     $FFFFED                           ; Counter register
190       FFFFEC           DCR0      EQU     $FFFFEC                           ; Control register
191    
192                        ; Addresses of ESSI port
193       FFFFBC           TX00      EQU     $FFFFBC                           ; Transmit Data Register 0
194       FFFFB7           SSISR0    EQU     $FFFFB7                           ; Status Register
195       FFFFB6           CRB0      EQU     $FFFFB6                           ; Control Register B
196       FFFFB5           CRA0      EQU     $FFFFB5                           ; Control Register A
197    
198                        ; SSI Control Register A Bit Flags
199       000006           TDE       EQU     6                                 ; Set when transmitter data register is empty
200    
201                        ; Miscellaneous addresses
202       FFFFFF           RDFIFO    EQU     $FFFFFF                           ; Read the FIFO for incoming fiber optic data
203    
204                                  IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
205                        ; Timer Addresses
206       FFFF8F           TCSR0     EQU     $FFFF8F                           ; Triple timer control and status register 0
207       FFFF8E           TLR0      EQU     $FFFF8E                           ; Timer load register = 0
208       FFFF8D           TCPR0     EQU     $FFFF8D                           ; Timer compare register = exposure time
209       FFFF8C           TCR0      EQU     $FFFF8C                           ; Timer count register = elapsed time
210       FFFF8B           TCSR1     EQU     $FFFF8B                           ; Triple timer control and status register 1
211       FFFF8A           TLR1      EQU     $FFFF8A                           ; Timer load register = 0
212       FFFF89           TCPR1     EQU     $FFFF89                           ; Timer compare register = exposure time
213       FFFF88           TCR1      EQU     $FFFF88                           ; Timer count register = elapsed time
214       FFFF87           TCSR2     EQU     $FFFF87                           ; Triple timer control and status register 2
215       FFFF86           TLR2      EQU     $FFFF86                           ; Timer load register = 0
216       FFFF85           TCPR2     EQU     $FFFF85                           ; Timer compare register = exposure time
217       FFFF84           TCR2      EQU     $FFFF84                           ; Timer count register = elapsed time
218       FFFF83           TPLR      EQU     $FFFF83                           ; Timer prescaler load register => milliseconds
219       FFFF82           TPCR      EQU     $FFFF82                           ; Timer prescaler count register
220       000000           TIM_BIT   EQU     0                                 ; Set to enable the timer
221       000015           TCF       EQU     21                                ; Set when timer counter = compare register
222                                  ELSE
226                                  ENDIF
227    
228                        ; Phase Locked Loop initialization
229       050003           PLL_INIT  EQU     $050003                           ; PLL = 25 MHz x 4 = 100 MHz
230    
231                        ; Port C is Enhanced Synchronous Serial Port 0
232       FFFFBF           PCRC      EQU     $FFFFBF                           ; Port C Control Register
233       FFFFBE           PRRC      EQU     $FFFFBE                           ; Port C Data direction Register
234       FFFFBD           PDRC      EQU     $FFFFBD                           ; Port C GPIO Data Register
235    
236                        ; Port D is Enhanced Synchronous Serial Port 1
237       FFFFAF           PCRD      EQU     $FFFFAF                           ; Port D Control Register
238       FFFFAE           PRRD      EQU     $FFFFAE                           ; Port D Data direction Register
239       FFFFAD           PDRD      EQU     $FFFFAD                           ; Port D GPIO Data Register
240    
241                        ; Bit number definitions of GPIO pins on Port D
242       000000           EF        EQU     0                                 ; FIFO Empty flag, low true
243       000001           HF        EQU     1                                 ; FIFO Half Full flag, low true
244    
245                        ; STATUS bit definition
246       000000           ODD       EQU     0                                 ; Set if odd number of pixels are in the image
247       000001           TIMROMBURN EQU    1                                 ; Burning timing board EEPROM, ignore replies
248    
249                        ; PCI transfer constants
250       000200           FOBURST   EQU     512                               ; unit of pixels.
251       000080           PCIBURST  EQU     128                               ; unit of pixels.
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 5



252       000100           PCI2BURST EQU     256                               ; unit of pixels.
253                        PCI_ERRMAGIC
254       FEEDEE                     EQU     $FEEDEE                           ; set PCI_ERRLOG to this to enable retry log
255                        PCI_ERRLOGSIZE
256       000064                     EQU     100                               ; Maximum entries in Y memory pci error log
257                        PCI_ERRLOGFIRST
258       000400                     EQU     1024                              ; Start of Y memory pci error log
259                        PCI_ERRLOGLAST
260       000464                     EQU     1124                              ; End+1 of Y memory pci error log
261       0007D0           PCI_YCOMM EQU     2000                              ; small comm area up through 2047
262       0007E0           RPXLS_SAFE EQU    PCI_YCOMM+16                      ; alternate R_PXLS copy for race
263    
264                        ; History log
265                                  IF      @SCP("SUPPORTED","SUPPORTED")
266                        PCI_HISTFIRST
267       000800                     EQU     2048                              ; history log start in Y memory
268                        PCI_HISTEND
269       001000                     EQU     4096                              ; history log end + 1 in Y memory
270    
271                        ; PCI history tags
272       524E50           H_RDNUMPIX EQU    'RNP'                             ; READ_NUMBER_OF_PIXELS_READ
273                        H_RDREPLYVAL
274       525250                     EQU     'RRP'                             ; READ_REPLY_VALUE
275                        H_BASEPCIADDR
276       574250                     EQU     'WBP'                             ; WRITE_BASE_PCI_ADDRESS
277                        H_CLEARHOSTFLG
278       434846                     EQU     'CHF'                             ; CLEAR_HOST_FLAG
279                        F_READ_IMAGE
280       524441                     EQU     'RDA'                             ; READ_IMAGE
281                        F_READING_IMAGE
282       524449                     EQU     'RDI'                             ; READING_IMAGE
283                        F_INIT_NO_PIX
284       494941                     EQU     'IIA'                             ; INITIALIZE_NUMBER_OF_PIXELS
285       575331           F_WCMDSTG1 EQU    'WS1'                             ; WRITE-COMMAND error, stage 1, fifo empty
286       575332           F_WCMDSTG2 EQU    'WS2'                             ; WRITE-COMMAND error, stage 2, header bad
287       575333           F_WCMDSTG3 EQU    'WS3'                             ; WRITE-COMMAND error, stage 3, header bad
288       575334           F_WCMDSTG4 EQU    'WS4'                             ; WRITE-COMMAND error, stage 4, arg cnt <= 0
289       575335           F_WCMDSTG5 EQU    'WS5'                             ; WRITE-COMMAND error, stage 5, arg cnt too lrg
290       575336           F_WCMDSTG6 EQU    'WS6'                             ; WRITE-COMMAND error, stage 6, dest = 0
291                                  ENDIF
292    
293                        ;       Standard info fields specification
294                                  INCLUDE "infospec.s"
295                        ; General DSP info field specifications.
296                        ; These values are 'addresses' and used as the argument for the INF command.
297    
298                        GET_VERSION
299       000000                     EQU     0                                 ; IVERSION field
300       000001           GET_FLAVOR EQU    1                                 ; IFLAVOR field
301       000002           GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
302       000003           GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
303       000004           GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if available)
304    
305                        ;       PCI-specific info fields specification
306                                  INCLUDE "pciinfospec.s"
307                        ; PCI DSP info field specifications.
308                        ; These values are 'addresses' and used as the argument for the INF command.
309    
310                        GET_CAPABLE
311       000100                     EQU     $100                              ; ICAPABLE field (what dsp supports).
312    
313                        ;       File of info field values
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 6



314                                  INCLUDE "pciinfo.s"
315                        ; DSP Version
316       0471C5           IVERSION  EQU     291269                            ; 1.7/7/5
317    
318       202020           IFLAVOR   EQU     '   '                             ; none
319    
320       001C21           ITIME0    EQU     7201                              ; lo order time: 2011 2 26  15:28:33 GMT
321    
322       004D69           ITIME1    EQU     19817                             ; hi order time: 2011 2 26  15:28:33 GMT
323    
324       000000           ISVNREV   EQU     0                                 ; most recent code svn rev
325    
326                                  INCLUDE "version.s"                       ; backward compatibility
327                        ; DSP Version
328       0471C1           VERSION   EQU     291265                            ; V1.7/7
329    
330    
331                        ; set up pci capabilities word
332                                  IF      @SCP("SUPPORTED","SUPPORTED")     ;bit 0 (1)
333       000001           RDACAPABLE EQU    1
334                                  ELSE
336                                  ENDIF
337                                  IF      @SCP("SUPPORTED","SUPPORTED")     ;bit 0 (1)
338                        HISTCAPABLE
339       000002                     EQU     2
340                                  ELSE
342                                  ENDIF
343                                  IF      @SCP("SUPPORTED","SUPPORTED")     ;bit 0 (1)
344       000004           TIMCAPABLE EQU    4
345                                  ELSE
347                                  ENDIF
348       000007           PCICAPABLE EQU    TIMCAPABLE+HISTCAPABLE+RDACAPABLE
349    
350    
351                        ; Special address for two words for the DSP to bootstrap code from the EEPROM
352                                  IF      @SCP("HOST","ROM")                ; Boot from ROM on power-on
359                                  ENDIF
360    
361                                  IF      @SCP("HOST","HOST")               ; Download via host computer
362       P:000000 P:000000                   ORG     P:0,P:0
363       P:000000 P:000000                   DC      END_ADR-INIT                      ; Number of boot words
364       P:000001 P:000001                   DC      INIT                              ; Starting address
365       P:000000 P:000000                   ORG     P:0,P:0
366       P:000000 P:000000 0C00B2  INIT      JMP     <START
367       P:000001 P:000001 000000            NOP
368                                           ENDIF
369    
370                                           IF      @SCP("HOST","ONCE")               ; Download via ONCE debugger
374                                           ENDIF
375    
376                                 ; Vectored interrupt table, addresses at the beginning are reserved
377       P:000002 P:000002                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0       ; $02-$0f Reserved
378       P:000010 P:000010                   DC      0,0                               ; $11 - IRQA* = FIFO EF*
379       P:000012 P:000012                   DC      0,0                               ; $13 - IRQB* = FIFO HF*
380       P:000014 P:000014 0BF080            JSR     CLEAN_UP_PCI                      ; $15 - Software reset switch
                            00034E
381       P:000016 P:000016                   DC      0,0,0,0,0,0,0,0,0,0,0,0           ; Reserved for DMA and Timer
382       P:000022 P:000022                   DC      0,0,0,0,0,0,0,0,0,0,0,0           ;   interrupts
383       P:00002E P:00002E 0BF080            JSR     DOWNLOAD_PCI_DSP_CODE             ; $2F
                            000045
384    
385                                 ; Now we're at P:$30, where some unused vector addresses are located
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 7



386    
387                                 ; This is ROM only code that is only executed once on power-up when the
388                                 ;   ROM code is downloaded. It is skipped over on OnCE or PCI downloads.
389                                 ; Initialize the PLL - phase locked loop
390                                 INIT_PCI
391       P:000030 P:000030 08F4BD            MOVEP             #PLL_INIT,X:PCTL        ; Initialize PLL
                            050003
392       P:000032 P:000032 000000            NOP
393    
394                                 ; Program the PCI self-configuration registers
395       P:000033 P:000033 240000            MOVE              #0,X0
396       P:000034 P:000034 08F485            MOVEP             #$500000,X:DCTR         ; Set self-configuration mode
                            500000
397       P:000036 P:000036 0604A0            REP     #4
398       P:000037 P:000037 08C408            MOVEP             X0,X:DPAR               ; Dummy writes to configuration space
399       P:000038 P:000038 08F487            MOVEP             #>$0000,X:DPMC          ; Subsystem ID
                            000000
400       P:00003A P:00003A 08F488            MOVEP             #>$0000,X:DPAR          ; Subsystem Vendor ID
                            000000
401    
402                                 ; PCI Personal reset
403       P:00003C P:00003C 08C405            MOVEP             X0,X:DCTR               ; Personal software reset
404       P:00003D P:00003D 000000            NOP
405       P:00003E P:00003E 000000            NOP
406       P:00003F P:00003F 0A89B7            JSET    #HACT,X:DSR,*                     ; Test for personal reset completion
                            00003F
407       P:000041 P:000041 07F084            MOVE              P:(*+3),X0              ; Trick to write "JMP <START" to P:0
                            000044
408       P:000043 P:000043 070004            MOVE              X0,P:(0)
409       P:000044 P:000044 0C00B2            JMP     <START
410    
411                                 DOWNLOAD_PCI_DSP_CODE
412       P:000045 P:000045 0A8615            BCLR    #IAE,X:DPCR                       ; Do not insert PCI address with data
413       P:000046 P:000046 0A8982  DNL0      JCLR    #SRRQ,X:DSR,*                     ; Wait for a receiver word
                            000046
414       P:000048 P:000048 084E0B            MOVEP             X:DRXR,A                ; Read it
415       P:000049 P:000049 0140C5            CMP     #$555AAA,A                        ; Check for sanity header word
                            555AAA
416       P:00004B P:00004B 0E2046            JNE     <DNL0
417       P:00004C P:00004C 044EBA            MOVE              OMR,A
418       P:00004D P:00004D 0140C6            AND     #$FFFFF0,A
                            FFFFF0
419       P:00004F P:00004F 014C82            OR      #$00000C,A
420       P:000050 P:000050 000000            NOP
421       P:000051 P:000051 04CEBA            MOVE              A,OMR                   ; Set boot mode to $C = PCI
422       P:000052 P:000052 0AF080            JMP     $FF0000                           ; Jump to boot code internal to DSP
                            FF0000
423    
424       P:000054 P:000054                   DC      0,0,0,0,0,0,0,0,0,0,0,0           ; Filler
425       P:000060 P:000060                   DC      0,0                               ; $60 - PCI Transaction Termination
426       P:000062 P:000062                   DC      0,0,0,0,0,0,0,0,0                 ; $62-$71 Reserved PCI
427       P:00006B P:00006B                   DC      0,0,0,0,0,0,0
428       P:000072 P:000072 0A8506            BCLR    #INTA,X:DCTR                      ; $73 - Clear PCI interrupt
429       P:000073 P:000073                   DC      0                                 ; Clear interrupt bit
430    
431    
432                                 ; These interrupts are non-maskable, called from the host with $80xx
433       P:000074 P:000074 0BF080            JSR     READ_NUMBER_OF_PIXELS_READ        ; $8075
                            0002C0
434       P:000076 P:000076 0BF080            JSR     CLEAN_UP_PCI                      ; $8077
                            00034E
435       P:000078 P:000078 0BF080            JSR     ABORT_READOUT                     ; $8079
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 8



                            000333
436       P:00007A P:00007A 0BF080            JSR     BOOT_EEPROM                       ; $807B
                            0001DB
437       P:00007C P:00007C                   DC      0,0,0,0                           ; Available
438    
439                                 ; These vector interrupts are masked at IPL = 1
440       P:000080 P:000080 0BF080            JSR     READ_REPLY_HEADER                 ; $81
                            0005FA
441       P:000082 P:000082 0BF080            JSR     READ_REPLY_VALUE                  ; $83
                            0005EA
442       P:000084 P:000084 0BF080            JSR     CLEAR_HOST_FLAG                   ; $85
                            0005FC
443       P:000086 P:000086 0BF080            JSR     RESET_CONTROLLER                  ; $87
                            0002DA
444       P:000088 P:000088 0BF080            JSR     READ_IMAGE                        ; $89
                            000358
445       P:00008A P:00008A                   DC      0,0                               ; Available
446       P:00008C P:00008C 0BF080            JSR     WRITE_BASE_PCI_ADDRESS            ; $8D
                            000300
447    
448       P:00008E P:00008E                   DC      0,0,0,0                           ; Available
449       P:000092 P:000092                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0
450       P:0000A0 P:0000A0                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
451    
452                                 ; New manual command for Version 1.6
453       P:0000B0 P:0000B0 0BF080            JSR     WRITE_COMMAND                     ; $B1
                            0001E5
454    
455                                 ; ******************************************************************
456                                 ;
457                                 ;       AA0 = RDFIFO* of incoming fiber optic data
458                                 ;       AA1 = EEPROM access
459                                 ;       AA2 = DRAM access
460                                 ;       AA3 = output to parallel data connector, for a video pixel clock
461                                 ;       $FFxxxx = Write to fiber optic transmitter
462                                 ;
463                                 ; ******************************************************************
464    
465    
466       P:0000B2 P:0000B2 08F487  START     MOVEP             #>$00001,X:DPMC         ; 32-bit PCI <-> 24-bit DSP data
                            000001
467       P:0000B4 P:0000B4 0A8534            BSET    #20,X:DCTR                        ; HI32 mode = 1 => PCI
468       P:0000B5 P:0000B5 0A8515            BCLR    #21,X:DCTR
469       P:0000B6 P:0000B6 0A8516            BCLR    #22,X:DCTR
470       P:0000B7 P:0000B7 000000            NOP
471       P:0000B8 P:0000B8 0A8AAC            JSET    #12,X:DPSR,*                      ; Host data transfer not in progress
                            0000B8
472       P:0000BA P:0000BA 000000            NOP
473       P:0000BB P:0000BB 0A8632            BSET    #MACE,X:DPCR                      ; Master access counter enable
474       P:0000BC P:0000BC 000000            NOP                                       ; End of PCI programming
475    
476                                 ; Set operation mode register OMR to normal expanded
477       P:0000BD P:0000BD 0500BA            MOVEC             #$0000,OMR              ; Operating Mode Register = Normal Expanded
478       P:0000BE P:0000BE 0500BB            MOVEC             #0,SP                   ; Reset the Stack Pointer SP
479    
480                                 ; Move the table of constants from P: space to X: space
481       P:0000BF P:0000BF 61F400            MOVE              #CONSTANTS_TBL_START,R1 ; Start of table of constants
                            0006AE
482       P:0000C1 P:0000C1 300200            MOVE              #2,R0                   ; Leave X:0 for STATUS
483       P:0000C2 P:0000C2 060F80            DO      #CONSTANTS_TBL_LENGTH,L_WRITE
                            0000C5
484       P:0000C4 P:0000C4 07D984            MOVE              P:(R1)+,X0
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 9



485       P:0000C5 P:0000C5 445800            MOVE              X0,X:(R0)+              ; Write the constants to X:
486                                 L_WRITE
487    
488                                 ; Program the serial port ESSI0 = Port C for serial transmission to
489                                 ;   the timing board
490       P:0000C6 P:0000C6 07F43F            MOVEP             #>0,X:PCRC              ; Software reset of ESSI0
                            000000
491       P:0000C8 P:0000C8 07F435            MOVEP             #$00080B,X:CRA0         ; Divide 100.0 MHz by 24 to get 4.17 MHz
                            00080B
492                                                                                     ; DC0-CD4 = 0 for non-network operation
493                                                                                     ; WL0-WL2 = ALC = 0 for 2-bit data words
494                                                                                     ; SSC1 = 0 for SC1 not used
495       P:0000CA P:0000CA 07F436            MOVEP             #$010120,X:CRB0         ; SCKD = 1 for internally generated clock
                            010120
496                                                                                     ; SHFD = 0 for MSB shifted first
497                                                                                     ; CKP = 0 for rising clock edge transitions
498                                                                                     ; TE0 = 1 to enable transmitter #0
499                                                                                     ; MOD = 0 for normal, non-networked mode
500                                                                                     ; FSL1 = 1, FSL0 = 0 for on-demand transmit
501       P:0000CC P:0000CC 07F43F            MOVEP             #%101000,X:PCRC         ; Control Register (0 for GPIO, 1 for ESSI)
                            000028
502                                                                                     ; Set SCK0 = P3, STD0 = P5 to ESSI0
503       P:0000CE P:0000CE 07F43E            MOVEP             #%111100,X:PRRC         ; Data Direction Register (0 for In, 1 for O
ut)
                            00003C
504    
505       P:0000D0 P:0000D0 07F43D            MOVEP             #%000000,X:PDRC         ; Data Register - AUX1 = output, AUX3 = inpu
t
                            000000
506    
507                                 ; Conversion from software bits to schematic labels for Port C and D
508                                 ;       PC0 = SC00 = AUX3               PD0 = SC10 = EF*
509                                 ;       PC1 = SC01 = A/B* = input       PD1 = SC11 = HF*
510                                 ;       PC2 = SC02 = No connect         PD2 = SC12 = RS*
511                                 ;       PC3 = SCK0 = No connect         PD3 = SCK1 = NWRFIFO*
512                                 ;       PC4 = SRD0 = AUX1               PD4 = SRD1 = No connect
513                                 ;       PC5 = STD0 = No connect         PD5 = STD1 = WRFIFO*
514    
515    
516                                 ; Program the serial port ESSI1 = Port D for general purpose I/O (GPIO)
517       P:0000D2 P:0000D2 07F42F            MOVEP             #%000000,X:PCRD         ; Control Register (0 for GPIO, 1 for ESSI)
                            000000
518       P:0000D4 P:0000D4 07F42E            MOVEP             #%011100,X:PRRD         ; Data Direction Register (0 for In, 1 for O
ut)
                            00001C
519       P:0000D6 P:0000D6 07F42D            MOVEP             #%011000,X:PDRD         ; Data Register - Pulse RS* low
                            000018
520       P:0000D8 P:0000D8 060AA0            REP     #10
521       P:0000D9 P:0000D9 000000            NOP
522       P:0000DA P:0000DA 07F42D            MOVEP             #%011100,X:PDRD
                            00001C
523    
524    
525                                 ; Program the SCI port to benign values
526       P:0000DC P:0000DC 07F41F            MOVEP             #%000,X:PCRE            ; Port Control Register   (0 => GPIO)
                            000000
527       P:0000DE P:0000DE 07F41E            MOVEP             #%110,X:PRRE            ; Port Direction Register (0 => Input)
                            000006
528       P:0000E0 P:0000E0 07F41D            MOVEP             #%010,X:PDRE            ; Port Data Register
                            000002
529                                 ;       PE0 = RXD
530                                 ;       PE1 = TXD
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 10



531                                 ;       PE2 = SCLK
532                                 ;       PE2 = SCLK = XMT SC = Fiber optic transmitter special character when set
533    
534    
535                                 ; Program the triple timer to assert TCI0 as a GPIO output = 1
536       P:0000E2 P:0000E2 07F40F            MOVEP             #$2800,X:TCSR0
                            002800
537       P:0000E4 P:0000E4 07F40B            MOVEP             #$2800,X:TCSR1
                            002800
538       P:0000E6 P:0000E6 07F407            MOVEP             #$2800,X:TCSR2
                            002800
539    
540                                 ; Program the address attribute pins AA0 to AA2. AA3 is not yet implemented.
541       P:0000E8 P:0000E8 08F4B9            MOVEP             #$FFFC21,X:AAR0         ; Y = $FFF000 to $FFFFFF asserts Y:RDFIFO*
                            FFFC21
542       P:0000EA P:0000EA 08F4B8            MOVEP             #$008929,X:AAR1         ; P = $008000 to $00FFFF asserts AA1 low tru
e
                            008929
543       P:0000EC P:0000EC 08F4B7            MOVEP             #$000122,X:AAR2         ; Y = $000800 to $7FFFFF accesses SRAM
                            000122
544    
545    
546    
547                                 ; Program the bus control and DRAM memory access registers
548                                 ;       MOVEP   #$020022,X:BCR  ; !!! was slower
549       P:0000EE P:0000EE 08F4BB            MOVEP             #$020021,X:BCR          ; Bus Control Register
                            020021
550       P:0000F0 P:0000F0 08F4BA            MOVEP             #$893A05,X:DCR          ; DRAM Control Register
                            893A05
551    
552    
553    
554                                 ; Clear all PCI error conditions
555       P:0000F2 P:0000F2 084E0A            MOVEP             X:DPSR,A
556       P:0000F3 P:0000F3 0140C2            OR      #$1FE,A
                            0001FE
557       P:0000F5 P:0000F5 000000            NOP
558       P:0000F6 P:0000F6 08CE0A            MOVEP             A,X:DPSR
559       P:0000F7 P:0000F7 240000            MOVE              #0,X0
560       P:0000F8 P:0000F8 440000            MOVE              X0,X:<STATUS            ; Initialize the STATUS variable
561    
562                                 ; Establish interrupt priority levels IPL
563       P:0000F9 P:0000F9 08F4BF            MOVEP             #$0001C0,X:IPRC         ; IRQC priority IPL = 2 (reset switch, edge)
                            0001C0
564                                                                                     ; IRQB priority IPL = 2 or 0
565                                                                                     ;     (FIFO half full - HF*, level)
566       P:0000FB P:0000FB 08F4BE            MOVEP             #>2,X:IPRP              ; Enable PCI Host interrupts, IPL = 1
                            000002
567       P:0000FD P:0000FD 0A8520            BSET    #HCIE,X:DCTR                      ; Enable host command interrupts
568       P:0000FE P:0000FE 0500B9            MOVE              #0,SR                   ; Don't mask any interrupts
569    
570                                 ; Initialize the fiber optic serial transmitter to zero
571       P:0000FF P:0000FF 01B786            JCLR    #TDE,X:SSISR0,*
                            0000FF
572       P:000101 P:000101 07F43C            MOVEP             #$000000,X:TX00
                            000000
573    
574                                 ; Clear out the PCI receiver and transmitter FIFOs
575       P:000103 P:000103 0A862E            BSET    #CLRT,X:DPCR                      ; Clear the master transmitter
576       P:000104 P:000104 0A86AE            JSET    #CLRT,X:DPCR,*                    ; Wait for the clearing to be complete
                            000104
577       P:000106 P:000106 0A8982  CLR0      JCLR    #SRRQ,X:DSR,CLR1                  ; Wait for the receiver to be empty
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 11



                            00010B
578       P:000108 P:000108 08440B            MOVEP             X:DRXR,X0               ; Read receiver to empty it
579       P:000109 P:000109 000000            NOP
580       P:00010A P:00010A 0C0106            JMP     <CLR0
581                                 CLR1
582    
583                                 ; Clear the host buffer size thus disabling wrap mode
584       P:00010B P:00010B 200013            CLR     A
585       P:00010C P:00010C 448600            MOVE              X:<FLAG_DONE,X0         ; Flag = 1 => Normal execution
586       P:00010D P:00010D 543600            MOVE              A1,X:<PCI_BUFSIZE_0     ; Non-wrap mode for pci transfer
587       P:00010E P:00010E 503700            MOVE              A0,X:<PCI_BUFSIZE_1     ; Non-wrap mode for pci transfer
588                                           IF      @SCP("SUPPORTED","SUPPORTED")
589       P:00010F P:00010F 54F400            MOVE              #2000,A1
                            0007D0
590       P:000111 P:000111 000000            NOP
591       P:000112 P:000112 543D00            MOVE              A1,X:<WAIT_RDA          ; nominal wait in RDA.
592                                           ENDIF
593    
594    
595                                           IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
596                                 ;    This is timer code contributed by one of Bob Leach's users.
597                                 ;
598                                 ;    Set up the timer parameters and start the timer
599                                 ;    We use two timers to generate a combined 45-bit counter.
600                                 ;       Timer 0 - fine grain timer
601                                 ;                 this timer is incremented using the internal
602                                 ;                 clock, so it is incremented at a rate of (CLK/2)
603                                 ;       Timer 1 - course grain timer
604                                 ;                 This uses the prescalar, which is set to count to
605                                 ;                 increment using the internal clock, and set to
606                                 ;                 trigger when it counts to '$1FFFFF', the maximum
607                                 ;                 21-bit value.
608                                 ;    Thus, 'Timer 1' is updated at a frequency '1/2^21' that of 'Timer 0',
609                                 ;    and consequently the MSB '3' bits of 'Timer 0' and the LSB '3' bits
610                                 ;    of 'Timer 1' are redundant.  ( Note that to ensure that these '3'
611                                 ;    bits are actually equal, we need to initially load 'TCR1' with '1'
612                                 ;    instead of '0', because the value from 'TLR1' is loaded when the
613                                 ;    prescalar initially triggers, which is after it has already counted
614                                 ;    to '$1FFFFF' once ).  The redundant '3' bits are actually useful because
615                                 ;    the two timers cannot be read atomically, so they will indicate if the
616                                 ;    fine-grain timer has wrapped between the times the two are read.
617                                 ;
618                                 ;************************************************************
619       P:000113 P:000113 010F00            BCLR    #TIM_BIT,X:TCSR0                  ; Disable the timer
620       P:000114 P:000114 010B00            BCLR    #TIM_BIT,X:TCSR1                  ; Disable the timer
621       P:000115 P:000115 07F403            MOVEP             #$1FFFFF,X:TPLR         ; Prescaler to generate msec timer,
                            1FFFFF
622                                                                                     ; counting from system clock/2 = 50 MHz
623       P:000117 P:000117 07F40F            MOVEP             #$200000,X:TCSR0        ; Clear timer 0 complete bit,
                            200000
624                                                                                     ; use internal (CLK/2) signal
625       P:000119 P:000119 07F40B            MOVEP             #$208000,X:TCSR1        ; Clear timer 1 complete bit,
                            208000
626                                                                                     ; use prescaler
627       P:00011B P:00011B 07F40E            MOVEP             #0,X:TLR0               ; Timer load register
                            000000
628       P:00011D P:00011D 07F40A            MOVEP             #1,X:TLR1               ; Timer 1 load register - use '1' here
                            000001
629                                                                                     ; because it is only loaded after
630                                                                                     ;'TPLR' is first decremented down to 0
631       P:00011F P:00011F 010F20            BSET    #TIM_BIT,X:TCSR0                  ; Enable the timer #0
632       P:000120 P:000120 010B20            BSET    #TIM_BIT,X:TCSR1                  ; Enable the timer #1
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 12



633                                           ENDIF
634    
635    
636                                 ; Repy = DONE host flags
637       P:000121 P:000121 441D00            MOVE              X0,X:<HOST_FLAG
638       P:000122 P:000122 0D01B7            JSR     <FO_WRITE_HOST_FLAG
639    
640                                           IF      @SCP("SUPPORTED","SUPPORTED")
641       P:000123 P:000123 63F400            MOVE              #PCI_HISTFIRST,R3       ; hist buffer ptr initialization
                            000800
642       P:000125 P:000125 633B00            MOVE              R3,X:<PCI_HISTFILL
643                                           ENDIF
644    
645       P:000126 P:000126 000000            NOP
646    
647                                 ; ********************************************************************
648                                 ;
649                                 ;                       REGISTER  USAGE
650                                 ;
651                                 ;       X0, X1, Y0, Y1, A and B are used freely in READ_IMAGE. Interrups
652                                 ;               during readout will clobber these registers, as a result
653                                 ;               of which only catastrophic commands such as ABORT_READOUT
654                                 ;               and BOOT_EEPROM are allowed during readout.
655                                 ;
656                                 ;       X0, X1 and A are used for all interrupt handling routines, such
657                                 ;               as CLEAR_HOST-FLAGS, command processing and so on.
658                                 ;
659                                 ;       Y0, Y1 and B are used for all fiber optic processing routines,
660                                 ;               which are not in interrupt service routines.
661                                 ;
662                                 ; *********************************************************************
663    
664    
665    
666                                 ; ************  Start of command interpreting code  ******************
667    
668                                 ; Test for fiber optic data on the FIFO. Discard the header for now
669    
670                                 ; Check for the header $AC in the first byte = Y0. Wait a little while and
671                                 ;  clear the FIFO if its not $AC - there was probably noise on the line.
672                                 ; We assume only two word replies here - Header = (S,D,#words)  Reply
673    
674                                 GET_FO
675                                           IF      @SCP("SUPPORTED","SUPPORTED")
676       P:000127 P:000127 20001B            CLR     B
677    
678       P:000128 P:000128 55BB00            MOVE              X:<PCI_HISTFILL,B1
679       P:000129 P:000129 000000            NOP
680       P:00012A P:00012A 0140CC            SUB     #PCI_HISTEND,B
                            001000
681       P:00012C P:00012C 000000            NOP
682       P:00012D P:00012D 0AF0A9            JLT     CHK_FO
                            000134
683       P:00012F P:00012F 55F400            MOVE              #PCI_HISTFIRST,B1       ; hist buffer ptr wrapped
                            000800
684       P:000131 P:000131 000000            NOP
685       P:000132 P:000132 553B00            MOVE              B1,X:<PCI_HISTFILL
686       P:000133 P:000133 000000            NOP
687    
688                                 CHK_FO
689                                           ENDIF
690    
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 13



691       P:000134 P:000134 01AD80            JCLR    #EF,X:PDRD,GET_FO                 ; Test for new fiber optic data
                            000127
692       P:000136 P:000136 0D0641            JSR     <RD_FO_TIMEOUT                    ; Move the FIFO reply into B1
693       P:000137 P:000137 0E81C9            JCS     <FO_ERR
694    
695                                 ; Check the header bytes for self-consistency
696       P:000138 P:000138 21A600            MOVE              B1,Y0
697       P:000139 P:000139 57F400            MOVE              #$FCFCF8,B              ; Test for S.LE.3 and D.LE.3 and N.LE.7
                            FCFCF8
698       P:00013B P:00013B 20005E            AND     Y0,B
699       P:00013C P:00013C 0E21C9            JNE     <FO_ERR                           ; Test failed
700       P:00013D P:00013D 57F400            MOVE              #$030300,B              ; Test for either S.NE.0 or D.NE.0
                            030300
701       P:00013F P:00013F 20005E            AND     Y0,B
702       P:000140 P:000140 0EA1C9            JEQ     <FO_ERR                           ; Test failed
703       P:000141 P:000141 57F400            MOVE              #>7,B
                            000007
704       P:000143 P:000143 20005E            AND     Y0,B                              ; Extract NWORDS, must be >= 2
705       P:000144 P:000144 01418D            CMP     #1,B
706       P:000145 P:000145 0EF1C2            JLE     <HDR_ERR
707       P:000146 P:000146 20CF00            MOVE              Y0,B
708       P:000147 P:000147 0C1891            EXTRACTU #$008020,B,B                     ; Extract bits 15-8 = destination byte
                            008020
709       P:000149 P:000149 000000            NOP
710       P:00014A P:00014A 511E00            MOVE              B0,X:<FO_DEST
711    
712                                 ; Check whether this is a self-test header
713       P:00014B P:00014B 579E00            MOVE              X:<FO_DEST,B            ; B1 = Destination
714       P:00014C P:00014C 01428D            CMP     #2,B
715       P:00014D P:00014D 0EA1D3            JEQ     <SELF_TEST                        ; Command = $000203 'TDL' value
716    
717    
718                                 ; Read the reply or command from the fiber optics FIFO
719       P:00014E P:00014E 0D0641            JSR     <RD_FO_TIMEOUT                    ; Move the FIFO reply into A1
720       P:00014F P:00014F 0E81C9            JCS     <FO_ERR
721       P:000150 P:000150 551F00            MOVE              B1,X:<FO_CMD
722    
723                                 ; Check for commands from the controller to the PCI board, FO_DEST = 1
724       P:000151 P:000151 579E00            MOVE              X:<FO_DEST,B
725       P:000152 P:000152 01418D            CMP     #1,B
726       P:000153 P:000153 0E2162            JNE     <HOSTCMD
727       P:000154 P:000154 579F00            MOVE              X:<FO_CMD,B
728       P:000155 P:000155 0140CD            CMP     #'RDA',B                          ; Read the image
                            524441
729       P:000157 P:000157 0EA358            JEQ     <READ_IMAGE
730       P:000158 P:000158 0140CD            CMP     #'IIA',B
                            494941
731       P:00015A P:00015A 0EA319            JEQ     <INITIALIZE_NUMBER_OF_PIXELS      ; IPXLS = 0
732       P:00015B P:00015B 0140CD            CMP     #'RDI',B
                            524449
733       P:00015D P:00015D 0EA199            JEQ     <READING_IMAGE                    ; Controller is reading an image
734       P:00015E P:00015E 0140CD            CMP     #'RDO',B
                            52444F
735       P:000160 P:000160 0EA1B2            JEQ     <READING_IMAGE_OFF                ; Controller no longer reading an image
736       P:000161 P:000161 0C0127            JMP     <GET_FO                           ; Not on the list -> just ignore it
737    
738                                 ; Check if the command or reply is for the host. If not just ignore it.
739       P:000162 P:000162 579E00  HOSTCMD   MOVE              X:<FO_DEST,B
740       P:000163 P:000163 01408D            CMP     #0,B
741       P:000164 P:000164 0E2127            JNE     <GET_FO
742       P:000165 P:000165 579F00            MOVE              X:<FO_CMD,B             ; Get the command
743    
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 14



744                                           IF      @SCP("SUPPORTED","SUPPORTED")
745       P:000166 P:000166 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
746       P:000167 P:000167 000000            NOP
747       P:000168 P:000168 000000            NOP
748       P:000169 P:000169 000000            NOP
749       P:00016A P:00016A 5D5B00            MOVE                          B1,Y:(R3)+
750       P:00016B P:00016B 000000            NOP
751       P:00016C P:00016C 57BC00            MOVE              X:<PCI_HISTON,B
752       P:00016D P:00016D 20000B            TST     B
753       P:00016E P:00016E 0AF0AA            JEQ     DO_REPLYHST
                            000174
754                                           IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
755       P:000170 P:000170 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
756       P:000171 P:000171 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
757                                           ENDIF
758       P:000172 P:000172 633B00            MOVE              R3,X:<PCI_HISTFILL
759       P:000173 P:000173 000000            NOP
760                                 DO_REPLYHST
761       P:000174 P:000174 579F00            MOVE              X:<FO_CMD,B             ; Get the command
762       P:000175 P:000175 000000            NOP
763                                 ;       the fiber loop wraps PCI_HIST when it gets the chance.
764                                           ENDIF
765    
766       P:000176 P:000176 0140CD            CMP     #'DON',B
                            444F4E
767       P:000178 P:000178 0EA189            JEQ     <CONTROLLER_DONE                  ; Normal DONE reply
768       P:000179 P:000179 0A00A1            JSET    #TIMROMBURN,X:STATUS,FO_REPLY     ; If executing TimRomBurn
                            000184
769       P:00017B P:00017B 0140CD            CMP     #'ERR',B
                            455252
770       P:00017D P:00017D 0EA18D            JEQ     <CONTROLLER_ERROR                 ; Error reply
771       P:00017E P:00017E 0140CD            CMP     #'BSY',B
                            425359
772       P:000180 P:000180 0EA195            JEQ     <CONTROLLER_BUSY                  ; Controller is busy executing a command
773       P:000181 P:000181 0140CD            CMP     #'SYR',B
                            535952
774       P:000183 P:000183 0EA191            JEQ     <CONTROLLER_RESET                 ; Controller system reset
775    
776                                 ; The controller reply is none of the above so return it as a reply
777                                 FO_REPLY
778       P:000184 P:000184 551C00            MOVE              B1,X:<REPLY             ; Report value
779       P:000185 P:000185 468700            MOVE              X:<FLAG_REPLY,Y0        ; Flag = 2 => Reply with a value
780       P:000186 P:000186 461D00            MOVE              Y0,X:<HOST_FLAG
781       P:000187 P:000187 0D01B7            JSR     <FO_WRITE_HOST_FLAG
782       P:000188 P:000188 0C0127            JMP     <GET_FO
783    
784                                 CONTROLLER_DONE
785       P:000189 P:000189 468600            MOVE              X:<FLAG_DONE,Y0         ; Flag = 1 => Normal execution
786       P:00018A P:00018A 461D00            MOVE              Y0,X:<HOST_FLAG
787       P:00018B P:00018B 0D01B7            JSR     <FO_WRITE_HOST_FLAG
788       P:00018C P:00018C 0C0127            JMP     <GET_FO                           ; Keep looping for fiber optic commands
789    
790                                 CONTROLLER_ERROR
791       P:00018D P:00018D 468800            MOVE              X:<FLAG_ERR,Y0          ; Flag = 3 => controller error
792       P:00018E P:00018E 461D00            MOVE              Y0,X:<HOST_FLAG
793       P:00018F P:00018F 0D01B7            JSR     <FO_WRITE_HOST_FLAG
794       P:000190 P:000190 0C0127            JMP     <GET_FO                           ; Keep looping for fiber optic commands
795    
796                                 CONTROLLER_RESET
797       P:000191 P:000191 468900            MOVE              X:<FLAG_SYR,Y0          ; Flag = 4 => controller reset
798       P:000192 P:000192 461D00            MOVE              Y0,X:<HOST_FLAG
799       P:000193 P:000193 0D01B7            JSR     <FO_WRITE_HOST_FLAG
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 15



800       P:000194 P:000194 0C0127            JMP     <GET_FO                           ; Keep looping for fiber optic commands
801    
802                                 CONTROLLER_BUSY
803       P:000195 P:000195 468B00            MOVE              X:<FLAG_BUSY,Y0         ; Flag = 6 => controller busy
804       P:000196 P:000196 461D00            MOVE              Y0,X:<HOST_FLAG
805       P:000197 P:000197 0D01B7            JSR     <FO_WRITE_HOST_FLAG
806       P:000198 P:000198 0C0127            JMP     <GET_FO                           ; Keep looping for fiber optic commands
807    
808                                 ; A special handshaking here ensures that the host computer has read the 'DON'
809                                 ;   reply to the start_exposure command before the reading_image state is
810                                 ;   set in the host flags. Reading_image occurs only after a start_exposure
811                                 READING_IMAGE
812    
813                                           IF      @SCP("SUPPORTED","SUPPORTED")
814       P:000199 P:000199 57BC00            MOVE              X:<PCI_HISTON,B
815       P:00019A P:00019A 20000B            TST     B
816       P:00019B P:00019B 0AF0AA            JEQ     DO_IMG
                            0001A7
817       P:00019D P:00019D 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
818       P:00019E P:00019E 000000            NOP
819       P:00019F P:00019F 64F400            MOVE              #F_READING_IMAGE,R4     ; tag
                            524449
820       P:0001A1 P:0001A1 000000            NOP
821       P:0001A2 P:0001A2 6C5B00            MOVE                          R4,Y:(R3)+
822       P:0001A3 P:0001A3 000000            NOP
823                                           IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
824       P:0001A4 P:0001A4 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
825       P:0001A5 P:0001A5 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
826                                           ENDIF
827    
828       P:0001A6 P:0001A6 633B00            MOVE              R3,X:<PCI_HISTFILL
829                                 DO_IMG
830                                           ENDIF
831    
832                                 READING_IMG
833       P:0001A7 P:0001A7 579D00            MOVE              X:<HOST_FLAG,B          ; Retrieve current host flag value
834       P:0001A8 P:0001A8 448A00            MOVE              X:<FLAG_RDI,X0
835       P:0001A9 P:0001A9 20004D            CMP     X0,B                              ; If we're already in read_image
836       P:0001AA P:0001AA 0EA127            JEQ     <GET_FO                           ;   mode then do nothing
837       P:0001AB P:0001AB 20000B            TST     B                                 ; Wait for flag to be cleared, which
838       P:0001AC P:0001AC 0E21A7            JNE     <READING_IMG                      ;  the host does when it gets the DONE
839    
840       P:0001AD P:0001AD 0A8500            BCLR    #HCIE,X:DCTR                      ; Disable host command interrupts
841       P:0001AE P:0001AE 468A00            MOVE              X:<FLAG_RDI,Y0
842       P:0001AF P:0001AF 461D00            MOVE              Y0,X:<HOST_FLAG
843       P:0001B0 P:0001B0 0D01B7            JSR     <FO_WRITE_HOST_FLAG               ; Set Host Flag to "reading out"
844       P:0001B1 P:0001B1 0C0127            JMP     <GET_FO                           ; Keep looping for fiber optic commands
845    
846                                 READING_IMAGE_OFF                                   ; Controller is no longer reading out
847       P:0001B2 P:0001B2 468500            MOVE              X:<FLAG_ZERO,Y0
848       P:0001B3 P:0001B3 461D00            MOVE              Y0,X:<HOST_FLAG
849       P:0001B4 P:0001B4 0D01B7            JSR     <FO_WRITE_HOST_FLAG
850       P:0001B5 P:0001B5 0A8520            BSET    #HCIE,X:DCTR                      ; Enable host command interrupts
851       P:0001B6 P:0001B6 0C0127            JMP     <GET_FO                           ; Keep looping for fiber optic commands
852    
853                                 ; Write X:<HOST_FLAG to the DCTR flag bits 5,4,3, as a subroutine
854                                 FO_WRITE_HOST_FLAG
855       P:0001B7 P:0001B7 57F000            MOVE              X:DCTR,B
                            FFFFC5
856       P:0001B9 P:0001B9 469D00            MOVE              X:<HOST_FLAG,Y0
857       P:0001BA P:0001BA 0140CE            AND     #$FFFFC7,B                        ; Clear bits 5,4,3
                            FFFFC7
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 16



858       P:0001BC P:0001BC 000000            NOP
859       P:0001BD P:0001BD 20005A            OR      Y0,B                              ; Set flags appropriately
860       P:0001BE P:0001BE 000000            NOP
861       P:0001BF P:0001BF 577000            MOVE              B,X:DCTR
                            FFFFC5
862       P:0001C1 P:0001C1 00000C            RTS
863    
864                                 ; There was an erroneous header word on the fiber optic line
865       P:0001C2 P:0001C2 46F400  HDR_ERR   MOVE              #'HDR',Y0
                            484452
866       P:0001C4 P:0001C4 461C00            MOVE              Y0,X:<REPLY             ; Set REPLY = header as a diagnostic
867       P:0001C5 P:0001C5 468700            MOVE              X:<FLAG_REPLY,Y0        ; Flag = 2 => Reply with a value
868       P:0001C6 P:0001C6 461D00            MOVE              Y0,X:<HOST_FLAG
869       P:0001C7 P:0001C7 0D01B7            JSR     <FO_WRITE_HOST_FLAG
870       P:0001C8 P:0001C8 0C0127            JMP     <GET_FO
871    
872                                 ; There was an erroneous word on the fiber optic line -> clear the FIFO
873       P:0001C9 P:0001C9 07F42D  FO_ERR    MOVEP             #%010000,X:PDRD         ; Clear FIFO RESET* for 2 milliseconds
                            000010
874       P:0001CB P:0001CB 46F400            MOVE              #200000,Y0
                            030D40
875       P:0001CD P:0001CD 06C600            DO      Y0,*+3
                            0001CF
876       P:0001CF P:0001CF 000000            NOP
877       P:0001D0 P:0001D0 07F42D            MOVEP             #%010100,X:PDRD         ; Data Register - Set RS* high
                            000014
878       P:0001D2 P:0001D2 0C0127            JMP     <GET_FO
879    
880                                 ; Connect PCI board fiber out <==> fiber in and execute 'TDL' timing board
881                                 SELF_TEST
882       P:0001D3 P:0001D3 0D0641            JSR     <RD_FO_TIMEOUT                    ; Move the 'COMMAND' into B1
883       P:0001D4 P:0001D4 0E81C9            JCS     <FO_ERR
884       P:0001D5 P:0001D5 0140CD            CMP     #'TDL',B
                            54444C
885       P:0001D7 P:0001D7 0E218D            JNE     <CONTROLLER_ERROR                 ; Must be 'TDL' if destination = 2
886       P:0001D8 P:0001D8 0D0641            JSR     <RD_FO_TIMEOUT                    ; Move the argument into B1
887       P:0001D9 P:0001D9 0E81C9            JCS     <FO_ERR
888       P:0001DA P:0001DA 0C0184            JMP     <FO_REPLY                         ; Return argument as the reply value
889    
890    
891    
892                                 ; **************  Boot from byte-wide on-board EEPROM  *******************
893    
894                                 BOOT_EEPROM
895       P:0001DB P:0001DB 08F4BB            MOVEP             #$0202A0,X:BCR          ; Bus Control Register for slow EEPROM
                            0202A0
896       P:0001DD P:0001DD 044EBA            MOVE              OMR,A
897       P:0001DE P:0001DE 0140C6            AND     #$FFFFF0,A
                            FFFFF0
898       P:0001E0 P:0001E0 014982            OR      #$000009,A                        ; Boot mode = $9 = byte-wide EEPROM
899       P:0001E1 P:0001E1 000000            NOP
900       P:0001E2 P:0001E2 04CEBA            MOVE              A,OMR
901       P:0001E3 P:0001E3 0AF080            JMP     $FF0000                           ; Jump to boot code internal to DSP
                            FF0000
902    
903                                 ; ***************  Command processing  ****************
904    
905                                 WRITE_COMMAND
906                                 ;       JCLR    #SRRQ,X:DSR,ERROR       ; Error if receiver FIFO has no data
907       P:0001E5 P:0001E5 0A89A2            JSET    #SRRQ,X:DSR,WCSTG1                ; Error if receiver FIFO has no data
                            0001EA
908       P:0001E7 P:0001E7 56F400            MOVE              #F_WCMDSTG1,A
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 17



                            575331
909       P:0001E9 P:0001E9 0C0213            JMP     <WC_ERROR
910    
911                                 WCSTG1
912       P:0001EA P:0001EA 084E0B            MOVEP             X:DRXR,A                ; Get the header
913       P:0001EB P:0001EB 000000            NOP                                       ; Pipeline restriction
914       P:0001EC P:0001EC 543000            MOVE              A1,X:<HEADER
915    
916                                 ; Check the header bytes for self-consistency
917       P:0001ED P:0001ED 218400            MOVE              A1,X0
918       P:0001EE P:0001EE 56F400            MOVE              #$FCFCF8,A              ; Test for S.LE.3 and D.LE.3 and N.LE.7
                            FCFCF8
919       P:0001F0 P:0001F0 200046            AND     X0,A
920                                 ;       JNE     <ERROR                  ; Test failed
921       P:0001F1 P:0001F1 0EA1F5            JEQ     <WCSTG2
922       P:0001F2 P:0001F2 56F400            MOVE              #F_WCMDSTG2,A           ; Test failed, illegal bits set
                            575332
923       P:0001F4 P:0001F4 0C0213            JMP     <WC_ERROR
924    
925                                 WCSTG2
926       P:0001F5 P:0001F5 56F400            MOVE              #$030300,A              ; Test for either S.NE.0 or D.NE.0
                            030300
927       P:0001F7 P:0001F7 200046            AND     X0,A
928                                 ;       JEQ     <ERROR                  ; Test failed- both 0
929       P:0001F8 P:0001F8 0E21FC            JNE     <WCSTG3
930       P:0001F9 P:0001F9 56F400            MOVE              #F_WCMDSTG3,A           ; Test failed- both 0
                            575333
931       P:0001FB P:0001FB 0C0213            JMP     <WC_ERROR
932    
933                                 WCSTG3
934       P:0001FC P:0001FC 56F400            MOVE              #>7,A
                            000007
935       P:0001FE P:0001FE 200046            AND     X0,A                              ; Extract NUM_ARG, must be >= 0
936       P:0001FF P:0001FF 000000            NOP                                       ; Pipeline restriction
937       P:000200 P:000200 014284            SUB     #2,A
938                                 ;       JLT     <ERROR                  ; Number of arguments >= 0
939       P:000201 P:000201 0E1205            JGE     <WCSTG4                           ; Number of arguments >= 1
940       P:000202 P:000202 56F400            MOVE              #F_WCMDSTG4,A
                            575334
941       P:000204 P:000204 0C0213            JMP     <WC_ERROR
942    
943                                 WCSTG4
944       P:000205 P:000205 543500            MOVE              A1,X:<NUM_ARG           ; Store number of arguments in command
945       P:000206 P:000206 014685            CMP     #6,A                              ; Number of arguments <= 6
946                                 ;       JGT     <ERROR
947       P:000207 P:000207 0EF20B            JLE     <WCSTG5
948       P:000208 P:000208 56F400            MOVE              #F_WCMDSTG5,A           ; too many arguments
                            575335
949       P:00020A P:00020A 0C0213            JMP     <WC_ERROR
950    
951                                 WCSTG5
952                                 ; Get the DESTINATION number (1 = PCI, 2 = timing, 3 = utility)
953       P:00020B P:00020B 208E00            MOVE              X0,A                    ; Still the header
954       P:00020C P:00020C 0C1ED0            LSR     #8,A
955       P:00020D P:00020D 0140C6            AND     #>3,A                             ; Extract just three bits of
                            000003
956       P:00020F P:00020F 543400            MOVE              A1,X:<DESTINATION       ;   the destination byte
957                                 ;       JEQ     <ERROR                  ; Destination of zero = host not allowed
958       P:000210 P:000210 0E223C            JNE     <WCSTG6                           ; Destination of zero = host not allowed
959       P:000211 P:000211 56F400            MOVE              #F_WCMDSTG6,A           ; destination = host
                            575336
960    
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 18



961                                 WC_ERROR
962                                           IF      @SCP("SUPPORTED","SUPPORTED")
963       P:000213 P:000213 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
964       P:000214 P:000214 000000            NOP
965       P:000215 P:000215 000000            NOP
966       P:000216 P:000216 000000            NOP
967       P:000217 P:000217 5C5B00            MOVE                          A1,Y:(R3)+
968       P:000218 P:000218 000000            NOP
969       P:000219 P:000219 56BC00            MOVE              X:<PCI_HISTON,A
970       P:00021A P:00021A 200003            TST     A
971       P:00021B P:00021B 0EA220            JEQ     <DO_FIFO0
972                                           IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
973       P:00021C P:00021C 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
974       P:00021D P:00021D 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
975                                           ENDIF
976       P:00021E P:00021E 633B00            MOVE              R3,X:<PCI_HISTFILL
977       P:00021F P:00021F 000000            NOP
978    
979                                 ;       the fiber loop wraps PCI_HIST when it gets the chance.
980                                           ENDIF
981    
982                                 DO_FIFO0
983                                 ;       now clear out anything remaining in the fifo. If history is on, the
984                                 ;       second parameter (or the first if only 1) will be logged, assuming
985                                 ;       anything is there at all. It's really a violation of the command
986                                 ;       protocol and should never occur.
987       P:000220 P:000220 0A8982            JCLR    #SRRQ,X:DSR,DO_ERROR              ; Is the receiver empty?
                            00023B
988    
989       P:000222 P:000222 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
990       P:000223 P:000223 000000            NOP                                       ; wait for flag to toggle
991       P:000224 P:000224 0A8982            JCLR    #SRRQ,X:DSR,LOG_RCV0              ; If now empty, go log parameter 1.
                            000228
992       P:000226 P:000226 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
993       P:000227 P:000227 000000            NOP                                       ; wait for flag to toggle
994                                 LOG_RCV0
995    
996                                           IF      @SCP("SUPPORTED","SUPPORTED")
997       P:000228 P:000228 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
998       P:000229 P:000229 000000            NOP
999       P:00022A P:00022A 000000            NOP
1000      P:00022B P:00022B 000000            NOP
1001      P:00022C P:00022C 585B00            MOVE                          A0,Y:(R3)+
1002      P:00022D P:00022D 000000            NOP
1003      P:00022E P:00022E 56BC00            MOVE              X:<PCI_HISTON,A
1004      P:00022F P:00022F 200003            TST     A
1005      P:000230 P:000230 0AF0AA            JEQ     DO_ENDFIFO0
                            000236
1006                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1007      P:000232 P:000232 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1008      P:000233 P:000233 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1009                                          ENDIF
1010      P:000234 P:000234 633B00            MOVE              R3,X:<PCI_HISTFILL
1011      P:000235 P:000235 000000            NOP
1012   
1013                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
1014                                          ENDIF
1015   
1016                                DO_ENDFIFO0
1017      P:000236 P:000236 0A8982            JCLR    #SRRQ,X:DSR,DO_ERROR              ; Wait for the receiver to be empty
                            00023B
1018      P:000238 P:000238 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 19



1019      P:000239 P:000239 000000            NOP                                       ; wait for flag to toggle
1020      P:00023A P:00023A 0C0236            JMP     DO_ENDFIFO0
1021   
1022   
1023                                DO_ERROR
1024      P:00023B P:00023B 0C05D6            JMP     <ERROR                            ; various errors in cmd recognition
1025   
1026                                WCSTG6
1027   
1028      P:00023C P:00023C 014185            CMP     #1,A                              ; Destination byte for PCI board
1029      P:00023D P:00023D 0EA275            JEQ     <PCI
1030   
1031                                ; Write the controller command and its arguments to the fiber optics
1032      P:00023E P:00023E 56B000            MOVE              X:<HEADER,A
1033      P:00023F P:00023F 0BF080            JSR     XMT_WRD                           ; Write the word to the fiber optics
                            000614
1034      P:000241 P:000241 0A8982            JCLR    #SRRQ,X:DSR,ERROR                 ; Error if receiver FIFO has no data
                            0005D6
1035      P:000243 P:000243 084E0B            MOVEP             X:DRXR,A                ; Write the command
1036      P:000244 P:000244 0D0614            JSR     <XMT_WRD                          ; Write the command to the fiber optics
1037   
1038                                          IF      @SCP("SUPPORTED","SUPPORTED")
1039      P:000245 P:000245 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1040      P:000246 P:000246 000000            NOP
1041      P:000247 P:000247 000000            NOP
1042      P:000248 P:000248 000000            NOP
1043      P:000249 P:000249 5C5B00            MOVE                          A1,Y:(R3)+
1044      P:00024A P:00024A 000000            NOP
1045      P:00024B P:00024B 56BC00            MOVE              X:<PCI_HISTON,A
1046      P:00024C P:00024C 200003            TST     A
1047      P:00024D P:00024D 0AF0AA            JEQ     DO_ARGS
                            000253
1048                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1049      P:00024F P:00024F 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1050      P:000250 P:000250 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1051                                          ENDIF
1052      P:000251 P:000251 633B00            MOVE              R3,X:<PCI_HISTFILL
1053      P:000252 P:000252 000000            NOP
1054                                DO_ARGS
1055                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
1056                                          ENDIF
1057   
1058      P:000253 P:000253 063500            DO      X:<NUM_ARG,L_ARGS1                ; Do loop won't execute if NUM_ARG = 0
                            000257
1059      P:000255 P:000255 084E0B            MOVEP             X:DRXR,A                ; Get the arguments
1060      P:000256 P:000256 0D0614            JSR     <XMT_WRD                          ; Write the argument to the fiber optics
1061      P:000257 P:000257 000000            NOP                                       ; DO loop restriction
1062                                L_ARGS1
1063                                ;       now clear out anything remaining in the fifo. If history is on, the
1064                                ;       second parameter (or the first if only 1) will be logged, assuming
1065                                ;       anything is there at all. It's really a violation of the command
1066                                ;       protocol and should never occur.
1067      P:000258 P:000258 0A8982            JCLR    #SRRQ,X:DSR,END_CMCTRLR           ; Is the receiver empty?
                            000274
1068   
1069      P:00025A P:00025A 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
1070      P:00025B P:00025B 000000            NOP                                       ; wait for flag to toggle
1071      P:00025C P:00025C 0A8982            JCLR    #SRRQ,X:DSR,LOG_RCV1              ; If now empty, go log parameter 1.
                            000260
1072      P:00025E P:00025E 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
1073      P:00025F P:00025F 000000            NOP                                       ; wait for flag to toggle
1074                                LOG_RCV1
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 20



1075   
1076                                          IF      @SCP("SUPPORTED","SUPPORTED")
1077      P:000260 P:000260 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1078      P:000261 P:000261 000000            NOP
1079      P:000262 P:000262 000000            NOP
1080      P:000263 P:000263 000000            NOP
1081      P:000264 P:000264 585B00            MOVE                          A0,Y:(R3)+
1082      P:000265 P:000265 000000            NOP
1083      P:000266 P:000266 56BC00            MOVE              X:<PCI_HISTON,A
1084      P:000267 P:000267 200003            TST     A
1085      P:000268 P:000268 0AF0AA            JEQ     DO_ENDFIFO1
                            00026F
1086                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1087      P:00026A P:00026A 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1088      P:00026B P:00026B 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1089                                          ENDIF
1090      P:00026C P:00026C 633B00            MOVE              R3,X:<PCI_HISTFILL
1091      P:00026D P:00026D 000000            NOP
1092      P:00026E P:00026E 000000            NOP
1093   
1094                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
1095                                          ENDIF
1096   
1097                                DO_ENDFIFO1
1098      P:00026F P:00026F 0A8982            JCLR    #SRRQ,X:DSR,END_CMCTRLR           ; Wait for the receiver to be empty
                            000274
1099      P:000271 P:000271 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
1100      P:000272 P:000272 000000            NOP                                       ; wait for flag to toggle
1101      P:000273 P:000273 0C026F            JMP     DO_ENDFIFO1
1102   
1103                                END_CMCTRLR
1104      P:000274 P:000274 000004            RTI                                       ; The other board will generate reply
1105   
1106                                ; Since it's a PCI command store the command and its arguments in X: memory
1107      P:000275 P:000275 0A8982  PCI       JCLR    #SRRQ,X:DSR,ERROR                 ; Error if receiver FIFO has no data
                            0005D6
1108      P:000277 P:000277 08708B            MOVEP             X:DRXR,X:COMMAND        ; Get the command
                            000031
1109      P:000279 P:000279 56B500            MOVE              X:<NUM_ARG,A            ; Get number of arguments in command
1110      P:00027A P:00027A 60F400            MOVE              #ARG1,R0                ; Starting address of argument list
                            000032
1111      P:00027C P:00027C 06CE00            DO      A,L_ARGS2                         ; DO loop won't execute if A = 0
                            000280
1112      P:00027E P:00027E 0A8982            JCLR    #SRRQ,X:DSR,ERROR                 ; Error if receiver FIFO has no data
                            0005D6
1113      P:000280 P:000280 08588B            MOVEP             X:DRXR,X:(R0)+          ; Get arguments
1114                                L_ARGS2
1115   
1116                                ;       now clear out anything remaining in the fifo. If history is on, the
1117                                ;       second parameter (or the first if only 1) will be logged, assuming
1118                                ;       anything is there at all. It's really a violation of the command
1119                                ;       protocol and should never occur.
1120      P:000281 P:000281 0A8982            JCLR    #SRRQ,X:DSR,PCI_COMMAND           ; Is the receiver empty?
                            00029C
1121   
1122      P:000283 P:000283 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
1123      P:000284 P:000284 000000            NOP                                       ; wait for flag to toggle
1124      P:000285 P:000285 0A8982            JCLR    #SRRQ,X:DSR,LOG_RCV2              ; If now empty, go log parameter 1.
                            000289
1125      P:000287 P:000287 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
1126      P:000288 P:000288 000000            NOP                                       ; wait for flag to toggle
1127                                LOG_RCV2
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 21



1128   
1129                                          IF      @SCP("SUPPORTED","SUPPORTED")
1130      P:000289 P:000289 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1131      P:00028A P:00028A 000000            NOP
1132      P:00028B P:00028B 000000            NOP
1133      P:00028C P:00028C 000000            NOP
1134      P:00028D P:00028D 585B00            MOVE                          A0,Y:(R3)+
1135      P:00028E P:00028E 000000            NOP
1136      P:00028F P:00028F 56BC00            MOVE              X:<PCI_HISTON,A
1137      P:000290 P:000290 200003            TST     A
1138      P:000291 P:000291 0AF0AA            JEQ     DO_ENDFIFO2
                            000297
1139                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1140      P:000293 P:000293 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1141      P:000294 P:000294 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1142                                          ENDIF
1143      P:000295 P:000295 633B00            MOVE              R3,X:<PCI_HISTFILL
1144      P:000296 P:000296 000000            NOP
1145   
1146                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
1147                                          ENDIF
1148   
1149                                DO_ENDFIFO2
1150      P:000297 P:000297 0A8982            JCLR    #SRRQ,X:DSR,PCI_COMMAND           ; Wait for the receiver to be empty
                            00029C
1151      P:000299 P:000299 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
1152      P:00029A P:00029A 000000            NOP                                       ; wait for flag to toggle
1153      P:00029B P:00029B 0C0297            JMP     DO_ENDFIFO2
1154   
1155   
1156                                ; Process a PCI board non-vector command
1157                                PCI_COMMAND
1158      P:00029C P:00029C 56B100            MOVE              X:<COMMAND,A            ; Get the command
1159   
1160                                          IF      @SCP("SUPPORTED","SUPPORTED")
1161      P:00029D P:00029D 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1162      P:00029E P:00029E 000000            NOP
1163      P:00029F P:00029F 000000            NOP
1164      P:0002A0 P:0002A0 000000            NOP
1165      P:0002A1 P:0002A1 5C5B00            MOVE                          A1,Y:(R3)+
1166      P:0002A2 P:0002A2 000000            NOP
1167      P:0002A3 P:0002A3 56BC00            MOVE              X:<PCI_HISTON,A
1168      P:0002A4 P:0002A4 200003            TST     A
1169      P:0002A5 P:0002A5 0AF0AA            JEQ     DO_CMDPCI
                            0002AB
1170                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1171      P:0002A7 P:0002A7 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1172      P:0002A8 P:0002A8 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1173                                          ENDIF
1174      P:0002A9 P:0002A9 633B00            MOVE              R3,X:<PCI_HISTFILL
1175      P:0002AA P:0002AA 000000            NOP
1176                                DO_CMDPCI
1177      P:0002AB P:0002AB 56B100            MOVE              X:<COMMAND,A            ; Get the command
1178      P:0002AC P:0002AC 000000            NOP
1179                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
1180                                          ENDIF
1181   
1182      P:0002AD P:0002AD 0140C5            CMP     #'TRM',A                          ; Is it the test DRAM command?
                            54524D
1183      P:0002AF P:0002AF 0EA673            JEQ     <TEST_DRAM
1184      P:0002B0 P:0002B0 0140C5            CMP     #'TDL',A                          ; Is it the test data link command?
                            54444C
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 22



1185      P:0002B2 P:0002B2 0EA55C            JEQ     <TEST_DATA_LINK
1186      P:0002B3 P:0002B3 0140C5            CMP     #'RDM',A
                            52444D
1187      P:0002B5 P:0002B5 0EA55E            JEQ     <READ_MEMORY                      ; Is it the read memory command?
1188      P:0002B6 P:0002B6 0140C5            CMP     #'WRM',A
                            57524D
1189      P:0002B8 P:0002B8 0EA583            JEQ     <WRITE_MEMORY                     ; Is it the write memory command?
1190   
1191                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1192      P:0002B9 P:0002B9 0140C5            CMP     #'GTK',A
                            47544B
1193      P:0002BB P:0002BB 0EA5AD            JEQ     <GET_TICK                         ; Is it Get Ticks?
1194                                          ENDIF
1195      P:0002BC P:0002BC 0140C5            CMP     #'INF',A
                            494E46
1196      P:0002BE P:0002BE 0EA5B5            JEQ     <GET_INFO                         ; Is it Get Info?
1197   
1198      P:0002BF P:0002BF 0C05D6            JMP     <ERROR                            ; Its not a recognized command
1199   
1200                                ; ********************  Vector commands  *******************
1201   
1202                                READ_NUMBER_OF_PIXELS_READ                          ; Write the reply to the DTXS FIFO
1203   
1204                                          IF      @SCP("SUPPORTED","SUPPORTED")
1205      P:0002C0 P:0002C0 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1206      P:0002C1 P:0002C1 000000            NOP
1207      P:0002C2 P:0002C2 64F400            MOVE              #H_RDNUMPIX,R4
                            524E50
1208      P:0002C4 P:0002C4 6C5B00            MOVE                          R4,Y:(R3)+  ; tag
1209                                ;       the main readout loop wraps PCI_HISTFILL when it gets the chance.
1210                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1211      P:0002C5 P:0002C5 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1212      P:0002C6 P:0002C6 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1213                                          ENDIF
1214      P:0002C7 P:0002C7 000000            NOP
1215      P:0002C8 P:0002C8 633B00            MOVE              R3,X:<PCI_HISTFILL
1216      P:0002C9 P:0002C9 000000            NOP
1217                                          ENDIF
1218   
1219      P:0002CA P:0002CA 0A3EA0            JSET    #0,X:<R_PXLS_CRIT,SEND_RPXLS_LAST ;are R_PXLS 'safe'?
                            0002D2
1220   
1221      P:0002CC P:0002CC 08F08D            MOVEP             X:R_PXLS_0,X:DTXS       ; DSP-to-host slave transmit
                            000019
1222      P:0002CE P:0002CE 000000            NOP
1223      P:0002CF P:0002CF 08F08D            MOVEP             X:R_PXLS_1,X:DTXS       ; DSP-to-host slave transmit
                            000018
1224   
1225      P:0002D1 P:0002D1 000004            RTI
1226   
1227                                ;       use the safe copy in RPXLS_SAFE
1228                                SEND_RPXLS_LAST
1229      P:0002D2 P:0002D2 65F400            MOVE              #RPXLS_SAFE,R5
                            0007E0
1230      P:0002D4 P:0002D4 0A3E21            BSET    #1,X:<R_PXLS_CRIT                 ; mark race as having happened
1231      P:0002D5 P:0002D5 000000            NOP
1232      P:0002D6 P:0002D6 08DDCD            MOVEP             Y:(R5)+,X:DTXS          ;DSP-to-host slave transmit
1233      P:0002D7 P:0002D7 000000            NOP
1234      P:0002D8 P:0002D8 08DDCD            MOVEP             Y:(R5)+,X:DTXS          ;DSP-to-host slave transmit
1235   
1236      P:0002D9 P:0002D9 000004            RTI
1237   
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 23



1238                                ; Reset the controller by transmitting a special byte code
1239                                RESET_CONTROLLER
1240      P:0002DA P:0002DA 011D22            BSET    #SCLK,X:PDRE                      ; Enable special command mode
1241      P:0002DB P:0002DB 000000            NOP
1242      P:0002DC P:0002DC 000000            NOP
1243      P:0002DD P:0002DD 60F400            MOVE              #$FFF000,R0             ; Memory mapped address of transmitter
                            FFF000
1244      P:0002DF P:0002DF 44F400            MOVE              #$10000B,X0             ; Special command to reset controller
                            10000B
1245      P:0002E1 P:0002E1 446000            MOVE              X0,X:(R0)
1246      P:0002E2 P:0002E2 0606A0            REP     #6                                ; Wait for transmission to complete
1247      P:0002E3 P:0002E3 000000            NOP
1248      P:0002E4 P:0002E4 011D02            BCLR    #SCLK,X:PDRE                      ; Disable special command mode
1249   
1250                                ; Wait until the timing board is reset, because FO data is invalid
1251      P:0002E5 P:0002E5 44F400            MOVE              #10000,X0               ; Delay by about 350 milliseconds
                            002710
1252      P:0002E7 P:0002E7 06C400            DO      X0,L_DELAY
                            0002ED
1253      P:0002E9 P:0002E9 06E883            DO      #1000,L_RDFIFO
                            0002EC
1254      P:0002EB P:0002EB 09463F            MOVEP             Y:RDFIFO,Y0             ; Read the FIFO word to keep the
1255      P:0002EC P:0002EC 000000            NOP                                       ;   receiver empty
1256                                L_RDFIFO
1257      P:0002ED P:0002ED 000000            NOP
1258                                L_DELAY
1259      P:0002EE P:0002EE 000000            NOP
1260   
1261                                ; Wait for 'SYR' from the controller, with a 260 millisecond timeout
1262      P:0002EF P:0002EF 061480            DO      #20,L_WAIT_SYR
                            0002F5
1263      P:0002F1 P:0002F1 0D0641            JSR     <RD_FO_TIMEOUT                    ; Move the FIFO reply into B1
1264      P:0002F2 P:0002F2 0E82F5            JCS     <L_WAIT_SYR-1
1265      P:0002F3 P:0002F3 00008C            ENDDO
1266      P:0002F4 P:0002F4 0C02F7            JMP     <L_SYS
1267      P:0002F5 P:0002F5 000000            NOP
1268                                L_WAIT_SYR
1269      P:0002F6 P:0002F6 0C05D6            JMP     <ERROR                            ; Timeout, respond with error
1270   
1271      P:0002F7 P:0002F7 0140CD  L_SYS     CMP     #$020002,B
                            020002
1272      P:0002F9 P:0002F9 0E25D6            JNE     <ERROR                            ; There was an error
1273      P:0002FA P:0002FA 0D0641            JSR     <RD_FO_TIMEOUT                    ; Move the FIFO reply into B1
1274      P:0002FB P:0002FB 0E85D6            JCS     <ERROR
1275      P:0002FC P:0002FC 0140CD            CMP     #'SYR',B
                            535952
1276      P:0002FE P:0002FE 0E25D6            JNE     <ERROR                            ; There was an error
1277      P:0002FF P:0002FF 0C05D9            JMP     <SYR                              ; Reply to host, return from interrupt
1278   
1279   
1280                                ; ****************  Exposure and readout commands  ****************
1281   
1282                                WRITE_BASE_PCI_ADDRESS
1283      P:000300 P:000300 0A8982            JCLR    #SRRQ,X:DSR,ERROR                 ; Error if receiver FIFO has no data
                            0005D6
1284      P:000302 P:000302 08480B            MOVEP             X:DRXR,A0
1285      P:000303 P:000303 0A8982            JCLR    #SRRQ,X:DSR,ERROR                 ; Error if receiver FIFO has no data
                            0005D6
1286      P:000305 P:000305 08440B            MOVEP             X:DRXR,X0               ; Get most significant word
1287      P:000306 P:000306 0C1940            INSERT  #$010010,X0,A
                            010010
1288      P:000308 P:000308 000000            NOP
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 24



1289      P:000309 P:000309 501200            MOVE              A0,X:<BASE_ADDR_0       ; BASE_ADDR is 8 + 24 bits
1290      P:00030A P:00030A 541100            MOVE              A1,X:<BASE_ADDR_1
1291   
1292                                          IF      @SCP("SUPPORTED","SUPPORTED")
1293      P:00030B P:00030B 56BC00            MOVE              X:<PCI_HISTON,A
1294      P:00030C P:00030C 200003            TST     A
1295      P:00030D P:00030D 0AF0AA            JEQ     DO_DON
                            000318
1296      P:00030F P:00030F 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1297      P:000310 P:000310 000000            NOP
1298      P:000311 P:000311 64F400            MOVE              #H_BASEPCIADDR,R4       ; tag
                            574250
1299      P:000313 P:000313 6C5B00            MOVE                          R4,Y:(R3)+
1300      P:000314 P:000314 000000            NOP
1301                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1302      P:000315 P:000315 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1303      P:000316 P:000316 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1304                                          ENDIF
1305      P:000317 P:000317 633B00            MOVE              R3,X:<PCI_HISTFILL
1306                                DO_DON
1307                                          ENDIF
1308   
1309                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
1310      P:000318 P:000318 0C05CF            JMP     <FINISH                           ; Write 'DON' reply
1311   
1312                                ; Write the base PCI image address to the PCI address
1313                                INITIALIZE_NUMBER_OF_PIXELS
1314   
1315                                          IF      @SCP("SUPPORTED","SUPPORTED")
1316      P:000319 P:000319 56BC00            MOVE              X:<PCI_HISTON,A
1317      P:00031A P:00031A 200003            TST     A
1318      P:00031B P:00031B 0AF0AA            JEQ     DO_NPIX
                            000327
1319      P:00031D P:00031D 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1320      P:00031E P:00031E 000000            NOP
1321      P:00031F P:00031F 64F400            MOVE              #F_INIT_NO_PIX,R4       ; tag
                            494941
1322      P:000321 P:000321 000000            NOP
1323      P:000322 P:000322 6C5B00            MOVE                          R4,Y:(R3)+
1324      P:000323 P:000323 000000            NOP
1325                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1326      P:000324 P:000324 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1327      P:000325 P:000325 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1328                                          ENDIF
1329      P:000326 P:000326 633B00            MOVE              R3,X:<PCI_HISTFILL
1330                                DO_NPIX
1331                                          ENDIF
1332   
1333      P:000327 P:000327 200013            CLR     A
1334      P:000328 P:000328 000000            NOP
1335      P:000329 P:000329 541800            MOVE              A1,X:<R_PXLS_1          ; Up counter of number of pixels read
1336      P:00032A P:00032A 501900            MOVE              A0,X:<R_PXLS_0
1337      P:00032B P:00032B 503E00            MOVE              A0,X:<R_PXLS_CRIT       ; mark safe
1338      P:00032C P:00032C 503F00            MOVE              A0,X:<R_PXLS_RACE       ; clear stats
1339   
1340      P:00032D P:00032D 509200            MOVE              X:<BASE_ADDR_0,A0       ; BASE_ADDR is 2 x 16-bits
1341      P:00032E P:00032E 549100            MOVE              X:<BASE_ADDR_1,A1
1342      P:00032F P:00032F 000000            NOP
1343      P:000330 P:000330 501B00            MOVE              A0,X:<PCI_ADDR_0        ; PCI_ADDR is 8 + 24 bits
1344      P:000331 P:000331 541A00            MOVE              A1,X:<PCI_ADDR_1
1345   
1346   
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 25



1347      P:000332 P:000332 0C0189            JMP     <CONTROLLER_DONE                  ; Repy = DONE host flags
1348   
1349                                ; Send an abort readout command to the controller to stop image transmission
1350                                ABORT_READOUT
1351      P:000333 P:000333 448600            MOVE              X:<FLAG_DONE,X0
1352      P:000334 P:000334 441D00            MOVE              X0,X:<HOST_FLAG
1353      P:000335 P:000335 0D01B7            JSR     <FO_WRITE_HOST_FLAG
1354   
1355      P:000336 P:000336 568E00            MOVE              X:<C000202,A
1356      P:000337 P:000337 0D0614            JSR     <XMT_WRD                          ; Timing board header word
1357      P:000338 P:000338 56F400            MOVE              #'ABR',A
                            414252
1358      P:00033A P:00033A 0D0614            JSR     <XMT_WRD                          ; Abort Readout
1359   
1360      P:00033B P:00033B 200013            CLR     A
1361   
1362      P:00033C P:00033C 0140C0  ABR0      ADD     #>1,A
                            000001
1363                                ; Ensure that image data is no longer being received from the controller
1364      P:00033E P:00033E 01AD80            JCLR    #EF,X:PDRD,ABR2                   ; Test for incoming FIFO data
                            000344
1365      P:000340 P:000340 09443F  ABR1      MOVEP             Y:RDFIFO,X0             ; Read the FIFO until its empty
1366      P:000341 P:000341 000000            NOP
1367      P:000342 P:000342 01ADA0            JSET    #EF,X:PDRD,ABR1
                            000340
1368      P:000344 P:000344 066089  ABR2      DO      #2400,ABR3                        ; Wait for about 30 microsec in case
                            000346
1369      P:000346 P:000346 000000            NOP                                       ;   FIFO data is still arriving
1370      P:000347 P:000347 01ADA0  ABR3      JSET    #EF,X:PDRD,ABR1                   ; Keep emptying if more data arrived
                            000340
1371      P:000349 P:000349 543A00            MOVE              A1,X:<ABT_PIXELS
1372      P:00034A P:00034A 06FF8F            DO      #4095,PUNT                        ; Wait
                            00034C
1373      P:00034C P:00034C 000000            NOP
1374      P:00034D P:00034D 000000  PUNT      NOP
1375   
1376                                ; Wait for a 'DON' reply from the controller
1377                                ;        JSR     <RD_FO_TIMEOUT          ; Move the FIFO reply into B1
1378                                ;        JCS     <ERROR
1379                                ;        CMP     #$020002,B
1380                                ;        JNE     <ERROR                  ; There was an error
1381                                ;        JSR     <RD_FO_TIMEOUT          ; Move the FIFO reply into B1
1382                                ;        JCS     <ERROR
1383                                ;        CMP     #'DON',B
1384                                ;        JNE     <ERROR                  ; There was an error
1385   
1386   
1387   
1388                                ; Clean up the PCI board from wherever it was executing
1389                                CLEAN_UP_PCI
1390      P:00034E P:00034E 08F4BF            MOVEP             #$0001C0,X:IPRC         ; Disable HF* FIFO interrupt
                            0001C0
1391      P:000350 P:000350 0A8520            BSET    #HCIE,X:DCTR                      ; Enable host command interrupts
1392      P:000351 P:000351 0501BB            MOVEC             #1,SP                   ; Point stack pointer to the top
1393      P:000352 P:000352 05F43D            MOVEC             #$000200,SSL            ; SR = zero except for interrupts
                            000200
1394      P:000354 P:000354 0500BB            MOVEC             #0,SP                   ; Writing to SSH preincrements the SP
1395      P:000355 P:000355 05B2BC            MOVEC             #START,SSH              ; Set PC to for full initialization
1396      P:000356 P:000356 000000            NOP
1397      P:000357 P:000357 000004            RTI
1398   
1399                                ; Read the image - change the serial receiver to expect 16-bit (image) data
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 26



1400                                READ_IMAGE
1401   
1402                                          IF      @SCP("SUPPORTED","SUPPORTED")
1403                                                                                    ; give the host a chance to clear host flags
 (FWIW).
1404      P:000358 P:000358 063D00            DO      X:<WAIT_RDA,*+3                   ; Do loop won't execute if WAIT_RDA = 0
                            00035A
1405      P:00035A P:00035A 000000            NOP
1406                                          ENDIF
1407   
1408      P:00035B P:00035B 0A8500            BCLR    #HCIE,X:DCTR                      ; Disable host command interrupts
1409      P:00035C P:00035C 448A00            MOVE              X:<FLAG_RDI,X0
1410      P:00035D P:00035D 441D00            MOVE              X0,X:<HOST_FLAG
1411      P:00035E P:00035E 0D01B7            JSR     <FO_WRITE_HOST_FLAG               ; Set HCTR bits to "reading out"
1412      P:00035F P:00035F 084E0A            MOVEP             X:DPSR,A                ; Clear all PCI error conditions
1413      P:000360 P:000360 0140C2            OR      #$1FE,A
                            0001FE
1414      P:000362 P:000362 000000            NOP
1415      P:000363 P:000363 08CE0A            MOVEP             A,X:DPSR
1416      P:000364 P:000364 0A862E            BSET    #CLRT,X:DPCR                      ; Clear the master transmitter FIFO
1417      P:000365 P:000365 0A86AE            JSET    #CLRT,X:DPCR,*                    ; Wait for the clearing to be complete
                            000365
1418   
1419                                          IF      @SCP("SUPPORTED","SUPPORTED")
1420      P:000367 P:000367 56BC00            MOVE              X:<PCI_HISTON,A
1421      P:000368 P:000368 200003            TST     A
1422      P:000369 P:000369 0AF0AA            JEQ     DO_PXL
                            000375
1423      P:00036B P:00036B 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1424      P:00036C P:00036C 000000            NOP
1425      P:00036D P:00036D 64F400            MOVE              #F_READ_IMAGE,R4        ; tag
                            524441
1426      P:00036F P:00036F 000000            NOP
1427      P:000370 P:000370 6C5B00            MOVE                          R4,Y:(R3)+
1428      P:000371 P:000371 000000            NOP
1429                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1430      P:000372 P:000372 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1431      P:000373 P:000373 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1432                                          ENDIF
1433      P:000374 P:000374 633B00            MOVE              R3,X:<PCI_HISTFILL
1434                                DO_PXL
1435                                          ENDIF
1436   
1437   
1438                                ; Compute the number of pixels to read from the controller
1439      P:000375 P:000375 0D0641            JSR     <RD_FO_TIMEOUT                    ; Read number of columns
1440      P:000376 P:000376 0E81C9            JCS     <FO_ERR
1441      P:000377 P:000377 21A500            MOVE              B1,X1
1442      P:000378 P:000378 0D0641            JSR     <RD_FO_TIMEOUT                    ; Read number of rows
1443      P:000379 P:000379 0E81C9            JCS     <FO_ERR
1444      P:00037A P:00037A 21A700            MOVE              B1,Y1                   ; Number of rows to read is in Y1
1445      P:00037B P:00037B 2000F0            MPY     X1,Y1,A
1446      P:00037C P:00037C 200022            ASR     A                                 ; Correct for 0 in LS bit after MPY
1447      P:00037D P:00037D 000000            NOP
1448      P:00037E P:00037E 541400            MOVE              A1,X:<NPXLS_1           ; NPXLS set by controller
1449      P:00037F P:00037F 501500            MOVE              A0,X:<NPXLS_0
1450   
1451                                                                                    ; Make sure the PCI address is on a 512 pixe
l boundary
1452      P:000380 P:000380 569B00            MOVE              X:<PCI_ADDR_0,A         ; Current PCI address
1453      P:000381 P:000381 0140C6            AND     #$0003FF,A                        ; If addr .and. $3FF .ne. 0 then
                            0003FF
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 27



1454      P:000383 P:000383 0EA391            JEQ     <IM_INIT                          ;   addr = (addr + $400) .and. $FFFC00
1455      P:000384 P:000384 549A00            MOVE              X:<PCI_ADDR_1,A1
1456      P:000385 P:000385 509B00            MOVE              X:<PCI_ADDR_0,A0
1457      P:000386 P:000386 250000            MOVE              #0,X1
1458      P:000387 P:000387 44F400            MOVE              #$400,X0
                            000400
1459      P:000389 P:000389 200020            ADD     X,A
1460      P:00038A P:00038A 000000            NOP
1461      P:00038B P:00038B 541A00            MOVE              A1,X:<PCI_ADDR_1
1462      P:00038C P:00038C 210D00            MOVE              A0,B1
1463      P:00038D P:00038D 0140CE            AND     #$FFFC00,B
                            FFFC00
1464      P:00038F P:00038F 000000            NOP
1465      P:000390 P:000390 551B00            MOVE              B1,X:<PCI_ADDR_0
1466   
1467      P:000391 P:000391 20001B  IM_INIT   CLR     B
1468                                ;     a pad of zeroes as sentinel if we overrun on the DMA phase.
1469                                ;     clear the whole image buffer and again as much beyond.
1470      P:000392 P:000392 61F400            MOVE              #IMAGE_BUFER,R1
                            000000
1471      P:000394 P:000394 06D087            DO      #2000,Z_BUFFER
                            000396
1472      P:000396 P:000396 5D5900            MOVE                          B1,Y:(R1)+
1473                                Z_BUFFER
1474      P:000397 P:000397 62F400            MOVE              #PCI_ERRLOGFIRST,R2     ; error buffer to record pci dma events
                            000400
1475      P:000399 P:000399 552800            MOVE              B1,X:<PCI_BURST_NO      ; overall count of pci bursts completed
1476      P:00039A P:00039A 551600            MOVE              B1,X:<IPXLS_1           ; IPXLS = 0
1477      P:00039B P:00039B 511700            MOVE              B0,X:<IPXLS_0
1478      P:00039C P:00039C 212500            MOVE              B0,X1                   ; X = 512 = 1/2 the FIFO depth
1479      P:00039D P:00039D 448C00            MOVE              X:<C512,X0
1480      P:00039E P:00039E 66F400            MOVE              #RDFIFO,R6
                            FFFFFF
1481   
1482   
1483                                ; There are four separate stages of writing the image to the PCI bus
1484                                ;       a. Write complete 512 pixel FIFO half full blocks
1485                                ;       b. Write the pixels left over from the last complete FIFO block
1486                                ;               in blocks of 32 pixels
1487                                ;       c. Write the pixels left over from the last 32 pixel block
1488                                ;       d. If the number of pixels in the image is odd write the very last pixel
1489   
1490   
1491                                ; Compute the number of pixel pairs from the FIFO --> PCI bus
1492                                L_FIFO
1493   
1494                                          IF      @SCP("SUPPORTED","SUPPORTED")
1495      P:0003A0 P:0003A0 200013            CLR     A
1496   
1497      P:0003A1 P:0003A1 54BB00            MOVE              X:<PCI_HISTFILL,A1
1498      P:0003A2 P:0003A2 000000            NOP
1499      P:0003A3 P:0003A3 0140C4            SUB     #PCI_HISTEND,A
                            001000
1500      P:0003A5 P:0003A5 000000            NOP
1501      P:0003A6 P:0003A6 0AF0A9            JLT     CHK_FO_RDO
                            0003AC
1502      P:0003A8 P:0003A8 54F400            MOVE              #PCI_HISTFIRST,A1       ; hist buffer ptr wrapped
                            000800
1503      P:0003AA P:0003AA 000000            NOP
1504      P:0003AB P:0003AB 543B00            MOVE              A1,X:<PCI_HISTFILL
1505                                          ENDIF
1506   
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 28



1507                                CHK_FO_RDO
1508      P:0003AC P:0003AC 200013            CLR     A
1509      P:0003AD P:0003AD 549400            MOVE              X:<NPXLS_1,A1           ; Number of pixels to write to PCI
1510      P:0003AE P:0003AE 509500            MOVE              X:<NPXLS_0,A0
1511      P:0003AF P:0003AF 479600            MOVE              X:<IPXLS_1,Y1           ; Compare it to image pixels written.
1512      P:0003B0 P:0003B0 469700            MOVE              X:<IPXLS_0,Y0
1513      P:0003B1 P:0003B1 000000            NOP
1514      P:0003B2 P:0003B2 200034            SUB     Y,A                               ; If (Image size - Ipxls)  <= 512
1515      P:0003B3 P:0003B3 000000            NOP                                       ;   we're at the end of the image
1516      P:0003B4 P:0003B4 200024            SUB     X,A
1517      P:0003B5 P:0003B5 0EF42B            JLE     <WRITE_LAST_LITTLE_BIT_OF_IMAGE
1518   
1519   
1520                                ; (a) New DMA writing in burst mode, 128 pixels in a burst
1521                                WR_IMAGE
1522                                ;       BSET    #4,X:PDRC
1523      P:0003B6 P:0003B6 01ADA1            JSET    #HF,X:PDRD,*                      ; Wait for FIFO to be half full + 1
                            0003B6
1524      P:0003B8 P:0003B8 000000            NOP
1525      P:0003B9 P:0003B9 000000            NOP
1526      P:0003BA P:0003BA 01ADA1            JSET    #HF,X:PDRD,WR_IMAGE               ; Protection against metastability
                            0003B6
1527                                ;       BCLR    #4,X:PDRC
1528   
1529                                ; Priming the pump:
1530                                ; Copy part of the fiber optic FIFO load  (512 pixels) to DSP Y: memory
1531                                ; We need a PCIBURST worth of pixels before we can  start a transfer to the bus.
1532      P:0003BC P:0003BC 60F400            MOVE              #IMAGE_BUFER,R0
                            000000
1533      P:0003BE P:0003BE 221100            MOVE              R0,R1                   ;R0,R1 to 'FIRST'
1534   
1535   
1536                                ;       BSET    #4,X:PDRC
1537      P:0003BF P:0003BF 068080            DO      #PCIBURST,L_BUFFER
                            0003C1
1538      P:0003C1 P:0003C1 0958FF            MOVEP             Y:RDFIFO,Y:(R0)+
1539                                L_BUFFER
1540   
1541                                ; Priming the pump:
1542                                ; Prepare the HI32 DPMC and DPAR address registers
1543      P:0003C2 P:0003C2 549A00            MOVE              X:<PCI_ADDR_1,A1        ; Current PCI address
1544      P:0003C3 P:0003C3 509B00            MOVE              X:<PCI_ADDR_0,A0
1545      P:0003C4 P:0003C4 0C1D10            ASL     #8,A,A
1546      P:0003C5 P:0003C5 000000            NOP
1547      P:0003C6 P:0003C6 0140C2            ORI     #$3F0000,A                        ; Burst length = # of PCI writes (!!!)
                            3F0000
1548      P:0003C8 P:0003C8 000000            NOP                                       ;   = # of pixels / 2 - 1
1549      P:0003C9 P:0003C9 547000            MOVE              A1,X:DPMC               ; DPMC = B[31:16] + $070000
                            FFFFC7
1550      P:0003CB P:0003CB 0C1D20            ASL     #16,A,A                           ; Get PCI_ADDR[15:0] into A1[15:0]
1551      P:0003CC P:0003CC 000000            NOP
1552      P:0003CD P:0003CD 0140C6            AND     #$00FFFF,A                        ; Making sure it is just 16bits
                            00FFFF
1553      P:0003CF P:0003CF 000000            NOP
1554      P:0003D0 P:0003D0 0140C2            OR      #$070000,A                        ; A1 will get written to DPAR register
                            070000
1555                                ; Make sure its always 512 pixels per loop = 1/2 FIFO (4 bursts -> PCI)
1556      P:0003D2 P:0003D2 617000            MOVE              R1,X:DSR0               ; Source address for DMA = pixel data
                            FFFFEF
1557      P:0003D4 P:0003D4 08F4AE            MOVEP             #DTXM,X:DDR0            ; Destination = PCI master transmitter
                            FFFFCC
1558      P:0003D6 P:0003D6 08F4AD            MOVEP             #>127,X:DCO0            ; DMA Count = # of pixels - 1 (!!!)
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 29



                            00007F
1559      P:0003D8 P:0003D8 08F4AC            MOVEP             #$8EFA51,X:DCR0         ; Start DMA with control register DE=1
                            8EFA51
1560      P:0003DA P:0003DA 08CC08            MOVEP             A1,X:DPAR               ; Initiate writing to the PCI bus
1561                                ;       NOP
1562                                ;       NOP
1563   
1564                                ; At  this point we have a PCI transfer underway to be checked later.
1565                                ; Enter the main loop which interleaves FO and PCI transfers.
1566                                ; R0 is now the 'FILL' ptr for the image buffer, and R1
1567                                ; is the empty ptr.  (R1 only reflects DMA successfully completed)
1568                                ; A0,1 holds the pci address
1569                                ; X0 holds a constant 512.
1570   
1571   
1572                                ;       BCLR    #4,X:PDRC
1573                                NEXTBURST
1574                                ; First try to read out the fiber optic. We want to read at least enough
1575                                ; to have one more pci burst worth ready to go (beyond the pci transfer
1576                                ; ongoing) but we cannot read past the 512 pixel limit authorized by the
1577                                ; HF flag on the fifo.
1578      P:0003DB P:0003DB 20001B            CLR     B
1579      P:0003DC P:0003DC 220D00            MOVE              R0,B1
1580      P:0003DD P:0003DD 0140CC            SUB     #IMAGE_BUFER,B                    ; FILL - FIRST == available data (no wrap)
                            000000
1581      P:0003DF P:0003DF 0140CC            SUB     #FOBURST,B
                            000200
1582      P:0003E1 P:0003E1 0E13F1            JGE     <PCIXFERPOLL                      ; No more pixels in this empty of FO.
1583      P:0003E2 P:0003E2 20001B            CLR     B
1584      P:0003E3 P:0003E3 222600            MOVE              R1,Y0
1585      P:0003E4 P:0003E4 220D00            MOVE              R0,B1
1586      P:0003E5 P:0003E5 000000            NOP
1587      P:0003E6 P:0003E6 20005C            SUB     Y0,B                              ;FILL- EMPTY == data not DMA'd (! wrap)
1588      P:0003E7 P:0003E7 000000            NOP
1589      P:0003E8 P:0003E8 21A600            MOVE              B1,Y0                   ; Image bytes already available for pci
1590      P:0003E9 P:0003E9 20001B            CLR     B
1591      P:0003EA P:0003EA 57F400            MOVE              #PCI2BURST,B            ; want enough more for additional burst
                            000100
1592      P:0003EC P:0003EC 20005C            SUB     Y0,B
1593      P:0003ED P:0003ED 0EF3F1            JLE     <PCIXFERPOLL
1594      P:0003EE P:0003EE 06CD00            DO      B1,FOXFER
                            0003F0
1595      P:0003F0 P:0003F0 0958FF            MOVEP             Y:RDFIFO,Y:(R0)+
1596                                FOXFER
1597                                ; we are guaranteed to have a transfer waiting here.
1598                                PCIXFERPOLL
1599      P:0003F1 P:0003F1 0A8A84            JCLR    #MARQ,X:DPSR,*                    ; Wait until the PCI operation is done
                            0003F1
1600                                ;       BCLR    #4,X:PDRC
1601      P:0003F3 P:0003F3 0A8AAE            JSET    #MDT,X:DPSR,WR_OK0                ; If no error go to the next sub-block
                            0003F6
1602                                ;       BSET    #4,X:PDRC
1603      P:0003F5 P:0003F5 0D0514            JSR     <PCI_ERROR_RECOVERY               ; clear h/w and then do the retry.
1604      P:0003F6 P:0003F6 0140C0  WR_OK0    ADD     #>256,A                           ; PCI address = + 2 x # of pixels (!!!)
                            000100
1605      P:0003F8 P:0003F8 20001B            CLR     B
1606      P:0003F9 P:0003F9 222D00            MOVE              R1,B1                   ; update R1 for the image buffer addr
1607      P:0003FA P:0003FA 000000            NOP
1608      P:0003FB P:0003FB 0140C8            ADD     #>128,B                           ; corresponding to the next pci block
                            000080
1609      P:0003FD P:0003FD 000000            NOP
1610      P:0003FE P:0003FE 21B100            MOVE              B1,R1
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 30



1611      P:0003FF P:0003FF 20001B            CLR     B
1612      P:000400 P:000400 55A800            MOVE              X:<PCI_BURST_NO,B1      ;increment count of pci burst
1613      P:000401 P:000401 0140C8            ADD     #>1,B
                            000001
1614      P:000403 P:000403 000000            NOP
1615      P:000404 P:000404 552800            MOVE              B1,X:<PCI_BURST_NO
1616   
1617                                ;       BCLR    #4,X:PDRC
1618                                STARTBURST
1619                                ;       Is the DMA pending in the image buffer done here?
1620      P:000405 P:000405 20001B            CLR     B
1621      P:000406 P:000406 222600            MOVE              R1,Y0
1622      P:000407 P:000407 220D00            MOVE              R0,B1
1623      P:000408 P:000408 20005C            SUB     Y0,B
1624      P:000409 P:000409 0AF0AA            JEQ     CHECKENDBURST
                            000414
1625                                ;       No go to the next burst block.
1626      P:00040B P:00040B 0A862E            BSET    #CLRT,X:DPCR                      ; Clear the master transmitter
1627      P:00040C P:00040C 0A86AE            JSET    #CLRT,X:DPCR,*                    ; Wait for the clearing to be complete
                            00040C
1628      P:00040E P:00040E 08F4AC            MOVEP             #$8EFA51,X:DCR0         ; Start DMA with control register DE=1
                            8EFA51
1629      P:000410 P:000410 08CC08            MOVEP             A1,X:DPAR               ; Initiate writing to the PCI bus
1630      P:000411 P:000411 000000            NOP
1631      P:000412 P:000412 000000            NOP
1632      P:000413 P:000413 0C03DB            JMP     NEXTBURST
1633                                CHECKENDBURST
1634                                                                                    ; there's no more bytes to dma, check FO fil
l progress
1635      P:000414 P:000414 20001B            CLR     B
1636      P:000415 P:000415 220D00            MOVE              R0,B1
1637      P:000416 P:000416 0140CC            SUB     #IMAGE_BUFER,B
                            000000
1638      P:000418 P:000418 0140CC            SUB     #FOBURST,B
                            000200
1639      P:00041A P:00041A 0E93DB            JLT     NEXTBURST
1640                                ; DMA is done and 512 bytes emptied.
1641   
1642   
1643                                ;       BCLR    #4,X:PDRC
1644                                ; Re-calculate and store the PCI address where image data is being written to
1645      P:00041B P:00041B 200013            CLR     A
1646      P:00041C P:00041C 509700            MOVE              X:<IPXLS_0,A0           ; Number of pixels to write to PCI
1647      P:00041D P:00041D 549600            MOVE              X:<IPXLS_1,A1
1648      P:00041E P:00041E 200020            ADD     X,A                               ; X = 512 = 1/2 FIFO size
1649      P:00041F P:00041F 000000            NOP
1650      P:000420 P:000420 501700            MOVE              A0,X:<IPXLS_0           ; Number of pixels to write to PCI
1651      P:000421 P:000421 541600            MOVE              A1,X:<IPXLS_1
1652      P:000422 P:000422 549A00            MOVE              X:<PCI_ADDR_1,A1        ; Current PCI address
1653      P:000423 P:000423 509B00            MOVE              X:<PCI_ADDR_0,A0
1654      P:000424 P:000424 200020            ADD     X,A                               ; Add the byte increment = 1024
1655      P:000425 P:000425 200020            ADD     X,A
1656   
1657      P:000426 P:000426 000000            NOP
1658      P:000427 P:000427 541A00            MOVE              A1,X:<PCI_ADDR_1        ; Incremented current PCI address
1659      P:000428 P:000428 501B00            MOVE              A0,X:<PCI_ADDR_0
1660   
1661      P:000429 P:000429 0D04E1            JSR     <C_RPXLS                          ; Calculate number of pixels read
1662      P:00042A P:00042A 0C03A0            JMP     <L_FIFO                           ; Go process the next 1/2 FIFO
1663   
1664                                ; (b) Write the pixels left over, in 32 pixel blocks
1665                                WRITE_LAST_LITTLE_BIT_OF_IMAGE
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 31



1666      P:00042B P:00042B 20001B            CLR     B
1667      P:00042C P:00042C 200020            ADD     X,A                               ; Exit if there are no more pixels
1668      P:00042D P:00042D 200003            TST     A
1669      P:00042E P:00042E 0EF4C3            JLE     <ALLDONE
1670      P:00042F P:00042F 51F400            MOVE              #>31,B0
                            00001F
1671      P:000431 P:000431 502000            MOVE              A0,X:<NUM_PIX           ; Number of pixels in the last block
1672                                ;       ADD     #>31,A                  ; round up to next 32 pixel block
1673      P:000432 P:000432 21A700            MOVE              B1,Y1
1674      P:000433 P:000433 212600            MOVE              B0,Y0
1675      P:000434 P:000434 000000            NOP
1676      P:000435 P:000435 200030            ADD     Y,A
1677      P:000436 P:000436 000000            NOP
1678   
1679      P:000437 P:000437 0C1C0A            ASR     #5,A,A
1680      P:000438 P:000438 000000            NOP
1681      P:000439 P:000439 502100            MOVE              A0,X:<NUM_BLOCKS        ; Number (upper) of small blocks at end
1682      P:00043A P:00043A 200013            CLR     A                                 ; being safe (?)
1683      P:00043B P:00043B 50A000            MOVE              X:<NUM_PIX,A0           ; being safe (?)
1684      P:00043C P:00043C 000000            NOP
1685      P:00043D P:00043D 0C1C0A            ASR     #5,A,A
1686      P:00043E P:00043E 46F400            MOVE              #>16,Y0
                            000010
1687      P:000440 P:000440 210700            MOVE              A0,Y1
1688      P:000441 P:000441 2000B0            MPY     Y0,Y1,A
1689      P:000442 P:000442 000000            NOP
1690      P:000443 P:000443 210600            MOVE              A0,Y0
1691      P:000444 P:000444 56A000            MOVE              X:<NUM_PIX,A            ; LAST_BIT = NUM_PIX - INT(NUMPIX*32)
1692      P:000445 P:000445 200054            SUB     Y0,A
1693      P:000446 P:000446 000000            NOP
1694      P:000447 P:000447 542200            MOVE              A1,X:<LAST_BIT          ; # of pixels in the last little bit
1695   
1696                                ; Prepare the HI32 DPMC and DPAR address registers
1697      P:000448 P:000448 549A00            MOVE              X:<PCI_ADDR_1,A1        ; Current PCI address
1698      P:000449 P:000449 509B00            MOVE              X:<PCI_ADDR_0,A0
1699      P:00044A P:00044A 0C1D10            ASL     #8,A,A
1700      P:00044B P:00044B 000000            NOP
1701      P:00044C P:00044C 0140C2            ORI     #$0F0000,A                        ; Burst length = # of PCI writes (!!!)
                            0F0000
1702      P:00044E P:00044E 000000            NOP                                       ;   = # of pixels / 2 - 1
1703      P:00044F P:00044F 547000            MOVE              A1,X:DPMC               ; DPMC = B[31:16] + $070000
                            FFFFC7
1704      P:000451 P:000451 0C1D20            ASL     #16,A,A                           ; Get PCI_ADDR[15:0] into A1[15:0]
1705      P:000452 P:000452 000000            NOP
1706      P:000453 P:000453 0140C6            AND     #$00FFFF,A
                            00FFFF
1707      P:000455 P:000455 000000            NOP
1708      P:000456 P:000456 0140C2            OR      #$070000,A                        ; A1 will get written to DPAR register
                            070000
1709   
1710                                ; Write the image pixels from FIFO to PCI bus one 32 pixel block at a time
1711      P:000458 P:000458 60F400            MOVE              #IMAGE_BUFER,R0
                            000000
1712      P:00045A P:00045A 221100            MOVE              R0,R1
1713      P:00045B P:00045B 08F4AE            MOVEP             #DTXM,X:DDR0            ; Destination = PCI master transmitter
                            FFFFCC
1714      P:00045D P:00045D 08F4AD            MOVEP             #>31,X:DCO0             ; DMA Count = # of pixels - 1 (!!!)
                            00001F
1715      P:00045F P:00045F 08D02F            MOVEP             R0,X:DSR0               ; Source address for DMA = pixel data
1716   
1717      P:000460 P:000460 062100            DO      X:<NUM_BLOCKS,L_SMALL_BLOCKS
                            00048B
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 32



1718      P:000462 P:000462 20001B            CLR     B
1719      P:000463 P:000463 55A100            MOVE              X:<NUM_BLOCKS,B1
1720      P:000464 P:000464 000000            NOP
1721      P:000465 P:000465 01418C            SUB     #$1,B
1722      P:000466 P:000466 000000            NOP
1723      P:000467 P:000467 552100            MOVE              B1,X:<NUM_BLOCKS        ; Decrement block count
1724      P:000468 P:000468 20000B            TST     B
1725      P:000469 P:000469 0AF0A7            JGT     LGBLK
                            000470
1726      P:00046B P:00046B 55A200            MOVE              X:<LAST_BIT,B1          ; this last block is small
1727      P:00046C P:00046C 000000            NOP
1728      P:00046D P:00046D 20000B            TST     B
1729      P:00046E P:00046E 0AF0A7            JGT     SMFIFO                            ; unless LAST_BIT is 0
                            000472
1730                                LGBLK
1731      P:000470 P:000470 2D2000            MOVE              #32,B1
1732      P:000471 P:000471 000000            NOP
1733                                SMFIFO                                              ; copy pixels from fiber to Y: area
1734   
1735      P:000472 P:000472 06CD00            DO      B1,S_BUFFER
                            000477
1736      P:000474 P:000474 01AD80            JCLR    #EF,X:PDRD,*                      ; Wait for the pixel datum to be there
                            000474
1737      P:000476 P:000476 000000            NOP                                       ; Settling time
1738      P:000477 P:000477 0958FF            MOVEP             Y:RDFIFO,Y:(R0)+
1739                                S_BUFFER
1740   
1741      P:000478 P:000478 0A862E  AGAIN1    BSET    #CLRT,X:DPCR                      ; Clear the master transmitter FIFO
1742      P:000479 P:000479 0A86AE            JSET    #CLRT,X:DPCR,*                    ; Wait for the clearing to be complete
                            000479
1743      P:00047B P:00047B 08F4AC            MOVEP             #$8EFA51,X:DCR0         ; Start DMA with control register DE=1
                            8EFA51
1744      P:00047D P:00047D 08CC08            MOVEP             A1,X:DPAR               ; Initiate writing to the PCI bus
1745      P:00047E P:00047E 000000            NOP
1746      P:00047F P:00047F 000000            NOP
1747      P:000480 P:000480 0A8A84            JCLR    #MARQ,X:DPSR,*                    ; Wait until the PCI operation is done
                            000480
1748      P:000482 P:000482 0A8AAE            JSET    #MDT,X:DPSR,WR_OK1                ; If no error go to the next sub-block
                            000489
1749      P:000484 P:000484 55B800            MOVE              X:<PCI_LSTERRS,B1
1750      P:000485 P:000485 014188            ADD     #$1,B
1751      P:000486 P:000486 000000            NOP
1752      P:000487 P:000487 553800            MOVE              B1,X:<PCI_LSTERRS
1753      P:000488 P:000488 0D0514            JSR     <PCI_ERROR_RECOVERY
1754      P:000489 P:000489 0140C0  WR_OK1    ADD     #>64,A                            ; PCI address = + 2 x # of pixels (!!!)
                            000040
1755      P:00048B P:00048B 221100            MOVE              R0,R1
1756                                L_SMALL_BLOCKS
1757      P:00048C P:00048C 0C04C3            JMP     <ALLDONE
1758   
1759                                ; (c) Write the pixels left over from the last 32 pixel block
1760      P:00048D P:00048D 57A200            MOVE              X:<LAST_BIT,B           ; Skip over this if there are no
1761      P:00048E P:00048E 20000B            TST     B                                 ;   pixels left to write to the PCI bus
1762      P:00048F P:00048F 0EF4C3            JLE     <ALLDONE
1763      P:000490 P:000490 57F000            MOVE              X:DPMC,B                ; Burst length = 0
                            FFFFC7
1764      P:000492 P:000492 0140CE            AND     #$FFFF,B
                            00FFFF
1765      P:000494 P:000494 557000            MOVE              B1,X:DPMC
                            FFFFC7
1766      P:000496 P:000496 57A200            MOVE              X:<LAST_BIT,B
1767      P:000497 P:000497 20002B            LSR     B
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 33



1768      P:000498 P:000498 000000            NOP
1769      P:000499 P:000499 06CD00            DO      B1,L_BIT
                            0004AF
1770      P:00049B P:00049B 01AD80            JCLR    #EF,X:PDRD,*
                            00049B
1771      P:00049D P:00049D 4CE600            MOVE                          Y:(R6),X0
1772      P:00049E P:00049E 447000            MOVE              X0,X:DTXM
                            FFFFCC
1773      P:0004A0 P:0004A0 01AD80            JCLR    #EF,X:PDRD,*
                            0004A0
1774      P:0004A2 P:0004A2 4CE600            MOVE                          Y:(R6),X0
1775      P:0004A3 P:0004A3 447000            MOVE              X0,X:DTXM
                            FFFFCC
1776   
1777      P:0004A5 P:0004A5 08CC08  AGAIN2    MOVEP             A1,X:DPAR               ; Write to PCI bus
1778      P:0004A6 P:0004A6 000000            NOP                                       ; Pipeline delay
1779      P:0004A7 P:0004A7 000000            NOP
1780      P:0004A8 P:0004A8 0A8A84            JCLR    #MARQ,X:DPSR,*                    ; Bit is clear if PCI is still active
                            0004A8
1781      P:0004AA P:0004AA 0A8AAE            JSET    #MDT,X:DPSR,DONE2                 ; If no error then we're all done
                            0004AD
1782                                ;       JSR     <PCI_ERROR_RECOVERY
1783      P:0004AC P:0004AC 0C04A5            JMP     <AGAIN2
1784      P:0004AD P:0004AD 0140C0  DONE2     ADD     #>4,A                             ; Two bytes per PCI write
                            000004
1785      P:0004AF P:0004AF 000000            NOP
1786                                L_BIT
1787   
1788                                ; (d) If the number of pixels in the image is odd write the very last pixel
1789      P:0004B0 P:0004B0 0A2280            JCLR    #0,X:<LAST_BIT,ALLDONE            ; All done if even number of pixels
                            0004C3
1790      P:0004B2 P:0004B2 01AD80            JCLR    #EF,X:PDRD,*
                            0004B2
1791      P:0004B4 P:0004B4 4CE600            MOVE                          Y:(R6),X0
1792      P:0004B5 P:0004B5 447000            MOVE              X0,X:DTXM
                            FFFFCC
1793      P:0004B7 P:0004B7 240000            MOVE              #0,X0
1794      P:0004B8 P:0004B8 447000            MOVE              X0,X:DTXM
                            FFFFCC
1795      P:0004BA P:0004BA 08CC08  AGAIN3    MOVEP             A1,X:DPAR               ; Write to PCI bus
1796      P:0004BB P:0004BB 000000            NOP                                       ; Pipeline delay
1797      P:0004BC P:0004BC 000000            NOP
1798      P:0004BD P:0004BD 0A8A84            JCLR    #MARQ,X:DPSR,*                    ; Bit is clear if PCI is still active
                            0004BD
1799      P:0004BF P:0004BF 0A8AAE            JSET    #MDT,X:DPSR,ALLDONE               ; If no error then we're all done
                            0004C3
1800                                ;       JSR     <PCI_ERROR_RECOVERY
1801      P:0004C1 P:0004C1 0C04BA            JMP     <AGAIN3
1802      P:0004C2 P:0004C2 0C04C3            JMP     <ALLDONE
1803   
1804   
1805                                ; Calculate and store the PCI address where image data is being written to
1806                                ALLDONE
1807      P:0004C3 P:0004C3 549A00            MOVE              X:<PCI_ADDR_1,A1        ; Current PCI address
1808      P:0004C4 P:0004C4 509B00            MOVE              X:<PCI_ADDR_0,A0
1809      P:0004C5 P:0004C5 44A000            MOVE              X:<NUM_PIX,X0           ; Add the byte increment = NUM_PIX * 2
1810      P:0004C6 P:0004C6 250000            MOVE              #0,X1
1811      P:0004C7 P:0004C7 200020            ADD     X,A
1812      P:0004C8 P:0004C8 200020            ADD     X,A
1813      P:0004C9 P:0004C9 000000            NOP
1814      P:0004CA P:0004CA 541A00            MOVE              A1,X:<PCI_ADDR_1        ; Incremented current PCI address
1815      P:0004CB P:0004CB 501B00            MOVE              A0,X:<PCI_ADDR_0
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 34



1816      P:0004CC P:0004CC 0D04E1            JSR     <C_RPXLS                          ; Calculate number of pixels read
1817   
1818                                ; see how many extra pixels need to be tossed
1819      P:0004CD P:0004CD 200013            CLR     A
1820      P:0004CE P:0004CE 01AD80            JCLR    #EF,X:PDRD,TOSS2                  ; Test for incoming FIFO data
                            0004D6
1821      P:0004D0 P:0004D0 0140C0  TOSS1     ADD     #>1,A
                            000001
1822      P:0004D2 P:0004D2 09443F            MOVEP             Y:RDFIFO,X0             ; Read the FIFO until its empty
1823      P:0004D3 P:0004D3 000000            NOP
1824      P:0004D4 P:0004D4 01ADA0            JSET    #EF,X:PDRD,TOSS1
                            0004D0
1825      P:0004D6 P:0004D6 066089  TOSS2     DO      #2400,TOSS3                       ; Wait for about 30 microsec in case
                            0004D8
1826      P:0004D8 P:0004D8 000000            NOP                                       ;   FIFO data is still arriving
1827      P:0004D9 P:0004D9 01ADA0  TOSS3     JSET    #EF,X:PDRD,TOSS1                  ; Keep emptying if more data arrived
                            0004D0
1828      P:0004DB P:0004DB 543900            MOVE              A1,X:<TOSS_PIXELS
1829   
1830      P:0004DC P:0004DC 448600            MOVE              X:<FLAG_DONE,X0
1831      P:0004DD P:0004DD 441D00            MOVE              X0,X:<HOST_FLAG
1832      P:0004DE P:0004DE 0D01B7            JSR     <FO_WRITE_HOST_FLAG               ; Clear Host Flag to 'DONE'
1833      P:0004DF P:0004DF 0A8520            BSET    #HCIE,X:DCTR                      ; Enable host command interrupts
1834      P:0004E0 P:0004E0 0C0127            JMP     <GET_FO                           ; We're all done, go process FO input
1835   
1836                                ; R_PXLS is the number of pixels read out since the last IIA command
1837                                ; in non-wrap mode. In wrap mode it represents the position of the FILL
1838                                ; ptr in the low order 26 bits, and the number of times the fill ptr has
1839                                ; wrapped, modulo 6 in the upper 6.
1840                                ;
1841                                ; C_RPXLS looks for a non-zero PCI_BUFSIZE to signal wrap mode-
1842                                ; and also where to wrap.
1843                                C_RPXLS
1844                                                                                    ; safe copy of R_PXLS_
1845      P:0004E1 P:0004E1 67F400            MOVE              #RPXLS_SAFE,R7
                            0007E0
1846      P:0004E3 P:0004E3 519900            MOVE              X:<R_PXLS_0,B0
1847      P:0004E4 P:0004E4 200013            CLR     A
1848      P:0004E5 P:0004E5 595F00            MOVE                          B0,Y:(R7)+
1849      P:0004E6 P:0004E6 519800            MOVE              X:<R_PXLS_1,B0
1850      P:0004E7 P:0004E7 47B700            MOVE              X:<PCI_BUFSIZE_1,Y1
1851      P:0004E8 P:0004E8 595F00            MOVE                          B0,Y:(R7)+
1852      P:0004E9 P:0004E9 20001B            CLR     B
1853      P:0004EA P:0004EA 0A3E20            BSET    #0,X:<R_PXLS_CRIT                 ; unsafe if R_PXLS_1,2 locs in xsition
1854   
1855      P:0004EB P:0004EB 51B600            MOVE              X:<PCI_BUFSIZE_0,B0
1856      P:0004EC P:0004EC 0C1971            INSERT  #$10010,Y1,B
                            010010
1857      P:0004EE P:0004EE 469200            MOVE              X:<BASE_ADDR_0,Y0       ; BASE_ADDR is 2 x 16-bits
1858      P:0004EF P:0004EF 479100            MOVE              X:<BASE_ADDR_1,Y1
1859      P:0004F0 P:0004F0 549A00            MOVE              X:<PCI_ADDR_1,A1        ; Current PCI address
1860      P:0004F1 P:0004F1 509B00            MOVE              X:<PCI_ADDR_0,A0
1861      P:0004F2 P:0004F2 200034            SUB     Y,A                               ; Current (PCI - BASE) address
1862      P:0004F3 P:0004F3 200022            ASR     A                                 ; /2 => convert byte address to pixel
1863      P:0004F4 P:0004F4 01408D            CMP     #$0000,B
1864      P:0004F5 P:0004F5 0AF0AA            JEQ     RPXLS_NOWRAP                      ; wrap is moot if bufsize 0.
                            000501
1865      P:0004F7 P:0004F7 20000D            CMP     A,B
1866      P:0004F8 P:0004F8 0AF0A7            JGT     RPXLS_NOWRAP                      ; wrap didn't happen
                            000501
1867      P:0004FA P:0004FA 200014            SUB     B,A
1868      P:0004FB P:0004FB 461B00            MOVE              Y0,X:<PCI_ADDR_0        ; reset pci address to base at wrap.
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 35



1869                                ; need to increment the fill wrap counter here.
1870      P:0004FC P:0004FC 559800            MOVE              X:<R_PXLS_1,B1
1871      P:0004FD P:0004FD 0140C8            ADD     #$400,B                           ; incr bit 26
                            000400
1872      P:0004FF P:0004FF 471A00            MOVE              Y1,X:<PCI_ADDR_1        ; reset pci address to base at wrap.
1873      P:000500 P:000500 551800            MOVE              B1,X:<R_PXLS_1
1874                                RPXLS_NOWRAP
1875      P:000501 P:000501 501900            MOVE              A0,X:<R_PXLS_0          ; R_PXLS is 2 x 16 bits, number of
1876      P:000502 P:000502 519800            MOVE              X:<R_PXLS_1,B0
1877      P:000503 P:000503 0C1880            EXTRACTU #$00A010,A,A                     ;   hi order 10 bits of fill pixels.
                            00A010
1878      P:000505 P:000505 0C1891            EXTRACTU #$00600A,B,B                     ;   preserve wrap counter for fill.
                            00600A
1879      P:000507 P:000507 0C1D95            ASL     #$A,B,B
1880      P:000508 P:000508 200010            ADD     B,A
1881      P:000509 P:000509 000000            NOP
1882      P:00050A P:00050A 501800            MOVE              A0,X:<R_PXLS_1
1883      P:00050B P:00050B 0A3E00            BCLR    #0,X:<R_PXLS_CRIT                 ; safe if these two locs not in xsition
1884      P:00050C P:00050C 0A3E81            JCLR    #1,X:<R_PXLS_CRIT,NORACE
                            000513
1885      P:00050E P:00050E 55BF00            MOVE              X:<R_PXLS_RACE,B1       ; increment race counter
1886      P:00050F P:00050F 014188            ADD     #$1,B
1887      P:000510 P:000510 000000            NOP
1888      P:000511 P:000511 553F00            MOVE              B1,X:<R_PXLS_RACE
1889      P:000512 P:000512 0A3E01            BCLR    #1,X:<R_PXLS_CRIT
1890                                NORACE
1891   
1892      P:000513 P:000513 00000C            RTS
1893   
1894                                ; Recover from an error writing to the PCI bus. Trashes B register.
1895                                ; All it does now is clear error bit in DPSR and log/record event.
1896                                ; The PCI_BURST_NO must fit in 16 bits. (8 Mpix with 128 pixel burst)
1897                                PCI_ERROR_RECOVERY
1898      P:000514 P:000514 55A700            MOVE              X:<PCI_ERRS,B1
1899      P:000515 P:000515 014188            ADD     #$1,B
1900      P:000516 P:000516 000000            NOP
1901      P:000517 P:000517 552700            MOVE              B1,X:<PCI_ERRS
1902      P:000518 P:000518 20001B            CLR     B
1903      P:000519 P:000519 57A900            MOVE              X:<PCI_ERRLOG,B
1904      P:00051A P:00051A 0140CD            CMP     #PCI_ERRMAGIC,B
                            FEEDEE
1905      P:00051C P:00051C 0AF0A2            JNE     WR_ERR
                            000530
1906      P:00051E P:00051E 20001B            CLR     B
1907      P:00051F P:00051F 08490A            MOVEP             X:DPSR,B0
1908      P:000520 P:000520 000000            NOP
1909      P:000521 P:000521 0C1891            EXTRACTU #$08005,B,B
                            008005
1910      P:000523 P:000523 212700            MOVE              B0,Y1
1911      P:000524 P:000524 55A800            MOVE              X:<PCI_BURST_NO,B1
1912      P:000525 P:000525 0C1971            INSERT  #$08028,Y1,B
                            008028
1913      P:000527 P:000527 5D5A00            MOVE                          B1,Y:(R2)+  ; log this one to error buf.
1914      P:000528 P:000528 20001B            CLR     B
1915      P:000529 P:000529 224D00            MOVE              R2,B1
1916      P:00052A P:00052A 0140CC            SUB     #PCI_ERRLOGLAST,B
                            000464
1917      P:00052C P:00052C 0AF0AF            JLE     CLEAR_EBITS
                            000530
1918      P:00052E P:00052E 62F400            MOVE              #PCI_ERRLOGFIRST,R2     ; error buffer ptr overflowed
                            000400
1919                                CLEAR_EBITS
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 36



1920                                ; Write the remaining pixels of the DMA block on a retry error
1921                                WR_ERR
1922   
1923                                ; Save DPMC and DPAR for later use
1924      P:000530 P:000530 087087            MOVEP             X:DPMC,X:SV_DPMC        ; These registers are changed here,
                            000023
1925      P:000532 P:000532 542500            MOVE              A1,X:<SV_A1             ;   so save and restore them
1926   
1927                                WR_ERR_AGAIN
1928      P:000533 P:000533 084E0A            MOVEP             X:DPSR,A                ; Get Remaining Data count bits[21:16]
1929      P:000534 P:000534 0C1EE0            LSR     #16,A                             ; Put RDC field in A1
1930      P:000535 P:000535 0A8A8F            JCLR    #RDCQ,X:DPSR,*+3
                            000538
1931      P:000537 P:000537 014180            ADD     #1,A                              ; Add one if RDCQ is set
1932      P:000538 P:000538 000000            NOP
1933      P:000539 P:000539 218700            MOVE              A1,Y1                   ; Save Y1 = # of PCI words remaining
1934   
1935                                ; Compute number of bytes completed, using previous DPMC burst length
1936      P:00053A P:00053A 084E07            MOVEP             X:DPMC,A
1937      P:00053B P:00053B 0140C6            ANDI    #$3F0000,A
                            3F0000
1938      P:00053D P:00053D 0C1EE0            LSR     #16,A
1939      P:00053E P:00053E 200074            SUB     Y1,A                              ; A1 = # of PCI writes completed
1940      P:00053F P:00053F 0C1E84            LSL     #2,A                              ; Convert to a byte address
1941      P:000540 P:000540 000000            NOP
1942      P:000541 P:000541 218600            MOVE              A1,Y0                   ; Byte address of # completed
1943   
1944      P:000542 P:000542 084E08            MOVEP             X:DPAR,A                ; Save Y0 = DPAR + # of bytes completed
1945      P:000543 P:000543 200050            ADD     Y0,A
1946      P:000544 P:000544 000000            NOP
1947      P:000545 P:000545 218600            MOVE              A1,Y0                   ; New DPAR value
1948   
1949                                ; Write the new burst length to the X:DPMC register
1950      P:000546 P:000546 084E07            MOVEP             X:DPMC,A
1951      P:000547 P:000547 0C1970            INSERT  #$006028,Y1,A                     ; Y1 = new burst length
                            006028
1952      P:000549 P:000549 000000            NOP
1953      P:00054A P:00054A 08CC07            MOVEP             A1,X:DPMC               ; Update DPMC burst length
1954   
1955                                ; Clear all error condition and initiate the PCI writing
1956      P:00054B P:00054B 084F0A            MOVEP             X:DPSR,B
1957      P:00054C P:00054C 0140CA            OR      #$1FE,B
                            0001FE
1958      P:00054E P:00054E 000000            NOP
1959      P:00054F P:00054F 08CF0A            MOVEP             B,X:DPSR
1960      P:000550 P:000550 08C608            MOVEP             Y0,X:DPAR               ; Initiate writing to the PCI bus
1961      P:000551 P:000551 000000            NOP
1962      P:000552 P:000552 000000            NOP
1963      P:000553 P:000553 0A8A84            JCLR    #MARQ,X:DPSR,*                    ; Test for PCI operation completion
                            000553
1964      P:000555 P:000555 0A8AAE            JSET    #MDT,X:DPSR,WR_ERR_OK             ; Test for Master Data Transfer complete
                            000558
1965      P:000557 P:000557 0C0533            JMP     <WR_ERR_AGAIN
1966                                WR_ERR_OK
1967      P:000558 P:000558 08F087            MOVEP             X:SV_DPMC,X:DPMC        ; Restore these two registers
                            000023
1968      P:00055A P:00055A 54A500            MOVE              X:<SV_A1,A1
1969      P:00055B P:00055B 00000C            RTS
1970   
1971                                ; ***** Test Data Link, Read Memory and Write Memory Commands ******
1972   
1973                                ; Test the data link by echoing back ARG1
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 37



1974                                TEST_DATA_LINK
1975      P:00055C P:00055C 44B200            MOVE              X:<ARG1,X0
1976      P:00055D P:00055D 0C05D2            JMP     <FINISH1
1977   
1978                                ; Read from PCI memory. The address is masked to 16 bits, so only
1979                                ;   the bottom 64k words of DRAM will be accessed.
1980                                READ_MEMORY
1981      P:00055E P:00055E 56B200            MOVE              X:<ARG1,A               ; Get the address in an accumulator
1982      P:00055F P:00055F 0140C6            AND     #$FFFF,A                          ; Mask off only 16 address bits
                            00FFFF
1983      P:000561 P:000561 219000            MOVE              A1,R0                   ; Get the address in an address register
1984      P:000562 P:000562 56B200            MOVE              X:<ARG1,A               ; Get the address in an accumulator
1985      P:000563 P:000563 000000            NOP
1986      P:000564 P:000564 0ACE14            JCLR    #20,A,RDX                         ; Test address bit for Program memory
                            000568
1987      P:000566 P:000566 07E084            MOVE              P:(R0),X0               ; Read from Program Memory
1988      P:000567 P:000567 0C05D2            JMP     <FINISH1                          ; Send out a header with the value
1989      P:000568 P:000568 0ACE15  RDX       JCLR    #21,A,RDY                         ; Test address bit for X: memory
                            00056C
1990      P:00056A P:00056A 44E000            MOVE              X:(R0),X0               ; Write to X data memory
1991      P:00056B P:00056B 0C05D2            JMP     <FINISH1                          ; Send out a header with the value
1992      P:00056C P:00056C 0ACE16  RDY       JCLR    #22,A,RDR                         ; Test address bit for Y: memory
                            000570
1993      P:00056E P:00056E 4CE000            MOVE                          Y:(R0),X0   ; Read from Y data memory
1994      P:00056F P:00056F 0C05D2            JMP     <FINISH1                          ; Send out a header with the value
1995      P:000570 P:000570 0ACE17  RDR       JCLR    #23,A,ERROR                       ; Test address bit for read from EEPROM memo
ry
                            0005D6
1996   
1997                                ; Read the word from the PCI board EEPROM
1998      P:000572 P:000572 08F4BB            MOVEP             #$0202A0,X:BCR          ; Bus Control Register for slow EEPROM
                            0202A0
1999      P:000574 P:000574 458300            MOVE              X:<THREE,X1             ; Convert to word address to a byte address
2000      P:000575 P:000575 220400            MOVE              R0,X0                   ; Get 16-bit address in a data register
2001      P:000576 P:000576 2000A0            MPY     X1,X0,A                           ; Multiply
2002      P:000577 P:000577 200022            ASR     A                                 ; Eliminate zero fill of fractional multiply
2003      P:000578 P:000578 211000            MOVE              A0,R0                   ; Need to address memory
2004      P:000579 P:000579 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
2005      P:00057A P:00057A 060380            DO      #3,L1RDR
                            00057E
2006      P:00057C P:00057C 07D88A            MOVE              P:(R0)+,A2              ; Read each ROM byte
2007      P:00057D P:00057D 0C1C10            ASR     #8,A,A                            ; Move right into A1
2008      P:00057E P:00057E 000000            NOP
2009                                L1RDR
2010      P:00057F P:00057F 218400            MOVE              A1,X0                   ; Prepare for FINISH1
2011      P:000580 P:000580 08F4BB            MOVEP             #$020021,X:BCR          ; Restore fast FIFO access
                            020021
2012      P:000582 P:000582 0C05D2            JMP     <FINISH1
2013   
2014   
2015                                ; Program WRMEM - write to PCI memory, reply = DONE host flags. The address is
2016                                ;  masked to 16 bits, so only the bottom 64k words of DRAM will be accessed.
2017                                WRITE_MEMORY
2018      P:000583 P:000583 56B200            MOVE              X:<ARG1,A               ; Get the address in an accumulator
2019      P:000584 P:000584 0140C6            AND     #$FFFF,A                          ; Mask off only 16 address bits
                            00FFFF
2020      P:000586 P:000586 219000            MOVE              A1,R0                   ; Get the address in an address register
2021      P:000587 P:000587 56B200            MOVE              X:<ARG1,A               ; Get the address in an accumulator
2022      P:000588 P:000588 44B300            MOVE              X:<ARG2,X0              ; Get the data to be written
2023      P:000589 P:000589 0ACE14            JCLR    #20,A,WRX                         ; Test address bit for Program memory
                            00058D
2024      P:00058B P:00058B 076084            MOVE              X0,P:(R0)               ; Write to Program memory
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 38



2025      P:00058C P:00058C 0C05CF            JMP     <FINISH
2026      P:00058D P:00058D 0ACE15  WRX       JCLR    #21,A,WRY                         ; Test address bit for X: memory
                            000591
2027      P:00058F P:00058F 446000            MOVE              X0,X:(R0)               ; Write to X: memory
2028      P:000590 P:000590 0C05CF            JMP     <FINISH
2029      P:000591 P:000591 0ACE16  WRY       JCLR    #22,A,WRR                         ; Test address bit for Y: memory
                            000595
2030      P:000593 P:000593 4C6000            MOVE                          X0,Y:(R0)   ; Write to Y: memory
2031      P:000594 P:000594 0C05CF            JMP     <FINISH
2032      P:000595 P:000595 0ACE17  WRR       JCLR    #23,A,ERROR                       ; Test address bit for write to EEPROM
                            0005D6
2033   
2034                                ; Write the word to the on-board PCI EEPROM
2035      P:000597 P:000597 08F4BB            MOVEP             #$0202A0,X:BCR          ; Bus Control Register for slow EEPROM
                            0202A0
2036      P:000599 P:000599 458300            MOVE              X:<THREE,X1             ; Convert to word address to a byte address
2037      P:00059A P:00059A 220400            MOVE              R0,X0                   ; Get 16-bit address in a data register
2038      P:00059B P:00059B 2000A0            MPY     X1,X0,A                           ; Multiply
2039      P:00059C P:00059C 200022            ASR     A                                 ; Eliminate zero fill of fractional multiply
2040      P:00059D P:00059D 211000            MOVE              A0,R0                   ; Need to address memory
2041      P:00059E P:00059E 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
2042      P:00059F P:00059F 56B300            MOVE              X:<ARG2,A               ; Get the data to be written, again
2043      P:0005A0 P:0005A0 060380            DO      #3,L1WRR                          ; Loop over three bytes of the word
                            0005A9
2044      P:0005A2 P:0005A2 07588C            MOVE              A1,P:(R0)+              ; Write each EEPROM byte
2045      P:0005A3 P:0005A3 0C1C10            ASR     #8,A,A                            ; Move right one byte
2046      P:0005A4 P:0005A4 44F400            MOVE              #1000000,X0
                            0F4240
2047      P:0005A6 P:0005A6 06C400            DO      X0,L2WRR                          ; Delay by 10 millisec for EEPROM write
                            0005A8
2048      P:0005A8 P:0005A8 000000            NOP
2049                                L2WRR
2050      P:0005A9 P:0005A9 000000            NOP                                       ; DO loop nesting restriction
2051                                L1WRR
2052      P:0005AA P:0005AA 08F4BB            MOVEP             #$020021,X:BCR          ; Restore fast FIFO access
                            020021
2053      P:0005AC P:0005AC 0C05CF            JMP     <FINISH
2054   
2055   
2056   
2057   
2058                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
2059                                ; save timer values in Y memory communications area
2060                                GET_TICK
2061      P:0005AD P:0005AD 67F400            MOVE              #PCI_YCOMM,R7
                            0007D0
2062      P:0005AF P:0005AF 000000            NOP
2063      P:0005B0 P:0005B0 000000            NOP
2064      P:0005B1 P:0005B1 075F48            MOVEP             X:TCR1,Y:(R7)+
2065      P:0005B2 P:0005B2 000000            NOP
2066      P:0005B3 P:0005B3 07674C            MOVEP             X:TCR0,Y:(R7)
2067      P:0005B4 P:0005B4 0C05CF            JMP     <FINISH
2068                                          ENDIF
2069   
2070                                ; return information fields from a pseudo address space.
2071                                GET_INFO
2072      P:0005B5 P:0005B5 56B200            MOVE              X:<ARG1,A               ; Get the address in an accumulator
2073      P:0005B6 P:0005B6 44F400            MOVE              #IVERSION,X0
                            0471C5
2074      P:0005B8 P:0005B8 014085            CMP     #GET_VERSION,A
2075      P:0005B9 P:0005B9 0EA5D2            JEQ     <FINISH1                          ; Is it Version?
2076      P:0005BA P:0005BA 44F400            MOVE              #IFLAVOR,X0
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 39



                            202020
2077      P:0005BC P:0005BC 014185            CMP     #GET_FLAVOR,A
2078      P:0005BD P:0005BD 0EA5D2            JEQ     <FINISH1                          ; Is it Flavor?
2079      P:0005BE P:0005BE 44F400            MOVE              #ITIME0,X0
                            001C21
2080      P:0005C0 P:0005C0 014285            CMP     #GET_TIME0,A
2081      P:0005C1 P:0005C1 0EA5D2            JEQ     <FINISH1                          ; Is it Time0?
2082      P:0005C2 P:0005C2 44F400            MOVE              #ITIME1,X0
                            004D69
2083      P:0005C4 P:0005C4 014385            CMP     #GET_TIME1,A
2084      P:0005C5 P:0005C5 0EA5D2            JEQ     <FINISH1                          ; Is it Time1?
2085      P:0005C6 P:0005C6 240000            MOVE              #ISVNREV,X0
2086      P:0005C7 P:0005C7 014485            CMP     #GET_SVNREV,A
2087      P:0005C8 P:0005C8 0EA5D2            JEQ     <FINISH1                          ; Is it Svn rev?
2088      P:0005C9 P:0005C9 44F400            MOVE              #>PCICAPABLE,X0
                            000007
2089      P:0005CB P:0005CB 0140C5            CMP     #GET_CAPABLE,A
                            000100
2090      P:0005CD P:0005CD 0EA5D2            JEQ     <FINISH1                          ; Is it Pci Capabilities?
2091      P:0005CE P:0005CE 0C05D6            JMP     <ERROR
2092   
2093   
2094                                ;  ***** Subroutines for generating replies to command execution ******
2095                                ; Return from the interrupt with a reply = DONE host flags
2096      P:0005CF P:0005CF 448600  FINISH    MOVE              X:<FLAG_DONE,X0         ; Flag = 1 => Normal execution
2097      P:0005D0 P:0005D0 441D00            MOVE              X0,X:<HOST_FLAG
2098      P:0005D1 P:0005D1 0C05DF            JMP     <RTI_WRITE_HOST_FLAG
2099   
2100                                ; Return from the interrupt with value in (X1,X0)
2101      P:0005D2 P:0005D2 441C00  FINISH1   MOVE              X0,X:<REPLY             ; Report value
2102      P:0005D3 P:0005D3 448700            MOVE              X:<FLAG_REPLY,X0        ; Flag = 2 => Reply with a value
2103      P:0005D4 P:0005D4 441D00            MOVE              X0,X:<HOST_FLAG
2104      P:0005D5 P:0005D5 0C05DF            JMP     <RTI_WRITE_HOST_FLAG
2105   
2106                                ; Routine for returning from the interrupt on an error
2107      P:0005D6 P:0005D6 448800  ERROR     MOVE              X:<FLAG_ERR,X0          ; Flag = 3 => Error value
2108      P:0005D7 P:0005D7 441D00            MOVE              X0,X:<HOST_FLAG
2109      P:0005D8 P:0005D8 0C05DF            JMP     <RTI_WRITE_HOST_FLAG
2110   
2111                                ; Routine for returning from the interrupt with a system reset
2112      P:0005D9 P:0005D9 448900  SYR       MOVE              X:<FLAG_SYR,X0          ; Flag = 4 => System reset
2113      P:0005DA P:0005DA 441D00            MOVE              X0,X:<HOST_FLAG
2114      P:0005DB P:0005DB 0C05DF            JMP     <RTI_WRITE_HOST_FLAG
2115   
2116                                ; Routine for returning a BUSY status from the controller
2117      P:0005DC P:0005DC 448B00  BUSY      MOVE              X:<FLAG_BUSY,X0         ; Flag = 6 => Controller is busy
2118      P:0005DD P:0005DD 441D00            MOVE              X0,X:<HOST_FLAG
2119      P:0005DE P:0005DE 0C05DF            JMP     <RTI_WRITE_HOST_FLAG
2120   
2121                                ; Write X:<HOST_FLAG to the DCTR flag bits 5,4,3, as an interrupt
2122                                RTI_WRITE_HOST_FLAG
2123      P:0005DF P:0005DF 56F000            MOVE              X:DCTR,A
                            FFFFC5
2124      P:0005E1 P:0005E1 449D00            MOVE              X:<HOST_FLAG,X0
2125      P:0005E2 P:0005E2 0140C6            AND     #$FFFFC7,A                        ; Clear bits 5,4,3
                            FFFFC7
2126      P:0005E4 P:0005E4 000000            NOP
2127      P:0005E5 P:0005E5 200042            OR      X0,A                              ; Set flags appropriately
2128      P:0005E6 P:0005E6 000000            NOP
2129      P:0005E7 P:0005E7 567000            MOVE              A,X:DCTR
                            FFFFC5
2130      P:0005E9 P:0005E9 000004            RTI
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 40



2131   
2132                                ; Put the reply value into the transmitter FIFO
2133                                READ_REPLY_VALUE
2134   
2135                                          IF      @SCP("SUPPORTED","SUPPORTED")
2136      P:0005EA P:0005EA 56BC00            MOVE              X:<PCI_HISTON,A
2137      P:0005EB P:0005EB 200003            TST     A
2138      P:0005EC P:0005EC 0AF0AA            JEQ     DO_REP
                            0005F7
2139      P:0005EE P:0005EE 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
2140      P:0005EF P:0005EF 000000            NOP
2141      P:0005F0 P:0005F0 64F400            MOVE              #H_RDREPLYVAL,R4        ; tag
                            525250
2142      P:0005F2 P:0005F2 6C5B00            MOVE                          R4,Y:(R3)+
2143      P:0005F3 P:0005F3 000000            NOP
2144                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
2145      P:0005F4 P:0005F4 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
2146      P:0005F5 P:0005F5 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
2147                                          ENDIF
2148      P:0005F6 P:0005F6 633B00            MOVE              R3,X:<PCI_HISTFILL
2149                                DO_REP
2150                                          ENDIF
2151   
2152                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
2153      P:0005F7 P:0005F7 08F08D            MOVEP             X:REPLY,X:DTXS          ; DSP-to-host slave transmit
                            00001C
2154      P:0005F9 P:0005F9 000004            RTI
2155   
2156                                READ_REPLY_HEADER
2157      P:0005FA P:0005FA 44B000            MOVE              X:<HEADER,X0
2158      P:0005FB P:0005FB 0C05D2            JMP     <FINISH1
2159   
2160                                ; Clear the reply flags and receiver FIFO after a successful reply transaction,
2161                                ;   but leave the Read Image flags set if the controller is reading out.
2162                                CLEAR_HOST_FLAG
2163   
2164                                          IF      @SCP("SUPPORTED","SUPPORTED")
2165      P:0005FC P:0005FC 56BC00            MOVE              X:<PCI_HISTON,A
2166      P:0005FD P:0005FD 200003            TST     A
2167      P:0005FE P:0005FE 0AF0AA            JEQ     DO_CLH
                            000609
2168      P:000600 P:000600 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
2169      P:000601 P:000601 000000            NOP
2170      P:000602 P:000602 64F400            MOVE              #H_CLEARHOSTFLG,R4      ; tag
                            434846
2171      P:000604 P:000604 6C5B00            MOVE                          R4,Y:(R3)+
2172      P:000605 P:000605 000000            NOP
2173                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
2174      P:000606 P:000606 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
2175      P:000607 P:000607 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
2176                                          ENDIF
2177      P:000608 P:000608 633B00            MOVE              R3,X:<PCI_HISTFILL
2178                                DO_CLH
2179                                          ENDIF
2180   
2181                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
2182   
2183      P:000609 P:000609 448500            MOVE              X:<FLAG_ZERO,X0
2184      P:00060A P:00060A 441D00            MOVE              X0,X:<HOST_FLAG
2185      P:00060B P:00060B 44F400            MOVE              #$FFFFC7,X0
                            FFFFC7
2186      P:00060D P:00060D 56F000            MOVE              X:DCTR,A
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 41



                            FFFFC5
2187      P:00060F P:00060F 200046            AND     X0,A
2188      P:000610 P:000610 000000            NOP
2189      P:000611 P:000611 547000            MOVE              A1,X:DCTR
                            FFFFC5
2190   
2191                                ;       the receiver clear below engendered a race condition with the
2192                                ;       host submitting the next cmd. We clear the receiver now -after-
2193                                ;       receipt of each command via WRITE-COMMAND.
2194   
2195                                ;CLR_RCV        JCLR    #SRRQ,X:DSR,CLR_RTS     ; Wait for the receiver to be empty
2196   
2197                                ;       MOVEP   X:DRXR,X0               ; Read receiver to empty it
2198   
2199                                ;       IF      @SCP("SUPPORTED","SUPPORTED")
2200                                ;       MOVE    X:<PCI_HISTON,A
2201                                ;       TST     A
2202                                ;       JEQ    DO_CLRR
2203                                ;        MOVE   X:<PCI_HISTFILL,R3              ; history buffer
2204                                ;       NOP
2205                                ;       MOVE    X0,R4                           ; tag
2206                                ;       NOP
2207                                ;       MOVE    R4,Y:(R3)+
2208                                ;       NOP
2209                                ;       IF      @SCP("SUPPORTED","SUPPORTED")   ; Hardware timer
2210                                ;        MOVEP   X:TCR0,Y:(R3)+                 ; lo order time
2211                                ;        MOVEP   X:TCR1,Y:(R3)+                 ; hi order time
2212                                ;       ENDIF
2213                                ;       MOVE   R3,X:<PCI_HISTFILL
2214                                ;DO_CLRR
2215                                ;       ENDIF
2216   
2217                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
2218   
2219                                ;       NOP                             ; Wait for flag to change
2220                                ;       JMP     <CLR_RCV
2221                                ;CLR_RTS
2222      P:000613 P:000613 000004            RTI
2223   
2224                                ; *************  Miscellaneous subroutines used everywhere  *************
2225   
2226                                ; 250 MHz code - Transmit contents of Accumulator A1 to the timing board.
2227      P:000614 P:000614 507000  XMT_WRD   MOVE              A0,X:SV_A0              ; Save registers used in XMT_WRD
                            000024
2228      P:000616 P:000616 547000            MOVE              A1,X:SV_A1
                            000025
2229      P:000618 P:000618 527000            MOVE              A2,X:SV_A2
                            000026
2230      P:00061A P:00061A 457000            MOVE              X1,X:SV_X1
                            00002B
2231      P:00061C P:00061C 447000            MOVE              X0,X:SV_X0
                            00002A
2232      P:00061E P:00061E 477000            MOVE              Y1,X:SV_Y1
                            00002D
2233      P:000620 P:000620 467000            MOVE              Y0,X:SV_Y0
                            00002C
2234      P:000622 P:000622 47F400            MOVE              #$1000AC,Y1
                            1000AC
2235      P:000624 P:000624 0C1D10            ASL     #8,A,A
2236      P:000625 P:000625 60F400            MOVE              #$FFF000,R0             ; Memory mapped address of transmitter
                            FFF000
2237      P:000627 P:000627 214600            MOVE              A2,Y0
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 42



2238      P:000628 P:000628 0C1D10            ASL     #8,A,A
2239      P:000629 P:000629 000000            NOP
2240      P:00062A P:00062A 214500            MOVE              A2,X1
2241      P:00062B P:00062B 0C1D10            ASL     #8,A,A
2242      P:00062C P:00062C 000000            NOP
2243      P:00062D P:00062D 214400            MOVE              A2,X0
2244      P:00062E P:00062E 476000            MOVE              Y1,X:(R0)               ; Header = $AC
2245      P:00062F P:00062F 466000            MOVE              Y0,X:(R0)               ; MS Byte
2246      P:000630 P:000630 456000            MOVE              X1,X:(R0)               ; Middle byte
2247      P:000631 P:000631 446000            MOVE              X0,X:(R0)               ; LS byte
2248      P:000632 P:000632 507000            MOVE              A0,X:SV_A0
                            000024
2249      P:000634 P:000634 547000            MOVE              A1,X:SV_A1
                            000025
2250      P:000636 P:000636 527000            MOVE              A2,X:SV_A2
                            000026
2251      P:000638 P:000638 45F000            MOVE              X:SV_X1,X1              ; Restore registers used here
                            00002B
2252      P:00063A P:00063A 44F000            MOVE              X:SV_X0,X0
                            00002A
2253      P:00063C P:00063C 47F000            MOVE              X:SV_Y1,Y1
                            00002D
2254      P:00063E P:00063E 46F000            MOVE              X:SV_Y0,Y0
                            00002C
2255      P:000640 P:000640 00000C            RTS
2256   
2257   
2258                                ; Read one word of the fiber optic FIFO into B1 with a timeout
2259                                RD_FO_TIMEOUT
2260      P:000641 P:000641 46F400            MOVE              #1000000,Y0             ; 13 millisecond timeout
                            0F4240
2261      P:000643 P:000643 06C600            DO      Y0,LP_TIM
                            00064D
2262      P:000645 P:000645 01AD80            JCLR    #EF,X:PDRD,NOT_YET                ; Test for new fiber optic data
                            00064D
2263      P:000647 P:000647 000000            NOP
2264      P:000648 P:000648 000000            NOP
2265      P:000649 P:000649 01AD80            JCLR    #EF,X:PDRD,NOT_YET                ; For metastability, check it twice
                            00064D
2266      P:00064B P:00064B 00008C            ENDDO
2267      P:00064C P:00064C 0C0652            JMP     <RD_FIFO                          ; Go read the FIFO word
2268      P:00064D P:00064D 000000  NOT_YET   NOP
2269      P:00064E P:00064E 000000  LP_TIM    NOP
2270      P:00064F P:00064F 0AF960            BSET    #0,SR                             ; Timeout reached, error return
2271      P:000650 P:000650 000000            NOP
2272      P:000651 P:000651 00000C            RTS
2273   
2274                                ; Read one word from the fiber optics FIFO, check it and put it in B1
2275      P:000652 P:000652 09463F  RD_FIFO   MOVEP             Y:RDFIFO,Y0             ; Read the FIFO word
2276      P:000653 P:000653 578D00            MOVE              X:<C00FF00,B            ; DMASK = $00FF00
2277      P:000654 P:000654 20005E            AND     Y0,B
2278      P:000655 P:000655 0140CD            CMP     #$00AC00,B
                            00AC00
2279      P:000657 P:000657 0EA664            JEQ     <GT_RPLY                          ; If byte equalS $AC then continue
2280      P:000658 P:000658 07F42D            MOVEP             #%011000,X:PDRD         ; Clear RS* low for 2 milliseconds
                            000018
2281      P:00065A P:00065A 47F400            MOVE              #200000,Y1
                            030D40
2282      P:00065C P:00065C 06C700            DO      Y1,*+3
                            00065E
2283      P:00065E P:00065E 000000            NOP
2284      P:00065F P:00065F 07F42D            MOVEP             #%011100,X:PDRD         ; Data Register - Set RS* high
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 43



                            00001C
2285      P:000661 P:000661 0AF960            BSET    #0,SR                             ; Set carry bit => error
2286      P:000662 P:000662 000000            NOP
2287      P:000663 P:000663 00000C            RTS
2288   
2289      P:000664 P:000664 20CF00  GT_RPLY   MOVE              Y0,B
2290      P:000665 P:000665 0C1EA1            LSL     #16,B                             ; Shift byte in D7-D0 to D23-D16
2291      P:000666 P:000666 000000            NOP
2292      P:000667 P:000667 21A700            MOVE              B1,Y1
2293      P:000668 P:000668 4EF000            MOVE                          Y:RDFIFO,Y0 ; Read the FIFO word
                            FFFFFF
2294      P:00066A P:00066A 57F400            MOVE              #$00FFFF,B
                            00FFFF
2295      P:00066C P:00066C 20005E            AND     Y0,B                              ; Select out D15-D0
2296      P:00066D P:00066D 20007A            OR      Y1,B                              ; Add D23-D16 to D15-D0
2297      P:00066E P:00066E 000000            NOP
2298      P:00066F P:00066F 000000            NOP
2299      P:000670 P:000670 0AF940            BCLR    #0,SR                             ; Clear carry bit => no error
2300      P:000671 P:000671 000000            NOP
2301      P:000672 P:000672 00000C            RTS
2302   
2303   
2304                                ; This might work with some effort
2305                                ;GT_RPLY        MOVE    Y:RDFIFO,B              ; Read the FIFO word
2306                                ;       EXTRACTU #$010018,B,B
2307                                ;       INSERT  #$008000,Y0,B           ; Add MSB to D23-D16
2308                                ;       NOP
2309                                ;       MOVE    B0,B1
2310                                ;       NOP
2311                                ;       NOP
2312                                ;       BCLR    #0,SR                   ; Clear carry bit => no error
2313                                ;       NOP
2314                                ;       RTS
2315   
2316                                ; ************************  Test on board DRAM  ***********************
2317                                ; Test Y: memory mapped to AA0 and AA2 from $000000 to $FFFFFF (16 megapixels)
2318                                ; DRAM definitions
2319   
2320                                TEST_DRAM
2321   
2322                                ; Test Y: memory mapped to AA0 and AA2 from $000000 to $FFFFFF (16 megapixels)
2323      P:000673 P:000673 200013            CLR     A
2324      P:000674 P:000674 000000            NOP
2325      P:000675 P:000675 21D000            MOVE              A,R0
2326      P:000676 P:000676 26FF00            MOVE              #$FF0000,Y0             ; Y:$000000 to Y:$FEFFFF
2327      P:000677 P:000677 06C600            DO      Y0,L_WRITE_RAM0
                            00067B
2328      P:000679 P:000679 5C5800            MOVE                          A1,Y:(R0)+
2329      P:00067A P:00067A 014180            ADD     #1,A
2330      P:00067B P:00067B 000000            NOP
2331                                L_WRITE_RAM0
2332   
2333      P:00067C P:00067C 200013            CLR     A
2334      P:00067D P:00067D 000000            NOP
2335      P:00067E P:00067E 21D000            MOVE              A,R0
2336      P:00067F P:00067F 26FF00            MOVE              #$FF0000,Y0
2337      P:000680 P:000680 06C600            DO      Y0,L_CHECK_RAM0
                            000688
2338      P:000682 P:000682 4CD800            MOVE                          Y:(R0)+,X0
2339      P:000683 P:000683 0C1FF8            CMPU    X0,A
2340      P:000684 P:000684 0EA687            JEQ     <L_RAM4
2341      P:000685 P:000685 00008C            ENDDO
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 44



2342      P:000686 P:000686 0C06A2            JMP     <ERROR_Y
2343      P:000687 P:000687 014180  L_RAM4    ADD     #1,A
2344      P:000688 P:000688 000000            NOP
2345                                L_CHECK_RAM0
2346   
2347                                ; Test X: memory mapped to AA3 from $1000 to $7FFFFF (8 megapixels)
2348      P:000689 P:000689 200013            CLR     A
2349      P:00068A P:00068A 60F400            MOVE              #$1000,R0               ; Skip over internal X: memory
                            001000
2350      P:00068C P:00068C 46F400            MOVE              #$7FF000,Y0             ; X:$001000 to X:$7FFFFF
                            7FF000
2351      P:00068E P:00068E 06C600            DO      Y0,L_WRITE_RAM3
                            000692
2352      P:000690 P:000690 565800            MOVE              A,X:(R0)+
2353      P:000691 P:000691 014180            ADD     #1,A
2354      P:000692 P:000692 000000            NOP
2355                                L_WRITE_RAM3
2356   
2357      P:000693 P:000693 200013            CLR     A
2358      P:000694 P:000694 60F400            MOVE              #$1000,R0
                            001000
2359      P:000696 P:000696 46F400            MOVE              #$7FF000,Y0
                            7FF000
2360      P:000698 P:000698 06C600            DO      Y0,L_CHECK_RAM3
                            0006A0
2361      P:00069A P:00069A 44D800            MOVE              X:(R0)+,X0
2362      P:00069B P:00069B 0C1FF8            CMPU    X0,A
2363      P:00069C P:00069C 0EA69F            JEQ     <L_RAM5
2364      P:00069D P:00069D 00008C            ENDDO
2365      P:00069E P:00069E 0C06A7            JMP     <ERROR_X
2366      P:00069F P:00069F 014180  L_RAM5    ADD     #1,A
2367      P:0006A0 P:0006A0 000000            NOP
2368                                L_CHECK_RAM3
2369      P:0006A1 P:0006A1 0C05CF            JMP     <FINISH
2370   
2371      P:0006A2 P:0006A2 44F400  ERROR_Y   MOVE              #'__Y',X0
                            5F5F59
2372      P:0006A4 P:0006A4 440F00            MOVE              X0,X:<TRM_MEM
2373      P:0006A5 P:0006A5 601000            MOVE              R0,X:<TRM_ADR
2374      P:0006A6 P:0006A6 0C05D6            JMP     <ERROR
2375      P:0006A7 P:0006A7 44F400  ERROR_X   MOVE              #'__X',X0
                            5F5F58
2376      P:0006A9 P:0006A9 440F00            MOVE              X0,X:<TRM_MEM
2377      P:0006AA P:0006AA 601000            MOVE              R0,X:<TRM_ADR
2378      P:0006AB P:0006AB 0C05D6            JMP     <ERROR
2379   
2380                                ;  ****************  Setup memory tables in X: space ********************
2381   
2382                                ; Define the address in P: space where the table of constants begins
2383   
2384      X:000000 P:0006AC                   ORG     X:VAR_TBL,P:
2385   
2386                                ; Parameters
2387      X:000000 P:0006AC         STATUS    DC      0                                 ; Execution status bits
2388      X:000001 P:0006AD                   DC      0                                 ; Reserved
2389   
2390                                          IF      @SCP("HOST","HOST")               ; Download via host computer
2391                                 CONSTANTS_TBL_START
2392      0006AE                              EQU     @LCV(L)
2393                                          ENDIF
2394   
2395                                          IF      @SCP("HOST","ROM")                ; Boot ROM code
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 45



2397                                          ENDIF
2398   
2399                                          IF      @SCP("HOST","ONCE")               ; Download via ONCE debugger
2401                                          ENDIF
2402   
2403                                ; Parameter table in P: space to be copied into X: space during
2404                                ;   initialization, and must be copied from ROM in the boot process
2405      X:000002 P:0006AE         ONE       DC      1                                 ; One
2406      X:000003 P:0006AF         THREE     DC      3                                 ; Three
2407      X:000004 P:0006B0         FOUR      DC      4                                 ; Four
2408   
2409                                ; Host flags are bits 5,4,3 of the HSTR
2410      X:000005 P:0006B1         FLAG_ZERO DC      0                                 ; Flag = 0 => command executing
2411      X:000006 P:0006B2         FLAG_DONE DC      $000008                           ; Flag = 1 => DONE
2412      X:000007 P:0006B3         FLAG_REPLY DC     $000010                           ; Flag = 2 => reply value available
2413      X:000008 P:0006B4         FLAG_ERR  DC      $000018                           ; Flag = 3 => error
2414      X:000009 P:0006B5         FLAG_SYR  DC      $000020                           ; Flag = 4 => controller reset
2415      X:00000A P:0006B6         FLAG_RDI  DC      $000028                           ; Flag = 5 => reading out image
2416      X:00000B P:0006B7         FLAG_BUSY DC      $000030                           ; Flag = 6 => controller is busy
2417      X:00000C P:0006B8         C512      DC      512                               ; 1/2 the FIFO size
2418      X:00000D P:0006B9         C00FF00   DC      $00FF00
2419      X:00000E P:0006BA         C000202   DC      $000202                           ; Timing board header
2420      X:00000F P:0006BB         TRM_MEM   DC      0                                 ; Test DRAM, memory type of failure
2421      X:000010 P:0006BC         TRM_ADR   DC      0                                 ; Test DRAM, address of failure
2422   
2423                                ; Tack the length of the variable table onto the length of code to be booted
2424                                 CONSTANTS_TBL_LENGTH
2425      00000F                              EQU     @CVS(P,*-ONE)                     ; Length of variable table
2426   
2427                                ; Ending address of program so its length can be calculated for bootstrapping
2428                                ; The constants defined after this are NOT initialized, so need not be
2429                                ;    downloaded.
2430   
2431      0006BD                    END_ADR   EQU     @LCV(L)                           ; End address of P: code written to ROM
2432   
2433                                ; Miscellaneous variables
2434                                 BASE_ADDR_1
2435      X:000011 P:0006BD                   DC      0                                 ; Starting PCI address of image, MS byte
2436                                 BASE_ADDR_0
2437      X:000012 P:0006BE                   DC      0                                 ; Starting PCI address of image, LS 24-bits
2438      X:000013 P:0006BF         DSP_VERS  DC      VERSION                           ; code version
2439      X:000014 P:0006C0         NPXLS_1   DC      0                                 ; # of pxls in current READ_IMAGE call, MS b
yte
2440      X:000015 P:0006C1         NPXLS_0   DC      0                                 ; # of pxls in current READ_IMAGE, LS 24-bit
s
2441      X:000016 P:0006C2         IPXLS_1   DC      0                                 ; Down pixel counter in READ_IMAGE, MS byte
2442      X:000017 P:0006C3         IPXLS_0   DC      0                                 ; Down pixel counter in READ_IMAGE, 24-bits
2443      X:000018 P:0006C4         R_PXLS_1  DC      0                                 ; Up Counter of # of pixels read, MS 16-bits
2444      X:000019 P:0006C5         R_PXLS_0  DC      0                                 ; Up Counter of # of pixels read, LS 16-bits
2445      X:00001A P:0006C6         PCI_ADDR_1 DC     0                                 ; Current PCI address of image, MS byte
2446      X:00001B P:0006C7         PCI_ADDR_0 DC     0                                 ; Current PCI address of image, LS 24-bits
2447      X:00001C P:0006C8         REPLY     DC      0                                 ; Reply value
2448      X:00001D P:0006C9         HOST_FLAG DC      0                                 ; Value of host flags written to X:DCTR
2449      X:00001E P:0006CA         FO_DEST   DC      0                                 ; Whether host or PCI board receives command
2450      X:00001F P:0006CB         FO_CMD    DC      0                                 ; Fiber optic command or reply
2451      X:000020 P:0006CC         NUM_PIX   DC      0                                 ; Number of pixels in the last block
2452      X:000021 P:0006CD         NUM_BLOCKS DC     0                                 ; Number of small blocks at the end
2453      X:000022 P:0006CE         LAST_BIT  DC      0                                 ; # of pixels in the last little bit
2454      X:000023 P:0006CF         SV_DPMC   DC      0                                 ; Save register
2455      X:000024 P:0006D0         SV_A0     DC      0                                 ; Place for saving accumulator A
2456      X:000025 P:0006D1         SV_A1     DC      0                                 ; Accumulator A in interrupt service routine
2457      X:000026 P:0006D2         SV_A2     DC      0                                 ; Accumulator A in interrupt service routine
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 46



2458      X:000027 P:0006D3         PCI_ERRS  DC      0                                 ; Detected error count for pci xfer, DMA onl
y.
2459                                 PCI_BURST_NO
2460      X:000028 P:0006D4                   DC      0                                 ; count of pci bursts for an image.
2461      X:000029 P:0006D5         PCI_ERRLOG DC     0                                 ; set to PCI_ERRMAGIC to get error logging i
n Y:
2462      X:00002A P:0006D6         SV_X0     DC      0
2463      X:00002B P:0006D7         SV_X1     DC      0
2464      X:00002C P:0006D8         SV_Y0     DC      0
2465      X:00002D P:0006D9         SV_Y1     DC      0
2466   
2467   
2468   
2469                                ; Check that the parameter table is not too big
2470                                          IF      @CVS(N,*)>=ARG_TBL
2472                                          ENDIF
2473   
2474      X:000030 P:0006DA                   ORG     X:ARG_TBL,P:
2475   
2476                                ; Table that contains the header, command and its arguments
2477      X:000030 P:0006DA         HEADER    DC      0                                 ; (Source, Destination, Number of words)
2478      X:000031 P:0006DB         COMMAND   DC      0                                 ; Manual command
2479      X:000032 P:0006DC         ARG1      DC      0                                 ; First command argument
2480      X:000033 P:0006DD         ARG2      DC      0                                 ; Second command argument
2481                                 DESTINATION
2482      X:000034 P:0006DE                   DC      0                                 ; Derived from header
2483      X:000035 P:0006DF         NUM_ARG   DC      0                                 ; Derived from header
2484   
2485                                ;        ORG     X:VAR2_TBL,P:
2486   
2487                                ; If PCI_BUFSIZE_1 is set non-zero (by host) PCI_BUFSIZE* is understood to
2488                                ; be the size of the mapped dma buffer in the host, and if the dma transfer
2489                                ; for an image exceeds this size, the transfer will wrap back to the start
2490                                ; of the buffer at BASE_ADDR*. The size MUST be a multiple of 512 pixels.
2491                                ; PCI_BUFSIZE* is in units of pixels.
2492                                ;
2493                                ; The value returned by the
2494                                ; READ_NUMBER_OF_PIXELS_READ command is modified as follows: Bits 25-0 are
2495                                ; the difference between BASE_ADDR* and the next location into which data
2496                                ; will transfer, serving as a "FILL" ptr for the transfer. Bits 31-26 are
2497                                ; the low order 6 bits of the number of times the FILL has wrapped. Note that
2498                                ; if the FILL ptr does not wrap (for example, if the BUFSIZE exceeds the image
2499                                ; size) the READ_NUMBER_OF_PIXELS_READ will return the same values in either
2500                                ; mode. Ordinarily, the wrapping mode is used for continuous or effectively
2501                                ; continuous transfers in strip scan or occultation modes, and an extremely
2502                                ; large count of rows is given to the controller. The transfer ends when this
2503                                ; effective image size is exhausted or the image is aborted. The maximum image
2504                                ; size that can be handled in this way is 2**48 pixels.
2505   
2506                                 PCI_BUFSIZE_0
2507      X:000036 P:0006E0                   DC      0
2508                                 PCI_BUFSIZE_1
2509      X:000037 P:0006E1                   DC      0
2510                                 PCI_LSTERRS
2511      X:000038 P:0006E2                   DC      0                                 ; pci errors in the "last little bit"- these
 are
2512                                                                                    ; also recorded in PCI_ERRS.
2513   
2514                                 TOSS_PIXELS
2515      X:000039 P:0006E3                   DC      0                                 ; count of pixels thrown away in end of read
out,
2516      X:00003A P:0006E4         ABT_PIXELS DC     0                                 ; count of pixels thrown away in ABORT_READO
Motorola DSP56300 Assembler  Version 6.2.23   111-02-26  08:28:35  pciboot.s  Page 47



UT
2517   
2518                                          IF      @SCP("SUPPORTED","SUPPORTED")
2519                                 PCI_HISTFILL
2520      X:00003B P:0006E5                   DC      0                                 ; Current history fill ptr.
2521      X:00003C P:0006E6         PCI_HISTON DC     0                                 ; If zero all history log suppressed save NM
I.
2522                                          ENDIF
2523   
2524                                          IF      @SCP("SUPPORTED","SUPPORTED")
2525      X:00003D P:0006E7         WAIT_RDA  DC      0                                 ; time units to wait to enter rdi after RDA
2526                                          ENDIF
2527   
2528                                 R_PXLS_CRIT
2529      X:00003E P:0006E8                   DC      0                                 ; if non-zero R_PXL's are in a transitory st
ate..
2530                                 R_PXLS_RACE
2531      X:00003F P:0006E9                   DC      0                                 ; if non-zero R_PXL's are in a transitory st
ate..
2532   
2533      Y:000000 P:0006EA                   ORG     Y:0,P:
2534   
2535                                ; This must be the LAST constant definition, because it is a large table
2536                                 IMAGE_BUFER
2537      Y:000000 P:0006EA                   DC      0                                 ; Copy image data from FIFO to here
2538   
2539   
2540                                ; End of program
2541                                          END

0    Errors
0    Warnings


