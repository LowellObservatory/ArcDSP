Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  tim.s  Page 1



1                        ; This file is used to generate DSP code for the TimII second generation
2                        ;   timing board. This is Rev. 3.00 software.
3                        ;
4                        ; This file contains two subroutines and X and Y data areas.  The two
5                        ; subroutines are RDCCD (with secondary entry point RCCD1) and CLOCK.
6                        ; These need to be in fast P memory.  The boot code and tim.s are there.
7                        ; tim.s includes timmisc.s and timCCDmisc.s at the
8                        ; beginning and the waveforms file at the end in Y memory.
9      
10                                 PAGE    132                               ; Printronix page width - 132 columns
11     
12                       ; Define a section name so it doesn't conflict with other application programs
13                                 SECTION TIMEEV57
14     
15                       ; Include a header file that defines global parameters
16                                 INCLUDE "timhdr.s"
17                              COMMENT *
18     
19                       This is a header file that is shared between the fiber optic timing board
20                       boot and application code files
21                               *
22     
23                                 PAGE    132                               ; Printronix page width - 132 columns
24     
25                       ; Some basic structural definitions
26        000130         APL_ADR   EQU     $130                              ; P: memory location where application code begins
27        0000D0         APL_LEN   EQU     $200-APL_ADR                      ; Maximum length of application program
28        000030         IMGVAR_ADR EQU    $30                               ;  Special Image Mode variables Starting Address in X:
29     
30                       ; CHANGING MISC_LEN FROM 0X280 TO A LARGER NUMBER BREAKS THE ROM COPY APPROACH!
31                       ; However if all you do is download there is a lot more memory available.
32        000450         MISC_LEN  EQU     $450                              ; Maximum length of "miscellanous" code
33                       ;MISC_LEN EQU   $3F0    ; Maximum length of "miscellanous" code
34                       ; MISC_LEN EQU  $280    ; Maximum length of "miscellanous" code
35     
36        000040         COM_LEN   EQU     $40                               ; Length of memory for application commands
37        00003C         TIM_ISR   EQU     $3C                               ; DSP timer interrupt service routine address
38        00003E         PGM_CON   EQU     $3E                               ; Program continues on here
39        000080         COM_TBL   EQU     $80                               ; Starting address of command table in X: memory
40        000500         N_W_APL   EQU     $500                              ; Number of words in each application
41        000028         NUM_COM   EQU     40                                ; Number of entries in command table
42     
43        000000         RST_ISR   EQU     $00                               ; Hardware reset interrupt
44        000006         ROM_ID    EQU     $06                               ; Location of program Identification = SWI interrupt
45        000008         START     EQU     $08                               ; Starting address of program
46        000060         RCV_BUF   EQU     $60                               ; Starting address of receiver buffer in X:
47        00000F         TBL_ADR   EQU     $0F                               ; (IR) Waveform tables starting address
48     
49        004000         ROM_OFF   EQU     $4000                             ; Boot program offset address in EEPROM
50        004200         LD_X      EQU     $4200                             ; Assembler loads X: starting at this EEPROM address
51        00C600         RD_X      EQU     $C600                             ; DSP reads X: from this EEPROM address
52     
53                       ; Define DSP port addresses
54        00FF80         WRSS      EQU     $FF80                             ; Write clock driver and VP switch states
55        00FFC0         RDFO      EQU     $FFC0                             ; Read serial receiver fiber optic contents
56        00FFC0         WRFO      EQU     $FFC0                             ; Write to fiber optic serial transmitter
57        00FFA0         RDAD      EQU     $FFA0                             ; Read A/D datum into DSP
58        00FFA0         RDAD0     EQU     $FFA0                             ; Address for reading A/D #0
59        00FFA1         RDAD1     EQU     $FFA1                             ; Address for reading A/D #1
60        00FFC1         WRLATCH   EQU     $FFC1                             ; Write to timing board latch
61        006000         RSTWDT    EQU     $6000                             ; Address to reset the timing board watchdog timer
62        00FFFE         BCR       EQU     $FFFE                             ; Bus (=Port A) Control Register -> Wait States
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timhdr.s  Page 2



63        00FFE0         PBC       EQU     $FFE0                             ; Port B Control Register
64        00FFE2         PBDDR     EQU     $FFE2                             ; Port B Data Direction Register
65        00FFE4         PBD       EQU     $FFE4                             ; Port B Data Register
66        00FFE1         PCC       EQU     $FFE1                             ; Port C Control Register
67        00FFE3         PCDDR     EQU     $FFE3                             ; PortC Data Direction Register
68        00FFE5         PCD       EQU     $FFE5                             ; Port C Data Register
69        00FFFF         IPR       EQU     $FFFF                             ; Interrupt Priority Register
70        00FFEF         SSITX     EQU     $FFEF                             ; SSI Transmit and Receive data register
71        00FFEF         SSIRX     EQU     $FFEF                             ; SSI Transmit and Receive data register
72        00FFEE         SSISR     EQU     $FFEE                             ; SSI Status Register
73        00FFEC         CRA       EQU     $FFEC                             ; SSI Control Register A
74        00FFED         CRB       EQU     $FFED                             ; SSI Control Regsiter B
75        00FFDE         TCSR      EQU     $FFDE                             ; Timer control and status register
76        00FFDF         TCR       EQU     $FFDF                             ; Timer count register
77     
78                       ; Hardware bit definitions all over the place
79        000006         SSI_TDE   EQU     6                                 ; SSI Transmitter data register empty
80        000007         SSI_RDF   EQU     7                                 ; SSI Receiver data register full
81        000002         LVEN      EQU     2                                 ; Low voltage enable (+/-15 volt nominal)
82        000003         HVEN      EQU     3                                 ; Enable high voltage (+32V nominal)
83        000005         TIM_U_RST EQU     5                                 ; Timing to utility board reset bit number in U25
84        00000D         PWRST     EQU     13                                ; Power control board reset
85        000007         RST_FIFO  EQU     7                                 ; Reset FIFO bit number in control latch U25
86        000009         EF        EQU     9                                 ; FIFO empty flag, low true
87        000000         TIM_BIT   EQU     0                                 ; Timer status bit
88        000001         WW        EQU     1                                 ; Word width = 1 for 16-bit image data, 0 for 24-bit
89        000000         CDAC      EQU     0                                 ; Bit number in U25 for clearing DACs
90        000002         ENCK      EQU     2                                 ; Bit number in U25 for enabling analog switches
91        000001         DUALCLK   EQU     1                                 ; Set to clock two halves of clock driver board togethe
r
92     
93                       ; Software status bits, defined at X:<STATUS = X:0
94                       ; NOTE- SHUT and TST_IMG are used in lois and should be in tim_dsp.h
95        000000         ST_RCV    EQU     0                                 ; Set if FO, cleared if SSI
96        00000A         TST_IMG   EQU     10                                ; Set if ctlr is to generate a test (syn) image
97        00000B         SHUT      EQU     11                                ; Set if opening shutter at beginning of exposure
98        00000C         ST_EXP    EQU     12                                ; Set if presently in EXPOSE or waiting for trigger
99     
100                      ; Software status bits, defined at X:<STATUS = X:0
101       000002         IDLMODE   EQU     2                                 ; Set if need to idle after readout
102       000003         ST_SHUT   EQU     3                                 ; Set to indicate shutter is closed, clear for open
103       000004         ST_RDC    EQU     4                                 ; Set if executing 'RDC' command - reading out
104       000005         SPLIT_S   EQU     5                                 ; Set if split serial
105       000006         SPLIT_P   EQU     6                                 ; Set if split parallel
106       000007         MPP       EQU     7                                 ; Set if parallels are in MPP mode
107       000008         TRIGGER   EQU     8                                 ; Set if a Hardware triggered exposure
108       000009         ST_ABRT   EQU     9                                 ; Set if an abort (readout or exp) in progress
109    
110                      ; These may be temporary- they steal TST_IMG, a capability we don't have,
111                      ; and likewise SPLIT_P
112    
113       00000A         ST_DDCLK  EQU     10                                ; Set if DD bias levels are set, or going there
114       000006         ST_SBFAIL EQU     6                                 ; Set if last call to SET_DAC  failed
115    
116    
117                      ; Image mode bits, defined at X:<IMAGE_MODE
118    
119       000000         FDOTS     EQU     0                                 ; Fast Dots
120       000001         FIND      EQU     1                                 ; Find
121       000002         SDOTS     EQU     2                                 ; Slow Dots
122       000003         SERIES    EQU     3                                 ; Series
123       000004         SINGLE    EQU     4                                 ; Single
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timhdr.s  Page 3



124       000005         STRIP     EQU     5                                 ; Stripscan
125       000006         F_OCC     EQU     6                                 ; Fast occultation, keep as 6 for compatibility
126       000007         B_OCC     EQU     7                                 ; Basic occultation
127       000008         P_OCC     EQU     8                                 ; Pipelined occultation
128    
129                      ; Image Status, define at X:<ISTATUS
130       000000         NO_SKIP   EQU     0                                 ; Set for slow dots, fast and pipelined occultation mod
e
131                                                                          ; to avoid parallel skipping to the subframe boundary.
132       000001         OPEN_CLOSE EQU    1                                 ; Set if shutter opens/closes each image
133                                                                          ; Clear if shutter stays open for many images
134       000002         STORAGE   EQU     2                                 ; Set if storage area is to be clocked
135    
136    
137       000050         MAXDACTBL EQU     80                                ; largest table for SET_DAC (to verify R0 address)
138    
139                      ; Specify controller configuration bits of the X:STATUS word
140                      ;   to describe the software capabilities of this application file
141                      ; The bit is set (=1) if the capability is supported by the controller
142    
143    
144                              COMMENT *
145    
146                      BIT #'s         FUNCTION
147                      2,1,0           Video Processor
148                                              000     CCD Rev. 3
149                                              001     CCD Gen I
150                                              010     IR Rev. 4
151                                              011     IR Coadder
152    
153                      4,3             Timing Board
154                                              00      Rev. 4, Gen II
155                                              01      Gen I
156    
157                      6,5             Utility Board
158                                              00      No utility board
159                                              01      Utility Rev. 3
160    
161                      7               Shutter
162                                              0       No shutter support
163                                              1       Yes shutter support
164    
165                      9,8             Temperature readout
166                                              00      No temperature readout
167                                              01      Polynomial Diode calibration
168                                              10      Linear temperature sensor calibration
169    
170                      10              Subarray readout
171                                              0       Not supported
172                                              1       Yes supported
173    
174                      11              Binning
175                                              0       Not supported
176                                              1       Yes supported
177    
178                      12              Split-Serial readout
179                                              0       Not supported
180                                              1       Yes supported
181    
182                      13              Split-Parallel readout
183                                              0       Not supported
184                                              1       Yes supported
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timhdr.s  Page 4



185    
186                      14              MPP = Inverted parallel clocks
187                                              0       Not supported
188                                              1       Yes supported
189    
190                      16,15           Clock Driver Board
191                                              00      Rev. 3
192                                              11      No clock driver board (Gen I)
193    
194                      19,18,17                Special implementations
195                                              000     Somewhere else
196                                              001     Mount Laguna Observatory
197                                              010     NGST Aladdin
198                                              xxx     Other
199                              *
200    
201                      CCDVIDREV3B
202       000000                   EQU     $000000                           ; CCD Video Processor Rev. 3
203       000001         VIDGENI   EQU     $000001                           ; CCD Video Processor Gen I
204       000002         IRREV4    EQU     $000002                           ; IR Video Processor Rev. 4
205       000003         COADDER   EQU     $000003                           ; IR Coadder
206       000000         TIMREV4   EQU     $000000                           ; Timing Rev. 4
207       000008         TIMGENI   EQU     $000008                           ; Timing Gen I
208       000020         UTILREV3  EQU     $000020                           ; Utility Rev. 3 supported
209       000080         SHUTTER_CC EQU    $000080                           ; Shutter supported
210       000100         TEMP_POLY EQU     $000100                           ; Polynomial calibration
211                      TEMP_LINEAR
212       000200                   EQU     $000200                           ; Linear calibration
213       000400         SUBARRAY  EQU     $000400                           ; Subarray readout supported
214       000800         BINNING   EQU     $000800                           ; Binning supported
215                      SPLIT_SERIAL
216       001000                   EQU     $001000                           ; Split serial supported
217                      SPLIT_PARALLEL
218       002000                   EQU     $002000                           ; Split parallel supported
219       004000         MPP_CC    EQU     $004000                           ; Inverted clocks supported
220       018000         CLKDRVGENI EQU    $018000                           ; No clock driver board - Gen I
221       020000         MLO       EQU     $020000                           ; Set if Mount Laguna Observatory
222       040000         NGST      EQU     $040000                           ; NGST Aladdin implementation
223                                INCLUDE "infospec.s"
224                      ; General DSP info field specifications.
225                      ; These values are 'addresses' and used as the argument for the INF command.
226    
227                      GET_VERSION
228       000000                   EQU     0                                 ; IVERSION field
229       000001         GET_FLAVOR EQU    1                                 ; IFLAVOR field
230       000002         GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
231       000003         GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
232       000004         GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if available)
233    
234                                INCLUDE "timinfospec.s"
235                      ; TIM DSP info field specifications.
236                      ; These values are 'addresses' and used as the argument for the INF command.
237    
238                      GET_CAPABLE
239       000100                   EQU     $100                              ; ICAPABLE field (what dsp supports).
240                      GET_INT_TIM
241       000101                   EQU     $101                              ; Integration time per pixel in leach units
242                      GET_R_DELAY
243       000102                   EQU     $102                              ; Serial overlap in leach units
244                      GET_SI_DELAY
245       000103                   EQU     $103                              ; Parallel overlap in leach units
246    
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timinfospec.s  Page 5



247                                INCLUDE "timinfo.s"
248                      ; DSP Version
249       04507F         IVERSION  EQU     282751                            ; 1.5/1
250    
251       612020         IFLAVOR   EQU     'a  '                             ; a
252    
253       0079C8         ITIME0    EQU     31176                             ; lo order time: 2014 1 13  5:29:44 GMT
254    
255       0052D3         ITIME1    EQU     21203                             ; hi order time: 2014 1 13  5:29:44 GMT
256    
257       000000         ISVNREV   EQU     0                                 ; most recent code svn rev
258    
259                      ; tim capability definitions
260                      FINDCAPABLE
261       000001                   EQU     1                                 ; Find exposure mode
262                      SNGLCAPABLE
263       000002                   EQU     2                                 ; Single exposure mode
264                      SERICAPABLE
265       000004                   EQU     4                                 ; Series exposure mode
266                      BASCCAPABLE
267       000008                   EQU     8                                 ; Basic occ exposure mode
268                      FASTCAPABLE
269       000010                   EQU     16                                ; Fast occ exposure mode
270                      PIPECAPABLE
271       000020                   EQU     32                                ; Pipeline occ exposure mode
272                      FDOTCAPABLE
273       000040                   EQU     64                                ; Fast dots exposure mode
274                      SDOTCAPABLE
275       000080                   EQU     128                               ; Slow dots exposure mode
276                      STRPCAPABLE
277       000100                   EQU     256                               ; Slow dots exposure mode
278       0001FB         TIMCAPABLE EQU    FINDCAPABLE+SNGLCAPABLE+STRPCAPABLE+BASCCAPABLE+FASTCAPABLE+PIPECAPABLE+FDOTCAPABLE+SDOTC
APABLE
279    
280       000000         APL_NUM   EQU     0                                 ; Application number from 0 to 3
281    
282       001420         CC        EQU     CCDVIDREV3B+TIMREV4+UTILREV3+SUBARRAY+SPLIT_SERIAL
283    
284                      ; Include miscellaneous timing commands
285                                INCLUDE "timmisc.s"                       ; Custom
286                      ; This file is for utilities that are in common to all the timing board
287                      ;   programs, located starting at P:$200 in external SRAM
288    
289                                IF      @SCP("50","50")
290       000032         SDELAY    EQU     50
291                                ENDIF
292                                IF      @SCP("50","200")
294                                ENDIF
295    
296                      ;  ****************  PROGRAM CODE IN SRAM PROGRAM SPACE    *******************
297                      ; Put all the following code in SRAM, starting at P:$200.
298                                IF      @SCP("HOST","HOST")
299       P:0200 P:0200                   ORG     P:$200,P:$200                     ; Download address
300                                       ELSE
302                                       ENDIF
303    
304                             ; Fast clear of CCD, executed as a command
305       P:0200 P:0200 0D0202  CLEAR     JSR     <CLR_CCD
306       P:0201 P:0201 0C0000            JMP     <FINISH
307    
308                             ; Fast clear image before each exposure, executed as a subroutine.  Uses DG
309       P:0202 P:0202 060440  CLR_CCD   DO      Y:<NPCLR,LPCLR                    ; Loop over number of lines in image
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 6



                        000207
310       P:0204 P:0204 60F400            MOVE              #IS_CLEAR,R0            ; Address of parallel transfer waveform
                        000063
311       P:0206 P:0206 0D01E7            JSR     <CLOCK                            ; Go clock out the CCD charge
312       P:0207 P:0207 000000            NOP                                       ; Do loop restriction
313                             LPCLR
314       P:0208 P:0208 60F400            MOVE              #DUMP_SERIAL,R0
                        00006C
315       P:020A P:020A 0D01E7            JSR     <CLOCK                            ; and wipe out the dregs in the SR
316       P:020B P:020B 44F400            MOVE              #TST_RCV,X0             ; Wait for commands during exposure
                        000000
317       P:020D P:020D 440000            MOVE              X0,X:<IDL_ADR           ;  instead of idling
318       P:020E P:020E 00000C            RTS
319    
320                             ; Keep the CCD idling when not reading out
321       P:020F P:020F 060140  IDLE      DO      Y:<NSR,IDL1                       ; Loop over number of pixels per line
                        000217
322       P:0211 P:0211 307200            MOVE              #<SERIAL_IDLE,R0        ; Serial transfer on pixel
323       P:0212 P:0212 0D01E7            JSR     <CLOCK                            ; Go to it
324       P:0213 P:0213 0D0000            JSR     <GET_RCV                          ; Check for FO or SSI commands
325       P:0214 P:0214 0E0217            JCC     <NO_COM                           ; Continue IDLE if no commands received
326       P:0215 P:0215 00008C            ENDDO                                     ; Cancel the DO loop
327       P:0216 P:0216 0C0000            JMP     <CHK_SSI                          ; Go process header and command
328       P:0217 P:0217 000000  NO_COM    NOP
329                             IDL1
330       P:0218 P:0218 306300            MOVE              #<IS_CLEAR,R0           ; Address of parallel clocking waveform
331       P:0219 P:0219 0D01E7            JSR     <CLOCK                            ; Go clock out the CCD charge
332       P:021A P:021A 0C020F            JMP     <IDLE
333    
334    
335                             ; Select which readouts to process
336                             ;   'SOS'  Amplifier_name
337                             ;       Amplifier_name = '__L', '__R', '_LR'
338    
339       P:021B P:021B 44DC00  SEL_OS    MOVE              X:(R4)+,X0              ; Get amplifier(s) name
340       P:021C P:021C 0D021E            JSR     <SELECT_OUTPUT_SOURCE
341       P:021D P:021D 0C0000            JMP     <FINISH1
342    
343                             ; A massive subroutine for setting all the addresses depending on the
344                             ; output source(s) selection and binning parameter.  Most of the
345                             ; waveforms are in fast Y memory (< 0xFF) but there isn't enough
346                             ; space for the fast serial binning waveforms for binning factors
347                             ; 1 through 5.  These are in high Y memory and have to be copied in.
348    
349                             SELECT_OUTPUT_SOURCE
350                             ; Set all the waveform addresses depending on which readout/binning mode
351       P:021E P:021E 56F400            MOVE              #'__L',A                ; LEFT Amplifier = readout #0
                        5F5F4C
352       P:0220 P:0220 200045            CMP     X0,A
353       P:0221 P:0221 0E226C            JNE     <CMP_R
354       P:0222 P:0222 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
355       P:0223 P:0223 56F400            MOVE              #SERIAL_SKIP_LEFT,A
                        0000E8
356       P:0225 P:0225 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
357       P:0227 P:0227 56F400            MOVE              #INITIAL_CLOCK_LEFT,A
                        000097
358       P:0229 P:0229 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
359       P:022B P:022B 56F400            MOVE              #SERIAL_CLOCK_LEFT,A
                        0000B1
360       P:022D P:022D 5E7000            MOVE                          A,Y:SERIAL_CLOCK
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 7



                        00000D
361       P:022F P:022F 56F400            MOVE              #(CLK2+$030000+000+000+000+000+H2L+H2R+000+000),A
                        032012
362       P:0231 P:0231 5E7000            MOVE                          A,Y:CCLK_1
                        0000BC
363       P:0233 P:0233 0A7005            BCLR    #SPLIT_S,X:STATUS
                        000000
364                             ; Now go through copying in the serial read waveform if binning more than 5.
365       P:0235 P:0235 200013            CLR     A
366       P:0236 P:0236 20001B            CLR     B
367       P:0237 P:0237 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
368       P:0238 P:0238 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
369       P:0239 P:0239 50F400            MOVE              #>5,A0
                        000005
370       P:023B P:023B 200005            CMP     B,A
371       P:023C P:023C 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
372       P:023D P:023D 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
373       P:023E P:023E 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
374       P:023F P:023F 0A3781  TRY_1_L   JCLR    #1,X:<BINBIT,TRY_2_L
                        000248
375                             ;       MOVE    #1,A0                   ; HACK
376                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
377       P:0241 P:0241 60F400            MOVE              #SERIAL_READ_LEFT_1,R0  ; Here if left amp, bin by 1
                        0001BA
378       P:0243 P:0243 51F400            MOVE              #(END_SERIAL_READ_LEFT_1-SERIAL_READ_LEFT_1),B0
                        00000D
379       P:0245 P:0245 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
380       P:0246 P:0246 0D030D            JSR     <WAVECPY                          ; Copy the waveform
381       P:0247 P:0247 0C0307            JMP     <CMP_END
382       P:0248 P:0248 0A3782  TRY_2_L   JCLR    #2,X:<BINBIT,TRY_3_L
                        000251
383       P:024A P:024A 60F400            MOVE              #SERIAL_READ_LEFT_2,R0  ; Here if left amp, bin by 2
                        0001E1
384       P:024C P:024C 51F400            MOVE              #(END_SERIAL_READ_LEFT_2-SERIAL_READ_LEFT_2),B0
                        000013
385       P:024E P:024E 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
386       P:024F P:024F 0D030D            JSR     <WAVECPY                          ; Copy the waveform
387       P:0250 P:0250 0C0307            JMP     <CMP_END
388       P:0251 P:0251 0A3783  TRY_3_L   JCLR    #3,X:<BINBIT,TRY_4_L
                        00025A
389       P:0253 P:0253 60F400            MOVE              #SERIAL_READ_LEFT_3,R0  ; Here if left amp, bin by 3
                        00021A
390       P:0255 P:0255 51F400            MOVE              #(END_SERIAL_READ_LEFT_3-SERIAL_READ_LEFT_3),B0
                        000019
391       P:0257 P:0257 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
392       P:0258 P:0258 0D030D            JSR     <WAVECPY                          ; Copy the waveform
393       P:0259 P:0259 0C0307            JMP     <CMP_END
394       P:025A P:025A 0A3784  TRY_4_L   JCLR    #4,X:<BINBIT,TRY_5_L
                        000263
395       P:025C P:025C 60F400            MOVE              #SERIAL_READ_LEFT_4,R0  ; Here if left amp, bin by 4
                        000265
396       P:025E P:025E 51F400            MOVE              #(END_SERIAL_READ_LEFT_4-SERIAL_READ_LEFT_4),B0
                        00001F
397       P:0260 P:0260 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
398       P:0261 P:0261 0D030D            JSR     <WAVECPY                          ; Copy the waveform
399       P:0262 P:0262 0C0307            JMP     <CMP_END
400       P:0263 P:0263 0A3785  TRY_5_L   JCLR    #5,X:<BINBIT,CMP_END
                        000307
401       P:0265 P:0265 60F400            MOVE              #SERIAL_READ_LEFT_5,R0  ; Here if left amp, bin by 5
                        0002C2
402       P:0267 P:0267 51F400            MOVE              #(END_SERIAL_READ_LEFT_5-SERIAL_READ_LEFT_5),B0
                        000025
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 8



403       P:0269 P:0269 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
404       P:026A P:026A 0D030D            JSR     <WAVECPY                          ; Copy the waveform
405       P:026B P:026B 0C0307            JMP     <CMP_END
406    
407       P:026C P:026C 56F400  CMP_R     MOVE              #'__R',A                ; RIGHT Amplifier = readout #1
                        5F5F52
408       P:026E P:026E 200045            CMP     X0,A
409       P:026F P:026F 0E22BA            JNE     <CMP_LR
410       P:0270 P:0270 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
411       P:0271 P:0271 56F400            MOVE              #SERIAL_SKIP_RIGHT,A
                        0000F0
412       P:0273 P:0273 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
413       P:0275 P:0275 56F400            MOVE              #INITIAL_CLOCK_RIGHT,A
                        00008B
414       P:0277 P:0277 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
415       P:0279 P:0279 56F400            MOVE              #SERIAL_CLOCK_RIGHT,A
                        0000AA
416       P:027B P:027B 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
417       P:027D P:027D 56F400            MOVE              #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),A
                        032009
418       P:027F P:027F 5E7000            MOVE                          A,Y:CCLK_1
                        0000BC
419       P:0281 P:0281 0A7005            BCLR    #SPLIT_S,X:STATUS
                        000000
420                             ; Now go through copying in the serial read waveform if binning more than 5.
421       P:0283 P:0283 200013            CLR     A
422       P:0284 P:0284 20001B            CLR     B
423       P:0285 P:0285 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
424       P:0286 P:0286 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
425       P:0287 P:0287 50F400            MOVE              #>5,A0
                        000005
426       P:0289 P:0289 200005            CMP     B,A
427       P:028A P:028A 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
428       P:028B P:028B 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
429       P:028C P:028C 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
430       P:028D P:028D 0A3781  TRY_1_R   JCLR    #1,X:<BINBIT,TRY_2_R
                        000296
431                             ;       MOVE    #2,A0                   ; HACK
432                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
433       P:028F P:028F 60F400            MOVE              #SERIAL_READ_RIGHT_1,R0 ; Here if right amp, bin by 1
                        0001C7
434       P:0291 P:0291 51F400            MOVE              #(END_SERIAL_READ_RIGHT_1-SERIAL_READ_RIGHT_1),B0
                        00000D
435       P:0293 P:0293 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
436       P:0294 P:0294 0D030D            JSR     <WAVECPY                          ; Copy the waveform
437       P:0295 P:0295 0C0307            JMP     <CMP_END
438       P:0296 P:0296 0A3782  TRY_2_R   JCLR    #2,X:<BINBIT,TRY_3_R
                        00029F
439       P:0298 P:0298 60F400            MOVE              #SERIAL_READ_RIGHT_2,R0 ; Here if right amp, bin by 2
                        0001F4
440       P:029A P:029A 51F400            MOVE              #(END_SERIAL_READ_RIGHT_2-SERIAL_READ_RIGHT_2),B0
                        000013
441       P:029C P:029C 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
442       P:029D P:029D 0D030D            JSR     <WAVECPY                          ; Copy the waveform
443       P:029E P:029E 0C0307            JMP     <CMP_END
444       P:029F P:029F 0A3783  TRY_3_R   JCLR    #3,X:<BINBIT,TRY_4_R
                        0002A8
445       P:02A1 P:02A1 60F400            MOVE              #SERIAL_READ_RIGHT_3,R0 ; Here if right amp, bin by 3
                        000233
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 9



446       P:02A3 P:02A3 51F400            MOVE              #(END_SERIAL_READ_RIGHT_3-SERIAL_READ_RIGHT_3),B0
                        000019
447       P:02A5 P:02A5 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
448       P:02A6 P:02A6 0D030D            JSR     <WAVECPY                          ; Copy the waveform
449       P:02A7 P:02A7 0C0307            JMP     <CMP_END
450       P:02A8 P:02A8 0A3784  TRY_4_R   JCLR    #4,X:<BINBIT,TRY_5_R
                        0002B1
451       P:02AA P:02AA 60F400            MOVE              #SERIAL_READ_RIGHT_4,R0 ; Here if right amp, bin by 4
                        000284
452       P:02AC P:02AC 51F400            MOVE              #(END_SERIAL_READ_RIGHT_4-SERIAL_READ_RIGHT_4),B0
                        00001F
453       P:02AE P:02AE 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
454       P:02AF P:02AF 0D030D            JSR     <WAVECPY                          ; Copy the waveform
455       P:02B0 P:02B0 0C0307            JMP     <CMP_END
456       P:02B1 P:02B1 0A3785  TRY_5_R   JCLR    #5,X:<BINBIT,CMP_END
                        000307
457       P:02B3 P:02B3 60F400            MOVE              #SERIAL_READ_RIGHT_5,R0 ; Here if right amp, bin by 5
                        0002E7
458       P:02B5 P:02B5 51F400            MOVE              #(END_SERIAL_READ_RIGHT_5-SERIAL_READ_RIGHT_5),B0
                        000025
459       P:02B7 P:02B7 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
460       P:02B8 P:02B8 0D030D            JSR     <WAVECPY                          ; Copy the waveform
461       P:02B9 P:02B9 0C0307            JMP     <CMP_END
462    
463       P:02BA P:02BA 56F400  CMP_LR    MOVE              #'_LR',A                ; LEFT and RIGHT = readouts #0 and #1
                        5F4C52
464       P:02BC P:02BC 200045            CMP     X0,A
465       P:02BD P:02BD 0E230A            JNE     <CMP_ERROR
466       P:02BE P:02BE 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
467       P:02BF P:02BF 56F400            MOVE              #SERIAL_SKIP_SPLIT,A
                        0000F8
468       P:02C1 P:02C1 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
469       P:02C3 P:02C3 56F400            MOVE              #INITIAL_CLOCK_SPLIT,A
                        00007F
470       P:02C5 P:02C5 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
471       P:02C7 P:02C7 56F400            MOVE              #SERIAL_CLOCK_SPLIT,A
                        0000A3
472       P:02C9 P:02C9 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
473       P:02CB P:02CB 56F400            MOVE              #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),A
                        03200A
474       P:02CD P:02CD 5E7000            MOVE                          A,Y:CCLK_1
                        0000BC
475       P:02CF P:02CF 0A7025            BSET    #SPLIT_S,X:STATUS
                        000000
476                             ; Now go through copying in the serial read waveform if binning more than 5.
477       P:02D1 P:02D1 200013            CLR     A
478       P:02D2 P:02D2 20001B            CLR     B
479       P:02D3 P:02D3 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
480       P:02D4 P:02D4 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
481       P:02D5 P:02D5 50F400            MOVE              #>5,A0
                        000005
482       P:02D7 P:02D7 200005            CMP     B,A
483       P:02D8 P:02D8 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
484       P:02D9 P:02D9 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
485       P:02DA P:02DA 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
486       P:02DB P:02DB 0A3781  TRY_1_S   JCLR    #1,X:<BINBIT,TRY_2_S
                        0002E4
487                             ;       MOVE    #3,A0                   ; HACK
488                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 10



489       P:02DD P:02DD 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if split amp, bin by 1
                        0001D4
490       P:02DF P:02DF 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                        00000D
491       P:02E1 P:02E1 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
492       P:02E2 P:02E2 0D030D            JSR     <WAVECPY                          ; Copy the waveform
493       P:02E3 P:02E3 0C0307            JMP     <CMP_END
494       P:02E4 P:02E4 0A3782  TRY_2_S   JCLR    #2,X:<BINBIT,TRY_3_S
                        0002ED
495       P:02E6 P:02E6 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if split amp, bin by 2
                        000207
496       P:02E8 P:02E8 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                        000013
497       P:02EA P:02EA 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
498       P:02EB P:02EB 0D030D            JSR     <WAVECPY                          ; Copy the waveform
499       P:02EC P:02EC 0C0307            JMP     <CMP_END
500       P:02ED P:02ED 0A3783  TRY_3_S   JCLR    #3,X:<BINBIT,TRY_4_S
                        0002F6
501       P:02EF P:02EF 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if split amp, bin by 3
                        00024C
502       P:02F1 P:02F1 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                        000019
503       P:02F3 P:02F3 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
504       P:02F4 P:02F4 0D030D            JSR     <WAVECPY                          ; Copy the waveform
505       P:02F5 P:02F5 0C0307            JMP     <CMP_END
506       P:02F6 P:02F6 0A3784  TRY_4_S   JCLR    #4,X:<BINBIT,TRY_5_S
                        0002FF
507       P:02F8 P:02F8 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if split amp, bin by 4
                        0002A3
508       P:02FA P:02FA 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                        00001F
509       P:02FC P:02FC 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
510       P:02FD P:02FD 0D030D            JSR     <WAVECPY                          ; Copy the waveform
511       P:02FE P:02FE 0C0307            JMP     <CMP_END
512       P:02FF P:02FF 0A3785  TRY_5_S   JCLR    #5,X:<BINBIT,CMP_END
                        000307
513       P:0301 P:0301 60F400            MOVE              #SERIAL_READ_SPLIT_5,R0 ; Here if split amp, bin by 5
                        00030C
514       P:0303 P:0303 51F400            MOVE              #(END_SERIAL_READ_SPLIT_5-SERIAL_READ_SPLIT_5),B0
                        000025
515       P:0305 P:0305 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
516       P:0306 P:0306 0D030D            JSR     <WAVECPY                          ; Copy the waveform
517    
518       P:0307 P:0307 44F400  CMP_END   MOVE              #'DON',X0
                        444F4E
519       P:0309 P:0309 00000C            RTS
520                             CMP_ERROR
521       P:030A P:030A 44F400            MOVE              #'ERR',X0
                        455252
522       P:030C P:030C 00000C            RTS
523    
524                             ; Short function to copy in waveforms from high Y to fast Y memory.
525                             ; R0 is the source address, R7 the destination, and X0 is intermediary reg.
526                             WAVECPY
527       P:030D P:030D 06C900            DO      B0,WAVELP                         ; Copy the waveform; B0 is SERWAVLEN already
                        000311
528       P:030F P:030F 4CD800            MOVE                          Y:(R0)+,X0
529       P:0310 P:0310 4C5F00            MOVE                          X0,Y:(R7)+
530       P:0311 P:0311 000000            NOP
531                             WAVELP
532       P:0312 P:0312 000000            NOP
533       P:0313 P:0313 00000C            RTS
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 11



534    
535                             ; Short function to set the correct bit in BINBIT based on NSBIN
536                             ; Called only if NSBIN is less than 6.
537    
538                             SET_BINBIT
539                             ;       MOVE    Y:<TESTLOC1,A0                  ; HACK - test if this code is executed
540                             ;       INC     A                               ; HACK
541                             ;       MOVE    A0,Y:<TESTLOC1                  ; HACK
542       P:0314 P:0314 50F400            MOVE              #>1,A0                  ; Put a bit in A and shift to right spot
                        000001
543       P:0316 P:0316 060540            DO      Y:<NSBIN,BINLOOP                  ; Bit zero position not used, 1-5 used
                        000318
544       P:0318 P:0318 200032            ASL     A
545                             BINLOOP
546       P:0319 P:0319 503700            MOVE              A0,X:<BINBIT            ; set bit 1-5 for SELECT_OUTPUT_SOURCE jump tabl
e
547       P:031A P:031A 00000C            RTS
548    
549    
550                             ; Set the number of rows and columns and binning factors
551                             SET_ROWS_COLUMNS
552       P:031B P:031B 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NSR = NAXIS1
553       P:031C P:031C 4C7000            MOVE                          X0,Y:NSR
                        000001
554       P:031E P:031E 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NPR = NAXIS2
555       P:031F P:031F 4C7000            MOVE                          X0,Y:NPR
                        000002
556       P:0321 P:0321 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NSBIN
557       P:0322 P:0322 4C7000            MOVE                          X0,Y:NSBIN
                        000005
558       P:0324 P:0324 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NPBIN
559       P:0325 P:0325 4C7000            MOVE                          X0,Y:NPBIN
                        000006
560       P:0327 P:0327 4CBD00            MOVE                          Y:<AMPVAL,X0 ; Get ampval in X0 for SOS call
561       P:0328 P:0328 0D021E            JSR     <SELECT_OUTPUT_SOURCE             ; Update serial read waveform in case binning ch
anged
562       P:0329 P:0329 0C0000            JMP     <FINISH
563    
564                             ; Set the variables for the time-resolved modes
565                             SET_IMAGE_PARAM
566       P:032A P:032A 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Image mode
567       P:032B P:032B 447000            MOVE              X0,X:IMAGE_MODE
                        000030
568       P:032D P:032D 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Iframes = NAXIS3
569       P:032E P:032E 4C7000            MOVE                          X0,Y:IFRAMES
                        00003A
570       P:0330 P:0330 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Srows
571       P:0331 P:0331 4C7000            MOVE                          X0,Y:SROWS
                        000038
572       P:0333 P:0333 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Interval
573                             ;       MOVE    X0,Y:INTERVAL           ; HACK - Using Interval as a test location
574       P:0334 P:0334 0C0000            JMP     <FINISH
575    
576    
577                             ; Set the hardware trigger bit, executed as a command
578                             SET_TRIGGER
579       P:0335 P:0335 44DC00            MOVE              X:(R4)+,X0              ; Get the trigger value
580       P:0336 P:0336 56F400            MOVE              #'_ON',A
                        5F4F4E
581       P:0338 P:0338 200045            CMP     X0,A
582       P:0339 P:0339 0AF0A2            JNE     NO_TRIGGER
                        000340
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 12



583       P:033B P:033B 0AA4AB            JSET    #11,X:PBD,TRIG_CLR                ; Is Trigger running?
                        00033E
584       P:033D P:033D 0C0000            JMP     <ERROR                            ; Yes! report Error!  Why do this?
585                             TRIG_CLR
586       P:033E P:033E 0A0028            BSET    #TRIGGER,X:<STATUS                ; Set status bit, hardware trigger
587       P:033F P:033F 0C0000            JMP     <FINISH
588                             NO_TRIGGER
589       P:0340 P:0340 0A0008            BCLR    #TRIGGER,X:<STATUS                ; Clear Status bit, software timing
590       P:0341 P:0341 0C0000            JMP     <FINISH
591    
592                             ; Calculate the fast read parameters for each readout box
593                             SETUP_SUBROUTINE
594       P:0342 P:0342 4C8C00            MOVE                          Y:<SERWAVLEN,X0 ; # of waveforms
595       P:0343 P:0343 4D9000            MOVE                          Y:<NSERIALS_READ,X1 ; Number of pixels to read
596       P:0344 P:0344 0D04A6            JSR     <FASTSKP                          ; Compute number of clocks required
597       P:0345 P:0345 4D1300            MOVE                          X1,Y:<NREAD ; Number of waveforms per line
598       P:0346 P:0346 5E9A00            MOVE                          Y:<NR_BIAS,A ; Number of pixels to read
599       P:0347 P:0347 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                        00034A
600       P:0349 P:0349 200022            ASR     A
601       P:034A P:034A 21C500            MOVE              A,X1                    ; Number of waveforms per line
602       P:034B P:034B 0D04A6            JSR     <FASTSKP                          ; Compute number of clocks required
603       P:034C P:034C 4D1500            MOVE                          X1,Y:<NBIAS ; Number of waveforms per line
604       P:034D P:034D 44F400            MOVE              #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT),X0 ; # of waveforms
                        000006
605       P:034F P:034F 4D8300            MOVE                          Y:<NS_CLR,X1 ; Number of pixels to skip
606       P:0350 P:0350 0D04A6            JSR     <FASTSKP                          ; Compute number of clocks required
607       P:0351 P:0351 4D1100            MOVE                          X1,Y:<NSCLR ; Number of waveforms per line
608       P:0352 P:0352 4D9700            MOVE                          Y:<NS_SKP1,X1 ; Number of pixels to skip
609       P:0353 P:0353 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
610       P:0354 P:0354 2000F0            MPY     Y1,X1,A
611       P:0355 P:0355 200022            ASR     A
612       P:0356 P:0356 210500            MOVE              A0,X1
613       P:0357 P:0357 0D04A6            JSR     <FASTSKP                          ; Compute number of clocks required
614       P:0358 P:0358 4D1200            MOVE                          X1,Y:<NSKIP1 ; Number of waveforms per line
615       P:0359 P:0359 4D9800            MOVE                          Y:<NS_SKP2,X1 ; Number of pixels to skip
616       P:035A P:035A 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
617       P:035B P:035B 2000F0            MPY     Y1,X1,A
618       P:035C P:035C 200022            ASR     A
619       P:035D P:035D 210500            MOVE              A0,X1
620       P:035E P:035E 0D04A6            JSR     <FASTSKP                          ; Compute number of clocks required
621       P:035F P:035F 4D1400            MOVE                          X1,Y:<NSKIP2 ; Number of waveforms per line
622       P:0360 P:0360 4D9600            MOVE                          Y:<NP_SKIP,X1
623       P:0361 P:0361 4F8600            MOVE                          Y:<NPBIN,Y1
624       P:0362 P:0362 2000F0            MPY     X1,Y1,A
625       P:0363 P:0363 200022            ASR     A
626       P:0364 P:0364 581600            MOVE                          A0,Y:<NP_SKIP
627       P:0365 P:0365 00000C            RTS
628    
629                             ; Returns immediately if hardware triggering is not being used
630                             ; Blocks until the trigger is found to be high twice in a row.
631                             ; Waits until the trigger goes high
632                             WAIT_UNTIL_TRIGGER
633       P:0366 P:0366 0A0088            JCLR    #TRIGGER,X:STATUS,UNTIL_TRIGGER_RETURN
                        00036F
634       P:0368 P:0368 000000            NOP
635       P:0369 P:0369 0AA48B            JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER      ; Is Trigger Low?
                        000366
636       P:036B P:036B 000000            NOP                                       ; Pause
637       P:036C P:036C 0AA48B            JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER      ; Is Trigger still Low?
                        000366
638       P:036E P:036E 000000            NOP
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 13



639                             UNTIL_TRIGGER_RETURN
640       P:036F P:036F 00000C            RTS
641    
642                             ; Returns immediately if hardware triggering is not being used
643                             ; Blocks until the trigger is found to be low twice in a row.
644                             ; Waits while the trigger is high
645                             WAIT_WHILE_TRIGGER
646       P:0370 P:0370 0A0088            JCLR    #TRIGGER,X:STATUS,WHILE_TRIGGER_RETURN
                        000379
647       P:0372 P:0372 000000            NOP
648       P:0373 P:0373 0AA4AB            JSET    #11,X:PBD,WAIT_WHILE_TRIGGER      ; Is Trigger High?
                        000370
649       P:0375 P:0375 000000            NOP                                       ; Pause
650       P:0376 P:0376 0AA4AB            JSET    #11,X:PBD,WAIT_WHILE_TRIGGER      ; Is Trigger still High?
                        000370
651       P:0378 P:0378 000000            NOP
652                             WHILE_TRIGGER_RETURN
653       P:0379 P:0379 00000C            RTS
654    
655                             ; Like WAIT_WHILE_TRIGGER but clears the CCD while waiting
656                             ; Pro:  Clears CCD while waiting.  Con: timing rattiness of 1 parallel time
657                             ; Returns immediately if hardware triggering is not being used
658                             ; Blocks until the trigger is found to be low twice in a row.
659                             ; Waits while the trigger is high
660                             CLEAR_WHILE_TRIGGER
661       P:037A P:037A 0A0088            JCLR    #TRIGGER,X:STATUS,CLEAR_TRIG_RETURN
                        000385
662       P:037C P:037C 60F400            MOVE              #IS_CLEAR,R0            ; Address of parallel transfer waveform
                        000063
663       P:037E P:037E 0D01E7            JSR     <CLOCK                            ; Go clock out the CCD charge
664       P:037F P:037F 0AA4AB            JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER     ; Is Trigger High?
                        00037A
665       P:0381 P:0381 000000            NOP                                       ; Pause
666       P:0382 P:0382 0AA4AB            JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER     ; Is Trigger still High?
                        00037A
667       P:0384 P:0384 000000            NOP
668                             CLEAR_TRIG_RETURN
669       P:0385 P:0385 00000C            RTS
670    
671                             ; Subroutine to compute SROWS in unbinned pixels and store in UBSROWS
672    
673                             UB_CONV
674       P:0386 P:0386 4CB800            MOVE                          Y:<SROWS,X0
675       P:0387 P:0387 4D8600            MOVE                          Y:<NPBIN,X1 ; Adjust for for parallel binning factor
676       P:0388 P:0388 2000A0            MPY     X0,X1,A
677       P:0389 P:0389 200022            ASR     A
678       P:038A P:038A 583900            MOVE                          A0,Y:<UBSROWS ; Put unbinned number in UBSROWS
679       P:038B P:038B 00000C            RTS
680    
681                             ; Key code segments for the HIPO modes.
682                             ; Jump table to the various modes - see also timhdr.s
683                             START_FT_EXPOSURE
684       P:038C P:038C 0A0009            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of lingering abort flag
685       P:038D P:038D 0A00A6            JSET    #ST_SBFAIL,X:<STATUS,EXPMODE_ST
                        00039A
686                             ; go to transition bias levels and then to DD
687       P:038F P:038F 60F400            MOVE              #DACS_TRANS,R0
                        00017C
688       P:0391 P:0391 0BF080            JSR     SET_BIASES
                        00053F
689       P:0393 P:0393 0A00A6            JSET    #ST_SBFAIL,X:<STATUS,EXPMODE_ST
                        00039A
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 14



690                             ; go to deep depletion bias levels, preparation for imaging
691       P:0395 P:0395 60F400            MOVE              #DACS_DD,R0
                        000100
692       P:0397 P:0397 0BF080            JSR     SET_BIASES
                        00053F
693       P:0399 P:0399 0A002A            BSET    #ST_DDCLK,X:<STATUS
694                             EXPMODE_ST
695    
696       P:039A P:039A 0A30A1            JSET    #FIND,X:IMAGE_MODE,SINGLE_PROC
                        0003CB
697       P:039C P:039C 0A30A4            JSET    #SINGLE,X:IMAGE_MODE,SINGLE_PROC
                        0003CB
698                             ;       JSET    #SERIES,X:IMAGE_MODE,SERIES_PROC        ; defunct.  Use basic occ.
699       P:039E P:039E 0A30A0            JSET    #FDOTS,X:IMAGE_MODE,FDOT_PROC
                        0003AD
700       P:03A0 P:03A0 0A30A2            JSET    #SDOTS,X:IMAGE_MODE,SDOT_PROC     ; slow dots & strips use sdot_proc
                        0003FD
701       P:03A2 P:03A2 0A30A5            JSET    #STRIP,X:IMAGE_MODE,SDOT_PROC
                        0003FD
702       P:03A4 P:03A4 0A30A7            JSET    #B_OCC,X:IMAGE_MODE,SINGLE_PROC   ; basic occ uses single_proc
                        0003CB
703       P:03A6 P:03A6 0A30A6            JSET    #F_OCC,X:IMAGE_MODE,FPO_PROC      ; fast & pipelined occ use occ_proc
                        000427
704       P:03A8 P:03A8 0A30A8            JSET    #P_OCC,X:IMAGE_MODE,FPO_PROC
                        000427
705       P:03AA P:03AA 44F400            MOVE              #'ERR',X0               ; error if not a valid mode
                        455252
706       P:03AC P:03AC 0C0000            JMP     <ERROR
707    
708                             FDOT_PROC                                           ; used by fdots only
709                             ; Start by replacing SROWS (binned rows) with unbinned rows.  Will get rewritten on next SEX command
710                             ; Leave the DO loop in here - no reason to change it - won't exceed 65535 dots, for sure!
711       P:03AD P:03AD 0D0386            JSR     UB_CONV                           ; Fill in unbinned SROWS
712       P:03AE P:03AE 5E8200            MOVE                          Y:<NPR,A
713       P:03AF P:03AF 5E1C00            MOVE                          A,Y:<NP_READ ; Make sure that NP_READ=NPR in case of subfram
e
714       P:03B0 P:03B0 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
715       P:03B1 P:03B1 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for FDOTS
716       P:03B2 P:03B2 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
717       P:03B3 P:03B3 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        000457
718       P:03B5 P:03B5 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
719       P:03B6 P:03B6 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
720                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
721       P:03B7 P:03B7 0D04AD            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
722       P:03B8 P:03B8 063A40            DO      Y:<IFRAMES,FDOT_LOOP              ; Loop over the number of FDOTS
                        0003C3
723       P:03BA P:03BA 0A00A8            JSET    #TRIGGER,X:STATUS,FDX_END         ; If no triggering jump to expose image function
                        0003BF
724       P:03BC P:03BC 67F400            MOVE              #FDX_END,R7             ; Store the Address into R7
                        0003BF
725       P:03BE P:03BE 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
726       P:03BF P:03BF 0D0366  FDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
727       P:03C0 P:03C0 4DB900            MOVE                          Y:<UBSROWS,X1 ; Number of unbinned rows per shift
728       P:03C1 P:03C1 0D0478            JSR     <ISHIFT                           ; Clock out the waveforms
729       P:03C2 P:03C2 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
730       P:03C3 P:03C3 000000            NOP
731                             FDOT_LOOP
732       P:03C4 P:03C4 0D04B4            JSR     <C_CSHUT                          ; Conditionally close shutter
733       P:03C5 P:03C5 063A40            DO      Y:<IFRAMES,FDOT_LP1               ; Loop over the number of FDOTS during readout
                        0003C8
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 15



734       P:03C7 P:03C7 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD
735       P:03C8 P:03C8 000000            NOP
736                             FDOT_LP1
737                             ;       JSR     <WAIT_UNTIL_TRIGGER             ; If taking more than one set of dots sync. trigger.
  Vestigial?
738       P:03C9 P:03C9 0AF080            JMP     CLEANUP                           ; clean up after command.
                        000463
739    
740                             SINGLE_PROC                                         ; Used by find, single, and basic occ
741       P:03CB P:03CB 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for find & basic occ
742       P:03CC P:03CC 0A3084            JCLR    #SINGLE,X:IMAGE_MODE,*+3          ; But if single mode,
                        0003CF
743       P:03CE P:03CE 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
744       P:03CF P:03CF 0A3102            BCLR    #STORAGE,X:<ISTATUS               ; Do the FT, no storage clocks only during reado
ut
745       P:03D0 P:03D0 0A3100            BCLR    #NO_SKIP,X:<ISTATUS               ; Do parallel skip up to the subframe boundary
746    
747                                       IF      @SCP("50","0")
748                                       ELSE
749       P:03D1 P:03D1 063280            DO      #SDELAY,SNGL_DELAY1
                        0003D8
750       P:03D3 P:03D3 44F400            MOVE              #25000,X0
                        0061A8
751       P:03D5 P:03D5 06C400            DO      X0,SNGL_DELAY0
                        0003D7
752       P:03D7 P:03D7 000000            NOP
753                              SNGL_DELAY0
754       P:03D8 P:03D8 000000            NOP
755                              SNGL_DELAY1
756       P:03D9 P:03D9 000000            NOP
757                                       ENDIF
758    
759    
760       P:03DA P:03DA 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        000457
761       P:03DC P:03DC 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
762       P:03DD P:03DD 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
763                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
764       P:03DE P:03DE 58BA00            MOVE                          Y:<IFRAMES,A0
765       P:03DF P:03DF 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
766       P:03E0 P:03E0 0D04AD  SN_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
767       P:03E1 P:03E1 67F400            MOVE              #SNX_END,R7             ; Store the Address into R7
                        0003E7
768       P:03E3 P:03E3 0A002C            BSET    #ST_EXP,X:<STATUS
769       P:03E4 P:03E4 0A00A8            JSET    #TRIGGER,X:STATUS,SNX_END         ; If no triggering jump to expose image function
                        0003E7
770       P:03E6 P:03E6 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
771                             SNX_END
772       P:03E7 P:03E7 0A000C            BCLR    #ST_EXP,X:<STATUS
773       P:03E8 P:03E8 0A00A9            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                        0003F8
774    
775       P:03EA P:03EA 0D0366            JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
776       P:03EB P:03EB 0D04B4            JSR     <C_CSHUT                          ; Close shutter if open-close bit is set
777       P:03EC P:03EC 0A0024            BSET    #ST_RDC,X:<STATUS
778       P:03ED P:03ED 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD
779       P:03EE P:03EE 0A0004            BCLR    #ST_RDC,X:<STATUS
780       P:03EF P:03EF 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
781       P:03F0 P:03F0 0A00A9            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                        0003F8
782       P:03F2 P:03F2 200013            CLR     A
783       P:03F3 P:03F3 58BE00            MOVE                          Y:<IFLPCNT,A0
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 16



784       P:03F4 P:03F4 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
785       P:03F5 P:03F5 583E00            MOVE                          A0,Y:<IFLPCNT
786       P:03F6 P:03F6 200003            TST     A
787       P:03F7 P:03F7 0E23E0            JNE     SN_LP                             ; End of IFRAMES loop
788                             SNX_FINI
789       P:03F8 P:03F8 0A30A1            JSET    #FIND,X:IMAGE_MODE,*+3
                        0003FB
790       P:03FA P:03FA 0D04B6            JSR     <CSHUT                            ; Close the shutter unless in find mode
791       P:03FB P:03FB 0AF080            JMP     CLEANUP                           ; clean up after command.
                        000463
792    
793                             SDOT_PROC                                           ; Used by slow dots and strips
794       P:03FD P:03FD 5EB800            MOVE                          Y:<SROWS,A
795       P:03FE P:03FE 5E1C00            MOVE                          A,Y:<NP_READ ; Make sure that NP_READ=SROWS
796       P:03FF P:03FF 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for strips
797       P:0400 P:0400 0A3082            JCLR    #SDOTS,X:IMAGE_MODE,*+3           ; But if sdots mode,
                        000403
798       P:0402 P:0402 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
799       P:0403 P:0403 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for SDOTS and st
rips
800       P:0404 P:0404 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
801                                       IF      @SCP("50","0")
802                                       ELSE
803       P:0405 P:0405 063280            DO      #SDELAY,SDOT_DELAY1
                        00040C
804       P:0407 P:0407 44F400            MOVE              #25000,X0
                        0061A8
805       P:0409 P:0409 06C400            DO      X0,SDOT_DELAY0
                        00040B
806       P:040B P:040B 000000            NOP
807                              SDOT_DELAY0
808       P:040C P:040C 000000            NOP
809                              SDOT_DELAY1
810       P:040D P:040D 000000            NOP
811                                       ENDIF
812    
813       P:040E P:040E 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        000457
814       P:0410 P:0410 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
815       P:0411 P:0411 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
816                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
817       P:0412 P:0412 58BA00            MOVE                          Y:<IFRAMES,A0
818       P:0413 P:0413 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
819       P:0414 P:0414 0D04AD  SD_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
820       P:0415 P:0415 0A00A8            JSET    #TRIGGER,X:STATUS,SDX_END         ; If no triggering jump to expose image function
                        00041A
821       P:0417 P:0417 67F400            MOVE              #SDX_END,R7             ; Store the Address into R7
                        00041A
822       P:0419 P:0419 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
823       P:041A P:041A 0D0366  SDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
824       P:041B P:041B 0D04B4            JSR     <C_CSHUT                          ; Close shutter if open-close is set
825       P:041C P:041C 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD.
826                                                                                 ; No FT or parallel skip since STORAGE=1
827       P:041D P:041D 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
828       P:041E P:041E 200013            CLR     A
829       P:041F P:041F 58BE00            MOVE                          Y:<IFLPCNT,A0
830       P:0420 P:0420 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
831       P:0421 P:0421 583E00            MOVE                          A0,Y:<IFLPCNT
832       P:0422 P:0422 200003            TST     A
833       P:0423 P:0423 0E2414            JNE     SD_LP                             ; End of IFRAMES loop
834       P:0424 P:0424 0D04B6            JSR     <CSHUT                            ; Unconditionally close shutter
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 17



835       P:0425 P:0425 0AF080            JMP     CLEANUP                           ; clean up after command.
                        000463
836    
837                             FPO_PROC                                            ; Used by fast and pipelined occultation modes
838       P:0427 P:0427 5E9C00            MOVE                          Y:<NP_READ,A
839       P:0428 P:0428 5E3800            MOVE                          A,Y:<SROWS  ; Make sure that SROWS=NP_READ
840       P:0429 P:0429 0D0386            JSR     UB_CONV                           ; Fill in unbinned SROWS in UBSROWS
841       P:042A P:042A 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for both of these modes
842       P:042B P:042B 0A3102            BCLR    #STORAGE,X:<ISTATUS               ; Storage clocks only during readout
843       P:042C P:042C 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
844       P:042D P:042D 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        000457
845       P:042F P:042F 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
846       P:0430 P:0430 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
847                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
848       P:0431 P:0431 0D04AD            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
849       P:0432 P:0432 58BA00            MOVE                          Y:<IFRAMES,A0
850       P:0433 P:0433 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
851       P:0434 P:0434 0A00A8  FP_LP     JSET    #TRIGGER,X:STATUS,FPO_END         ; If no triggering jump to expose image function
                        000439
852       P:0436 P:0436 67F400            MOVE              #FPO_END,R7             ; Store the Address into R7
                        000439
853       P:0438 P:0438 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
854       P:0439 P:0439 0D0366  FPO_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
855       P:043A P:043A 4DB900            MOVE                          Y:<UBSROWS,X1 ; Shift down UBSROWS unbinned rows
856       P:043B P:043B 0BF080            JSR     ISHIFT                            ; Clock down subframe height
                        000478
857       P:043D P:043D 0A30A8            JSET    #P_OCC,X:IMAGE_MODE,FPO_RD        ; Shift the rest of the way for F_OCC
                        000447
858                                                                                 ; Go straight to readout if P_OCC
859       P:043F P:043F 4CF000            MOVE                          Y:S_SIZE,X0
                        00003B
860       P:0441 P:0441 208E00            MOVE              X0,A                    ; Get only least significant 24 bits
861       P:0442 P:0442 4CB900            MOVE                          Y:<UBSROWS,X0
862       P:0443 P:0443 200044            SUB     X0,A                              ;
863       P:0444 P:0444 21C500            MOVE              A,X1                    ; X1 = S_SIZE - UBSROWS
864       P:0445 P:0445 0BF080            JSR     SSHIFT                            ; Clock storage the rest of the way
                        000481
865       P:0447 P:0447 0D0134  FPO_RD    JSR     <RCCD1                            ; Finally, read out the CCD.  Skip the FT
866       P:0448 P:0448 0A30A6            JSET    #F_OCC,X:IMAGE_MODE,FPO_SK        ; Shift back up by UBSROWS if P_OCC
                        00044D
867       P:044A P:044A 4DB900            MOVE                          Y:<UBSROWS,X1 ; Shift UBSROWS unbinned rows back up
868       P:044B P:044B 0BF080            JSR     RSHIFT                            ; Clock subframe height back up
                        00048A
869       P:044D P:044D 0D0370  FPO_SK    JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
870       P:044E P:044E 200013            CLR     A
871       P:044F P:044F 58BE00            MOVE                          Y:<IFLPCNT,A0
872       P:0450 P:0450 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
873       P:0451 P:0451 583E00            MOVE                          A0,Y:<IFLPCNT
874       P:0452 P:0452 200003            TST     A
875       P:0453 P:0453 0E2434            JNE     FP_LP                             ; End of IFRAMES loop
876       P:0454 P:0454 0D04B6            JSR     <CSHUT                            ; Unconditionally close shutter
877       P:0455 P:0455 0AF080            JMP     CLEANUP                           ; clean up after command.
                        000463
878    
879                             ; Support subroutines and code fragments used in the various mode code
880                             ; IMG_INI, CLEANUP, ISHIFT, SSHIFT, RSHIFT
881                             ;  Image initialization subroutine.  Sets up status bits & PCI card
882    
883       P:0457 P:0457 09F480  IMG_INI   MOVEP             #$020102,Y:WRFO         ; Transmit header word
                        020102
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 18



884       P:0459 P:0459 060FA0            REP     #15                               ; Delay for transmission
885       P:045A P:045A 000000            NOP
886       P:045B P:045B 09F480            MOVEP             #'IIA',Y:WRFO           ; Initialize Image Address
                        494941
887       P:045D P:045D 060FA0            REP     #15
888       P:045E P:045E 000000            NOP
889                             ;        BSET    #ST_RDC,X:<STATUS       ; Set status to reading out
890       P:045F P:045F 0D0623            JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
891       P:0460 P:0460 0AA421            BSET    #WW,X:PBD                         ; Set WW = 1 for 16-bit image data
892       P:0461 P:0461 000000            NOP
893       P:0462 P:0462 00000C            RTS
894    
895                             ; Cleanup code fragment (not a subroutine) for the end all modes.  JMP to it.
896    
897       P:0463 P:0463 0AA401  CLEANUP   BCLR    #WW,X:PBD                         ; Clear WW to 0 for 32-bit commands
898                             ;        BCLR    #ST_RDC,X:<STATUS       ; Clear status to NOT reading out
899       P:0464 P:0464 0A0009            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of any abort flag
900       P:0465 P:0465 0A00A6            JSET    #ST_SBFAIL,X:<STATUS,EXPMODE_IDL
                        000472
901                             ; go to transition bias levels, then to standard levels
902       P:0467 P:0467 60F400            MOVE              #DACS_TRANS,R0
                        00017C
903       P:0469 P:0469 0BF080            JSR     SET_BIASES
                        00053F
904       P:046B P:046B 0A00A6            JSET    #ST_SBFAIL,X:<STATUS,EXPMODE_IDL
                        000472
905                             ; go to standard inverted bias levels, preparation for idling
906       P:046D P:046D 60F400            MOVE              #DACS_INV,R0
                        00013E
907                             ; WE SHOULD set status bit for bias levels
908       P:046F P:046F 0BF080            JSR     SET_BIASES
                        00053F
909       P:0471 P:0471 0A000A            BCLR    #ST_DDCLK,X:<STATUS
910    
911                             EXPMODE_IDL
912                             ; Restore the controller to non-image data transfer and idling if necessary
913       P:0472 P:0472 0A0082            JCLR    #IDLMODE,X:<STATUS,START          ; Don't idle after readout
                        000008
914       P:0474 P:0474 44F400            MOVE              #IDLE,X0
                        00020F
915       P:0476 P:0476 440000            MOVE              X0,X:<IDL_ADR
916       P:0477 P:0477 0C0008            JMP     <START                            ; Wait for a new command
917    
918                             ; Shift image and storage areas down by the number of rows in X1
919                             ISHIFT
920       P:0478 P:0478 06C500            DO      X1,ISH_LOOP                       ; Number of rows to shift is in X1
                        00047C
921       P:047A P:047A 306300            MOVE              #<IS_CLEAR,R0           ; Ganged clocks with DG running
922       P:047B P:047B 0D01E7            JSR     <CLOCK                            ; Parallel clocking
923       P:047C P:047C 000000            NOP
924                             ISH_LOOP
925       P:047D P:047D 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                        00006C
926       P:047F P:047F 0D01E7            JSR     <CLOCK
927       P:0480 P:0480 00000C            RTS                                       ; End of ISHIFT
928    
929                             ; Shift storage area only down by the number of rows in X1
930                             SSHIFT
931       P:0481 P:0481 06C500            DO      X1,SSH_LOOP                       ; Number of rows to shift is in X1
                        000485
932       P:0483 P:0483 305100            MOVE              #<S_CLEAR,R0            ; Storage clocks only with DG running
933       P:0484 P:0484 0D01E7            JSR     <CLOCK                            ; Parallel clocking
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timmisc.s  Page 19



934       P:0485 P:0485 000000            NOP
935                             SSH_LOOP
936       P:0486 P:0486 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                        00006C
937       P:0488 P:0488 0D01E7            JSR     <CLOCK
938       P:0489 P:0489 00000C            RTS                                       ; End of SSHIFT
939    
940                             ; Used by pipelined occultation mode to move the storage area back up to
941                             ; the seam following read of a subframe
942                             RSHIFT
943       P:048A P:048A 06C500            DO      X1,RVS_SHIFT                      ; Number of rows to read out
                        00048E
944       P:048C P:048C 304900            MOVE              #<R_S_PARALLEL,R0       ; Reverse parallel waveform
945       P:048D P:048D 0D01E7            JSR     <CLOCK                            ; Parallel clocking
946       P:048E P:048E 000000            NOP
947                             RVS_SHIFT
948       P:048F P:048F 00000C            RTS                                       ; End of RSHIFT
949                                       INCLUDE "timCCDmisc.s"                    ; Generic
950                             ; This file is for utilities that are in common to all the timing board
951                             ;   programs, located starting at P:$200 in external SRAM
952    
953                                     COMMENT *
954    
955                             The following commands are supported in this "timmisc.s" file
956                             PAL_DLY                 Subroutine to delay by about 8 microseconds
957                             SET_DAC                 Transfer DAC values in (R0) table to the DACs
958                             FASTSKP                 Compute number of waveform table entries in a readout
959                                                             for fast clocking
960                             SYNTHETIC_IMAGE         Generate a synthetic image for system testing
961                             OSHUT                   Subroutine call for opening the shutter
962                             CSHUT                   Subroutine call for closing the shutter
963                             OPEN_SHUTTER            Command for opening the shutter
964                             CLOSE_SHUTTER           Command for closing the shutter
965                             SET_EXP_TIME            Write desired exposure time to timing board variable
966                             RD_EXP_TIME             Read elapsed exposure time
967                             START_EXPOSURE          Start an exposure - 'DON' reply, clear FPA, open
968                                                     shutter, expose, close shutter, delay Y:SH_DLY, readout
969                             PAUSE_EXPOSURE          Close shutter, stop exposure timer
970                             RESUME_EXPOSURE         Open shutter if necessary, resume exposure timer
971                             ABORT_EXPOSURE          Close shutter, stop exposure timer
972                             INF                     Return version and timing information
973                             IDL                     Put FPA to clocking when not processing commands or
974                                                     reading out
975                             STP                     Put FPA to not clocking when not processing commands or
976                                                     reading out
977                             READ_CONTROLLER_CONFIGURATION
978    
979                             PWR_OFF                 Turn off ananlog power supply voltages to backplane
980                             PWR_ON                  Turn on analog power supply voltages to backplane
981                             SETBIAS                 Command to call SET_BIASES and reply 'DON'
982                             SET_BIASES              Subroutine to turn on all bias and clock voltages
983                                                     by reading them from the waveform tables and writing
984                                                     them to the DACs
985                             SER_ANA                 Direct the timing board DSP's synchronous serial
986                                                     transmitter to the analog boards (clock driver, video)
987                             SER_UTL                 Direct the timing board DSP's synchronous serial
988                                                     transmitter to the utility board
989                             CLR_SWS                 Clear the analog switches in the clock driver and
990                                                     video boards to lower their power consumption, as a
991                                                     command with a 'DON' reply
992                             CLEAR_SWITCHES          A subroutine call for CLR_WSW
993                             ST_GAIN                 Set the video processor gain to one of four values
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timCCDmisc.s  Page 20



994                             WR_CNTRL
995                             SET_DC
996                             SET_BIAS_NUMBER
997                             SET_MUX
998    
999                                     *
1000   
1001                            ;  ** Place this file after the custom timmisc.s file so it continues
1002                            ;       to be written in the P:$200 address space  ****
1003   
1004                            ; Hardware control bit definitions
1005      000004                SHUTTER   EQU     4                                 ; Shutter control bit = TIM-LATCH0, A30
1006   
1007   
1008                            ; Delay for serial writes to the PALs and DACs by 8 microsec
1009      P:0490 P:0490 06FA80  PAL_DLY   DO      #250,DLY                          ; Wait 8 usec for serial data transmission
                        000492
1010      P:0492 P:0492 000000            NOP
1011      P:0493 P:0493 000000  DLY       NOP
1012      P:0494 P:0494 00000C            RTS
1013   
1014                            ;  Update the DACs
1015                            ; IF A is non-zero an error was found in the DAC table
1016      P:0495 P:0495 4CD800  SET_DAC   MOVE                          Y:(R0)+,X0  ; Get the number of table entries
1017                            ;  WE SHOULD VALIDATE X0 here (between 1 and something reasonable)
1018      P:0496 P:0496 2E5000            MOVE              #MAXDACTBL,A
1019      P:0497 P:0497 200045            CMP     X0,A
1020      P:0498 P:0498 0AF0A9            JLT     FAIL
                        0004A4
1021      P:049A P:049A 200013            CLR     A
1022      P:049B P:049B 200045            CMP     X0,A
1023      P:049C P:049C 0AF0A1            JGE     FAIL
                        0004A4
1024      P:049E P:049E 06C400            DO      X0,SET_L0                         ; Repeat X0 times
                        0004A2
1025      P:04A0 P:04A0 08D8EF            MOVEP             Y:(R0)+,X:SSITX         ; Send out the waveform
1026      P:04A1 P:04A1 0D0490            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
1027      P:04A2 P:04A2 000000            NOP                                       ; Do loop restriction
1028                            SET_L0
1029      P:04A3 P:04A3 00000C            RTS                                       ; Return from subroutine
1030                            FAIL
1031      P:04A4 P:04A4 2E0100            MOVE              #1,A
1032      P:04A5 P:04A5 00000C            RTS
1033   
1034                            ; Subroutine for computing number of fast clocks needed
1035      P:04A6 P:04A6 2000A8  FASTSKP   MPY     X0,X1,B                           ; X1 = number of pixels to skip,
1036                                                                                ; X0 = number of waveform table entries
1037      P:04A7 P:04A7 20002A            ASR     B                                 ; Correct for multiplication left shift
1038      P:04A8 P:04A8 212E00            MOVE              B0,A                    ; Get only least significant 24 bits
1039      P:04A9 P:04A9 458000            MOVE              X:<ONE,X1
1040      P:04AA P:04AA 200064            SUB     X1,A                              ; Subtract 1
1041      P:04AB P:04AB 21C500            MOVE              A,X1                    ; X1 = X0 * X1 - 1
1042      P:04AC P:04AC 00000C            RTS
1043   
1044                            ; Subroutine with two entry points.  C_OSHUT is conditional on SHUT
1045                            ; Open the shutter conditionally based on the shutter status bit
1046                            ; Open the shutter by setting the backplane bit TIM-LATCH0
1047      P:04AD P:04AD 0A008B  C_OSHUT   JCLR    #SHUT,X:STATUS,OSH_RTN
                        0004B3
1048      P:04AF P:04AF 0A0023  OSHUT     BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
1049      P:04B0 P:04B0 0A0004            BCLR    #SHUTTER,X:<LATCH                 ; Clear hardware shutter bit to open
1050      P:04B1 P:04B1 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timCCDmisc.s  Page 21



                        000000
1051      P:04B3 P:04B3 00000C  OSH_RTN   RTS
1052   
1053                            ; Subroutine with two entry points.  C_CSHUT is conditional on OPEN_CLOSE
1054                            ; Close the shutter conditionally based on the open-close ISTATUS bit
1055                            ; Close the shutter by clearing the backplane bit TIM-LATCH0
1056      P:04B4 P:04B4 0A3181  C_CSHUT   JCLR    #OPEN_CLOSE,X:ISTATUS,CSH_RTN     ; Don't close if always open
                        0004C6
1057      P:04B6 P:04B6 0A0003  CSHUT     BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
1058      P:04B7 P:04B7 0A0024            BSET    #SHUTTER,X:<LATCH                 ; Set hardware shutter bit to close
1059      P:04B8 P:04B8 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                        000000
1060      P:04BA P:04BA 5E8900            MOVE                          Y:<SH_DEL,A
1061      P:04BB P:04BB 200003            TST     A
1062      P:04BC P:04BC 0EF4C5            JLE     <S_DEL0
1063      P:04BD P:04BD 44F400            MOVE              #25000,X0
                        0061A8
1064      P:04BF P:04BF 06CE00            DO      A,S_DEL0                          ; Delay by Y:SH_DEL milliseconds
                        0004C4
1065      P:04C1 P:04C1 06C400            DO      X0,S_DEL1
                        0004C3
1066      P:04C3 P:04C3 000000            NOP
1067      P:04C4 P:04C4 000000  S_DEL1    NOP
1068      P:04C5 P:04C5 000000  S_DEL0    NOP
1069      P:04C6 P:04C6 00000C  CSH_RTN   RTS
1070   
1071                            ; Open the shutter from the timing board, executed as a command
1072                            OPEN_SHUTTER
1073      P:04C7 P:04C7 0D04AF            JSR     <OSHUT
1074      P:04C8 P:04C8 0C0000            JMP     <FINISH
1075   
1076                            ; Close the shutter from the timing board, executed as a command
1077                            CLOSE_SHUTTER
1078      P:04C9 P:04C9 0D04B6            JSR     <CSHUT
1079      P:04CA P:04CA 0C0000            JMP     <FINISH
1080   
1081                            ; Set the desired exposure time
1082                            SET_EXP_TIME
1083      P:04CB P:04CB 44DC00            MOVE              X:(R4)+,X0
1084      P:04CC P:04CC 440000            MOVE              X0,X:<EXP_TIM           ; Write to magic address
1085      P:04CD P:04CD 440000            MOVE              X0,X:<TGT_TIM
1086      P:04CE P:04CE 0C0000            JMP     <FINISH
1087   
1088   
1089                            ; Abort exposure - close the shutter, stop the timer and resume idle mode
1090                            ABORT_EXPOSURE
1091      P:04CF P:04CF 0A00AC            JSET    #ST_EXP,X:<STATUS,DO_ABEXP
                        0004D2
1092                            ; assume we got here via the idle rcv loop
1093      P:04D1 P:04D1 0C0000            JMP     <FINISH
1094                            DO_ABEXP
1095      P:04D2 P:04D2 0A9E00            BCLR    #TIM_BIT,X:TCSR                   ; Disable the DSP exposure timer
1096                            ;
1097                            ; The place to return must be in R7-
1098      P:04D3 P:04D3 0AE780            JMP     (R7)                              ; 'return' from EXPOSE
1099                            ;       JSR     <CSHUT                  ; Close the shutter
1100                            ;       JCLR    #IDLMODE,X:<STATUS,FINISH ; Check whether to idle after readout
1101                            ;       MOVE    #IDLE,X0                ; Idle after readout
1102                            ;       MOVE    X0,X:<IDL_ADR
1103                            ;       JMP     <FINISH
1104   
1105                            ;       Process INF according to the single addressing parameter
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timCCDmisc.s  Page 22



1106                            GET_INFO
1107      P:04D4 P:04D4 56DC00            MOVE              X:(R4)+,A               ; 0-4 is generic, >= 0x100 tim specific
1108      P:04D5 P:04D5 44F400            MOVE              #IVERSION,X0
                        04507F
1109      P:04D7 P:04D7 46F400            MOVE              #>GET_VERSION,Y0
                        000000
1110      P:04D9 P:04D9 200055            CMP     Y0,A
1111      P:04DA P:04DA 0EA000            JEQ     <FINISH1
1112      P:04DB P:04DB 44F400            MOVE              #IFLAVOR,X0
                        612020
1113      P:04DD P:04DD 46F400            MOVE              #>GET_FLAVOR,Y0
                        000001
1114      P:04DF P:04DF 200055            CMP     Y0,A
1115      P:04E0 P:04E0 0EA000            JEQ     <FINISH1
1116      P:04E1 P:04E1 44F400            MOVE              #ITIME0,X0
                        0079C8
1117      P:04E3 P:04E3 46F400            MOVE              #>GET_TIME0,Y0
                        000002
1118      P:04E5 P:04E5 200055            CMP     Y0,A
1119      P:04E6 P:04E6 0EA000            JEQ     <FINISH1                          ; Is it Time0?
1120      P:04E7 P:04E7 44F400            MOVE              #ITIME1,X0
                        0052D3
1121      P:04E9 P:04E9 46F400            MOVE              #>GET_TIME1,Y0
                        000003
1122      P:04EB P:04EB 200055            CMP     Y0,A
1123      P:04EC P:04EC 0EA000            JEQ     <FINISH1                          ; Is it Time1?
1124      P:04ED P:04ED 240000            MOVE              #ISVNREV,X0
1125      P:04EE P:04EE 46F400            MOVE              #>GET_SVNREV,Y0
                        000004
1126      P:04F0 P:04F0 200055            CMP     Y0,A
1127      P:04F1 P:04F1 0EA000            JEQ     <FINISH1                          ; Is it Svn rev?
1128      P:04F2 P:04F2 44F400            MOVE              #TIMCAPABLE,X0
                        0001FB
1129      P:04F4 P:04F4 46F400            MOVE              #>GET_CAPABLE,Y0
                        000100
1130      P:04F6 P:04F6 200055            CMP     Y0,A
1131      P:04F7 P:04F7 0EA000            JEQ     <FINISH1                          ; Is it Tim Capabilities?
1132      P:04F8 P:04F8 44F400            MOVE              #INT_TIM,X0
                        1D0000
1133      P:04FA P:04FA 46F400            MOVE              #>GET_INT_TIM,Y0
                        000101
1134      P:04FC P:04FC 200055            CMP     Y0,A
1135      P:04FD P:04FD 0EA000            JEQ     <FINISH1                          ; Is it Integration time?
1136      P:04FE P:04FE 44F400            MOVE              #R_DELAY,X0
                        000000
1137      P:0500 P:0500 46F400            MOVE              #>GET_R_DELAY,Y0
                        000102
1138      P:0502 P:0502 200055            CMP     Y0,A
1139      P:0503 P:0503 0EA000            JEQ     <FINISH1                          ; Is it Serial time?
1140      P:0504 P:0504 44F400            MOVE              #SI_DELAY,X0
                        820000
1141      P:0506 P:0506 46F400            MOVE              #>GET_SI_DELAY,Y0
                        000103
1142      P:0508 P:0508 200055            CMP     Y0,A
1143      P:0509 P:0509 0EA000            JEQ     <FINISH1                          ; Is it Parallel time?
1144      P:050A P:050A 0C0000            JMP     <ERROR
1145   
1146   
1147                            ; Set software to IDLE mode
1148      P:050B P:050B 44F400  IDL       MOVE              #IDLE,X0                ; Exercise clocks when idling
                        00020F
1149      P:050D P:050D 440000            MOVE              X0,X:<IDL_ADR
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timCCDmisc.s  Page 23



1150      P:050E P:050E 0A0022            BSET    #IDLMODE,X:<STATUS                ; Idle after readout
1151      P:050F P:050F 0C0000            JMP     <FINISH                           ; Need to send header and 'DON'
1152   
1153                            ; Come to here on a 'STP' command so 'DON' can be sent
1154      P:0510 P:0510 44F400  STP       MOVE              #TST_RCV,X0             ; Wait for commands during exposure
                        000000
1155      P:0512 P:0512 440000            MOVE              X0,X:<IDL_ADR           ;  instead of exercising clocks
1156      P:0513 P:0513 0A0002            BCLR    #IDLMODE,X:<STATUS                ; Don't idle after readout
1157      P:0514 P:0514 0C0000            JMP     <FINISH
1158   
1159                            ; Let the host computer read the controller configuration
1160                            READ_CONTROLLER_CONFIGURATION
1161      P:0515 P:0515 4C8A00            MOVE                          Y:<CONFIG,X0 ; Just transmit the configuration
1162      P:0516 P:0516 0C0000            JMP     <FINISH1
1163   
1164                            ; Power off
1165      P:0517 P:0517 0D056A  PWR_OFF   JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1166      P:0518 P:0518 0AA202            BCLR    #LVEN,X:PBDDR                     ; Set these signals to DSP inputs
1167      P:0519 P:0519 0AA20D            BCLR    #PWRST,X:PBDDR
1168      P:051A P:051A 0AA203            BCLR    #HVEN,X:PBDDR
1169      P:051B P:051B 0AA422            BSET    #LVEN,X:PBD                       ; LVEN = HVEN = 1 => Power reset
1170      P:051C P:051C 0AA42D            BSET    #PWRST,X:PBD
1171      P:051D P:051D 0AA423            BSET    #HVEN,X:PBD
1172      P:051E P:051E 0C0000            JMP     <FINISH
1173   
1174                            ; Start power-on cycle
1175      P:051F P:051F 0AA222  PWR_ON    BSET    #LVEN,X:PBDDR                     ; Set these signals to DSP outputs
1176      P:0520 P:0520 0AA22D            BSET    #PWRST,X:PBDDR
1177      P:0521 P:0521 0AA223            BSET    #HVEN,X:PBDDR
1178      P:0522 P:0522 0D056A            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1179   
1180                            ; Ramp up the low voltages (+/- 6.5V, 16.5V) and then delay
1181      P:0523 P:0523 0AA402            BCLR    #LVEN,X:PBD                       ; LVEN = Low => Turn on +/- 6.5V,
1182      P:0524 P:0524 0AA40D            BCLR    #PWRST,X:PBD
1183      P:0525 P:0525 44F400            MOVE              #60000,X0
                        00EA60
1184      P:0527 P:0527 06C400            DO      X0,WT_PON1                        ; Wait 10 millisec or so for settling
                        00052C
1185      P:0529 P:0529 07708E            MOVE              A,P:RSTWDT              ; Reset watchdog timer
                        006000
1186      P:052B P:052B 07708E            MOVE              A,P:RSTWDT
                        006000
1187                            WT_PON1
1188   
1189                            ; Ramp up the high +36 volt power line and then delay
1190      P:052D P:052D 0AA403            BCLR    #HVEN,X:PBD                       ; HVEN = Low => Turn on +36V
1191      P:052E P:052E 44F400            MOVE              #60000,X0
                        00EA60
1192      P:0530 P:0530 06C400            DO      X0,WT_PON2                        ; Wait 10 millisec or so for settling
                        000535
1193      P:0532 P:0532 07708E            MOVE              A,P:RSTWDT              ; Reset watchdog timer
                        006000
1194      P:0534 P:0534 07708E            MOVE              A,P:RSTWDT
                        006000
1195                            WT_PON2
1196                            ; WE SHOULD set a status bit for INV levels
1197      P:0536 P:0536 0A000A            BCLR    #ST_DDCLK,X:<STATUS
1198      P:0537 P:0537 60F400            MOVE              #DACS_INV,R0            ; standard (IDLE) INV levels here
                        00013E
1199      P:0539 P:0539 0D053F            JSR     <SET_BIASES                       ; Turn on the DC bias supplies
1200      P:053A P:053A 44F400            MOVE              #IDLE,X0
                        00020F
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timCCDmisc.s  Page 24



1201      P:053C P:053C 440000            MOVE              X0,X:<IDL_ADR
1202      P:053D P:053D 0C0000            JMP     <FINISH                           ; All done with 'DON'
1203   
1204                            ; This is not accessible from LOIS, so make it a no-op. If it were to be
1205                            ; implemented would need an argument
1206                            ;SETBIAS        JSR     <SET_BIASES
1207                            SETBIAS
1208      P:053E P:053E 0C0000            JMP     <FINISH
1209   
1210                            ; Set all the DC bias voltages and video processor offset values, reading
1211                            ;   them from the table labeled DACS in this file
1212                            SET_BIASES
1213      P:053F P:053F 0D055A            JSR     <SER_ANA
1214      P:0540 P:0540 0A0020            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
1215      P:0541 P:0541 0A0022            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
1216      P:0542 P:0542 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Disable clear of DAC and enable clocks
                        000000
1217      P:0544 P:0544 0D0490            JSR     <PAL_DLY                          ; Delay for all this to happen
1218      P:0545 P:0545 0D0490            JSR     <PAL_DLY                          ; Delay for all this to happen
1219   
1220                            ; Disable simultaneous update of clock driver boards
1221      P:0546 P:0546 0A0001            BCLR    #1,X:<LATCH
1222      P:0547 P:0547 09F081            MOVEP             X:LATCH,Y:WRLATCH
                        000000
1223   
1224                            ; Read DAC values from a table, and set DACs
1225                            ;       MOVE    #DACS,R0                ; Get starting address of DAC values
1226                            ;       R0 passed from caller for the bias levels needed
1227      P:0549 P:0549 0D0495            JSR     <SET_DAC
1228      P:054A P:054A 200003            TST     A
1229      P:054B P:054B 0AF0AA            JEQ     DACDONE
                        00054E
1230      P:054D P:054D 0A0026            BSET    #ST_SBFAIL,X:<STATUS              ; we don't ever clear this
1231                            DACDONE
1232   
1233                            ; Set all video processor analog switches to open to disable them (1 => OFF)
1234      P:054E P:054E 56F400            MOVE              #$000FFF,A
                        000FFF
1235      P:0550 P:0550 566600            MOVE              A,X:(R6)                ; Send out the waveform
1236      P:0551 P:0551 000000            NOP
1237   
1238                            ; Let the DAC voltages all ramp up before exiting
1239      P:0552 P:0552 56F400            MOVE              #400,A                  ; Delay 4 millisec
                        000190
1240      P:0554 P:0554 06CE00            DO      A,L_SBI1
                        000557
1241      P:0556 P:0556 0D0490            JSR     <PAL_DLY                          ; Delay for all this to happen
1242      P:0557 P:0557 000000            NOP
1243                            L_SBI1
1244      P:0558 P:0558 0D0561            JSR     <SER_UTL                          ; SSI -> utility board communication
1245      P:0559 P:0559 00000C            RTS
1246   
1247                            ; Enable serial communication to the analog boards
1248      P:055A P:055A 0AA420  SER_ANA   BSET    #0,X:PBD                          ; Set H0 for analog boards SSI
1249      P:055B P:055B 08F4A1            MOVEP             #$0000,X:PCC            ; Software reset of SSI
                        000000
1250      P:055D P:055D 0AAD0A            BCLR    #10,X:CRB                         ; SSI -> continuous clock for analog
1251      P:055E P:055E 08F4A1            MOVEP             #$0160,X:PCC            ; Re-enable the SSI
                        000160
1252      P:0560 P:0560 00000C            RTS
1253   
1254                            ; Enable serial communication to the utility board
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timCCDmisc.s  Page 25



1255      P:0561 P:0561 08F4A1  SER_UTL   MOVEP             #$0000,X:PCC            ; Software reset of SSI
                        000000
1256      P:0563 P:0563 0AAD2A            BSET    #10,X:CRB                         ; SSI -> gated clock for util board
1257      P:0564 P:0564 08F4A1            MOVEP             #$0160,X:PCC            ; Enable the SSI
                        000160
1258      P:0566 P:0566 0AA400            BCLR    #0,X:PBD                          ; Clear H0 for utility board SSI
1259      P:0567 P:0567 00000C            RTS
1260   
1261      P:0568 P:0568 0D056A  CLR_SWS   JSR     <CLEAR_SWITCHES
1262      P:0569 P:0569 0C0000            JMP     <FINISH
1263   
1264                            ; Clear all video processor analog switches to lower their power dissipation
1265                            CLEAR_SWITCHES
1266      P:056A P:056A 0D055A            JSR     <SER_ANA                          ; Set SSI to analog board communication
1267      P:056B P:056B 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                        0C3000
1268      P:056D P:056D 20001B            CLR     B
1269      P:056E P:056E 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC writes
1270      P:056F P:056F 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writes
                        001000
1271      P:0571 P:0571 060F80            DO      #15,L_VIDEO                       ; Fifteen video processor boards maximum
                        000578
1272      P:0573 P:0573 08CE2F            MOVEP             A,X:SSITX               ; Gain, integrate speed
1273      P:0574 P:0574 200040            ADD     X0,A
1274      P:0575 P:0575 577000            MOVE              B,X:WRSS
                        00FF80
1275      P:0577 P:0577 0D0490            JSR     <PAL_DLY                          ; Delay for the serial data transmission
1276      P:0578 P:0578 200068            ADD     X1,B
1277                            L_VIDEO
1278      P:0579 P:0579 0A0000            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
1279      P:057A P:057A 0A0002            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
1280      P:057B P:057B 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                        000000
1281      P:057D P:057D 44F400            MOVE              #IDLE,X0
                        00020F
1282      P:057F P:057F 440000            MOVE              X0,X:<IDL_ADR
1283      P:0580 P:0580 0D0561            JSR     <SER_UTL                          ; Return SSI to utility board
1284      P:0581 P:0581 00000C            RTS
1285   
1286                            ; Set the clock multiplexers
1287      P:0582 P:0582 0D055A  SET_MUX   JSR     <SER_ANA                          ; Set SSI to analog board communication
1288      P:0583 P:0583 56DC00            MOVE              X:(R4)+,A               ; Clock driver board number
1289      P:0584 P:0584 0614A0            REP     #20
1290      P:0585 P:0585 200033            LSL     A
1291      P:0586 P:0586 44F400            MOVE              #$003000,X0
                        003000
1292      P:0588 P:0588 200042            OR      X0,A
1293      P:0589 P:0589 21C500            MOVE              A,X1                    ; Move here for storage
1294   
1295                            ; Get the first MUX number
1296      P:058A P:058A 56DC00            MOVE              X:(R4)+,A               ; Get the first MUX number
1297      P:058B P:058B 0AF0A9            JLT     ERR_SM1
                        0005CD
1298      P:058D P:058D 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                        000018
1299      P:058F P:058F 200045            CMP     X0,A
1300      P:0590 P:0590 0AF0A1            JGE     ERR_SM1
                        0005CD
1301      P:0592 P:0592 21CF00            MOVE              A,B
1302      P:0593 P:0593 44F400            MOVE              #>7,X0
                        000007
1303      P:0595 P:0595 20004E            AND     X0,B
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timCCDmisc.s  Page 26



1304      P:0596 P:0596 44F400            MOVE              #>$18,X0
                        000018
1305      P:0598 P:0598 200046            AND     X0,A
1306      P:0599 P:0599 0E259C            JNE     <SMX_1                            ; Test for 0 <= MUX number <= 7
1307      P:059A P:059A 0ACD63            BSET    #3,B1
1308      P:059B P:059B 0C05A7            JMP     <SMX_A
1309      P:059C P:059C 44F400  SMX_1     MOVE              #>$08,X0
                        000008
1310      P:059E P:059E 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1311      P:059F P:059F 0E25A2            JNE     <SMX_2
1312      P:05A0 P:05A0 0ACD64            BSET    #4,B1
1313      P:05A1 P:05A1 0C05A7            JMP     <SMX_A
1314      P:05A2 P:05A2 44F400  SMX_2     MOVE              #>$10,X0
                        000010
1315      P:05A4 P:05A4 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1316      P:05A5 P:05A5 0E25CD            JNE     <ERR_SM1
1317      P:05A6 P:05A6 0ACD65            BSET    #5,B1
1318      P:05A7 P:05A7 20006A  SMX_A     OR      X1,B1                             ; Add prefix to MUX numbers
1319      P:05A8 P:05A8 21A700            MOVE              B1,Y1
1320   
1321                            ; Add on the second MUX number
1322      P:05A9 P:05A9 56DC00            MOVE              X:(R4)+,A               ; Get the next MUX number
1323      P:05AA P:05AA 0AF0A9            JLT     ERR_SM2
                        0005CE
1324      P:05AC P:05AC 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                        000018
1325      P:05AE P:05AE 200045            CMP     X0,A
1326      P:05AF P:05AF 0AF0A1            JGE     ERR_SM2
                        0005CE
1327      P:05B1 P:05B1 0606A0            REP     #6
1328      P:05B2 P:05B2 200033            LSL     A
1329      P:05B3 P:05B3 21CF00            MOVE              A,B
1330      P:05B4 P:05B4 44F400            MOVE              #$1C0,X0
                        0001C0
1331      P:05B6 P:05B6 20004E            AND     X0,B
1332      P:05B7 P:05B7 44F400            MOVE              #>$600,X0
                        000600
1333      P:05B9 P:05B9 200046            AND     X0,A
1334      P:05BA P:05BA 0E25BD            JNE     <SMX_3                            ; Test for 0 <= MUX number <= 7
1335      P:05BB P:05BB 0ACD69            BSET    #9,B1
1336      P:05BC P:05BC 0C05C8            JMP     <SMX_B
1337      P:05BD P:05BD 44F400  SMX_3     MOVE              #>$200,X0
                        000200
1338      P:05BF P:05BF 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1339      P:05C0 P:05C0 0E25C3            JNE     <SMX_4
1340      P:05C1 P:05C1 0ACD6A            BSET    #10,B1
1341      P:05C2 P:05C2 0C05C8            JMP     <SMX_B
1342      P:05C3 P:05C3 44F400  SMX_4     MOVE              #>$400,X0
                        000400
1343      P:05C5 P:05C5 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1344      P:05C6 P:05C6 0E25CE            JNE     <ERR_SM2
1345      P:05C7 P:05C7 0ACD6B            BSET    #11,B1
1346      P:05C8 P:05C8 200078  SMX_B     ADD     Y1,B                              ; Add prefix to MUX numbers
1347   
1348      P:05C9 P:05C9 08CD2F            MOVEP             B1,X:SSITX
1349      P:05CA P:05CA 0D0490            JSR     <PAL_DLY                          ; Delay for all this to happen
1350      P:05CB P:05CB 0D0561            JSR     <SER_UTL                          ; Return SSI to utility board communication
1351      P:05CC P:05CC 0C0000            JMP     <FINISH
1352      P:05CD P:05CD 56DC00  ERR_SM1   MOVE              X:(R4)+,A
1353      P:05CE P:05CE 0D0561  ERR_SM2   JSR     <SER_UTL                          ; Return SSI to utility board communication
1354      P:05CF P:05CF 0C0000            JMP     <ERROR
1355   
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timCCDmisc.s  Page 27



1356   
1357                            ; Set the video processor gain and integrator speed for all video boards
1358                            ;  Command syntax is  SGN  #GAIN  #SPEED, #GAIN = 1, 2, 5 or 10
1359                            ;                                         #SPEED = 0 for slow, 1 for fast
1360      P:05D0 P:05D0 0D055A  ST_GAIN   JSR     <SER_ANA                          ; Set SSI to analog board communication
1361      P:05D1 P:05D1 56DC00            MOVE              X:(R4)+,A               ; Gain value (1,2,5 or 10)
1362      P:05D2 P:05D2 44F400            MOVE              #>1,X0
                        000001
1363      P:05D4 P:05D4 200045            CMP     X0,A                              ; Check for gain = x1
1364      P:05D5 P:05D5 0E25D9            JNE     <STG2
1365      P:05D6 P:05D6 57F400            MOVE              #>$77,B
                        000077
1366      P:05D8 P:05D8 0C05ED            JMP     <STG_A
1367      P:05D9 P:05D9 44F400  STG2      MOVE              #>2,X0                  ; Check for gain = x2
                        000002
1368      P:05DB P:05DB 200045            CMP     X0,A
1369      P:05DC P:05DC 0E25E0            JNE     <STG5
1370      P:05DD P:05DD 57F400            MOVE              #>$BB,B
                        0000BB
1371      P:05DF P:05DF 0C05ED            JMP     <STG_A
1372      P:05E0 P:05E0 44F400  STG5      MOVE              #>5,X0                  ; Check for gain = x5
                        000005
1373      P:05E2 P:05E2 200045            CMP     X0,A
1374      P:05E3 P:05E3 0E25E7            JNE     <STG10
1375      P:05E4 P:05E4 57F400            MOVE              #>$DD,B
                        0000DD
1376      P:05E6 P:05E6 0C05ED            JMP     <STG_A
1377      P:05E7 P:05E7 44F400  STG10     MOVE              #>10,X0                 ; Check for gain = x10
                        00000A
1378      P:05E9 P:05E9 200045            CMP     X0,A
1379      P:05EA P:05EA 0E2000            JNE     <ERROR
1380      P:05EB P:05EB 57F400            MOVE              #>$EE,B
                        0000EE
1381   
1382      P:05ED P:05ED 56DC00  STG_A     MOVE              X:(R4)+,A               ; Integrator Speed (0 for slow, 1 for fast)
1383      P:05EE P:05EE 0ACC00            JCLR    #0,A1,STG_B
                        0005F2
1384      P:05F0 P:05F0 0ACD68            BSET    #8,B1
1385      P:05F1 P:05F1 0ACD69            BSET    #9,B1
1386      P:05F2 P:05F2 44F400  STG_B     MOVE              #$0C3C00,X0
                        0C3C00
1387      P:05F4 P:05F4 20004A            OR      X0,B
1388      P:05F5 P:05F5 5F0000            MOVE                          B,Y:<GAIN   ; Store the GAIN value for later us
1389   
1390                            ; Send this same value to 15 video processor boards whether they exist or not
1391      P:05F6 P:05F6 241000            MOVE              #$100000,X0             ; Increment value
1392      P:05F7 P:05F7 060F80            DO      #15,STG_LOOP
                        0005FC
1393      P:05F9 P:05F9 577000            MOVE              B,X:SSITX               ; Transmit the SSI word
                        00FFEF
1394      P:05FB P:05FB 0D0490            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
1395      P:05FC P:05FC 200048            ADD     X0,B                              ; Increment the video processor board number
1396                            STG_LOOP
1397   
1398      P:05FD P:05FD 0D0561            JSR     <SER_UTL                          ; Return SSI to utility board communication
1399      P:05FE P:05FE 0C0000            JMP     <FINISH
1400      P:05FF P:05FF 56DC00  ERR_SGN   MOVE              X:(R4)+,A
1401      P:0600 P:0600 0D0561            JSR     <SER_UTL                          ; Return SSI to utility board communication
1402      P:0601 P:0601 0C0000            JMP     <ERROR
1403   
1404                            ; Write an arbitraty control word over the SSI link to any register, any board
1405                            ; Command syntax is  WRC number, number is 24-bit number to be sent to any board
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timCCDmisc.s  Page 28



1406                            ;WR_CNTRL
1407                            ;       JSR     <SER_ANA        ; Set SSI to analog board communication
1408                            ;       JSR     <PAL_DLY        ; Wait for the number to be sent
1409                            ;        MOVEP  X:(R4)+,X:SSITX ; Send out the waveform
1410                            ;       JSR     <PAL_DLY        ; Wait for SSI and PAL to be empty
1411                            ;       JSR     <SER_UTL        ; Return SSI to utility board communication
1412                            ;       JMP     <FINISH
1413   
1414   
1415   
1416                            ; Specify subarray readout coordinates, one rectangle only
1417                            ; Call this subroutine BEFORE SET_SUBARRAY_POSITIONS since it
1418                            ; initializes NBOXES
1419                            SET_SUBARRAY_SIZES
1420      P:0602 P:0602 200013            CLR     A
1421      P:0603 P:0603 5E1900            MOVE                          A,Y:<NBOXES ; Number of subimage boxes = 0 to start
1422      P:0604 P:0604 44DC00            MOVE              X:(R4)+,X0
1423      P:0605 P:0605 4C1A00            MOVE                          X0,Y:<NR_BIAS ; Number of bias pixels to read
1424      P:0606 P:0606 44DC00            MOVE              X:(R4)+,X0
1425      P:0607 P:0607 4C1B00            MOVE                          X0,Y:<NS_READ ; Number of columns in subimage read
1426      P:0608 P:0608 44DC00            MOVE              X:(R4)+,X0
1427      P:0609 P:0609 4C1C00            MOVE                          X0,Y:<NP_READ ; Number of rows in subimage read
1428      P:060A P:060A 0C0000            JMP     <FINISH
1429   
1430                            ; Call this routine once for every subarray to be added to the table
1431                            ; Note that the way the variables are arranged the subframes all are the
1432                            ; same dimensions.  They also cannot overlap in the row direction.
1433                            ; SET_SUBARRAY_SIZES must be called first to initialize NBOXES
1434                            SET_SUBARRAY_POSITIONS
1435      P:060B P:060B 4C9900            MOVE                          Y:<NBOXES,X0 ; Next available slot
1436      P:060C P:060C 458000            MOVE              X:<THREE,X1
1437      P:060D P:060D 2000A0            MPY     X0,X1,A
1438      P:060E P:060E 200022            ASR     A
1439      P:060F P:060F 210C00            MOVE              A0,A1
1440      P:0610 P:0610 44F400            MOVE              #>24,X0
                        000018
1441      P:0612 P:0612 200045            CMP     X0,A
1442      P:0613 P:0613 0E7000            JGT     <ERROR                            ; Error if number of boxes > 9
1443      P:0614 P:0614 44F400            MOVE              #READ_TABLE,X0
                        00001D
1444      P:0616 P:0616 200040            ADD     X0,A
1445      P:0617 P:0617 219700            MOVE              A1,R7
1446      P:0618 P:0618 44DC00            MOVE              X:(R4)+,X0
1447      P:0619 P:0619 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of rows (parallels) to clear
1448      P:061A P:061A 44DC00            MOVE              X:(R4)+,X0
1449      P:061B P:061B 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears before
1450      P:061C P:061C 44DC00            MOVE              X:(R4)+,X0              ;  the box readout
1451      P:061D P:061D 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears after
1452      P:061E P:061E 5E9900            MOVE                          Y:<NBOXES,A ;  the box readout
1453      P:061F P:061F 448000            MOVE              X:<ONE,X0
1454      P:0620 P:0620 200040            ADD     X0,A                              ; Update the next available slot position
1455      P:0621 P:0621 5E1900            MOVE                          A,Y:<NBOXES
1456      P:0622 P:0622 0C0000            JMP     <FINISH
1457   
1458                            ; Alert the PCI interface board that images are coming soon
1459                            ; This tells the PCI card how many pixels to expect for each SEX command
1460                            ; This is fairly complex.  The first value sent is NSR*NPR (NAXIS1*NAXIS2).
1461                            ; The second value is IFRAMES, but if NBOXES > 0, it is IFRAMES*NBOXES
1462                            PCI_READ_IMAGE
1463      P:0623 P:0623 44F400            MOVE              #$020104,X0             ; Send header word to the FO transmitter
                        020104
1464      P:0625 P:0625 0D063E            JSR     <XMT_FO
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  timCCDmisc.s  Page 29



1465      P:0626 P:0626 44F400            MOVE              #'RDA',X0
                        524441
1466      P:0628 P:0628 0D063E            JSR     <XMT_FO
1467      P:0629 P:0629 4CF000            MOVE                          Y:NSR,X0    ; NSR = NAXIS1
                        000001
1468      P:062B P:062B 4DF000            MOVE                          Y:NPR,X1    ; NPR = NAXIS2
                        000002
1469      P:062D P:062D 2000A8            MPY     X0,X1,B
1470      P:062E P:062E 20002A            ASR     B                                 ; Correct for multiplication left shift
1471      P:062F P:062F 212400            MOVE              B0,X0
1472      P:0630 P:0630 0D063E            JSR     <XMT_FO                           ; Send NSR*NPR to PCI card
1473      P:0631 P:0631 4CF000            MOVE                          Y:IFRAMES,X0 ; IFRAMES = NAXIS3
                        00003A
1474      P:0633 P:0633 5E9900            MOVE                          Y:<NBOXES,A ; If NBOXES = 0, transmit that to PCI
1475      P:0634 P:0634 200003            TST     A
1476      P:0635 P:0635 0AF0AA            JEQ     XMT
                        00063B
1477      P:0637 P:0637 4D9900            MOVE                          Y:<NBOXES,X1 ; If NBOXES = 0, transmit that to PCI
1478      P:0638 P:0638 2000A8            MPY     X0,X1,B                           ; If not, multiply by NBOXES, then send
1479      P:0639 P:0639 20002A            ASR     B                                 ; Correct for multiplication left shift
1480      P:063A P:063A 212400            MOVE              B0,X0                   ; Get only least significant 24 bits
1481      P:063B P:063B 000000  XMT       NOP
1482      P:063C P:063C 0D063E            JSR     <XMT_FO
1483      P:063D P:063D 00000C            RTS
1484   
1485      P:063E P:063E 09C400  XMT_FO    MOVEP             X0,Y:WRFO
1486      P:063F P:063F 060FA0            REP     #15
1487      P:0640 P:0640 000000            NOP
1488      P:0641 P:0641 00000C            RTS
1489   
1490                            ; Check for program overflow
1491                                      IF      @CVS(N,*)-$200>MISC_LEN
1493                                      ENDIF                                     ;  will not overflow
1494   
1495   
1496                            ;**************************************************************************
1497                            ;                                                                         *
1498                            ;    Permanent address register assignments                               *
1499                            ;        R1 - Address of SSI receiver contents                            *
1500                            ;        R2 - Address of SCI receiver contents                            *
1501                            ;        R3 - Pointer to current top of command buffer                    *
1502                            ;        R4 - Pointer to processed contents of command buffer             *
1503                            ;        R5 - Temporary register for processing SSI and SCI contents      *
1504                            ;        R6 - CCD clock driver address for CCD #0 = $FF80                 *
1505                            ;                It is also the A/D address of analog board #0            *
1506                            ;                                                                         *
1507                            ;    Other registers                                                      *
1508                            ;        R0, R7 - Temporary registers used all over the place.            *
1509                            ;        R5 - Can be used as a temporary register but is circular,        *
1510                            ;               modulo 32.                                                *
1511                            ;**************************************************************************
1512   
1513                            ;  Specify execution and load addresses
1514                                      IF      @SCP("HOST","HOST")
1515      P:0130 P:0130                   ORG     P:APL_ADR,P:APL_ADR               ; Download address
1516                                      ELSE
1518                                      ENDIF
1519   
1520                            ;  ***********************   CCD  READOUT   ***********************
1521                            ; RDCCD is now a subroutine
1522   
1523                            RDCCD
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  tim.s  Page 30



1524      P:0130 P:0130 0A31A2            JSET    #STORAGE,X:ISTATUS,RCCD1
                        000134
1525                            ; Do the frame transfer if STORAGE==0, else skip it.
1526      P:0132 P:0132 4DBB00            MOVE                          Y:<S_SIZE,X1
1527      P:0133 P:0133 0D0478            JSR     ISHIFT                            ; Do the frame transfer
1528   
1529                            ; Calculate some readout parameters.
1530                            ; This is also an alternative entry point for skipping the frame transfer
1531                            ; STORAGE also selects ganged or storage only parallels during readout
1532                            ; NO_SKIP skips over the section that parallel skips to the subframe start
1533   
1534      P:0134 P:0134 5E9900  RCCD1     MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1535      P:0135 P:0135 200003            TST     A
1536      P:0136 P:0136 0E2140            JNE     <SUB_IMG
1537      P:0137 P:0137 5C1600            MOVE                          A1,Y:<NP_SKIP ; Zero these all out.  Full frame
1538      P:0138 P:0138 5C1700            MOVE                          A1,Y:<NS_SKP1
1539      P:0139 P:0139 5C1800            MOVE                          A1,Y:<NS_SKP2
1540      P:013A P:013A 5E8100            MOVE                          Y:<NSR,A    ; NSERIALS_READ = NSR
1541      P:013B P:013B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                        00013E
1542      P:013D P:013D 200022            ASR     A                                 ; Split serials require / 2
1543      P:013E P:013E 5E1000            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1544      P:013F P:013F 0C014F            JMP     <SETUP
1545   
1546                            ; Loop over the required number of subimage boxes if NBOXES > 0
1547      P:0140 P:0140 67F400  SUB_IMG   MOVE              #READ_TABLE,R7          ; Parameter table for subimage readout
                        00001D
1548      P:0142 P:0142 061940            DO      Y:<NBOXES,L_NBOXES                ; Loop over number of boxes
                        0001E0
1549      P:0144 P:0144 4CDF00            MOVE                          Y:(R7)+,X0
1550      P:0145 P:0145 4C1600            MOVE                          X0,Y:<NP_SKIP
1551      P:0146 P:0146 4CDF00            MOVE                          Y:(R7)+,X0
1552      P:0147 P:0147 4C1700            MOVE                          X0,Y:<NS_SKP1
1553      P:0148 P:0148 4CDF00            MOVE                          Y:(R7)+,X0
1554      P:0149 P:0149 4C1800            MOVE                          X0,Y:<NS_SKP2
1555      P:014A P:014A 5E9B00            MOVE                          Y:<NS_READ,A
1556      P:014B P:014B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                        00014E
1557      P:014D P:014D 200022            ASR     A
1558      P:014E P:014E 5E1000            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1559   
1560                            ; Calculate the fast readout parameters
1561      P:014F P:014F 0D0342  SETUP     JSR     <SETUP_SUBROUTINE
1562   
1563                            ; Skip over the required number of rows for subimage readout
1564                            ; If #NO_SKIP == 0 skip rows up to first subframe, storage clocks only
1565      P:0150 P:0150 0A31A0            JSET    #NO_SKIP,X:ISTATUS,CLR_SR
                        00015A
1566      P:0152 P:0152 5E9600            MOVE                          Y:<NP_SKIP,A ; Number of rows NP_SKIP to skip
1567      P:0153 P:0153 200003            TST     A
1568      P:0154 P:0154 0EA15A            JEQ     <CLR_SR                           ; If zero, skip this shift
1569      P:0155 P:0155 061640            DO      Y:<NP_SKIP,L_SKIP1                ; Clock number of rows to skip
                        000159
1570      P:0157 P:0157 305100            MOVE              #<S_CLEAR,R0            ; SR kept clear with DG
1571      P:0158 P:0158 0D01E7            JSR     <CLOCK
1572      P:0159 P:0159 000000            NOP
1573                            L_SKIP1
1574   
1575                            ; Clear out the accumulated charge from the serial shift register
1576                            ; Leave this commented-out code in until we can test it with a subframe
1577                            ; CLR_SR MOVE   #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1578                            ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  tim.s  Page 31



1579                            ;       NOP
1580                            ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1581                            ;       DO      Y:<NSCLR,*+3            ; Number of waveform entries total
1582                            ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1583                            ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1584   
1585      P:015A P:015A 60F400  CLR_SR    MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel skip
                        00006C
1586      P:015C P:015C 0D01E7            JSR     <CLOCK
1587   
1588                            ; Parallel shift the image into the serial shift register
1589      P:015D P:015D 4C8200            MOVE                          Y:<NPR,X0   ; Number of rows set by host computer
1590      P:015E P:015E 5E9900            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1591      P:015F P:015F 200003            TST     A
1592      P:0160 P:0160 0EA162            JEQ     *+2
1593      P:0161 P:0161 4C9C00            MOVE                          Y:<NP_READ,X0 ; If NBOXES .NE. 0 use subimage table
1594   
1595                            ; Main loop over each line to be read out
1596                            ; If split parallels have to divide NPR by two to be loop counter
1597                            ; Subimages implicitly assumes that parallels are not split
1598      P:0162 P:0162 0A0086            JCLR    #SPLIT_P,X:STATUS,PLOOP           ; skip this if not split parallels
                        000168
1599      P:0164 P:0164 5EF000            MOVE                          Y:NPR,A     ; Get NPR
                        000002
1600      P:0166 P:0166 200022            ASR     A                                 ; Divide by 2
1601      P:0167 P:0167 21C400            MOVE              A,X0                    ; Overwrite loop counter in X0
1602   
1603                            ; Finally start the row loop
1604      P:0168 P:0168 06C400  PLOOP     DO      X0,LPR                            ; Number of rows to read out
                        0001DF
1605   
1606                            ; Check for a command once per line. Only the ABORT command is allowed
1607      P:016A P:016A 0D0000            JSR     <GET_RCV                          ; Was a command received?
1608      P:016B P:016B 0E0170            JCC     <CONT_RD                          ; If no, continue reading out
1609      P:016C P:016C 0C0000            JMP     <CHK_SSI                          ; If yes, go process it
1610   
1611                            ; Abort the readout currently underway
1612                            ABR_RDC
1613      P:016D P:016D 0A0029            BSET    #ST_ABRT,X:<STATUS
1614      P:016E P:016E 0A0084            JCLR    #ST_RDC,X:<STATUS,ABORT_EXPOSURE
                        0004CF
1615                            ; already in readout- so just fall thru and continue,
1616                            ; having set the ST_ABRT flag.
1617                            ; currently we just let this readout segment run to the end and
1618                            ; handle the abort in the outer xxx_PROC code- this has
1619                            ; the advantage of ending the overall exposure on a frame boundary
1620                            ; in the case of 3-d images.
1621                            ; A more abrupt ending of the RDCCD code could be arranged if needed.
1622   
1623                            ;       ENDDO                           ; Properly terminate row loop
1624                            ;       MOVE    Y:<NBOXES,A             ; NBOXES = 0 => full image readout
1625                            ;       TST     A
1626                            ;       JEQ     *+2
1627                            ;       ENDDO                           ; Properly terminate box loop
1628                            ;       RTS                             ; Return early from subroutine
1629   
1630                            ; Move the row into the serial register.
1631      P:0170 P:0170 060640  CONT_RD   DO      Y:<NPBIN,LPR_I                    ; Transfer # of rows, with binning
                        000177
1632      P:0172 P:0172 305A00            MOVE              #<IS_PARALLEL,R0
1633      P:0173 P:0173 0A31A2            JSET    #STORAGE,X:ISTATUS,GANGED         ; if STORAGE == 1 ganged parallels
                        000176
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  tim.s  Page 32



1634      P:0175 P:0175 304000            MOVE              #<S_PARALLEL,R0         ; if STORAGE == 0 store clocks only
1635      P:0176 P:0176 0D01E7  GANGED    JSR     <CLOCK                            ; Parallel clocking
1636      P:0177 P:0177 000000            NOP
1637                            LPR_I
1638   
1639                            ; Skip over NS_SKP1 columns for subimage readout
1640      P:0178 P:0178 5E9700            MOVE                          Y:<NS_SKP1,A ; Number of columns to skip
1641      P:0179 P:0179 200003            TST     A
1642      P:017A P:017A 0EA183            JEQ     <L_READ
1643      P:017B P:017B 0505A1            MOVE              #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1644      P:017C P:017C 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1645      P:017D P:017D 000000            NOP
1646      P:017E P:017E 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1647      P:017F P:017F 061240            DO      Y:<NSKIP1,LS_SKIP1                ; Number of waveform entries total
                        000181
1648      P:0181 P:0181 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1649                            LS_SKIP1
1650      P:0182 P:0182 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1651   
1652                            ; Finally read some real pixels - this is the serial binning routine
1653      P:0183 P:0183 200013  L_READ    CLR     A
1654      P:0184 P:0184 20001B            CLR     B
1655      P:0185 P:0185 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1656      P:0186 P:0186 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                        000006
1657      P:0188 P:0188 200005            CMP     B,A                               ; else do special waveforms via NO_BIN
1658      P:0189 P:0189 0E719A            JGT     <NO_BIN                           ; Skip over general serial binning software
1659      P:018A P:018A 00000B            DEC     B                                 ; serial binning factor minus 1
1660      P:018B P:018B 212700            MOVE              B0,Y1
1661      P:018C P:018C 061040            DO      Y:<NSERIALS_READ,LSR_BIN          ; Number of pixels to read out
                        000198
1662      P:018E P:018E 688E00            MOVE                          Y:<INITIAL_CLOCK,R0 ; (already /2 if split serials)
1663      P:018F P:018F 0D01E7            JSR     <CLOCK
1664                            ;       DO      Y:<NSBIN,LSR_I          ; Bin serially NSBIN times
1665      P:0190 P:0190 06C700            DO      Y1,LSR_I                          ; Bin serially NSBIN times
                        000194
1666      P:0192 P:0192 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1667      P:0193 P:0193 0D01E7            JSR     <CLOCK                            ;   shift register
1668      P:0194 P:0194 000000            NOP
1669                            LSR_I
1670      P:0195 P:0195 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                        0000BB
1671      P:0197 P:0197 0D01E7            JSR     <CLOCK
1672                            ;       MOVE    Y1,Y:<INTERVAL          ; HACK.  Use for debugging
1673      P:0198 P:0198 000000            NOP
1674                            LSR_BIN
1675      P:0199 P:0199 0C01A4            JMP     <OVER_RD                          ; All done binning
1676   
1677                            ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1678      P:019A P:019A 588C00  NO_BIN    MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1679      P:019B P:019B 00000A            DEC     A                                 ; waveform - 1 into M1
1680      P:019C P:019C 04C8A1            MOVE              A0,M1                   ; Modularity
1681      P:019D P:019D 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1682      P:019E P:019E 000000            NOP
1683      P:019F P:019F 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1684      P:01A0 P:01A0 061340            DO      Y:<NREAD,LSR                      ; Number of waveform entries total
                        0001A2
1685      P:01A2 P:01A2 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1686                            LSR
1687      P:01A3 P:01A3 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1688   
1689                            ; If NR_BIAS=0 clobber SR with DG and skip to end of row loop
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  tim.s  Page 33



1690      P:01A4 P:01A4 5E9A00  OVER_RD   MOVE                          Y:<NR_BIAS,A ; Is NR_BIAS zero?
1691      P:01A5 P:01A5 200003            TST     A
1692      P:01A6 P:01A6 0E21AC            JNE     <OVR_RD1                          ; no, go to the NS_SKP2 section
1693      P:01A7 P:01A7 60F400            MOVE              #DUMP_SERIAL,R0         ; yes, clobber SR with DG
                        00006C
1694      P:01A9 P:01A9 0D01E7            JSR     <CLOCK
1695      P:01AA P:01AA 0AF080            JMP     END_ROW                           ; and go to the end of the row loop
                        0001DF
1696                            ; Skip over NS_SKP2 columns for subimage readout to get to overscan region
1697      P:01AC P:01AC 5E9800  OVR_RD1   MOVE                          Y:<NS_SKP2,A ; Number of columns to skip
1698      P:01AD P:01AD 200003            TST     A
1699      P:01AE P:01AE 0EA1B7            JEQ     <L_BIAS
1700      P:01AF P:01AF 0505A1            MOVE              #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1701      P:01B0 P:01B0 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1702      P:01B1 P:01B1 000000            NOP
1703      P:01B2 P:01B2 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1704      P:01B3 P:01B3 061440            DO      Y:<NSKIP2,LS_SKIP2                ; Number of waveform entries total
                        0001B5
1705      P:01B5 P:01B5 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1706                            LS_SKIP2
1707      P:01B6 P:01B6 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1708   
1709                            ; And read the bias pixels if in subimage readout mode
1710                            ; I think this means that if NBOXES==0 you have to have NSR include bias px.
1711      P:01B7 P:01B7 5E9900  L_BIAS    MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1712      P:01B8 P:01B8 200003            TST     A
1713      P:01B9 P:01B9 0EA1DF            JEQ     <END_ROW
1714   
1715                            ; Finally read some real bias pixels
1716      P:01BA P:01BA 200013            CLR     A
1717      P:01BB P:01BB 20001B            CLR     B
1718      P:01BC P:01BC 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1719      P:01BD P:01BD 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                        000006
1720      P:01BF P:01BF 200005            CMP     B,A                               ; else do special waveforms via NO_BIN_BIAS
1721      P:01C0 P:01C0 0E71D5            JGT     <NO_BIN_BIAS                      ; Skip over general serial binning software
1722      P:01C1 P:01C1 00000B            DEC     B                                 ; serial binning factor minus 1
1723      P:01C2 P:01C2 212700            MOVE              B0,Y1
1724      P:01C3 P:01C3 5E9A00            MOVE                          Y:<NR_BIAS,A
1725      P:01C4 P:01C4 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                        0001C7
1726      P:01C6 P:01C6 200022            ASR     A                                 ; Split serials require / 2
1727      P:01C7 P:01C7 06CE00            DO      A,LBIAS_BIN                       ; Number of pixels to read out
                        0001D3
1728      P:01C9 P:01C9 688E00            MOVE                          Y:<INITIAL_CLOCK,R0
1729      P:01CA P:01CA 0D01E7            JSR     <CLOCK
1730      P:01CB P:01CB 06C700            DO      Y1,LBIAS_I                        ; Bin serially NSBIN times
                        0001CF
1731                            ;       DO      Y:<NSBIN,LBIAS_I        ; Bin serially NSBIN times
1732      P:01CD P:01CD 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1733      P:01CE P:01CE 0D01E7            JSR     <CLOCK                            ;   shift register
1734      P:01CF P:01CF 000000            NOP
1735                            LBIAS_I
1736      P:01D0 P:01D0 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                        0000BB
1737      P:01D2 P:01D2 0D01E7            JSR     <CLOCK
1738      P:01D3 P:01D3 000000            NOP
1739                            LBIAS_BIN
1740      P:01D4 P:01D4 0C01DF            JMP     <END_ROW                          ; All done binning
1741   
1742                            ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1743                            ; NBIAS is already divided by 2 in SETUP_SUBROUTINE if split serials.
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  tim.s  Page 34



1744                            NO_BIN_BIAS
1745      P:01D5 P:01D5 588C00            MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1746      P:01D6 P:01D6 00000A            DEC     A                                 ; waveform - 1 into M1
1747      P:01D7 P:01D7 04C8A1            MOVE              A0,M1                   ; Modularity
1748      P:01D8 P:01D8 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1749      P:01D9 P:01D9 000000            NOP
1750      P:01DA P:01DA 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1751      P:01DB P:01DB 061540            DO      Y:<NBIAS,*+3                      ; Number of waveform entries total
                        0001DD
1752      P:01DD P:01DD FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1753      P:01DE P:01DE 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1754      P:01DF P:01DF 000000  END_ROW   NOP
1755      P:01E0 P:01E0 000000  LPR       NOP                                       ; End of parallel loop
1756      P:01E1 P:01E1 000000  L_NBOXES  NOP                                       ; End of subimage boxes loop
1757      P:01E2 P:01E2 000000            NOP
1758      P:01E3 P:01E3 60F400            MOVE              #DCRST_LAST,R0          ; get DC Restore going
                        0000B8
1759      P:01E5 P:01E5 0D01E7            JSR     <CLOCK
1760      P:01E6 P:01E6 00000C            RTS
1761   
1762                            ; ***************** END OF CCD READOUT SUBROUTINE  ************
1763   
1764                            ; Core subroutine for clocking out CCD charge
1765                            ; Must keep in tim.s to insure that it is in fast P memory
1766   
1767      P:01E7 P:01E7 4CD800  CLOCK     MOVE                          Y:(R0)+,X0  ; # of waveform entries
1768      P:01E8 P:01E8 5ED800            MOVE                          Y:(R0)+,A   ; Start the pipeline
1769      P:01E9 P:01E9 06C400            DO      X0,CLK1                           ; Repeat X0 times
                        0001EB
1770      P:01EB P:01EB FA0600            MOVE              A,X:(R6)    Y:(R0)+,A   ; Send out the waveform
1771                            CLK1
1772      P:01EC P:01EC 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1773      P:01ED P:01ED 00000C            RTS                                       ; Return from subroutine
1774   
1775                            ; Check for program overflow
1776                                      IF      @CVS(N,*)>$200
1778                                      ENDIF                                     ;  will not overflow
1779   
1780                            ; ***********  DATA AREAS - READOUT PARAMETERS AND WAVEFORMS  ************
1781                                      IF      @SCP("HOST","HOST")
1782      X:0030 X:0030                   ORG     X:IMGVAR_ADR,X:IMGVAR_ADR
1783      X:0030 X:0030         IMAGE_MODE DC     0
1784      X:0031 X:0031         ISTATUS   DC      0
1785      X:0032 X:0032         DSP_VERS  DC      VERSION                           ; code version must stay in loc,n 32!!
1786      X:0033 X:0033         DSP_FLAV  DC      FLAVOR                            ;  type of dsp support must stay in loc,n 33!!
1787                            ; The next three locations are for tracking the readout timing for gain
1788                            ; calculation, exp-int calculation, and greed factor calculation
1789                            ; They are locations 0x34, 35, and 36
1790      X:0034 X:0034         INTTIM    DC      INT_TIM                           ; per-pixel integration in Leach units
1791      X:0035 X:0035         RDELAY    DC      R_DELAY                           ; serial overlap in Leach units
1792      X:0036 X:0036         SIDELAY   DC      SI_DELAY                          ; parallel overlap in Leach units
1793      X:0037 X:0037         BINBIT    DC      2                                 ; Bit representation of bin factor, bits 1-5
1794                                                                                ; 2 = bit 1 set. Bit zero not used.
1795                                      ENDIF
1796   
1797                            ; Command table - make sure there are exactly 32 entries in it
1798                                      IF      @SCP("HOST","HOST")
1799      X:0080 X:0080                   ORG     X:COM_TBL,X:COM_TBL               ; Download address
1800                                      ELSE
1802                                      ENDIF
1803      X:0080 X:0080                   DC      'IDL',IDL                         ; Put CCD in IDLE mode
1804      X:0082 X:0082                   DC      'STP',STP                         ; Exit IDLE mode
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  tim.s  Page 35



1805      X:0084 X:0084                   DC      'SBV',SETBIAS                     ; Set DC bias supply voltages
1806      X:0086 X:0086                   DC      'RDC',RDCCD                       ; Begin CCD readout
1807      X:0088 X:0088                   DC      'CLR',CLEAR                       ; Fast clear the CCD
1808      X:008A X:008A                   DC      'SGN',ST_GAIN                     ; Set video processor gain
1809      X:008C X:008C                   DC      'SMX',SET_MUX                     ; Set clock driver MUX output
1810   
1811      X:008E X:008E                   DC      'ABR',ABR_RDC                     ; Abort readout
1812      X:0090 X:0090                   DC      'CRD',CONT_RD                     ; Continue reading out
1813      X:0092 X:0092                   DC      'CSW',CLR_SWS                     ; Clear analog switches to lower power
1814      X:0094 X:0094                   DC      'SOS',SEL_OS                      ; Select output source
1815      X:0096 X:0096                   DC      'RCC',READ_CONTROLLER_CONFIGURATION
1816      X:0098 X:0098                   DC      'SSS',SET_SUBARRAY_SIZES
1817      X:009A X:009A                   DC      'SSP',SET_SUBARRAY_POSITIONS
1818      X:009C X:009C                   DC      'DON',START                       ; Nothing special
1819      X:009E X:009E                   DC      'OSH',OPEN_SHUTTER
1820      X:00A0 X:00A0                   DC      'CSH',CLOSE_SHUTTER
1821      X:00A2 X:00A2                   DC      'PON',PWR_ON                      ; Turn on all camera biases and clocks
1822      X:00A4 X:00A4                   DC      'POF',PWR_OFF                     ; Turn +/- 15V power supplies off
1823      X:00A6 X:00A6                   DC      'SET',SET_EXP_TIME                ; Set exposure time
1824      X:00A8 X:00A8                   DC      'SEX',START_FT_EXPOSURE           ; Goes to mode-dependent jump table
1825      X:00AA X:00AA                   DC      'AEX',ABORT_EXPOSURE
1826      X:00AC X:00AC                   DC      'STG',SET_TRIGGER                 ;  Set Trigger Mode on or off
1827      X:00AE X:00AE                   DC      'SIP',SET_IMAGE_PARAM
1828      X:00B0 X:00B0                   DC      'SRC',SET_ROWS_COLUMNS            ; Set NSR, NPR, and binning
1829      X:00B2 X:00B2                   DC      'INF',GET_INFO                    ; info command for versioning and more
1830      X:00B4 X:00B4                   DC      ,0,START,0,START,0,START,0,START
1831   
1832                                      IF      @SCP("HOST","HOST")
1833      Y:0000 Y:0000                   ORG     Y:0,Y:0                           ; Download address
1834                                      ELSE
1836                                      ENDIF
1837   
1838                            ; NSR, NPR, NSBIN, and NPBIN are set by SET_ROWS_COLUMNS
1839      Y:0000 Y:0000         GAIN      DC      0                                 ; Video processor gain and integrator speed
1840      Y:0001 Y:0001         NSR       DC      1072                              ; Number Serial Read, prescan + image + bias
1841      Y:0002 Y:0002         NPR       DC      1030                              ; Number Parallel Read
1842      Y:0003 Y:0003         NS_CLR    DC      1070                              ; To clear serial register, twice
1843      Y:0004 Y:0004         NPCLR     DC      2057                              ; To clear parallel register, twice
1844      Y:0005 Y:0005         NSBIN     DC      1                                 ; Serial binning parameter
1845      Y:0006 Y:0006         NPBIN     DC      1                                 ; Parallel binning parameter
1846      Y:0007 Y:0007         NROWS     DC      1030                              ; Number of physical rows in CCD
1847      Y:0008 Y:0008         NCOLS     DC      1072                              ; Number of physical columns in CCD
1848   
1849                            ; Miscellaneous definitions
1850                            ; Delete TST_DAT since it isn't used.  Need the space so S_SIZE doesn't barf.
1851                            ; TST_DAT       DC      0               ; Temporary definition for test images
1852                            ;SH_DEL DC      3               ; Delay in milliseconds between shutter closing
1853                                                                                ;   and image readout.  Actual delay is 1.5x
1854                                                                                ;   as long as advertised, e.g. 4.5 ms for 3.
1855      Y:0009 Y:0009         SH_DEL    DC      4                                 ; Change needed to kill shift streak after DCRes
1856      Y:000A Y:000A         CONFIG    DC      CC                                ; Controller configuration
1857                            ; Readout peculiarity parameters
1858                             SERIAL_SKIP
1859      Y:000B Y:000B                   DC      SERIAL_SKIP_LEFT                  ; Serial skipping waveforms
1860      Y:000C Y:000C         SERWAVLEN DC      5                                 ; Serial read waveform table length
1861                             SERIAL_CLOCK
1862      Y:000D Y:000D                   DC      SERIAL_CLOCK_LEFT                 ; Serial waveform table
1863                             INITIAL_CLOCK
1864      Y:000E Y:000E                   DC      INITIAL_CLOCK_LEFT                ; Serial waveform table
1865                             PARALLEL_CLOCK
1866      Y:000F Y:000F                   DC      IS_PARALLEL                       ; Addr. of parallel clocking
1867   
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  tim.s  Page 36



1868                             NSERIALS_READ
1869      Y:0010 Y:0010                   DC      0                                 ; Number of serials to read
1870      Y:0011 Y:0011         NSCLR     DC      0                                 ; Number of waveforms in fast mode
1871      Y:0012 Y:0012         NSKIP1    DC      0                                 ; Number of waveforms in fast mode
1872      Y:0013 Y:0013         NREAD     DC      0                                 ; Number of waveforms in fast mode
1873      Y:0014 Y:0014         NSKIP2    DC      0                                 ; Number of waveforms in fast mode
1874      Y:0015 Y:0015         NBIAS     DC      0                                 ; Number of waveforms in fast mode
1875   
1876                            ; These three parameters are read from the READ_TABLE when needed by the
1877                            ;   RDCCD routine as it loops through the required number of boxes
1878      Y:0016 Y:0016         NP_SKIP   DC      0                                 ; Number of rows to skip
1879      Y:0017 Y:0017         NS_SKP1   DC      0                                 ; Number of serials to clear before read
1880      Y:0018 Y:0018         NS_SKP2   DC      0                                 ; Number of serials to clear after read
1881   
1882                            ; Subimage readout parameters. Ten subimage boxes maximum.
1883                            ; All subimage boxes are the same size, NS_READ x NP_READ
1884                            ; NR_BIAS, NS_READ, and NP_READ are set by SET_SUBARRAY_SIZES
1885                            ; The READ_TABLE entries and implicitly NBOXES are set by SET_SUBARRAY_POSITIONS
1886      Y:0019 Y:0019         NBOXES    DC      0                                 ; Number of boxes to read
1887      Y:001A Y:001A         NR_BIAS   DC      0                                 ; Number of bias pixels to read
1888      Y:001B Y:001B         NS_READ   DC      0                                 ; Number of columns per box
1889      Y:001C Y:001C         NP_READ   DC      0                                 ; Number of rows per box
1890      Y:001D Y:001D         READ_TABLE DC     0,0,0                             ; #1 = Number of rows to clear,
1891      Y:0020 Y:0020                   DC      0,0,0                             ; #2 = Number of columns to skip before
1892      Y:0023 Y:0023                   DC      0,0,0                             ;   subimage read
1893      Y:0026 Y:0026                   DC      0,0,0                             ; #3 = Number of columns to clear after
1894      Y:0029 Y:0029                   DC      0,0,0                             ;   subimage read to get to overscan area
1895      Y:002C Y:002C                   DC      0,0,0
1896      Y:002F Y:002F                   DC      0,0,0
1897      Y:0032 Y:0032                   DC      0,0,0
1898      Y:0035 Y:0035                   DC      0,0,0
1899   
1900                            ; IMAGE_MODE, SROWS, IFRAMES, and INTERVAL are set by SET_IMAGE_PARAM
1901                            ; UBSROWS is set later on by UB_CONV.  S_SIZE is hardwired.
1902      Y:0038 Y:0038         SROWS     DC      1                                 ; Number of Storage image rows to Loop over
1903      Y:0039 Y:0039         UBSROWS   DC      1                                 ; SROWS in unbinned pixels.  Set by UB_CONV
1904      Y:003A Y:003A         IFRAMES   DC      1                                 ; Number of Series frames to Loop over
1905      Y:003B Y:003B         S_SIZE    DC      1033                              ; Number of rows in the Storage Array
1906                                                                                ; NOTE: Not equal to # rows in image area!
1907      Y:003C Y:003C         INTERVAL  DC      7                                 ; Interval to pause for soft trigger
1908      Y:003D Y:003D         AMPVAL    DC      0                                 ; Amplifier selected
1909      Y:003E Y:003E         IFLPCNT   DC      0                                 ; 24-bit IFRAMES loop counter for timmisc.s
1910      Y:003F Y:003F         TESTLOC1  DC      0                                 ; Test location
1911                            ; NOTE:  TESTLOC1 is address 63 in the Y memory.  There are addressing problems
1912                            ; starting at the next address (64).
1913   
1914                            ; Include the waveform table
1915                                      INCLUDE "HIPO_DD.waveforms.s"             ; Readout and clocking waveforms
1916                            ; Waveform tables and definitions for the e2v DD 1K sq. frame
1917                            ; transfer CCD for HIPO.
1918                            ;
1919   
1920                            ; CCD clock voltage definitions
1921      000000                VIDEO     EQU     $000000                           ; Video processor board select = 0
1922      002000                CLK2      EQU     $002000                           ; Clock driver board select = 2
1923      003000                CLK3      EQU     $003000                           ; Clock driver board select = 3
1924      000800                CLK_ZERO  EQU     $000800                           ; Zero volts on clock driver line
1925      000800                BIAS_ZERO EQU     $000800                           ;
1926   
1927                            ; Select INT_TIM by value of 1D macro defined in Makefile or
1928                            ; environment. If one of the values indicated is not set, INT_TIM will be
1929                            ; undefined and the assemble will fail.
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 37



1930                            ; see the Confluence page for gwaves timing board port,
1931                            ; at the end of dated entry for July 1 2010
1932                            ; http://jumar.lowell.edu/confluence/display/GWAVES/Notes+On+Port+of++Timing+Board+DSP+to+Gen-iii+GW
AVES+CCD
1933                            ;
1934                            ; Please keep the tooltip commentn remarks as and where they are,
1935                            ; right before the EQU
1936   
1937                                      IF      @SCP("1D","04")
1941                                      ENDIF
1942                                      IF      @SCP("1D","08")
1946                                      ENDIF
1947                                      IF      @SCP("1D","15")
1951                                      ENDIF
1952                                      IF      @SCP("1D","1D")
1953                            ; 1.8 us/px - use gain 4.75, best overall
1954                            ; <tooltip comment1> Covers full dynamic range of CCD
1955      1D0000                INT_TIM   EQU     $1D0000
1956                                      ENDIF
1957                                      IF      @SCP("1D","47")
1961                                      ENDIF
1962                                      IF      @SCP("1D","6D")
1966                                      ENDIF
1967                                      IF      @SCP("1D","92")
1971                                      ENDIF
1972                            ;ADC_TIM                EQU     $0C0000 ; Slow ADC TIME
1973                            ; <tooltip comment1> Not a standard DSP
1974      000000                ADC_TIM   EQU     $000000                           ; Fast ADC TIME
1975   
1976                            ; Delay numbers in clocking
1977                            ; Select SI_DELAY by value of 82 macro defined in Makefile or
1978                            ; environment. If one of the values indicated is not set, SI_DELAY will be
1979                            ; undefined and the assemble will fail.
1980                            ; see the Confluence page for gwaves timing board port,
1981                            ; at the end of dated entry for July 1 2010
1982                            ; http://jumar.lowell.edu/confluence/display/GWAVES/Notes+On+Port+of++Timing+Board+DSP+to+Gen-iii+GW
AVES+CCD
1983                            ; Please keep the tooltip commentn remarks as and where they are,
1984                            ; right before the EQU
1985   
1986                                      IF      @SCP("82","82")
1987                            ; Fast Storage/Image Delay
1988                            ; <tooltip comment2> Very low light and moderately unflattenable
1989      820000                SI_DELAY  EQU     $820000
1990                                      ENDIF
1991                                      IF      @SCP("82","84")
1995                                      ENDIF
1996                                      IF      @SCP("82","85")
2000                                      ENDIF
2001                                      IF      @SCP("82","86")
2005                                      ENDIF
2006                                      IF      @SCP("82","89")
2010                                      ENDIF
2011                                      IF      @SCP("82","8B")
2015                                      ENDIF
2016                                      IF      @SCP("82","8C")
2020                                      ENDIF
2021                                      IF      @SCP("82","C0")
2025                                      ENDIF
2026   
2027                            ; Select R_DELAY by value of 00 macro defined in Makefile or
2028                            ; environment. If one of the values indicated is not set, R_DELAY will be
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 38



2029                            ; undefined and the assemble will fail.
2030                            ; see the Confluence page for gwaves timing board port,
2031                            ; at the end of dated entry for July 1 2010
2032                            ; http://jumar.lowell.edu/confluence/display/GWAVES/Notes+On+Port+of++Timing+Board+DSP+to+Gen-iii+GW
AVES+CCD
2033   
2034                                      IF      @SCP("00","00")
2035                            ; Fast serial register transfer delay
2036      000000                R_DELAY   EQU     $000000
2037                                      ENDIF
2038                                      IF      @SCP("00","08")
2041                                      ENDIF
2042   
2043      000000                SKIP_DELAY EQU    $000000                           ; Serial register skipping delay
2044   
2045                            ; DEEP DEPLETION LEVELS
2046                            ; These are available for use during integration & readout
2047                            ; FIX!!- Old New Data Sheet remarks are from ccd47.
2048                            ; Clock voltages in volts                       Old     New     Data Sheet
2049      9.000000E+000         RG_HI_D   EQU     +9.0                              ; Reset                  1.5     3.0     4
2050      -3.000000E+000        RG_LO_D   EQU     -3.0                              ;                       -3.0    -9.0    -8
2051      8.000000E+000         R_HI_D    EQU     +8.0                              ; Serials                4.65    4.5     2
2052      -2.000000E+000        R_LO_D    EQU     -2.0                              ;                       -6.6    -6.5    -8
2053      9.000000E+000         SI_HI_D   EQU     +9.0                              ; Parallels              3.7     4.0     4
2054      -3.000000E+000        SI_LO_D   EQU     -3.0                              ;                       -6.9    -7.0    -8
2055      9.000000E+000         DG_HI_D   EQU     +9.0                              ; Dump Gate
2056      -3.000000E+000        DG_LO_D   EQU     -3.0                              ;                                       -8
2057   
2058                            ; FIX!!- Old New Data Sheet remarks are from ccd47.
2059                            ; DC Bias voltages in volts                     Old     New     Data Sheet
2060      2.700000E+001         VODL_D    EQU     27.0                              ; Output Drain Left     25.1    24      21
2061      2.700000E+001         VODR_D    EQU     27.0                              ; Output Drain Right    25.1    24
2062      1.500000E+001         VRDL_D    EQU     15.00                             ; Reset Drain Left      12.2    11      10
2063      1.500000E+001         VRDR_D    EQU     15.00                             ; Reset Drain Right
2064      0.000000E+000         VOG_D     EQU     0.0                               ; Output Gate           -1.2    -3      -5
2065      -3.000000E+000        VABG_D    EQU     -3.0                              ; Anti-blooming gate    -5.0    -5      -8
2066   
2067                            ; We have these for DD levels only since that's the only imaging level
2068                            ; these give 5k for the pedestal
2069                            ;OFFSET EQU     $700
2070                            ;OFFSET0        EQU     $700    ; Left Side Of Frame
2071                            ;OFFSET1        EQU     $6EF    ; Right Side Of Frame
2072   
2073                            ; these give 1k for the pedestal
2074      000A98                OFFSET    EQU     $A98
2075      000A98                OFFSET0   EQU     $A98                              ; Left Side Of Frame
2076      000A87                OFFSET1   EQU     $A87                              ; Right Side Of Frame
2077   
2078                            ; INVERTED LEVELS
2079                            ; These are available for use during startup & idling
2080                            ; FIX!!- Old New Data Sheet remarks are from ccd47.
2081                            ; Clock voltages in volts                       Old     New     Data Sheet
2082      2.500000E+000         RG_HI_I   EQU     +2.5                              ; Reset                  1.5     3.0     4
2083      -9.500000E+000        RG_LO_I   EQU     -9.5                              ;                       -3.0    -9.0    -8
2084      1.500000E+000         R_HI_I    EQU     +1.5                              ; Serials                4.65    4.5     2
2085      -8.500000E+000        R_LO_I    EQU     -8.5                              ;                       -6.6    -6.5    -8
2086      2.500000E+000         SI_HI_I   EQU     +2.5                              ; Parallels              3.7     4.0     4
2087      -9.500000E+000        SI_LO_I   EQU     -9.5                              ;                       -6.9    -7.0    -8
2088      2.500000E+000         DG_HI_I   EQU     +2.5                              ; Dump Gate
2089      -9.500000E+000        DG_LO_I   EQU     -9.5                              ;                                       -8
2090   
2091                            ; FIX!!- Old New Data Sheet remarks are from ccd47.
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 39



2092                            ; DC Bias voltages in volts                     Old     New     Data Sheet
2093      2.050000E+001         VODL_I    EQU     20.5                              ; Output Drain Left     25.1    24      21
2094      2.050000E+001         VODR_I    EQU     20.5                              ; Output Drain Right    25.1    24
2095      9.000000E+000         VRDL_I    EQU     9.00                              ; Reset Drain Left      12.2    11      10
2096      9.000000E+000         VRDR_I    EQU     9.00                              ; Reset Drain Right
2097      -6.500000E+000        VOG_I     EQU     -6.5                              ; Output Gate           -1.2    -3      -5
2098      -9.500000E+000        VABG_I    EQU     -9.5                              ; Anti-blooming gate    -5.0    -5      -8
2099   
2100                            ; TRANSITION LEVELS
2101                            ; These are available for the sole purpose of buffering voltage swings
2102                            ; FIX!!- Old New Data Sheet remarks are from ccd47.
2103                            ; Clock voltages in volts                       Old     New     Data Sheet
2104      2.500000E+000         RG_HI_T   EQU     +2.5                              ; Reset                  1.5     3.0     4
2105      -3.000000E+000        RG_LO_T   EQU     -3.0                              ;                       -3.0    -9.0    -8
2106      1.500000E+000         R_HI_T    EQU     +1.5                              ; Serials                4.65    4.5     2
2107      -2.000000E+000        R_LO_T    EQU     -2.0                              ;                       -6.6    -6.5    -8
2108      2.500000E+000         SI_HI_T   EQU     +2.5                              ; Parallels              3.7     4.0     4
2109      -3.000000E+000        SI_LO_T   EQU     -3.0                              ;                       -6.9    -7.0    -8
2110      2.500000E+000         DG_HI_T   EQU     +2.5                              ; Dump Gate
2111      -3.000000E+000        DG_LO_T   EQU     -3.0                              ;                                       -8
2112   
2113                            ; FIX!!- Old New Data Sheet remarks are from ccd47.
2114                            ; DC Bias voltages in volts                     Old     New     Data Sheet
2115      2.050000E+001         VODL_T    EQU     20.5                              ; Output Drain Left     25.1    24      21
2116      2.050000E+001         VODR_T    EQU     20.5                              ; Output Drain Right    25.1    24
2117      9.000000E+000         VRDL_T    EQU     9.00                              ; Reset Drain Left      12.2    11      10
2118      9.000000E+000         VRDR_T    EQU     9.00                              ; Reset Drain Right
2119      0.000000E+000         VOG_T     EQU     0.0                               ; Output Gate           -1.2    -3      -5
2120      -3.000000E+000        VABG_T    EQU     -3.0                              ; Anti-blooming gate    -5.0    -5      -8
2121   
2122                            ; Define switch state bits for the lower CCD clock driver bank CLK2
2123      000001                H1L       EQU     1                                 ; Serial #1 Left, Pin 1 - clock 0
2124      000002                H2L       EQU     2                                 ; Serial #2 Left, Pin 2 - clock 1
2125      000004                H3L       EQU     4                                 ; Serial #3 Left, Pin 3 - clock 2
2126      000008                H1R       EQU     8                                 ; Serial #1 Right, Pin 4 - clock 3
2127      000010                H2R       EQU     $10                               ; Serial #2 Right, Pin 5 - clock 4
2128      000020                H3R       EQU     $20                               ; Serial #2 Right, Pin 6 - clock 5
2129      000100                RGL       EQU     $100                              ; Reset Gate Left, Pin 9 - clock 8
2130      000200                RGR       EQU     $200                              ; Reset Gate Right, Pin 10 - clock 9
2131   
2132                            ; Pins 9-12 are not used
2133   
2134                            ; Define switch state bits for the upper CCD clock driver bank CLK3
2135      000001                I1        EQU     1                                 ; Image, phase #1, Pin 13 - clock 12
2136      000002                I2        EQU     2                                 ; Image, phase #2, Pin 14 - clock 13
2137      000004                I3        EQU     4                                 ; Image, phase #3, Pin 15 - clock 14
2138      000008                S1        EQU     8                                 ; Storage, phase #1, Pin 16 - clock 15
2139      000010                S2        EQU     $10                               ; Storage, phase #2, Pin 17 - clock 16
2140      000020                S3        EQU     $20                               ; Storage, phase #3, Pin 18 - clock 17
2141      000100                DG        EQU     $100                              ; Dump Gate, Pin 34 - clock 20
2142   
2143                            ;  ***  Definitions for Y: memory waveform tables  *****
2144                            ; Clock only the Storage clocks : S1->S2->S3
2145                            S_PARALLEL
2146      Y:0040 Y:0040                   DC      END_S_PARALLEL-S_PARALLEL-2
2147      Y:0041 Y:0041                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
2148      Y:0042 Y:0042                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2149                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
2150      Y:0043 Y:0043                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00
2151      Y:0044 Y:0044                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00
2152      Y:0045 Y:0045                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3
2153      Y:0046 Y:0046                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 40



2154      Y:0047 Y:0047                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3
2155      Y:0048 Y:0048                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
2156                            END_S_PARALLEL
2157   
2158                            ; Reverse clock only the Storage clocks : S1->S3->S2->S1
2159                            ; Use in pipelined occultation mode
2160                            R_S_PARALLEL
2161      Y:0049 Y:0049                   DC      END_R_S_PARALLEL-R_S_PARALLEL-2
2162      Y:004A Y:004A                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2163      Y:004B Y:004B                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3
2164      Y:004C Y:004C                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3
2165      Y:004D Y:004D                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3
2166      Y:004E Y:004E                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00
2167      Y:004F Y:004F                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00
2168      Y:0050 Y:0050                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
2169                            END_R_S_PARALLEL
2170   
2171                            ; Clock only the Storage clocks : S1->S2->S3 with DG
2172                            S_CLEAR
2173      Y:0051 Y:0051                   DC      END_S_CLEAR-S_CLEAR-2
2174      Y:0052 Y:0052                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
2175      Y:0053 Y:0053                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2176                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
2177      Y:0054 Y:0054                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00+DG
2178      Y:0055 Y:0055                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00+DG
2179      Y:0056 Y:0056                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3+DG
2180      Y:0057 Y:0057                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3+DG
2181      Y:0058 Y:0058                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3+DG
2182      Y:0059 Y:0059                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
2183                            END_S_CLEAR
2184                            ; 2 microsecond delay before readout starts may be needed here
2185                            ;       DC      CLK3+$600000+I1+00+00+S1+00+0000
2186   
2187                            ; Clock both the Storage and Image clocks : I1->I2->I3 and S1->S2->S3
2188                            IS_PARALLEL
2189      Y:005A Y:005A                   DC      END_IS_PARALLEL-IS_PARALLEL-2
2190      Y:005B Y:005B                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
2191      Y:005C Y:005C                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2192                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
2193      Y:005D Y:005D                   DC      CLK3+SI_DELAY+I1+I2+00+S1+S2+00
2194      Y:005E Y:005E                   DC      CLK3+SI_DELAY+00+I2+00+00+S2+00
2195      Y:005F Y:005F                   DC      CLK3+SI_DELAY+00+I2+I3+00+S2+S3
2196      Y:0060 Y:0060                   DC      CLK3+SI_DELAY+00+00+I3+00+00+S3
2197      Y:0061 Y:0061                   DC      CLK3+SI_DELAY+I1+00+I3+S1+00+S3
2198      Y:0062 Y:0062                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
2199                            END_IS_PARALLEL
2200   
2201                            ; Clock both the Storage and Image clocks : I1->I2->I3 and S1->S2->S3
2202                            IS_CLEAR
2203      Y:0063 Y:0063                   DC      IS_CLEAR_END-IS_CLEAR-2
2204      Y:0064 Y:0064                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
2205      Y:0065 Y:0065                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2206                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+00 ; Probably not needed
2207      Y:0066 Y:0066                   DC      CLK3+SI_DELAY+I1+I2+00+S1+S2+00+DG
2208      Y:0067 Y:0067                   DC      CLK3+SI_DELAY+00+I2+00+00+S2+00+DG
2209      Y:0068 Y:0068                   DC      CLK3+SI_DELAY+00+I2+I3+00+S2+S3+DG
2210      Y:0069 Y:0069                   DC      CLK3+SI_DELAY+00+00+I3+00+00+S3+DG
2211      Y:006A Y:006A                   DC      CLK3+SI_DELAY+I1+00+I3+S1+00+S3+DG
2212      Y:006B Y:006B                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
2213                            IS_CLEAR_END
2214   
2215                            DUMP_SERIAL
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 41



2216      Y:006C Y:006C                   DC      END_DUMP_SERIAL-DUMP_SERIAL-2
2217      Y:006D Y:006D                   DC      CLK2+SI_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2218      Y:006E Y:006E                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
2219      Y:006F Y:006F                   DC      CLK2+SI_DELAY+RGL+RGR+000+000+000+000+000+000
2220      Y:0070 Y:0070                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+00
2221      Y:0071 Y:0071                   DC      CLK2+SI_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2222                            END_DUMP_SERIAL
2223                                    COMMENT *
2224                            ; Michigan AIMO clocking - this is vestigial and commented out
2225                            PARALLEL DC     PARALLEL_CLEAR-PARALLEL-2
2226                                    DC      CLK2+$000000+RGL+RGR+H1L+H1R+H2L+H2R+00+000+000+00
2227                                    DC      CLK3+P_DELAY+00+00+I3
2228                                    DC      CLK3+P_DELAY+00+00+I3
2229                                    DC      CLK3+P_DELAY+I1+00+I3
2230                                    DC      CLK3+P_DELAY+I1+00+00
2231                                    DC      CLK3+P_DELAY+I1+I2+00
2232                                    DC      CLK3+P_DELAY+00+I2+00
2233                                    DC      CLK3+P_DELAY+00+I2+I3
2234                                    DC      CLK3+P_DELAY+00+00+I3
2235                                    DC      CLK3+P_DELAY+00+00+I3
2236                                    DC      CLK3+P_DELAY+00+00+00
2237                                    *
2238   
2239                            ; For serial clocking we know that the serial registers are laid out as
2240                            ; follows for a backside part per communication with Paul Jorden:
2241   
2242                            ;          Right Side               Left Side
2243                            ;       OG  3  2  1  3 .........  3  2  1  3  OG
2244   
2245                            ; Left amp is   2 -> 1 -> 3
2246                            ; Right amp is  1 -> 2 -> 3
2247   
2248                            ; For a frontside part the left and right are reversed.
2249                            ; Parallel phase 3 dumps into serial 1 and 2.
2250   
2251                            ; Between serial clock code lumps the serials are left as follows:
2252                            ; LEFT  Phase 2 L and R both high
2253                            ; RIGHT Phase 1 L and R both high
2254                            ; SPLIT H1R and H2L are high
2255   
2256                            ; Video processor bit definition
2257                            ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2258   
2259                            SERIAL_IDLE                                         ; Split serial
2260      Y:0072 Y:0072                   DC      END_SERIAL_IDLE-SERIAL_IDLE-2
2261      Y:0073 Y:0073                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2262      Y:0074 Y:0074                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2263      Y:0075 Y:0075                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2264      Y:0076 Y:0076                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2265      Y:0077 Y:0077                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2266      Y:0078 Y:0078                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2267      Y:0079 Y:0079                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2268      Y:007A Y:007A                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2269      Y:007B Y:007B                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2270      Y:007C Y:007C                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2271      Y:007D Y:007D                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2272      Y:007E Y:007E                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2273                            ; Not needed, so comment out
2274                            ;       DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2275                            END_SERIAL_IDLE
2276   
2277                            ; The following waveforms are for binned operation.  This is tricky with the
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 42



2278                            ; CCD47 because it doesn't have a summing well.  The reset level integration
2279                            ; has to happen before serial 3 drops for the first time and the data level
2280                            ; integration has to happen after it drops for the last time.  The initial
2281                            ; clocks go through the reset integration, the serial clocks are the
2282                            ; intervening clocks for additional pixels binned with the first one, and
2283                            ; the video process is left to do the last clock and data integration.
2284   
2285                            INITIAL_CLOCK_SPLIT                                 ; Both amplifiers
2286      Y:007F Y:007F                   DC      END_INITIAL_CLOCK_SPLIT-INITIAL_CLOCK_SPLIT-2
2287      Y:0080 Y:0080                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2288      Y:0081 Y:0081                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2289      Y:0082 Y:0082                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2290      Y:0083 Y:0083                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2291      Y:0084 Y:0084                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2292      Y:0085 Y:0085                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2293      Y:0086 Y:0086                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2294      Y:0087 Y:0087                   DC      $00F020                           ; Transmit A/D data to host
2295      Y:0088 Y:0088                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2296      Y:0089 Y:0089                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2297      Y:008A Y:008A                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2298                            END_INITIAL_CLOCK_SPLIT
2299   
2300                            INITIAL_CLOCK_RIGHT                                 ; Serial right, Swap S1L and S2L
2301      Y:008B Y:008B                   DC      END_INITIAL_CLOCK_RIGHT-INITIAL_CLOCK_RIGHT-2
2302      Y:008C Y:008C                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2303      Y:008D Y:008D                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2304      Y:008E Y:008E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2305      Y:008F Y:008F                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2306      Y:0090 Y:0090                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2307      Y:0091 Y:0091                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2308      Y:0092 Y:0092                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2309      Y:0093 Y:0093                   DC      $00F021                           ; Transmit A/D data to host
2310      Y:0094 Y:0094                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2311      Y:0095 Y:0095                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2312      Y:0096 Y:0096                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2313                            END_INITIAL_CLOCK_RIGHT
2314   
2315                            INITIAL_CLOCK_LEFT                                  ; Serial left, Swap S1R and S2R
2316      Y:0097 Y:0097                   DC      END_INITIAL_CLOCK_LEFT-INITIAL_CLOCK_LEFT-2
2317      Y:0098 Y:0098                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2318      Y:0099 Y:0099                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2319      Y:009A Y:009A                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2320      Y:009B Y:009B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2321      Y:009C Y:009C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2322      Y:009D Y:009D                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2323      Y:009E Y:009E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2324      Y:009F Y:009F                   DC      $00F000                           ; Transmit A/D data to host
2325      Y:00A0 Y:00A0                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2326      Y:00A1 Y:00A1                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2327      Y:00A2 Y:00A2                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2328                            END_INITIAL_CLOCK_LEFT
2329   
2330                            SERIAL_CLOCK_SPLIT                                  ; Both amplifiers
2331      Y:00A3 Y:00A3                   DC      END_SERIAL_CLOCK_SPLIT-SERIAL_CLOCK_SPLIT-2
2332      Y:00A4 Y:00A4                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2333      Y:00A5 Y:00A5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2334      Y:00A6 Y:00A6                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2335      Y:00A7 Y:00A7                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2336      Y:00A8 Y:00A8                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2337      Y:00A9 Y:00A9                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2338                            END_SERIAL_CLOCK_SPLIT
2339   
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 43



2340                            SERIAL_CLOCK_RIGHT                                  ; Serial right, Swap S1L and S2L
2341      Y:00AA Y:00AA                   DC      END_SERIAL_CLOCK_RIGHT-SERIAL_CLOCK_RIGHT-2
2342      Y:00AB Y:00AB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2343      Y:00AC Y:00AC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2344      Y:00AD Y:00AD                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2345      Y:00AE Y:00AE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2346      Y:00AF Y:00AF                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2347      Y:00B0 Y:00B0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2348                            END_SERIAL_CLOCK_RIGHT
2349   
2350                            SERIAL_CLOCK_LEFT                                   ; Serial left, Swap S1R and S2R
2351      Y:00B1 Y:00B1                   DC      END_SERIAL_CLOCK_LEFT-SERIAL_CLOCK_LEFT-2
2352      Y:00B2 Y:00B2                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2353      Y:00B3 Y:00B3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2354      Y:00B4 Y:00B4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2355      Y:00B5 Y:00B5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2356      Y:00B6 Y:00B6                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2357      Y:00B7 Y:00B7                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2358                            END_SERIAL_CLOCK_LEFT
2359   
2360                            ; need two if you want to call CLOCK
2361                            DCRST_LAST
2362      Y:00B8 Y:00B8                   DC      DCRST_LAST_END-DCRST_LAST-2
2363      Y:00B9 Y:00B9                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
2364      Y:00BA Y:00BA                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
2365                            DCRST_LAST_END
2366   
2367                            VIDEO_PROCESS
2368      Y:00BB Y:00BB                   DC      END_VIDEO_PROCESS-VIDEO_PROCESS-2
2369                            CCLK_1                                              ; The following line is overwritten by timmisc.s
2370      Y:00BC Y:00BC                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2371      Y:00BD Y:00BD                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2372      Y:00BE Y:00BE                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2373                            CCLK_2                                              ; The following line is overwritten by timmisc.s
, but is correct as is.
2374                            ; Actually it shouldn't be needed so comment it out.
2375                            ;       DC      CLK2+S_DLY+S1R+S2R+000+S1L+S2L+000+000+000+000+000
2376                            END_VIDEO_PROCESS
2377   
2378                            ; Starting Y: address of circular waveforms for no-overhead access
2379      0000C0                STRT_CIR  EQU     $C0
2380      000620                ROM_DISP  EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+STRT_CIR
2381      000660                DAC_DISP  EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+$100
2382   
2383                            ; Check for Y: data memory overflow
2384                                      IF      @CVS(N,*)>STRT_CIR
2386                                      ENDIF                                     ;  will not overflow
2387   
2388                            ; The fast serial code with the circulating address register must start
2389                            ;   on a boundary that is a multiple of the address register modulus.
2390   
2391                                      IF      @SCP("HOST","HOST")
2392      Y:00C0 Y:00C0                   ORG     Y:STRT_CIR,Y:STRT_CIR             ; Download address
2393                                      ELSE
2395                                      ENDIF
2396   
2397                            ; This is an area to copy in the serial fast binned waveforms from high Y memory
2398                            ; It is 0x28 = 40 locations long, enough to put in a binned-by-five waveform
2399                            ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2400                            SERIAL_READ
2401      Y:00C0 Y:00C0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2402      Y:00C1 Y:00C1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 44



2403      Y:00C2 Y:00C2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2404      Y:00C3 Y:00C3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2405      Y:00C4 Y:00C4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2406      Y:00C5 Y:00C5                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2407                            SXMIT
2408      Y:00C6 Y:00C6                   DC      $00F000                           ; Transmit A/D data to host
2409      Y:00C7 Y:00C7                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2410      Y:00C8 Y:00C8                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2411      Y:00C9 Y:00C9                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2412      Y:00CA Y:00CA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2413      Y:00CB Y:00CB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2414      Y:00CC Y:00CC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2415      Y:00CD Y:00CD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2416      Y:00CE Y:00CE                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2417      Y:00CF Y:00CF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2418      Y:00D0 Y:00D0                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2419      Y:00D1 Y:00D1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2420      Y:00D2 Y:00D2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2421      Y:00D3 Y:00D3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2422      Y:00D4 Y:00D4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2423      Y:00D5 Y:00D5                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2424      Y:00D6 Y:00D6                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2425      Y:00D7 Y:00D7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2426      Y:00D8 Y:00D8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2427      Y:00D9 Y:00D9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2428      Y:00DA Y:00DA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2429      Y:00DB Y:00DB                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2430      Y:00DC Y:00DC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2431      Y:00DD Y:00DD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2432      Y:00DE Y:00DE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2433      Y:00DF Y:00DF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2434      Y:00E0 Y:00E0                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2435      Y:00E1 Y:00E1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2436      Y:00E2 Y:00E2                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2437      Y:00E3 Y:00E3                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2438      Y:00E4 Y:00E4                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2439                            END_SERIAL
2440   
2441                            ; Serial clocking waveform for skipping
2442                                      IF      @SCP("HOST","HOST")
2443      Y:00E8 Y:00E8                   ORG     Y:STRT_CIR+$28,Y:STRT_CIR+$28     ; Download address
2444                                      ELSE
2446                                      ENDIF
2447   
2448                            ; There are three serial skip waveforms that must all be the same length
2449                            SERIAL_SKIP_LEFT
2450                            ;       DC      END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-2
2451      Y:00E8 Y:00E8                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2452      Y:00E9 Y:00E9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2453      Y:00EA Y:00EA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2454      Y:00EB Y:00EB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2455      Y:00EC Y:00EC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2456      Y:00ED Y:00ED                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2457                            END_SERIAL_SKIP_LEFT
2458   
2459                                      IF      @SCP("HOST","HOST")
2460      Y:00F0 Y:00F0                   ORG     Y:STRT_CIR+$30,Y:STRT_CIR+$30     ; Download address
2461                                      ELSE
2463                                      ENDIF
2464   
2465                            SERIAL_SKIP_RIGHT
2466                            ;       DC      END_SERIAL_SKIP_RIGHT-SERIAL_SKIP_RIGHT-2
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 45



2467      Y:00F0 Y:00F0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2468      Y:00F1 Y:00F1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2469      Y:00F2 Y:00F2                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2470      Y:00F3 Y:00F3                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2471      Y:00F4 Y:00F4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2472      Y:00F5 Y:00F5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2473                            END_SERIAL_SKIP_RIGHT
2474   
2475                                      IF      @SCP("HOST","HOST")
2476      Y:00F8 Y:00F8                   ORG     Y:STRT_CIR+$38,Y:STRT_CIR+$38     ; Download address
2477                                      ELSE
2479                                      ENDIF
2480   
2481                            SERIAL_SKIP_SPLIT
2482                            ;       DC      END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-2
2483      Y:00F8 Y:00F8                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2484      Y:00F9 Y:00F9                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2485      Y:00FA Y:00FA                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2486      Y:00FB Y:00FB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2487      Y:00FC Y:00FC                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2488      Y:00FD Y:00FD                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2489                            END_SERIAL_SKIP_SPLIT
2490   
2491                            ; Put all the following code in SRAM.
2492                                      IF      @SCP("HOST","HOST")
2493      Y:0100 Y:0100                   ORG     Y:$100,Y:$100                     ; Download address
2494                                      ELSE
2496                                      ENDIF
2497   
2498                            ; Initialization of clock driver and video processor DACs and switches
2499                            ; for DD levels used during integration & readout
2500      Y:0100 Y:0100         DACS_DD   DC      END_DACS_DD-DACS_DD-1
2501      Y:0101 Y:0101                   DC      (CLK2<<8)+(0<<14)+@CVI((R_HI_D+10.0)/20.0*4095) ; S1 Left High, pin 1
2502      Y:0102 Y:0102                   DC      (CLK2<<8)+(1<<14)+@CVI((R_LO_D+10.0)/20.0*4095) ; S1 Left Low
2503      Y:0103 Y:0103                   DC      (CLK2<<8)+(2<<14)+@CVI((R_HI_D+10.0)/20.0*4095) ; S2 Left Right High, pin 2
2504      Y:0104 Y:0104                   DC      (CLK2<<8)+(3<<14)+@CVI((R_LO_D+10.0)/20.0*4095) ; S2 Left Low
2505      Y:0105 Y:0105                   DC      (CLK2<<8)+(4<<14)+@CVI((R_HI_D+10.0)/20.0*4095) ; S3 Left High, pin 3
2506      Y:0106 Y:0106                   DC      (CLK2<<8)+(5<<14)+@CVI((R_LO_D+10.0)/20.0*4095) ; S3 Left Low
2507      Y:0107 Y:0107                   DC      (CLK2<<8)+(6<<14)+@CVI((R_HI_D+10.0)/20.0*4095) ; S1 Right High, pin 4
2508      Y:0108 Y:0108                   DC      (CLK2<<8)+(7<<14)+@CVI((R_LO_D+10.0)/20.0*4095) ; S1 Right Low
2509      Y:0109 Y:0109                   DC      (CLK2<<8)+(8<<14)+@CVI((R_HI_D+10.0)/20.0*4095) ; S2 Right High, pin 5
2510      Y:010A Y:010A                   DC      (CLK2<<8)+(9<<14)+@CVI((R_LO_D+10.0)/20.0*4095) ; S2 Right Low
2511      Y:010B Y:010B                   DC      (CLK2<<8)+(10<<14)+@CVI((R_HI_D+10.0)/20.0*4095) ; S3 Right High, pin 6
2512      Y:010C Y:010C                   DC      (CLK2<<8)+(11<<14)+@CVI((R_LO_D+10.0)/20.0*4095) ; S3 Right Low
2513      Y:010D Y:010D                   DC      (CLK2<<8)+(12<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 7
2514      Y:010E Y:010E                   DC      (CLK2<<8)+(13<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2515      Y:010F Y:010F                   DC      (CLK2<<8)+(14<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 8
2516      Y:0110 Y:0110                   DC      (CLK2<<8)+(15<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2517      Y:0111 Y:0111                   DC      (CLK2<<8)+(16<<14)+@CVI((RG_HI_D+10.0)/20.0*4095) ; RG Left High, pin 9
2518      Y:0112 Y:0112                   DC      (CLK2<<8)+(17<<14)+@CVI((RG_LO_D+10.0)/20.0*4095) ; RG Left Low
2519      Y:0113 Y:0113                   DC      (CLK2<<8)+(18<<14)+@CVI((RG_HI_D+10.0)/20.0*4095) ; RG Right High, pin 10
2520      Y:0114 Y:0114                   DC      (CLK2<<8)+(19<<14)+@CVI((RG_LO_D+10.0)/20.0*4095) ; RG Rightd Low
2521      Y:0115 Y:0115                   DC      (CLK2<<8)+(20<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 11
2522      Y:0116 Y:0116                   DC      (CLK2<<8)+(21<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2523      Y:0117 Y:0117                   DC      (CLK2<<8)+(22<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 12
2524      Y:0118 Y:0118                   DC      (CLK2<<8)+(23<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2525      Y:0119 Y:0119                   DC      (CLK2<<8)+(24<<14)+@CVI((SI_HI_D+10.0)/20.0*4095) ; I1 High, pin 13
2526      Y:011A Y:011A                   DC      (CLK2<<8)+(25<<14)+@CVI((SI_LO_D+10.0)/20.0*4095) ; I1 Low
2527      Y:011B Y:011B                   DC      (CLK2<<8)+(26<<14)+@CVI((SI_HI_D+10.0)/20.0*4095) ; I2 High, pin 14
2528      Y:011C Y:011C                   DC      (CLK2<<8)+(27<<14)+@CVI((SI_LO_D+10.0)/20.0*4095) ; I2 Low
2529      Y:011D Y:011D                   DC      (CLK2<<8)+(28<<14)+@CVI((SI_HI_D+10.0)/20.0*4095) ; I3 High, pin 15
2530      Y:011E Y:011E                   DC      (CLK2<<8)+(29<<14)+@CVI((SI_LO_D+10.0)/20.0*4095) ; I3 Low
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 46



2531      Y:011F Y:011F                   DC      (CLK2<<8)+(30<<14)+@CVI((SI_HI_D+10.0)/20.0*4095) ; S1 High, pin 16
2532      Y:0120 Y:0120                   DC      (CLK2<<8)+(31<<14)+@CVI((SI_LO_D+10.0)/20.0*4095) ; S1 Low
2533      Y:0121 Y:0121                   DC      (CLK2<<8)+(32<<14)+@CVI((SI_HI_D+10.0)/20.0*4095) ; S2 High, pin 17
2534      Y:0122 Y:0122                   DC      (CLK2<<8)+(33<<14)+@CVI((SI_LO_D+10.0)/20.0*4095) ; S2 Low
2535      Y:0123 Y:0123                   DC      (CLK2<<8)+(34<<14)+@CVI((SI_HI_D+10.0)/20.0*4095) ; S3 High, pin 18
2536      Y:0124 Y:0124                   DC      (CLK2<<8)+(35<<14)+@CVI((SI_LO_D+10.0)/20.0*4095) ; S3 Low
2537      Y:0125 Y:0125                   DC      (CLK2<<8)+(36<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 19
2538      Y:0126 Y:0126                   DC      (CLK2<<8)+(37<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2539      Y:0127 Y:0127                   DC      (CLK2<<8)+(38<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 33
2540      Y:0128 Y:0128                   DC      (CLK2<<8)+(39<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2541      Y:0129 Y:0129                   DC      (CLK2<<8)+(40<<14)+@CVI((DG_HI_D+10.0)/20.0*4095) ; DG High, pin 34
2542      Y:012A Y:012A                   DC      (CLK2<<8)+(41<<14)+@CVI((DG_LO_D+10.0)/20.0*4095) ; DG Low
2543      Y:012B Y:012B                   DC      (CLK2<<8)+(42<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 35
2544      Y:012C Y:012C                   DC      (CLK2<<8)+(43<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2545      Y:012D Y:012D                   DC      (CLK2<<8)+(44<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 36
2546      Y:012E Y:012E                   DC      (CLK2<<8)+(45<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2547      Y:012F Y:012F                   DC      (CLK2<<8)+(46<<14)+@CVI((VABG_D+10.0)/20.0*4095) ; Anti-Blooming Gate High, pin 37
2548      Y:0130 Y:0130                   DC      (CLK2<<8)+(47<<14)+@CVI((VABG_D+10.0)/20.0*4095) ; Anti-Blooming Gate Low
2549   
2550                            ; Set gain and integrator speed
2551      Y:0131 Y:0131                   DC      $0c3fdd                           ; Gain, speed
2552   
2553                            ;       DC      $0c3f77                 ; Gain x1, fast integ speed, board #0
2554                            ;       DC      $0c3fbb                 ; Gain x2, fast integ speed, board #0
2555                            ;       DC      $0c3fdd                 ; Gain x4.75, fast integ speed, board #0
2556                            ;       DC      $0c3fee                 ; Gain x9.50, fast integ speed, board #0
2557                            ;       DC      $0c3cee                 ; Gain x9.50, slow integ speed, board #0
2558   
2559                            ; Input offset voltages for DC coupling. Target is U4#6 = 24 volts
2560      Y:0132 Y:0132                   DC      $0c0800                           ; Input offset, ch. A
2561      Y:0133 Y:0133                   DC      $0c8800                           ; Input offset, ch. B
2562   
2563                            ; Output offset voltages
2564      Y:0134 Y:0134                   DC      $0c4000+OFFSET0                   ; Output video offset, ch. A
2565      Y:0135 Y:0135                   DC      $0cc000+OFFSET1                   ; Output video offset, ch. B
2566   
2567                            ; Output and reset drain DC bias voltages
2568      Y:0136 Y:0136                   DC      $0d0000+@CVI((VODL_D-7.50)/22.5*4095) ; VODL pin #1
2569      Y:0137 Y:0137                   DC      $0d4000+@CVI((VODR_D-7.50)/22.5*4095) ; VODR pin #2
2570      Y:0138 Y:0138                   DC      $0d8000+@CVI((VRDL_D-5.00)/15.0*4095) ; VRDL pin #3
2571      Y:0139 Y:0139                   DC      $0dc000+@CVI((VRDR_D-5.00)/15.0*4095) ; VRDR pin #4
2572   
2573   
2574                            ; Output and anti-blooming gates
2575      Y:013A Y:013A                   DC      $0f0000+BIAS_ZERO                 ; Unused pin #9
2576      Y:013B Y:013B                   DC      $0f4000+BIAS_ZERO                 ; Unused pin #10
2577      Y:013C Y:013C                   DC      $0f8000+@CVI((VOG_D+10.0)/20.0*4095) ; Unused pin #11
2578      Y:013D Y:013D                   DC      $0fc000+@CVI((VABG_D+10.0)/20.0*4095) ; Unused pin #12
2579                            END_DACS_DD
2580   
2581   
2582                            ; Initialization of clock driver and video processor DACs and switches
2583                            ; for Inverted levels used during startup & idling
2584      Y:013E Y:013E         DACS_INV  DC      END_DACS_INV-DACS_INV-1
2585      Y:013F Y:013F                   DC      (CLK2<<8)+(0<<14)+@CVI((R_HI_I+10.0)/20.0*4095) ; S1 Left High, pin 1
2586      Y:0140 Y:0140                   DC      (CLK2<<8)+(1<<14)+@CVI((R_LO_I+10.0)/20.0*4095) ; S1 Left Low
2587      Y:0141 Y:0141                   DC      (CLK2<<8)+(2<<14)+@CVI((R_HI_I+10.0)/20.0*4095) ; S2 Left Right High, pin 2
2588      Y:0142 Y:0142                   DC      (CLK2<<8)+(3<<14)+@CVI((R_LO_I+10.0)/20.0*4095) ; S2 Left Low
2589      Y:0143 Y:0143                   DC      (CLK2<<8)+(4<<14)+@CVI((R_HI_I+10.0)/20.0*4095) ; S3 Left High, pin 3
2590      Y:0144 Y:0144                   DC      (CLK2<<8)+(5<<14)+@CVI((R_LO_I+10.0)/20.0*4095) ; S3 Left Low
2591      Y:0145 Y:0145                   DC      (CLK2<<8)+(6<<14)+@CVI((R_HI_I+10.0)/20.0*4095) ; S1 Right High, pin 4
2592      Y:0146 Y:0146                   DC      (CLK2<<8)+(7<<14)+@CVI((R_LO_I+10.0)/20.0*4095) ; S1 Right Low
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 47



2593      Y:0147 Y:0147                   DC      (CLK2<<8)+(8<<14)+@CVI((R_HI_I+10.0)/20.0*4095) ; S2 Right High, pin 5
2594      Y:0148 Y:0148                   DC      (CLK2<<8)+(9<<14)+@CVI((R_LO_I+10.0)/20.0*4095) ; S2 Right Low
2595      Y:0149 Y:0149                   DC      (CLK2<<8)+(10<<14)+@CVI((R_HI_I+10.0)/20.0*4095) ; S3 Right High, pin 6
2596      Y:014A Y:014A                   DC      (CLK2<<8)+(11<<14)+@CVI((R_LO_I+10.0)/20.0*4095) ; S3 Right Low
2597      Y:014B Y:014B                   DC      (CLK2<<8)+(12<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 7
2598      Y:014C Y:014C                   DC      (CLK2<<8)+(13<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2599      Y:014D Y:014D                   DC      (CLK2<<8)+(14<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 8
2600      Y:014E Y:014E                   DC      (CLK2<<8)+(15<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2601      Y:014F Y:014F                   DC      (CLK2<<8)+(16<<14)+@CVI((RG_HI_I+10.0)/20.0*4095) ; RG Left High, pin 9
2602      Y:0150 Y:0150                   DC      (CLK2<<8)+(17<<14)+@CVI((RG_LO_I+10.0)/20.0*4095) ; RG Left Low
2603      Y:0151 Y:0151                   DC      (CLK2<<8)+(18<<14)+@CVI((RG_HI_I+10.0)/20.0*4095) ; RG Right High, pin 10
2604      Y:0152 Y:0152                   DC      (CLK2<<8)+(19<<14)+@CVI((RG_LO_I+10.0)/20.0*4095) ; RG Rightd Low
2605      Y:0153 Y:0153                   DC      (CLK2<<8)+(20<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 11
2606      Y:0154 Y:0154                   DC      (CLK2<<8)+(21<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2607      Y:0155 Y:0155                   DC      (CLK2<<8)+(22<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 12
2608      Y:0156 Y:0156                   DC      (CLK2<<8)+(23<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2609      Y:0157 Y:0157                   DC      (CLK2<<8)+(24<<14)+@CVI((SI_HI_I+10.0)/20.0*4095) ; I1 High, pin 13
2610      Y:0158 Y:0158                   DC      (CLK2<<8)+(25<<14)+@CVI((SI_LO_I+10.0)/20.0*4095) ; I1 Low
2611      Y:0159 Y:0159                   DC      (CLK2<<8)+(26<<14)+@CVI((SI_HI_I+10.0)/20.0*4095) ; I2 High, pin 14
2612      Y:015A Y:015A                   DC      (CLK2<<8)+(27<<14)+@CVI((SI_LO_I+10.0)/20.0*4095) ; I2 Low
2613      Y:015B Y:015B                   DC      (CLK2<<8)+(28<<14)+@CVI((SI_HI_I+10.0)/20.0*4095) ; I3 High, pin 15
2614      Y:015C Y:015C                   DC      (CLK2<<8)+(29<<14)+@CVI((SI_LO_I+10.0)/20.0*4095) ; I3 Low
2615      Y:015D Y:015D                   DC      (CLK2<<8)+(30<<14)+@CVI((SI_HI_I+10.0)/20.0*4095) ; S1 High, pin 16
2616      Y:015E Y:015E                   DC      (CLK2<<8)+(31<<14)+@CVI((SI_LO_I+10.0)/20.0*4095) ; S1 Low
2617      Y:015F Y:015F                   DC      (CLK2<<8)+(32<<14)+@CVI((SI_HI_I+10.0)/20.0*4095) ; S2 High, pin 17
2618      Y:0160 Y:0160                   DC      (CLK2<<8)+(33<<14)+@CVI((SI_LO_I+10.0)/20.0*4095) ; S2 Low
2619      Y:0161 Y:0161                   DC      (CLK2<<8)+(34<<14)+@CVI((SI_HI_I+10.0)/20.0*4095) ; S3 High, pin 18
2620      Y:0162 Y:0162                   DC      (CLK2<<8)+(35<<14)+@CVI((SI_LO_I+10.0)/20.0*4095) ; S3 Low
2621      Y:0163 Y:0163                   DC      (CLK2<<8)+(36<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 19
2622      Y:0164 Y:0164                   DC      (CLK2<<8)+(37<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2623      Y:0165 Y:0165                   DC      (CLK2<<8)+(38<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 33
2624      Y:0166 Y:0166                   DC      (CLK2<<8)+(39<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2625      Y:0167 Y:0167                   DC      (CLK2<<8)+(40<<14)+@CVI((DG_HI_I+10.0)/20.0*4095) ; DG High, pin 34
2626      Y:0168 Y:0168                   DC      (CLK2<<8)+(41<<14)+@CVI((DG_LO_I+10.0)/20.0*4095) ; DG Low
2627      Y:0169 Y:0169                   DC      (CLK2<<8)+(42<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 35
2628      Y:016A Y:016A                   DC      (CLK2<<8)+(43<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2629      Y:016B Y:016B                   DC      (CLK2<<8)+(44<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 36
2630      Y:016C Y:016C                   DC      (CLK2<<8)+(45<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2631      Y:016D Y:016D                   DC      (CLK2<<8)+(46<<14)+@CVI((VABG_I+10.0)/20.0*4095) ; Anti-Blooming Gate High, pin 37
2632      Y:016E Y:016E                   DC      (CLK2<<8)+(47<<14)+@CVI((VABG_I+10.0)/20.0*4095) ; Anti-Blooming Gate Low
2633   
2634                            ; Set gain and integrator speed
2635      Y:016F Y:016F                   DC      $0c3fdd                           ; Gain, speed
2636   
2637                            ;       DC      $0c3f77                 ; Gain x1, fast integ speed, board #0
2638                            ;       DC      $0c3fbb                 ; Gain x2, fast integ speed, board #0
2639                            ;       DC      $0c3fdd                 ; Gain x4.75, fast integ speed, board #0
2640                            ;       DC      $0c3fee                 ; Gain x9.50, fast integ speed, board #0
2641                            ;       DC      $0c3cee                 ; Gain x9.50, slow integ speed, board #0
2642   
2643                            ; Input offset voltages for DC coupling. Target is U4#6 = 24 volts
2644      Y:0170 Y:0170                   DC      $0c0800                           ; Input offset, ch. A
2645      Y:0171 Y:0171                   DC      $0c8800                           ; Input offset, ch. B
2646   
2647                            ; Output offset voltages
2648      Y:0172 Y:0172                   DC      $0c4000+OFFSET0                   ; Output video offset, ch. A
2649      Y:0173 Y:0173                   DC      $0cc000+OFFSET1                   ; Output video offset, ch. B
2650   
2651                            ; Output and reset drain DC bias voltages
2652      Y:0174 Y:0174                   DC      $0d0000+@CVI((VODL_I-7.50)/22.5*4095) ; VODL pin #1
2653      Y:0175 Y:0175                   DC      $0d4000+@CVI((VODR_I-7.50)/22.5*4095) ; VODR pin #2
2654      Y:0176 Y:0176                   DC      $0d8000+@CVI((VRDL_I-5.00)/15.0*4095) ; VRDL pin #3
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 48



2655      Y:0177 Y:0177                   DC      $0dc000+@CVI((VRDR_I-5.00)/15.0*4095) ; VRDR pin #4
2656   
2657   
2658                            ; Output and anti-blooming gates
2659      Y:0178 Y:0178                   DC      $0f0000+BIAS_ZERO                 ; Unused pin #9
2660      Y:0179 Y:0179                   DC      $0f4000+BIAS_ZERO                 ; Unused pin #10
2661      Y:017A Y:017A                   DC      $0f8000+@CVI((VOG_I+10.0)/20.0*4095) ; Unused pin #11
2662      Y:017B Y:017B                   DC      $0fc000+@CVI((VABG_I+10.0)/20.0*4095) ; Unused pin #12
2663                            END_DACS_INV
2664   
2665   
2666                            ; Initialization of clock driver and video processor DACs and switches
2667                            ; for Transitions levels used moving to or from the DD levels
2668      Y:017C Y:017C         DACS_TRANS DC     END_DACS_TRANS-DACS_TRANS-1
2669      Y:017D Y:017D                   DC      (CLK2<<8)+(0<<14)+@CVI((R_HI_T+10.0)/20.0*4095) ; S1 Left High, pin 1
2670      Y:017E Y:017E                   DC      (CLK2<<8)+(1<<14)+@CVI((R_LO_T+10.0)/20.0*4095) ; S1 Left Low
2671      Y:017F Y:017F                   DC      (CLK2<<8)+(2<<14)+@CVI((R_HI_T+10.0)/20.0*4095) ; S2 Left Right High, pin 2
2672      Y:0180 Y:0180                   DC      (CLK2<<8)+(3<<14)+@CVI((R_LO_T+10.0)/20.0*4095) ; S2 Left Low
2673      Y:0181 Y:0181                   DC      (CLK2<<8)+(4<<14)+@CVI((R_HI_T+10.0)/20.0*4095) ; S3 Left High, pin 3
2674      Y:0182 Y:0182                   DC      (CLK2<<8)+(5<<14)+@CVI((R_LO_T+10.0)/20.0*4095) ; S3 Left Low
2675      Y:0183 Y:0183                   DC      (CLK2<<8)+(6<<14)+@CVI((R_HI_T+10.0)/20.0*4095) ; S1 Right High, pin 4
2676      Y:0184 Y:0184                   DC      (CLK2<<8)+(7<<14)+@CVI((R_LO_T+10.0)/20.0*4095) ; S1 Right Low
2677      Y:0185 Y:0185                   DC      (CLK2<<8)+(8<<14)+@CVI((R_HI_T+10.0)/20.0*4095) ; S2 Right High, pin 5
2678      Y:0186 Y:0186                   DC      (CLK2<<8)+(9<<14)+@CVI((R_LO_T+10.0)/20.0*4095) ; S2 Right Low
2679      Y:0187 Y:0187                   DC      (CLK2<<8)+(10<<14)+@CVI((R_HI_T+10.0)/20.0*4095) ; S3 Right High, pin 6
2680      Y:0188 Y:0188                   DC      (CLK2<<8)+(11<<14)+@CVI((R_LO_T+10.0)/20.0*4095) ; S3 Right Low
2681      Y:0189 Y:0189                   DC      (CLK2<<8)+(12<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 7
2682      Y:018A Y:018A                   DC      (CLK2<<8)+(13<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2683      Y:018B Y:018B                   DC      (CLK2<<8)+(14<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 8
2684      Y:018C Y:018C                   DC      (CLK2<<8)+(15<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2685      Y:018D Y:018D                   DC      (CLK2<<8)+(16<<14)+@CVI((RG_HI_T+10.0)/20.0*4095) ; RG Left High, pin 9
2686      Y:018E Y:018E                   DC      (CLK2<<8)+(17<<14)+@CVI((RG_LO_T+10.0)/20.0*4095) ; RG Left Low
2687      Y:018F Y:018F                   DC      (CLK2<<8)+(18<<14)+@CVI((RG_HI_T+10.0)/20.0*4095) ; RG Right High, pin 10
2688      Y:0190 Y:0190                   DC      (CLK2<<8)+(19<<14)+@CVI((RG_LO_T+10.0)/20.0*4095) ; RG Rightd Low
2689      Y:0191 Y:0191                   DC      (CLK2<<8)+(20<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 11
2690      Y:0192 Y:0192                   DC      (CLK2<<8)+(21<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2691      Y:0193 Y:0193                   DC      (CLK2<<8)+(22<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 12
2692      Y:0194 Y:0194                   DC      (CLK2<<8)+(23<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2693      Y:0195 Y:0195                   DC      (CLK2<<8)+(24<<14)+@CVI((SI_HI_T+10.0)/20.0*4095) ; I1 High, pin 13
2694      Y:0196 Y:0196                   DC      (CLK2<<8)+(25<<14)+@CVI((SI_LO_T+10.0)/20.0*4095) ; I1 Low
2695      Y:0197 Y:0197                   DC      (CLK2<<8)+(26<<14)+@CVI((SI_HI_T+10.0)/20.0*4095) ; I2 High, pin 14
2696      Y:0198 Y:0198                   DC      (CLK2<<8)+(27<<14)+@CVI((SI_LO_T+10.0)/20.0*4095) ; I2 Low
2697      Y:0199 Y:0199                   DC      (CLK2<<8)+(28<<14)+@CVI((SI_HI_T+10.0)/20.0*4095) ; I3 High, pin 15
2698      Y:019A Y:019A                   DC      (CLK2<<8)+(29<<14)+@CVI((SI_LO_T+10.0)/20.0*4095) ; I3 Low
2699      Y:019B Y:019B                   DC      (CLK2<<8)+(30<<14)+@CVI((SI_HI_T+10.0)/20.0*4095) ; S1 High, pin 16
2700      Y:019C Y:019C                   DC      (CLK2<<8)+(31<<14)+@CVI((SI_LO_T+10.0)/20.0*4095) ; S1 Low
2701      Y:019D Y:019D                   DC      (CLK2<<8)+(32<<14)+@CVI((SI_HI_T+10.0)/20.0*4095) ; S2 High, pin 17
2702      Y:019E Y:019E                   DC      (CLK2<<8)+(33<<14)+@CVI((SI_LO_T+10.0)/20.0*4095) ; S2 Low
2703      Y:019F Y:019F                   DC      (CLK2<<8)+(34<<14)+@CVI((SI_HI_T+10.0)/20.0*4095) ; S3 High, pin 18
2704      Y:01A0 Y:01A0                   DC      (CLK2<<8)+(35<<14)+@CVI((SI_LO_T+10.0)/20.0*4095) ; S3 Low
2705      Y:01A1 Y:01A1                   DC      (CLK2<<8)+(36<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 19
2706      Y:01A2 Y:01A2                   DC      (CLK2<<8)+(37<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2707      Y:01A3 Y:01A3                   DC      (CLK2<<8)+(38<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 33
2708      Y:01A4 Y:01A4                   DC      (CLK2<<8)+(39<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2709      Y:01A5 Y:01A5                   DC      (CLK2<<8)+(40<<14)+@CVI((DG_HI_T+10.0)/20.0*4095) ; DG High, pin 34
2710      Y:01A6 Y:01A6                   DC      (CLK2<<8)+(41<<14)+@CVI((DG_LO_T+10.0)/20.0*4095) ; DG Low
2711      Y:01A7 Y:01A7                   DC      (CLK2<<8)+(42<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 35
2712      Y:01A8 Y:01A8                   DC      (CLK2<<8)+(43<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2713      Y:01A9 Y:01A9                   DC      (CLK2<<8)+(44<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 36
2714      Y:01AA Y:01AA                   DC      (CLK2<<8)+(45<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2715      Y:01AB Y:01AB                   DC      (CLK2<<8)+(46<<14)+@CVI((VABG_T+10.0)/20.0*4095) ; Anti-Blooming Gate High, pin 37
2716      Y:01AC Y:01AC                   DC      (CLK2<<8)+(47<<14)+@CVI((VABG_T+10.0)/20.0*4095) ; Anti-Blooming Gate Low
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 49



2717   
2718                            ; Set gain and integrator speed
2719      Y:01AD Y:01AD                   DC      $0c3fdd                           ; Gain, speed
2720   
2721                            ;       DC      $0c3f77                 ; Gain x1, fast integ speed, board #0
2722                            ;       DC      $0c3fbb                 ; Gain x2, fast integ speed, board #0
2723                            ;       DC      $0c3fdd                 ; Gain x4.75, fast integ speed, board #0
2724                            ;       DC      $0c3fee                 ; Gain x9.50, fast integ speed, board #0
2725                            ;       DC      $0c3cee                 ; Gain x9.50, slow integ speed, board #0
2726   
2727                            ; Input offset voltages for DC coupling. Target is U4#6 = 24 volts
2728      Y:01AE Y:01AE                   DC      $0c0800                           ; Input offset, ch. A
2729      Y:01AF Y:01AF                   DC      $0c8800                           ; Input offset, ch. B
2730   
2731                            ; Output offset voltages
2732      Y:01B0 Y:01B0                   DC      $0c4000+OFFSET0                   ; Output video offset, ch. A
2733      Y:01B1 Y:01B1                   DC      $0cc000+OFFSET1                   ; Output video offset, ch. B
2734   
2735                            ; Output and reset drain DC bias voltages
2736      Y:01B2 Y:01B2                   DC      $0d0000+@CVI((VODL_T-7.50)/22.5*4095) ; VODL pin #1
2737      Y:01B3 Y:01B3                   DC      $0d4000+@CVI((VODR_T-7.50)/22.5*4095) ; VODR pin #2
2738      Y:01B4 Y:01B4                   DC      $0d8000+@CVI((VRDL_T-5.00)/15.0*4095) ; VRDL pin #3
2739      Y:01B5 Y:01B5                   DC      $0dc000+@CVI((VRDR_T-5.00)/15.0*4095) ; VRDR pin #4
2740   
2741   
2742                            ; Output and anti-blooming gates
2743      Y:01B6 Y:01B6                   DC      $0f0000+BIAS_ZERO                 ; Unused pin #9
2744      Y:01B7 Y:01B7                   DC      $0f4000+BIAS_ZERO                 ; Unused pin #10
2745      Y:01B8 Y:01B8                   DC      $0f8000+@CVI((VOG_T+10.0)/20.0*4095) ; Unused pin #11
2746      Y:01B9 Y:01B9                   DC      $0fc000+@CVI((VABG_T+10.0)/20.0*4095) ; Unused pin #12
2747                            END_DACS_TRANS
2748   
2749                            ;       These are the 15 fast serial read waveforms for left, right,
2750                            ;       and split reads for serial binning factors from 1 to 5.
2751   
2752                            ;       Unbinned waveforms
2753                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2754                            SERIAL_READ_LEFT_1
2755      Y:01BA Y:01BA                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2756      Y:01BB Y:01BB                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2757      Y:01BC Y:01BC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2758      Y:01BD Y:01BD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2759      Y:01BE Y:01BE                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2760      Y:01BF Y:01BF                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2761                            SXMIT_LEFT_1
2762      Y:01C0 Y:01C0                   DC      $00F000                           ; Transmit A/D data to host
2763      Y:01C1 Y:01C1                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2764      Y:01C2 Y:01C2                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2765      Y:01C3 Y:01C3                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2766      Y:01C4 Y:01C4                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2767      Y:01C5 Y:01C5                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2768      Y:01C6 Y:01C6                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2769                            END_SERIAL_READ_LEFT_1
2770   
2771                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2772                            SERIAL_READ_RIGHT_1
2773      Y:01C7 Y:01C7                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2774      Y:01C8 Y:01C8                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2775      Y:01C9 Y:01C9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2776      Y:01CA Y:01CA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2777      Y:01CB Y:01CB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2778      Y:01CC Y:01CC                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 50



2779                            SXMIT_RIGHT_1
2780      Y:01CD Y:01CD                   DC      $00F021                           ; Transmit A/D data to host
2781      Y:01CE Y:01CE                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2782      Y:01CF Y:01CF                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2783      Y:01D0 Y:01D0                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2784      Y:01D1 Y:01D1                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2785      Y:01D2 Y:01D2                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2786      Y:01D3 Y:01D3                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2787                            END_SERIAL_READ_RIGHT_1
2788   
2789                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2790                            SERIAL_READ_SPLIT_1
2791      Y:01D4 Y:01D4                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2792      Y:01D5 Y:01D5                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2793      Y:01D6 Y:01D6                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2794      Y:01D7 Y:01D7                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2795      Y:01D8 Y:01D8                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2796      Y:01D9 Y:01D9                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2797                            SXMIT_SPLIT_1
2798      Y:01DA Y:01DA                   DC      $00F020                           ; Transmit A/D data to host
2799      Y:01DB Y:01DB                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2800      Y:01DC Y:01DC                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2801      Y:01DD Y:01DD                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2802      Y:01DE Y:01DE                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2803      Y:01DF Y:01DF                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2804      Y:01E0 Y:01E0                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2805                            END_SERIAL_READ_SPLIT_1
2806   
2807                            ; Bin by 2 waveforms
2808                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2809                            SERIAL_READ_LEFT_2
2810      Y:01E1 Y:01E1                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2811      Y:01E2 Y:01E2                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2812      Y:01E3 Y:01E3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2813      Y:01E4 Y:01E4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2814      Y:01E5 Y:01E5                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2815      Y:01E6 Y:01E6                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2816                            SXMIT_LEFT_2
2817      Y:01E7 Y:01E7                   DC      $00F000                           ; Transmit A/D data to host
2818      Y:01E8 Y:01E8                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2819      Y:01E9 Y:01E9                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2820      Y:01EA Y:01EA                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2821      Y:01EB Y:01EB                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2822      Y:01EC Y:01EC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2823      Y:01ED Y:01ED                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2824      Y:01EE Y:01EE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2825      Y:01EF Y:01EF                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2826      Y:01F0 Y:01F0                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2827      Y:01F1 Y:01F1                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2828      Y:01F2 Y:01F2                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2829      Y:01F3 Y:01F3                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2830                            END_SERIAL_READ_LEFT_2
2831   
2832                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2833                            SERIAL_READ_RIGHT_2
2834      Y:01F4 Y:01F4                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2835      Y:01F5 Y:01F5                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2836      Y:01F6 Y:01F6                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2837      Y:01F7 Y:01F7                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2838      Y:01F8 Y:01F8                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2839      Y:01F9 Y:01F9                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2840                            SXMIT_RIGHT_2
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 51



2841      Y:01FA Y:01FA                   DC      $00F021                           ; Transmit A/D data to host
2842      Y:01FB Y:01FB                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2843      Y:01FC Y:01FC                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2844      Y:01FD Y:01FD                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2845      Y:01FE Y:01FE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2846      Y:01FF Y:01FF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2847      Y:0200 Y:0200                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2848      Y:0201 Y:0201                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2849      Y:0202 Y:0202                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2850      Y:0203 Y:0203                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2851      Y:0204 Y:0204                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2852      Y:0205 Y:0205                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2853      Y:0206 Y:0206                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2854                            END_SERIAL_READ_RIGHT_2
2855   
2856                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2857                            SERIAL_READ_SPLIT_2
2858      Y:0207 Y:0207                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2859      Y:0208 Y:0208                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2860      Y:0209 Y:0209                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2861      Y:020A Y:020A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2862      Y:020B Y:020B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2863      Y:020C Y:020C                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2864                            SXMIT_SPLIT_2
2865      Y:020D Y:020D                   DC      $00F020                           ; Transmit A/D data to host
2866      Y:020E Y:020E                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2867      Y:020F Y:020F                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2868      Y:0210 Y:0210                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2869      Y:0211 Y:0211                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2870      Y:0212 Y:0212                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2871      Y:0213 Y:0213                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2872      Y:0214 Y:0214                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2873      Y:0215 Y:0215                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2874      Y:0216 Y:0216                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2875      Y:0217 Y:0217                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2876      Y:0218 Y:0218                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2877      Y:0219 Y:0219                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2878                            END_SERIAL_READ_SPLIT_2
2879   
2880   
2881                            ;       Binned by 3 waveforms
2882                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2883                            SERIAL_READ_LEFT_3
2884      Y:021A Y:021A                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2885      Y:021B Y:021B                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2886      Y:021C Y:021C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2887      Y:021D Y:021D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2888      Y:021E Y:021E                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2889      Y:021F Y:021F                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2890                            SXMIT_LEFT_3
2891      Y:0220 Y:0220                   DC      $00F000                           ; Transmit A/D data to host
2892      Y:0221 Y:0221                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2893      Y:0222 Y:0222                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2894      Y:0223 Y:0223                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2895      Y:0224 Y:0224                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2896      Y:0225 Y:0225                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2897      Y:0226 Y:0226                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2898      Y:0227 Y:0227                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2899      Y:0228 Y:0228                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2900      Y:0229 Y:0229                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2901      Y:022A Y:022A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2902      Y:022B Y:022B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 52



2903      Y:022C Y:022C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2904      Y:022D Y:022D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2905      Y:022E Y:022E                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2906      Y:022F Y:022F                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2907      Y:0230 Y:0230                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2908      Y:0231 Y:0231                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2909      Y:0232 Y:0232                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2910                            END_SERIAL_READ_LEFT_3
2911   
2912                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2913                            SERIAL_READ_RIGHT_3
2914      Y:0233 Y:0233                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2915      Y:0234 Y:0234                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2916      Y:0235 Y:0235                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2917      Y:0236 Y:0236                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2918      Y:0237 Y:0237                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2919      Y:0238 Y:0238                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2920                            SXMIT_RIGHT_3
2921      Y:0239 Y:0239                   DC      $00F021                           ; Transmit A/D data to host
2922      Y:023A Y:023A                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2923      Y:023B Y:023B                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2924      Y:023C Y:023C                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2925      Y:023D Y:023D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2926      Y:023E Y:023E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2927      Y:023F Y:023F                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2928      Y:0240 Y:0240                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2929      Y:0241 Y:0241                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2930      Y:0242 Y:0242                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2931      Y:0243 Y:0243                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2932      Y:0244 Y:0244                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2933      Y:0245 Y:0245                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2934      Y:0246 Y:0246                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2935      Y:0247 Y:0247                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2936      Y:0248 Y:0248                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2937      Y:0249 Y:0249                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2938      Y:024A Y:024A                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2939      Y:024B Y:024B                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2940                            END_SERIAL_READ_RIGHT_3
2941   
2942                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2943                            SERIAL_READ_SPLIT_3
2944      Y:024C Y:024C                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2945      Y:024D Y:024D                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2946      Y:024E Y:024E                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2947      Y:024F Y:024F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2948      Y:0250 Y:0250                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2949      Y:0251 Y:0251                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2950                            SXMIT_SPLIT_3
2951      Y:0252 Y:0252                   DC      $00F020                           ; Transmit A/D data to host
2952      Y:0253 Y:0253                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2953      Y:0254 Y:0254                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2954      Y:0255 Y:0255                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2955      Y:0256 Y:0256                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2956      Y:0257 Y:0257                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2957      Y:0258 Y:0258                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2958      Y:0259 Y:0259                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2959      Y:025A Y:025A                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2960      Y:025B Y:025B                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2961      Y:025C Y:025C                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2962      Y:025D Y:025D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2963      Y:025E Y:025E                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2964      Y:025F Y:025F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 53



2965      Y:0260 Y:0260                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2966      Y:0261 Y:0261                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2967      Y:0262 Y:0262                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2968      Y:0263 Y:0263                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2969      Y:0264 Y:0264                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2970                            END_SERIAL_READ_SPLIT_3
2971   
2972                            ;       Binned by 4 waveforms
2973                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2974                            SERIAL_READ_LEFT_4
2975      Y:0265 Y:0265                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2976      Y:0266 Y:0266                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2977      Y:0267 Y:0267                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2978      Y:0268 Y:0268                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2979      Y:0269 Y:0269                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2980      Y:026A Y:026A                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2981                            SXMIT_LEFT_4
2982      Y:026B Y:026B                   DC      $00F000                           ; Transmit A/D data to host
2983      Y:026C Y:026C                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2984      Y:026D Y:026D                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2985      Y:026E Y:026E                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2986      Y:026F Y:026F                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2987      Y:0270 Y:0270                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2988      Y:0271 Y:0271                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2989      Y:0272 Y:0272                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2990      Y:0273 Y:0273                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2991      Y:0274 Y:0274                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2992      Y:0275 Y:0275                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2993      Y:0276 Y:0276                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2994      Y:0277 Y:0277                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2995      Y:0278 Y:0278                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2996      Y:0279 Y:0279                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2997      Y:027A Y:027A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2998      Y:027B Y:027B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2999      Y:027C Y:027C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3000      Y:027D Y:027D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3001      Y:027E Y:027E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3002      Y:027F Y:027F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3003      Y:0280 Y:0280                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3004      Y:0281 Y:0281                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
3005      Y:0282 Y:0282                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
3006      Y:0283 Y:0283                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
3007                            END_SERIAL_READ_LEFT_4
3008   
3009                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3010                            SERIAL_READ_RIGHT_4
3011      Y:0284 Y:0284                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3012      Y:0285 Y:0285                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
3013      Y:0286 Y:0286                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3014      Y:0287 Y:0287                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3015      Y:0288 Y:0288                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3016      Y:0289 Y:0289                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
3017                            SXMIT_RIGHT_4
3018      Y:028A Y:028A                   DC      $00F021                           ; Transmit A/D data to host
3019      Y:028B Y:028B                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
3020      Y:028C Y:028C                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
3021      Y:028D Y:028D                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
3022      Y:028E Y:028E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3023      Y:028F Y:028F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3024      Y:0290 Y:0290                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3025      Y:0291 Y:0291                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3026      Y:0292 Y:0292                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 54



3027      Y:0293 Y:0293                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3028      Y:0294 Y:0294                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3029      Y:0295 Y:0295                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3030      Y:0296 Y:0296                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3031      Y:0297 Y:0297                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3032      Y:0298 Y:0298                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3033      Y:0299 Y:0299                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3034      Y:029A Y:029A                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3035      Y:029B Y:029B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3036      Y:029C Y:029C                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3037      Y:029D Y:029D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3038      Y:029E Y:029E                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3039      Y:029F Y:029F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3040      Y:02A0 Y:02A0                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
3041      Y:02A1 Y:02A1                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
3042      Y:02A2 Y:02A2                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
3043                            END_SERIAL_READ_RIGHT_4
3044   
3045                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3046                            SERIAL_READ_SPLIT_4
3047      Y:02A3 Y:02A3                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3048      Y:02A4 Y:02A4                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
3049      Y:02A5 Y:02A5                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3050      Y:02A6 Y:02A6                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3051      Y:02A7 Y:02A7                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3052      Y:02A8 Y:02A8                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3053                            SXMIT_SPLIT_4
3054      Y:02A9 Y:02A9                   DC      $00F020                           ; Transmit A/D data to host
3055      Y:02AA Y:02AA                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
3056      Y:02AB Y:02AB                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
3057      Y:02AC Y:02AC                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
3058      Y:02AD Y:02AD                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
3059      Y:02AE Y:02AE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3060      Y:02AF Y:02AF                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3061      Y:02B0 Y:02B0                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3062      Y:02B1 Y:02B1                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3063      Y:02B2 Y:02B2                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3064      Y:02B3 Y:02B3                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
3065      Y:02B4 Y:02B4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3066      Y:02B5 Y:02B5                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3067      Y:02B6 Y:02B6                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3068      Y:02B7 Y:02B7                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3069      Y:02B8 Y:02B8                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3070      Y:02B9 Y:02B9                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
3071      Y:02BA Y:02BA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3072      Y:02BB Y:02BB                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3073      Y:02BC Y:02BC                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3074      Y:02BD Y:02BD                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3075      Y:02BE Y:02BE                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3076      Y:02BF Y:02BF                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
3077      Y:02C0 Y:02C0                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
3078      Y:02C1 Y:02C1                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
3079                            END_SERIAL_READ_SPLIT_4
3080   
3081                            ;       Binned by 5 waveforms
3082                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3083                            SERIAL_READ_LEFT_5
3084      Y:02C2 Y:02C2                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3085      Y:02C3 Y:02C3                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
3086      Y:02C4 Y:02C4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3087      Y:02C5 Y:02C5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3088      Y:02C6 Y:02C6                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 55



3089      Y:02C7 Y:02C7                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
3090                            SXMIT_LEFT_5
3091      Y:02C8 Y:02C8                   DC      $00F000                           ; Transmit A/D data to host
3092      Y:02C9 Y:02C9                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
3093      Y:02CA Y:02CA                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
3094      Y:02CB Y:02CB                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
3095      Y:02CC Y:02CC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3096      Y:02CD Y:02CD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3097      Y:02CE Y:02CE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3098      Y:02CF Y:02CF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3099      Y:02D0 Y:02D0                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3100      Y:02D1 Y:02D1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3101      Y:02D2 Y:02D2                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3102      Y:02D3 Y:02D3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3103      Y:02D4 Y:02D4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3104      Y:02D5 Y:02D5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3105      Y:02D6 Y:02D6                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3106      Y:02D7 Y:02D7                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3107      Y:02D8 Y:02D8                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3108      Y:02D9 Y:02D9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3109      Y:02DA Y:02DA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3110      Y:02DB Y:02DB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3111      Y:02DC Y:02DC                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3112      Y:02DD Y:02DD                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3113      Y:02DE Y:02DE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3114      Y:02DF Y:02DF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3115      Y:02E0 Y:02E0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3116      Y:02E1 Y:02E1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3117      Y:02E2 Y:02E2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3118      Y:02E3 Y:02E3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3119      Y:02E4 Y:02E4                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
3120      Y:02E5 Y:02E5                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
3121      Y:02E6 Y:02E6                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
3122                            END_SERIAL_READ_LEFT_5
3123   
3124                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3125                            SERIAL_READ_RIGHT_5
3126      Y:02E7 Y:02E7                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3127      Y:02E8 Y:02E8                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
3128      Y:02E9 Y:02E9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3129      Y:02EA Y:02EA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3130      Y:02EB Y:02EB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3131      Y:02EC Y:02EC                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
3132                            SXMIT_RIGHT_5
3133      Y:02ED Y:02ED                   DC      $00F021                           ; Transmit A/D data to host
3134      Y:02EE Y:02EE                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
3135      Y:02EF Y:02EF                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
3136      Y:02F0 Y:02F0                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
3137      Y:02F1 Y:02F1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3138      Y:02F2 Y:02F2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3139      Y:02F3 Y:02F3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3140      Y:02F4 Y:02F4                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3141      Y:02F5 Y:02F5                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3142      Y:02F6 Y:02F6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3143      Y:02F7 Y:02F7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3144      Y:02F8 Y:02F8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3145      Y:02F9 Y:02F9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3146      Y:02FA Y:02FA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3147      Y:02FB Y:02FB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3148      Y:02FC Y:02FC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3149      Y:02FD Y:02FD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3150      Y:02FE Y:02FE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  HIPO_DD.waveforms.s  Page 56



3151      Y:02FF Y:02FF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3152      Y:0300 Y:0300                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3153      Y:0301 Y:0301                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3154      Y:0302 Y:0302                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3155      Y:0303 Y:0303                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
3156      Y:0304 Y:0304                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3157      Y:0305 Y:0305                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
3158      Y:0306 Y:0306                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
3159      Y:0307 Y:0307                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3160      Y:0308 Y:0308                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
3161      Y:0309 Y:0309                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
3162      Y:030A Y:030A                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
3163      Y:030B Y:030B                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
3164                            END_SERIAL_READ_RIGHT_5
3165   
3166                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3167                            SERIAL_READ_SPLIT_5
3168      Y:030C Y:030C                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
3169      Y:030D Y:030D                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
3170      Y:030E Y:030E                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3171      Y:030F Y:030F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3172      Y:0310 Y:0310                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3173      Y:0311 Y:0311                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3174                            SXMIT_SPLIT_5
3175      Y:0312 Y:0312                   DC      $00F020                           ; Transmit A/D data to host
3176      Y:0313 Y:0313                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
3177      Y:0314 Y:0314                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
3178      Y:0315 Y:0315                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
3179      Y:0316 Y:0316                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
3180      Y:0317 Y:0317                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3181      Y:0318 Y:0318                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3182      Y:0319 Y:0319                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3183      Y:031A Y:031A                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3184      Y:031B Y:031B                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3185      Y:031C Y:031C                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
3186      Y:031D Y:031D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3187      Y:031E Y:031E                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3188      Y:031F Y:031F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3189      Y:0320 Y:0320                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3190      Y:0321 Y:0321                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3191      Y:0322 Y:0322                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
3192      Y:0323 Y:0323                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3193      Y:0324 Y:0324                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3194      Y:0325 Y:0325                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3195      Y:0326 Y:0326                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3196      Y:0327 Y:0327                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3197      Y:0328 Y:0328                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
3198      Y:0329 Y:0329                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
3199      Y:032A Y:032A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
3200      Y:032B Y:032B                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
3201      Y:032C Y:032C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
3202      Y:032D Y:032D                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
3203      Y:032E Y:032E                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
3204      Y:032F Y:032F                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
3205      Y:0330 Y:0330                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
3206                            END_SERIAL_READ_SPLIT_5
3207   
3208   
3209                                      IF      @SCP("HOST","EEPROM")
3213                                      ENDIF
3214   
3215                               ENDSEC                                    ; End of section TIMEEV57
Motorola DSP56000 Assembler  Version 6.2.0   114-01-12  22:29:46  tim.s  Page 57



3216   
3217                     ;  End of program
3218                               END

0    Errors
0    Warnings


