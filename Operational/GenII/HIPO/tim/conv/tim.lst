Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  tim.s  Page 1



1                        ; This file is used to generate DSP code for the TimII second generation
2                        ;   timing board. This is Rev. 3.00 software.
3                        ;
4                        ; This file contains two subroutines and X and Y data areas.  The two
5                        ; subroutines are RDCCD (with secondary entry point RCCD1) and CLOCK.
6                        ; These need to be in fast P memory.  The boot code and tim.s are there.
7                        ; tim.s includes timmisc.s and timCCDmisc.s at the
8                        ; beginning and the waveforms file at the end in Y memory.
9      
10                                 PAGE    132                               ; Printronix page width - 132 columns
11     
12                       ; Define a section name so it doesn't conflict with other application programs
13                                 SECTION TIMEEV57
14     
15                       ; Include a header file that defines global parameters
16                                 INCLUDE "timhdr.s"
17                              COMMENT *
18     
19                       This is a header file that is shared between the fiber optic timing board
20                       boot and application code files
21                               *
22     
23                                 PAGE    132                               ; Printronix page width - 132 columns
24     
25                       ; Some basic structural definitions
26        000130         APL_ADR   EQU     $130                              ; P: memory location where application code begins
27        0000D0         APL_LEN   EQU     $200-APL_ADR                      ; Maximum length of application program
28        000030         IMGVAR_ADR EQU    $30                               ;  Special Image Mode variables Starting Address in X:
29     
30                       ; CHANGING MISC_LEN FROM 0X280 TO A LARGER NUMBER BREAKS THE ROM COPY APPROACH!
31                       ; However if all you do is download there is a lot more memory available.
32        000450         MISC_LEN  EQU     $450                              ; Maximum length of "miscellanous" code
33                       ;MISC_LEN EQU   $3F0    ; Maximum length of "miscellanous" code
34                       ; MISC_LEN EQU  $280    ; Maximum length of "miscellanous" code
35     
36        000040         COM_LEN   EQU     $40                               ; Length of memory for application commands
37        00003C         TIM_ISR   EQU     $3C                               ; DSP timer interrupt service routine address
38        00003E         PGM_CON   EQU     $3E                               ; Program continues on here
39        000080         COM_TBL   EQU     $80                               ; Starting address of command table in X: memory
40        000500         N_W_APL   EQU     $500                              ; Number of words in each application
41        000028         NUM_COM   EQU     40                                ; Number of entries in command table
42     
43        000000         RST_ISR   EQU     $00                               ; Hardware reset interrupt
44        000006         ROM_ID    EQU     $06                               ; Location of program Identification = SWI interrupt
45        000008         START     EQU     $08                               ; Starting address of program
46        000060         RCV_BUF   EQU     $60                               ; Starting address of receiver buffer in X:
47        00000F         TBL_ADR   EQU     $0F                               ; (IR) Waveform tables starting address
48     
49        004000         ROM_OFF   EQU     $4000                             ; Boot program offset address in EEPROM
50        004200         LD_X      EQU     $4200                             ; Assembler loads X: starting at this EEPROM address
51        00C600         RD_X      EQU     $C600                             ; DSP reads X: from this EEPROM address
52     
53                       ; Define DSP port addresses
54        00FF80         WRSS      EQU     $FF80                             ; Write clock driver and VP switch states
55        00FFC0         RDFO      EQU     $FFC0                             ; Read serial receiver fiber optic contents
56        00FFC0         WRFO      EQU     $FFC0                             ; Write to fiber optic serial transmitter
57        00FFA0         RDAD      EQU     $FFA0                             ; Read A/D datum into DSP
58        00FFA0         RDAD0     EQU     $FFA0                             ; Address for reading A/D #0
59        00FFA1         RDAD1     EQU     $FFA1                             ; Address for reading A/D #1
60        00FFC1         WRLATCH   EQU     $FFC1                             ; Write to timing board latch
61        006000         RSTWDT    EQU     $6000                             ; Address to reset the timing board watchdog timer
62        00FFFE         BCR       EQU     $FFFE                             ; Bus (=Port A) Control Register -> Wait States
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timhdr.s  Page 2



63        00FFE0         PBC       EQU     $FFE0                             ; Port B Control Register
64        00FFE2         PBDDR     EQU     $FFE2                             ; Port B Data Direction Register
65        00FFE4         PBD       EQU     $FFE4                             ; Port B Data Register
66        00FFE1         PCC       EQU     $FFE1                             ; Port C Control Register
67        00FFE3         PCDDR     EQU     $FFE3                             ; PortC Data Direction Register
68        00FFE5         PCD       EQU     $FFE5                             ; Port C Data Register
69        00FFFF         IPR       EQU     $FFFF                             ; Interrupt Priority Register
70        00FFEF         SSITX     EQU     $FFEF                             ; SSI Transmit and Receive data register
71        00FFEF         SSIRX     EQU     $FFEF                             ; SSI Transmit and Receive data register
72        00FFEE         SSISR     EQU     $FFEE                             ; SSI Status Register
73        00FFEC         CRA       EQU     $FFEC                             ; SSI Control Register A
74        00FFED         CRB       EQU     $FFED                             ; SSI Control Regsiter B
75        00FFDE         TCSR      EQU     $FFDE                             ; Timer control and status register
76        00FFDF         TCR       EQU     $FFDF                             ; Timer count register
77     
78                       ; Hardware bit definitions all over the place
79        000006         SSI_TDE   EQU     6                                 ; SSI Transmitter data register empty
80        000007         SSI_RDF   EQU     7                                 ; SSI Receiver data register full
81        000002         LVEN      EQU     2                                 ; Low voltage enable (+/-15 volt nominal)
82        000003         HVEN      EQU     3                                 ; Enable high voltage (+32V nominal)
83        000005         TIM_U_RST EQU     5                                 ; Timing to utility board reset bit number in U25
84        00000D         PWRST     EQU     13                                ; Power control board reset
85        000007         RST_FIFO  EQU     7                                 ; Reset FIFO bit number in control latch U25
86        000009         EF        EQU     9                                 ; FIFO empty flag, low true
87        000000         TIM_BIT   EQU     0                                 ; Timer status bit
88        000001         WW        EQU     1                                 ; Word width = 1 for 16-bit image data, 0 for 24-bit
89        000000         CDAC      EQU     0                                 ; Bit number in U25 for clearing DACs
90        000002         ENCK      EQU     2                                 ; Bit number in U25 for enabling analog switches
91        000001         DUALCLK   EQU     1                                 ; Set to clock two halves of clock driver board togethe
r
92     
93                       ; Software status bits, defined at X:<STATUS = X:0
94                       ; NOTE- SHUT and TST_IMG are used in lois and should be in tim_dsp.h
95        000000         ST_RCV    EQU     0                                 ; Set if FO, cleared if SSI
96        00000A         TST_IMG   EQU     10                                ; Set if ctlr is to generate a test (syn) image
97        00000B         SHUT      EQU     11                                ; Set if opening shutter at beginning of exposure
98        00000C         ST_EXP    EQU     12                                ; Set if presently in EXPOSE or waiting for trigger
99     
100                      ; Software status bits, defined at X:<STATUS = X:0
101       000002         IDLMODE   EQU     2                                 ; Set if need to idle after readout
102       000003         ST_SHUT   EQU     3                                 ; Set to indicate shutter is closed, clear for open
103       000004         ST_RDC    EQU     4                                 ; Set if executing 'RDC' command - reading out
104       000005         SPLIT_S   EQU     5                                 ; Set if split serial
105       000006         SPLIT_P   EQU     6                                 ; Set if split parallel
106       000007         MPP       EQU     7                                 ; Set if parallels are in MPP mode
107       000008         TRIGGER   EQU     8                                 ; Set if a Hardware triggered exposure
108       000009         ST_ABRT   EQU     9                                 ; Set if an abort (readout or exp) in progress
109    
110    
111                      ; Image mode bits, defined at X:<IMAGE_MODE
112    
113       000000         FDOTS     EQU     0                                 ; Fast Dots
114       000001         FIND      EQU     1                                 ; Find
115       000002         SDOTS     EQU     2                                 ; Slow Dots
116       000003         SERIES    EQU     3                                 ; Series
117       000004         SINGLE    EQU     4                                 ; Single
118       000005         STRIP     EQU     5                                 ; Stripscan
119       000006         F_OCC     EQU     6                                 ; Fast occultation, keep as 6 for compatibility
120       000007         B_OCC     EQU     7                                 ; Basic occultation
121       000008         P_OCC     EQU     8                                 ; Pipelined occultation
122    
123                      ; Image Status, define at X:<ISTATUS
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timhdr.s  Page 3



124       000000         NO_SKIP   EQU     0                                 ; Set for slow dots, fast and pipelined occultation mod
e
125                                                                          ; to avoid parallel skipping to the subframe boundary.
126       000001         OPEN_CLOSE EQU    1                                 ; Set if shutter opens/closes each image
127                                                                          ; Clear if shutter stays open for many images
128       000002         STORAGE   EQU     2                                 ; Set if storage area is to be clocked
129    
130    
131                      ; Specify controller configuration bits of the X:STATUS word
132                      ;   to describe the software capabilities of this application file
133                      ; The bit is set (=1) if the capability is supported by the controller
134    
135    
136                              COMMENT *
137    
138                      BIT #'s         FUNCTION
139                      2,1,0           Video Processor
140                                              000     CCD Rev. 3
141                                              001     CCD Gen I
142                                              010     IR Rev. 4
143                                              011     IR Coadder
144    
145                      4,3             Timing Board
146                                              00      Rev. 4, Gen II
147                                              01      Gen I
148    
149                      6,5             Utility Board
150                                              00      No utility board
151                                              01      Utility Rev. 3
152    
153                      7               Shutter
154                                              0       No shutter support
155                                              1       Yes shutter support
156    
157                      9,8             Temperature readout
158                                              00      No temperature readout
159                                              01      Polynomial Diode calibration
160                                              10      Linear temperature sensor calibration
161    
162                      10              Subarray readout
163                                              0       Not supported
164                                              1       Yes supported
165    
166                      11              Binning
167                                              0       Not supported
168                                              1       Yes supported
169    
170                      12              Split-Serial readout
171                                              0       Not supported
172                                              1       Yes supported
173    
174                      13              Split-Parallel readout
175                                              0       Not supported
176                                              1       Yes supported
177    
178                      14              MPP = Inverted parallel clocks
179                                              0       Not supported
180                                              1       Yes supported
181    
182                      16,15           Clock Driver Board
183                                              00      Rev. 3
184                                              11      No clock driver board (Gen I)
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timhdr.s  Page 4



185    
186                      19,18,17                Special implementations
187                                              000     Somewhere else
188                                              001     Mount Laguna Observatory
189                                              010     NGST Aladdin
190                                              xxx     Other
191                              *
192    
193                      CCDVIDREV3B
194       000000                   EQU     $000000                           ; CCD Video Processor Rev. 3
195       000001         VIDGENI   EQU     $000001                           ; CCD Video Processor Gen I
196       000002         IRREV4    EQU     $000002                           ; IR Video Processor Rev. 4
197       000003         COADDER   EQU     $000003                           ; IR Coadder
198       000000         TIMREV4   EQU     $000000                           ; Timing Rev. 4
199       000008         TIMGENI   EQU     $000008                           ; Timing Gen I
200       000020         UTILREV3  EQU     $000020                           ; Utility Rev. 3 supported
201       000080         SHUTTER_CC EQU    $000080                           ; Shutter supported
202       000100         TEMP_POLY EQU     $000100                           ; Polynomial calibration
203                      TEMP_LINEAR
204       000200                   EQU     $000200                           ; Linear calibration
205       000400         SUBARRAY  EQU     $000400                           ; Subarray readout supported
206       000800         BINNING   EQU     $000800                           ; Binning supported
207                      SPLIT_SERIAL
208       001000                   EQU     $001000                           ; Split serial supported
209                      SPLIT_PARALLEL
210       002000                   EQU     $002000                           ; Split parallel supported
211       004000         MPP_CC    EQU     $004000                           ; Inverted clocks supported
212       018000         CLKDRVGENI EQU    $018000                           ; No clock driver board - Gen I
213       020000         MLO       EQU     $020000                           ; Set if Mount Laguna Observatory
214       040000         NGST      EQU     $040000                           ; NGST Aladdin implementation
215                                INCLUDE "infospec.s"
216                      ; General DSP info field specifications.
217                      ; These values are 'addresses' and used as the argument for the INF command.
218    
219                      GET_VERSION
220       000000                   EQU     0                                 ; IVERSION field
221       000001         GET_FLAVOR EQU    1                                 ; IFLAVOR field
222       000002         GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
223       000003         GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
224       000004         GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if available)
225    
226                                INCLUDE "timinfospec.s"
227                      ; TIM DSP info field specifications.
228                      ; These values are 'addresses' and used as the argument for the INF command.
229    
230                      GET_CAPABLE
231       000100                   EQU     $100                              ; ICAPABLE field (what dsp supports).
232                      GET_INT_TIM
233       000101                   EQU     $101                              ; Integration time per pixel in leach units
234                      GET_R_DELAY
235       000102                   EQU     $102                              ; Serial overlap in leach units
236                      GET_SI_DELAY
237       000103                   EQU     $103                              ; Parallel overlap in leach units
238    
239                                INCLUDE "timinfo.s"
240                      ; DSP Version
241       04507F         IVERSION  EQU     282751                            ; 1.5/1
242    
243       612020         IFLAVOR   EQU     'a  '                             ; a
244    
245       00B3CC         ITIME0    EQU     46028                             ; lo order time: 2012 10 13  0:20:28 GMT
246    
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timinfo.s  Page 5



247       005078         ITIME1    EQU     20600                             ; hi order time: 2012 10 13  0:20:28 GMT
248    
249       000000         ISVNREV   EQU     0                                 ; most recent code svn rev
250    
251                      ; tim capability definitions
252                      FINDCAPABLE
253       000001                   EQU     1                                 ; Find exposure mode
254                      SNGLCAPABLE
255       000002                   EQU     2                                 ; Single exposure mode
256                      SERICAPABLE
257       000004                   EQU     4                                 ; Series exposure mode
258                      BASCCAPABLE
259       000008                   EQU     8                                 ; Basic occ exposure mode
260                      FASTCAPABLE
261       000010                   EQU     16                                ; Fast occ exposure mode
262                      PIPECAPABLE
263       000020                   EQU     32                                ; Pipeline occ exposure mode
264                      FDOTCAPABLE
265       000040                   EQU     64                                ; Fast dots exposure mode
266                      SDOTCAPABLE
267       000080                   EQU     128                               ; Slow dots exposure mode
268                      STRPCAPABLE
269       000100                   EQU     256                               ; Slow dots exposure mode
270       0001FB         TIMCAPABLE EQU    FINDCAPABLE+SNGLCAPABLE+STRPCAPABLE+BASCCAPABLE+FASTCAPABLE+PIPECAPABLE+FDOTCAPABLE+SDOTC
APABLE
271    
272       000000         APL_NUM   EQU     0                                 ; Application number from 0 to 3
273    
274       001420         CC        EQU     CCDVIDREV3B+TIMREV4+UTILREV3+SUBARRAY+SPLIT_SERIAL
275    
276                      ; Include miscellaneous timing commands
277                                INCLUDE "timmisc.s"                       ; Custom
278                      ; This file is for utilities that are in common to all the timing board
279                      ;   programs, located starting at P:$200 in external SRAM
280    
281                                IF      @SCP("50","50")
282       000032         SDELAY    EQU     50
283                                ENDIF
284                                IF      @SCP("50","200")
286                                ENDIF
287    
288                      ;  ****************  PROGRAM CODE IN SRAM PROGRAM SPACE    *******************
289                      ; Put all the following code in SRAM, starting at P:$200.
290                                IF      @SCP("HOST","HOST")
291       P:0200 P:0200                   ORG     P:$200,P:$200                     ; Download address
292                                       ELSE
294                                       ENDIF
295    
296                             ; Fast clear of CCD, executed as a command
297       P:0200 P:0200 0D0202  CLEAR     JSR     <CLR_CCD
298       P:0201 P:0201 0C0000            JMP     <FINISH
299    
300                             ; Fast clear image before each exposure, executed as a subroutine.  Uses DG
301       P:0202 P:0202 060440  CLR_CCD   DO      Y:<NPCLR,LPCLR                    ; Loop over number of lines in image
                        000207
302       P:0204 P:0204 60F400            MOVE              #IS_CLEAR,R0            ; Address of parallel transfer waveform
                        000063
303       P:0206 P:0206 0D01E7            JSR     <CLOCK                            ; Go clock out the CCD charge
304       P:0207 P:0207 000000            NOP                                       ; Do loop restriction
305                             LPCLR
306       P:0208 P:0208 60F400            MOVE              #DUMP_SERIAL,R0
                        00006C
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 6



307       P:020A P:020A 0D01E7            JSR     <CLOCK                            ; and wipe out the dregs in the SR
308       P:020B P:020B 44F400            MOVE              #TST_RCV,X0             ; Wait for commands during exposure
                        000000
309       P:020D P:020D 440000            MOVE              X0,X:<IDL_ADR           ;  instead of idling
310       P:020E P:020E 00000C            RTS
311    
312                             ; Keep the CCD idling when not reading out
313       P:020F P:020F 060140  IDLE      DO      Y:<NSR,IDL1                       ; Loop over number of pixels per line
                        000217
314       P:0211 P:0211 307200            MOVE              #<SERIAL_IDLE,R0        ; Serial transfer on pixel
315       P:0212 P:0212 0D01E7            JSR     <CLOCK                            ; Go to it
316       P:0213 P:0213 0D0000            JSR     <GET_RCV                          ; Check for FO or SSI commands
317       P:0214 P:0214 0E0217            JCC     <NO_COM                           ; Continue IDLE if no commands received
318       P:0215 P:0215 00008C            ENDDO                                     ; Cancel the DO loop
319       P:0216 P:0216 0C0000            JMP     <CHK_SSI                          ; Go process header and command
320       P:0217 P:0217 000000  NO_COM    NOP
321                             IDL1
322       P:0218 P:0218 306300            MOVE              #<IS_CLEAR,R0           ; Address of parallel clocking waveform
323       P:0219 P:0219 0D01E7            JSR     <CLOCK                            ; Go clock out the CCD charge
324       P:021A P:021A 0C020F            JMP     <IDLE
325    
326    
327                             ; Select which readouts to process
328                             ;   'SOS'  Amplifier_name
329                             ;       Amplifier_name = '__L', '__R', '_LR'
330    
331       P:021B P:021B 44DC00  SEL_OS    MOVE              X:(R4)+,X0              ; Get amplifier(s) name
332       P:021C P:021C 0D021E            JSR     <SELECT_OUTPUT_SOURCE
333       P:021D P:021D 0C0000            JMP     <FINISH1
334    
335                             ; A massive subroutine for setting all the addresses depending on the
336                             ; output source(s) selection and binning parameter.  Most of the
337                             ; waveforms are in fast Y memory (< 0xFF) but there isn't enough
338                             ; space for the fast serial binning waveforms for binning factors
339                             ; 1 through 5.  These are in high Y memory and have to be copied in.
340    
341                             SELECT_OUTPUT_SOURCE
342                             ; Set all the waveform addresses depending on which readout/binning mode
343       P:021E P:021E 56F400            MOVE              #'__L',A                ; LEFT Amplifier = readout #0
                        5F5F4C
344       P:0220 P:0220 200045            CMP     X0,A
345       P:0221 P:0221 0E226C            JNE     <CMP_R
346       P:0222 P:0222 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
347       P:0223 P:0223 56F400            MOVE              #SERIAL_SKIP_LEFT,A
                        0000E8
348       P:0225 P:0225 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
349       P:0227 P:0227 56F400            MOVE              #INITIAL_CLOCK_LEFT,A
                        000097
350       P:0229 P:0229 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
351       P:022B P:022B 56F400            MOVE              #SERIAL_CLOCK_LEFT,A
                        0000B1
352       P:022D P:022D 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
353       P:022F P:022F 56F400            MOVE              #(CLK2+$030000+000+000+000+000+H2L+H2R+000+000),A
                        032012
354       P:0231 P:0231 5E7000            MOVE                          A,Y:CCLK_1
                        0000BC
355       P:0233 P:0233 0A7005            BCLR    #SPLIT_S,X:STATUS
                        000000
356                             ; Now go through copying in the serial read waveform if binning more than 5.
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 7



357       P:0235 P:0235 200013            CLR     A
358       P:0236 P:0236 20001B            CLR     B
359       P:0237 P:0237 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
360       P:0238 P:0238 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
361       P:0239 P:0239 50F400            MOVE              #>5,A0
                        000005
362       P:023B P:023B 200005            CMP     B,A
363       P:023C P:023C 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
364       P:023D P:023D 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
365       P:023E P:023E 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
366       P:023F P:023F 0A3781  TRY_1_L   JCLR    #1,X:<BINBIT,TRY_2_L
                        000248
367                             ;       MOVE    #1,A0                   ; HACK
368                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
369       P:0241 P:0241 60F400            MOVE              #SERIAL_READ_LEFT_1,R0  ; Here if left amp, bin by 1
                        00013E
370       P:0243 P:0243 51F400            MOVE              #(END_SERIAL_READ_LEFT_1-SERIAL_READ_LEFT_1),B0
                        00000D
371       P:0245 P:0245 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
372       P:0246 P:0246 0D030D            JSR     <WAVECPY                          ; Copy the waveform
373       P:0247 P:0247 0C0307            JMP     <CMP_END
374       P:0248 P:0248 0A3782  TRY_2_L   JCLR    #2,X:<BINBIT,TRY_3_L
                        000251
375       P:024A P:024A 60F400            MOVE              #SERIAL_READ_LEFT_2,R0  ; Here if left amp, bin by 2
                        000165
376       P:024C P:024C 51F400            MOVE              #(END_SERIAL_READ_LEFT_2-SERIAL_READ_LEFT_2),B0
                        000013
377       P:024E P:024E 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
378       P:024F P:024F 0D030D            JSR     <WAVECPY                          ; Copy the waveform
379       P:0250 P:0250 0C0307            JMP     <CMP_END
380       P:0251 P:0251 0A3783  TRY_3_L   JCLR    #3,X:<BINBIT,TRY_4_L
                        00025A
381       P:0253 P:0253 60F400            MOVE              #SERIAL_READ_LEFT_3,R0  ; Here if left amp, bin by 3
                        00019E
382       P:0255 P:0255 51F400            MOVE              #(END_SERIAL_READ_LEFT_3-SERIAL_READ_LEFT_3),B0
                        000019
383       P:0257 P:0257 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
384       P:0258 P:0258 0D030D            JSR     <WAVECPY                          ; Copy the waveform
385       P:0259 P:0259 0C0307            JMP     <CMP_END
386       P:025A P:025A 0A3784  TRY_4_L   JCLR    #4,X:<BINBIT,TRY_5_L
                        000263
387       P:025C P:025C 60F400            MOVE              #SERIAL_READ_LEFT_4,R0  ; Here if left amp, bin by 4
                        0001E9
388       P:025E P:025E 51F400            MOVE              #(END_SERIAL_READ_LEFT_4-SERIAL_READ_LEFT_4),B0
                        00001F
389       P:0260 P:0260 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
390       P:0261 P:0261 0D030D            JSR     <WAVECPY                          ; Copy the waveform
391       P:0262 P:0262 0C0307            JMP     <CMP_END
392       P:0263 P:0263 0A3785  TRY_5_L   JCLR    #5,X:<BINBIT,CMP_END
                        000307
393       P:0265 P:0265 60F400            MOVE              #SERIAL_READ_LEFT_5,R0  ; Here if left amp, bin by 5
                        000246
394       P:0267 P:0267 51F400            MOVE              #(END_SERIAL_READ_LEFT_5-SERIAL_READ_LEFT_5),B0
                        000025
395       P:0269 P:0269 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
396       P:026A P:026A 0D030D            JSR     <WAVECPY                          ; Copy the waveform
397       P:026B P:026B 0C0307            JMP     <CMP_END
398    
399       P:026C P:026C 56F400  CMP_R     MOVE              #'__R',A                ; RIGHT Amplifier = readout #1
                        5F5F52
400       P:026E P:026E 200045            CMP     X0,A
401       P:026F P:026F 0E22BA            JNE     <CMP_LR
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 8



402       P:0270 P:0270 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
403       P:0271 P:0271 56F400            MOVE              #SERIAL_SKIP_RIGHT,A
                        0000F0
404       P:0273 P:0273 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
405       P:0275 P:0275 56F400            MOVE              #INITIAL_CLOCK_RIGHT,A
                        00008B
406       P:0277 P:0277 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
407       P:0279 P:0279 56F400            MOVE              #SERIAL_CLOCK_RIGHT,A
                        0000AA
408       P:027B P:027B 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
409       P:027D P:027D 56F400            MOVE              #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),A
                        032009
410       P:027F P:027F 5E7000            MOVE                          A,Y:CCLK_1
                        0000BC
411       P:0281 P:0281 0A7005            BCLR    #SPLIT_S,X:STATUS
                        000000
412                             ; Now go through copying in the serial read waveform if binning more than 5.
413       P:0283 P:0283 200013            CLR     A
414       P:0284 P:0284 20001B            CLR     B
415       P:0285 P:0285 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
416       P:0286 P:0286 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
417       P:0287 P:0287 50F400            MOVE              #>5,A0
                        000005
418       P:0289 P:0289 200005            CMP     B,A
419       P:028A P:028A 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
420       P:028B P:028B 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
421       P:028C P:028C 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
422       P:028D P:028D 0A3781  TRY_1_R   JCLR    #1,X:<BINBIT,TRY_2_R
                        000296
423                             ;       MOVE    #2,A0                   ; HACK
424                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
425       P:028F P:028F 60F400            MOVE              #SERIAL_READ_RIGHT_1,R0 ; Here if right amp, bin by 1
                        00014B
426       P:0291 P:0291 51F400            MOVE              #(END_SERIAL_READ_RIGHT_1-SERIAL_READ_RIGHT_1),B0
                        00000D
427       P:0293 P:0293 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
428       P:0294 P:0294 0D030D            JSR     <WAVECPY                          ; Copy the waveform
429       P:0295 P:0295 0C0307            JMP     <CMP_END
430       P:0296 P:0296 0A3782  TRY_2_R   JCLR    #2,X:<BINBIT,TRY_3_R
                        00029F
431       P:0298 P:0298 60F400            MOVE              #SERIAL_READ_RIGHT_2,R0 ; Here if right amp, bin by 2
                        000178
432       P:029A P:029A 51F400            MOVE              #(END_SERIAL_READ_RIGHT_2-SERIAL_READ_RIGHT_2),B0
                        000013
433       P:029C P:029C 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
434       P:029D P:029D 0D030D            JSR     <WAVECPY                          ; Copy the waveform
435       P:029E P:029E 0C0307            JMP     <CMP_END
436       P:029F P:029F 0A3783  TRY_3_R   JCLR    #3,X:<BINBIT,TRY_4_R
                        0002A8
437       P:02A1 P:02A1 60F400            MOVE              #SERIAL_READ_RIGHT_3,R0 ; Here if right amp, bin by 3
                        0001B7
438       P:02A3 P:02A3 51F400            MOVE              #(END_SERIAL_READ_RIGHT_3-SERIAL_READ_RIGHT_3),B0
                        000019
439       P:02A5 P:02A5 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
440       P:02A6 P:02A6 0D030D            JSR     <WAVECPY                          ; Copy the waveform
441       P:02A7 P:02A7 0C0307            JMP     <CMP_END
442       P:02A8 P:02A8 0A3784  TRY_4_R   JCLR    #4,X:<BINBIT,TRY_5_R
                        0002B1
443       P:02AA P:02AA 60F400            MOVE              #SERIAL_READ_RIGHT_4,R0 ; Here if right amp, bin by 4
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 9



                        000208
444       P:02AC P:02AC 51F400            MOVE              #(END_SERIAL_READ_RIGHT_4-SERIAL_READ_RIGHT_4),B0
                        00001F
445       P:02AE P:02AE 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
446       P:02AF P:02AF 0D030D            JSR     <WAVECPY                          ; Copy the waveform
447       P:02B0 P:02B0 0C0307            JMP     <CMP_END
448       P:02B1 P:02B1 0A3785  TRY_5_R   JCLR    #5,X:<BINBIT,CMP_END
                        000307
449       P:02B3 P:02B3 60F400            MOVE              #SERIAL_READ_RIGHT_5,R0 ; Here if right amp, bin by 5
                        00026B
450       P:02B5 P:02B5 51F400            MOVE              #(END_SERIAL_READ_RIGHT_5-SERIAL_READ_RIGHT_5),B0
                        000025
451       P:02B7 P:02B7 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
452       P:02B8 P:02B8 0D030D            JSR     <WAVECPY                          ; Copy the waveform
453       P:02B9 P:02B9 0C0307            JMP     <CMP_END
454    
455       P:02BA P:02BA 56F400  CMP_LR    MOVE              #'_LR',A                ; LEFT and RIGHT = readouts #0 and #1
                        5F4C52
456       P:02BC P:02BC 200045            CMP     X0,A
457       P:02BD P:02BD 0E230A            JNE     <CMP_ERROR
458       P:02BE P:02BE 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
459       P:02BF P:02BF 56F400            MOVE              #SERIAL_SKIP_SPLIT,A
                        0000F8
460       P:02C1 P:02C1 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
461       P:02C3 P:02C3 56F400            MOVE              #INITIAL_CLOCK_SPLIT,A
                        00007F
462       P:02C5 P:02C5 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
463       P:02C7 P:02C7 56F400            MOVE              #SERIAL_CLOCK_SPLIT,A
                        0000A3
464       P:02C9 P:02C9 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
465       P:02CB P:02CB 56F400            MOVE              #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),A
                        03200A
466       P:02CD P:02CD 5E7000            MOVE                          A,Y:CCLK_1
                        0000BC
467       P:02CF P:02CF 0A7025            BSET    #SPLIT_S,X:STATUS
                        000000
468                             ; Now go through copying in the serial read waveform if binning more than 5.
469       P:02D1 P:02D1 200013            CLR     A
470       P:02D2 P:02D2 20001B            CLR     B
471       P:02D3 P:02D3 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
472       P:02D4 P:02D4 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
473       P:02D5 P:02D5 50F400            MOVE              #>5,A0
                        000005
474       P:02D7 P:02D7 200005            CMP     B,A
475       P:02D8 P:02D8 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
476       P:02D9 P:02D9 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
477       P:02DA P:02DA 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
478       P:02DB P:02DB 0A3781  TRY_1_S   JCLR    #1,X:<BINBIT,TRY_2_S
                        0002E4
479                             ;       MOVE    #3,A0                   ; HACK
480                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
481       P:02DD P:02DD 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if split amp, bin by 1
                        000158
482       P:02DF P:02DF 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                        00000D
483       P:02E1 P:02E1 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
484       P:02E2 P:02E2 0D030D            JSR     <WAVECPY                          ; Copy the waveform
485       P:02E3 P:02E3 0C0307            JMP     <CMP_END
486       P:02E4 P:02E4 0A3782  TRY_2_S   JCLR    #2,X:<BINBIT,TRY_3_S
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 10



                        0002ED
487       P:02E6 P:02E6 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if split amp, bin by 2
                        00018B
488       P:02E8 P:02E8 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                        000013
489       P:02EA P:02EA 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
490       P:02EB P:02EB 0D030D            JSR     <WAVECPY                          ; Copy the waveform
491       P:02EC P:02EC 0C0307            JMP     <CMP_END
492       P:02ED P:02ED 0A3783  TRY_3_S   JCLR    #3,X:<BINBIT,TRY_4_S
                        0002F6
493       P:02EF P:02EF 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if split amp, bin by 3
                        0001D0
494       P:02F1 P:02F1 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                        000019
495       P:02F3 P:02F3 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
496       P:02F4 P:02F4 0D030D            JSR     <WAVECPY                          ; Copy the waveform
497       P:02F5 P:02F5 0C0307            JMP     <CMP_END
498       P:02F6 P:02F6 0A3784  TRY_4_S   JCLR    #4,X:<BINBIT,TRY_5_S
                        0002FF
499       P:02F8 P:02F8 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if split amp, bin by 4
                        000227
500       P:02FA P:02FA 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                        00001F
501       P:02FC P:02FC 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
502       P:02FD P:02FD 0D030D            JSR     <WAVECPY                          ; Copy the waveform
503       P:02FE P:02FE 0C0307            JMP     <CMP_END
504       P:02FF P:02FF 0A3785  TRY_5_S   JCLR    #5,X:<BINBIT,CMP_END
                        000307
505       P:0301 P:0301 60F400            MOVE              #SERIAL_READ_SPLIT_5,R0 ; Here if split amp, bin by 5
                        000290
506       P:0303 P:0303 51F400            MOVE              #(END_SERIAL_READ_SPLIT_5-SERIAL_READ_SPLIT_5),B0
                        000025
507       P:0305 P:0305 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
508       P:0306 P:0306 0D030D            JSR     <WAVECPY                          ; Copy the waveform
509    
510       P:0307 P:0307 44F400  CMP_END   MOVE              #'DON',X0
                        444F4E
511       P:0309 P:0309 00000C            RTS
512                             CMP_ERROR
513       P:030A P:030A 44F400            MOVE              #'ERR',X0
                        455252
514       P:030C P:030C 00000C            RTS
515    
516                             ; Short function to copy in waveforms from high Y to fast Y memory.
517                             ; R0 is the source address, R7 the destination, and X0 is intermediary reg.
518                             WAVECPY
519       P:030D P:030D 06C900            DO      B0,WAVELP                         ; Copy the waveform; B0 is SERWAVLEN already
                        000311
520       P:030F P:030F 4CD800            MOVE                          Y:(R0)+,X0
521       P:0310 P:0310 4C5F00            MOVE                          X0,Y:(R7)+
522       P:0311 P:0311 000000            NOP
523                             WAVELP
524       P:0312 P:0312 000000            NOP
525       P:0313 P:0313 00000C            RTS
526    
527                             ; Short function to set the correct bit in BINBIT based on NSBIN
528                             ; Called only if NSBIN is less than 6.
529    
530                             SET_BINBIT
531                             ;       MOVE    Y:<TESTLOC1,A0                  ; HACK - test if this code is executed
532                             ;       INC     A                               ; HACK
533                             ;       MOVE    A0,Y:<TESTLOC1                  ; HACK
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 11



534       P:0314 P:0314 50F400            MOVE              #>1,A0                  ; Put a bit in A and shift to right spot
                        000001
535       P:0316 P:0316 060540            DO      Y:<NSBIN,BINLOOP                  ; Bit zero position not used, 1-5 used
                        000318
536       P:0318 P:0318 200032            ASL     A
537                             BINLOOP
538       P:0319 P:0319 503700            MOVE              A0,X:<BINBIT            ; set bit 1-5 for SELECT_OUTPUT_SOURCE jump tabl
e
539       P:031A P:031A 00000C            RTS
540    
541    
542                             ; Set the number of rows and columns and binning factors
543                             SET_ROWS_COLUMNS
544       P:031B P:031B 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NSR = NAXIS1
545       P:031C P:031C 4C7000            MOVE                          X0,Y:NSR
                        000001
546       P:031E P:031E 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NPR = NAXIS2
547       P:031F P:031F 4C7000            MOVE                          X0,Y:NPR
                        000002
548       P:0321 P:0321 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NSBIN
549       P:0322 P:0322 4C7000            MOVE                          X0,Y:NSBIN
                        000005
550       P:0324 P:0324 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NPBIN
551       P:0325 P:0325 4C7000            MOVE                          X0,Y:NPBIN
                        000006
552       P:0327 P:0327 4CBD00            MOVE                          Y:<AMPVAL,X0 ; Get ampval in X0 for SOS call
553       P:0328 P:0328 0D021E            JSR     <SELECT_OUTPUT_SOURCE             ; Update serial read waveform in case binning ch
anged
554       P:0329 P:0329 0C0000            JMP     <FINISH
555    
556                             ; Set the variables for the time-resolved modes
557                             SET_IMAGE_PARAM
558       P:032A P:032A 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Image mode
559       P:032B P:032B 447000            MOVE              X0,X:IMAGE_MODE
                        000030
560       P:032D P:032D 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Iframes = NAXIS3
561       P:032E P:032E 4C7000            MOVE                          X0,Y:IFRAMES
                        00003A
562       P:0330 P:0330 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Srows
563       P:0331 P:0331 4C7000            MOVE                          X0,Y:SROWS
                        000038
564       P:0333 P:0333 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Interval
565                             ;       MOVE    X0,Y:INTERVAL           ; HACK - Using Interval as a test location
566       P:0334 P:0334 0C0000            JMP     <FINISH
567    
568    
569                             ; Set the hardware trigger bit, executed as a command
570                             SET_TRIGGER
571       P:0335 P:0335 44DC00            MOVE              X:(R4)+,X0              ; Get the trigger value
572       P:0336 P:0336 56F400            MOVE              #'_ON',A
                        5F4F4E
573       P:0338 P:0338 200045            CMP     X0,A
574       P:0339 P:0339 0AF0A2            JNE     NO_TRIGGER
                        000340
575       P:033B P:033B 0AA4AB            JSET    #11,X:PBD,TRIG_CLR                ; Is Trigger running?
                        00033E
576       P:033D P:033D 0C0000            JMP     <ERROR                            ; Yes! report Error!  Why do this?
577                             TRIG_CLR
578       P:033E P:033E 0A0028            BSET    #TRIGGER,X:<STATUS                ; Set status bit, hardware trigger
579       P:033F P:033F 0C0000            JMP     <FINISH
580                             NO_TRIGGER
581       P:0340 P:0340 0A0008            BCLR    #TRIGGER,X:<STATUS                ; Clear Status bit, software timing
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 12



582       P:0341 P:0341 0C0000            JMP     <FINISH
583    
584                             ; Calculate the fast read parameters for each readout box
585                             SETUP_SUBROUTINE
586       P:0342 P:0342 4C8C00            MOVE                          Y:<SERWAVLEN,X0 ; # of waveforms
587       P:0343 P:0343 4D9000            MOVE                          Y:<NSERIALS_READ,X1 ; Number of pixels to read
588       P:0344 P:0344 0D0482            JSR     <FASTSKP                          ; Compute number of clocks required
589       P:0345 P:0345 4D1300            MOVE                          X1,Y:<NREAD ; Number of waveforms per line
590       P:0346 P:0346 5E9A00            MOVE                          Y:<NR_BIAS,A ; Number of pixels to read
591       P:0347 P:0347 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                        00034A
592       P:0349 P:0349 200022            ASR     A
593       P:034A P:034A 21C500            MOVE              A,X1                    ; Number of waveforms per line
594       P:034B P:034B 0D0482            JSR     <FASTSKP                          ; Compute number of clocks required
595       P:034C P:034C 4D1500            MOVE                          X1,Y:<NBIAS ; Number of waveforms per line
596       P:034D P:034D 44F400            MOVE              #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT),X0 ; # of waveforms
                        000006
597       P:034F P:034F 4D8300            MOVE                          Y:<NS_CLR,X1 ; Number of pixels to skip
598       P:0350 P:0350 0D0482            JSR     <FASTSKP                          ; Compute number of clocks required
599       P:0351 P:0351 4D1100            MOVE                          X1,Y:<NSCLR ; Number of waveforms per line
600       P:0352 P:0352 4D9700            MOVE                          Y:<NS_SKP1,X1 ; Number of pixels to skip
601       P:0353 P:0353 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
602       P:0354 P:0354 2000F0            MPY     Y1,X1,A
603       P:0355 P:0355 200022            ASR     A
604       P:0356 P:0356 210500            MOVE              A0,X1
605       P:0357 P:0357 0D0482            JSR     <FASTSKP                          ; Compute number of clocks required
606       P:0358 P:0358 4D1200            MOVE                          X1,Y:<NSKIP1 ; Number of waveforms per line
607       P:0359 P:0359 4D9800            MOVE                          Y:<NS_SKP2,X1 ; Number of pixels to skip
608       P:035A P:035A 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
609       P:035B P:035B 2000F0            MPY     Y1,X1,A
610       P:035C P:035C 200022            ASR     A
611       P:035D P:035D 210500            MOVE              A0,X1
612       P:035E P:035E 0D0482            JSR     <FASTSKP                          ; Compute number of clocks required
613       P:035F P:035F 4D1400            MOVE                          X1,Y:<NSKIP2 ; Number of waveforms per line
614       P:0360 P:0360 4D9600            MOVE                          Y:<NP_SKIP,X1
615       P:0361 P:0361 4F8600            MOVE                          Y:<NPBIN,Y1
616       P:0362 P:0362 2000F0            MPY     X1,Y1,A
617       P:0363 P:0363 200022            ASR     A
618       P:0364 P:0364 581600            MOVE                          A0,Y:<NP_SKIP
619       P:0365 P:0365 00000C            RTS
620    
621                             ; Returns immediately if hardware triggering is not being used
622                             ; Blocks until the trigger is found to be high twice in a row.
623                             ; Waits until the trigger goes high
624                             WAIT_UNTIL_TRIGGER
625       P:0366 P:0366 0A0088            JCLR    #TRIGGER,X:STATUS,UNTIL_TRIGGER_RETURN
                        00036F
626       P:0368 P:0368 000000            NOP
627       P:0369 P:0369 0AA48B            JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER      ; Is Trigger Low?
                        000366
628       P:036B P:036B 000000            NOP                                       ; Pause
629       P:036C P:036C 0AA48B            JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER      ; Is Trigger still Low?
                        000366
630       P:036E P:036E 000000            NOP
631                             UNTIL_TRIGGER_RETURN
632       P:036F P:036F 00000C            RTS
633    
634                             ; Returns immediately if hardware triggering is not being used
635                             ; Blocks until the trigger is found to be low twice in a row.
636                             ; Waits while the trigger is high
637                             WAIT_WHILE_TRIGGER
638       P:0370 P:0370 0A0088            JCLR    #TRIGGER,X:STATUS,WHILE_TRIGGER_RETURN
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 13



                        000379
639       P:0372 P:0372 000000            NOP
640       P:0373 P:0373 0AA4AB            JSET    #11,X:PBD,WAIT_WHILE_TRIGGER      ; Is Trigger High?
                        000370
641       P:0375 P:0375 000000            NOP                                       ; Pause
642       P:0376 P:0376 0AA4AB            JSET    #11,X:PBD,WAIT_WHILE_TRIGGER      ; Is Trigger still High?
                        000370
643       P:0378 P:0378 000000            NOP
644                             WHILE_TRIGGER_RETURN
645       P:0379 P:0379 00000C            RTS
646    
647                             ; Like WAIT_WHILE_TRIGGER but clears the CCD while waiting
648                             ; Pro:  Clears CCD while waiting.  Con: timing rattiness of 1 parallel time
649                             ; Returns immediately if hardware triggering is not being used
650                             ; Blocks until the trigger is found to be low twice in a row.
651                             ; Waits while the trigger is high
652                             CLEAR_WHILE_TRIGGER
653       P:037A P:037A 0A0088            JCLR    #TRIGGER,X:STATUS,CLEAR_TRIG_RETURN
                        000385
654       P:037C P:037C 60F400            MOVE              #IS_CLEAR,R0            ; Address of parallel transfer waveform
                        000063
655       P:037E P:037E 0D01E7            JSR     <CLOCK                            ; Go clock out the CCD charge
656       P:037F P:037F 0AA4AB            JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER     ; Is Trigger High?
                        00037A
657       P:0381 P:0381 000000            NOP                                       ; Pause
658       P:0382 P:0382 0AA4AB            JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER     ; Is Trigger still High?
                        00037A
659       P:0384 P:0384 000000            NOP
660                             CLEAR_TRIG_RETURN
661       P:0385 P:0385 00000C            RTS
662    
663                             ; Subroutine to compute SROWS in unbinned pixels and store in UBSROWS
664    
665                             UB_CONV
666       P:0386 P:0386 4CB800            MOVE                          Y:<SROWS,X0
667       P:0387 P:0387 4D8600            MOVE                          Y:<NPBIN,X1 ; Adjust for for parallel binning factor
668       P:0388 P:0388 2000A0            MPY     X0,X1,A
669       P:0389 P:0389 200022            ASR     A
670       P:038A P:038A 583900            MOVE                          A0,Y:<UBSROWS ; Put unbinned number in UBSROWS
671       P:038B P:038B 00000C            RTS
672    
673                             ; Key code segments for the HIPO modes.
674                             ; Jump table to the various modes - see also timhdr.s
675                             START_FT_EXPOSURE
676       P:038C P:038C 0A0009            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of lingering abort flag
677       P:038D P:038D 0A30A1            JSET    #FIND,X:IMAGE_MODE,SINGLE_PROC
                        0003BE
678       P:038F P:038F 0A30A4            JSET    #SINGLE,X:IMAGE_MODE,SINGLE_PROC
                        0003BE
679                             ;       JSET    #SERIES,X:IMAGE_MODE,SERIES_PROC        ; defunct.  Use basic occ.
680       P:0391 P:0391 0A30A0            JSET    #FDOTS,X:IMAGE_MODE,FDOT_PROC
                        0003A0
681       P:0393 P:0393 0A30A2            JSET    #SDOTS,X:IMAGE_MODE,SDOT_PROC     ; slow dots & strips use sdot_proc
                        0003F0
682       P:0395 P:0395 0A30A5            JSET    #STRIP,X:IMAGE_MODE,SDOT_PROC
                        0003F0
683       P:0397 P:0397 0A30A7            JSET    #B_OCC,X:IMAGE_MODE,SINGLE_PROC   ; basic occ uses single_proc
                        0003BE
684       P:0399 P:0399 0A30A6            JSET    #F_OCC,X:IMAGE_MODE,FPO_PROC      ; fast & pipelined occ use occ_proc
                        00041A
685       P:039B P:039B 0A30A8            JSET    #P_OCC,X:IMAGE_MODE,FPO_PROC
                        00041A
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 14



686       P:039D P:039D 44F400            MOVE              #'ERR',X0               ; error if not a valid mode
                        455252
687       P:039F P:039F 0C0000            JMP     <ERROR
688    
689                             FDOT_PROC                                           ; used by fdots only
690                             ; Start by replacing SROWS (binned rows) with unbinned rows.  Will get rewritten on next SEX command
691                             ; Leave the DO loop in here - no reason to change it - won't exceed 65535 dots, for sure!
692       P:03A0 P:03A0 0D0386            JSR     UB_CONV                           ; Fill in unbinned SROWS
693       P:03A1 P:03A1 5E8200            MOVE                          Y:<NPR,A
694       P:03A2 P:03A2 5E1C00            MOVE                          A,Y:<NP_READ ; Make sure that NP_READ=NPR in case of subfram
e
695       P:03A3 P:03A3 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
696       P:03A4 P:03A4 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for FDOTS
697       P:03A5 P:03A5 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
698       P:03A6 P:03A6 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        00044A
699       P:03A8 P:03A8 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
700       P:03A9 P:03A9 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
701                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
702       P:03AA P:03AA 0D0489            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
703       P:03AB P:03AB 063A40            DO      Y:<IFRAMES,FDOT_LOOP              ; Loop over the number of FDOTS
                        0003B6
704       P:03AD P:03AD 0A00A8            JSET    #TRIGGER,X:STATUS,FDX_END         ; If no triggering jump to expose image function
                        0003B2
705       P:03AF P:03AF 67F400            MOVE              #FDX_END,R7             ; Store the Address into R7
                        0003B2
706       P:03B1 P:03B1 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
707       P:03B2 P:03B2 0D0366  FDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
708       P:03B3 P:03B3 4DB900            MOVE                          Y:<UBSROWS,X1 ; Number of unbinned rows per shift
709       P:03B4 P:03B4 0D045E            JSR     <ISHIFT                           ; Clock out the waveforms
710       P:03B5 P:03B5 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
711       P:03B6 P:03B6 000000            NOP
712                             FDOT_LOOP
713       P:03B7 P:03B7 0D0490            JSR     <C_CSHUT                          ; Conditionally close shutter
714       P:03B8 P:03B8 063A40            DO      Y:<IFRAMES,FDOT_LP1               ; Loop over the number of FDOTS during readout
                        0003BB
715       P:03BA P:03BA 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD
716       P:03BB P:03BB 000000            NOP
717                             FDOT_LP1
718                             ;       JSR     <WAIT_UNTIL_TRIGGER             ; If taking more than one set of dots sync. trigger.
  Vestigial?
719       P:03BC P:03BC 0AF080            JMP     CLEANUP                           ; clean up after command.
                        000456
720    
721                             SINGLE_PROC                                         ; Used by find, single, and basic occ
722       P:03BE P:03BE 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for find & basic occ
723       P:03BF P:03BF 0A3084            JCLR    #SINGLE,X:IMAGE_MODE,*+3          ; But if single mode,
                        0003C2
724       P:03C1 P:03C1 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
725       P:03C2 P:03C2 0A3102            BCLR    #STORAGE,X:<ISTATUS               ; Do the FT, no storage clocks only during reado
ut
726       P:03C3 P:03C3 0A3100            BCLR    #NO_SKIP,X:<ISTATUS               ; Do parallel skip up to the subframe boundary
727    
728                                       IF      @SCP("50","0")
729                                       ELSE
730       P:03C4 P:03C4 063280            DO      #SDELAY,SNGL_DELAY1
                        0003CB
731       P:03C6 P:03C6 44F400            MOVE              #25000,X0
                        0061A8
732       P:03C8 P:03C8 06C400            DO      X0,SNGL_DELAY0
                        0003CA
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 15



733       P:03CA P:03CA 000000            NOP
734                              SNGL_DELAY0
735       P:03CB P:03CB 000000            NOP
736                              SNGL_DELAY1
737       P:03CC P:03CC 000000            NOP
738                                       ENDIF
739    
740    
741       P:03CD P:03CD 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        00044A
742       P:03CF P:03CF 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
743       P:03D0 P:03D0 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
744                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
745       P:03D1 P:03D1 58BA00            MOVE                          Y:<IFRAMES,A0
746       P:03D2 P:03D2 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
747       P:03D3 P:03D3 0D0489  SN_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
748       P:03D4 P:03D4 67F400            MOVE              #SNX_END,R7             ; Store the Address into R7
                        0003DA
749       P:03D6 P:03D6 0A002C            BSET    #ST_EXP,X:<STATUS
750       P:03D7 P:03D7 0A00A8            JSET    #TRIGGER,X:STATUS,SNX_END         ; If no triggering jump to expose image function
                        0003DA
751       P:03D9 P:03D9 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
752                             SNX_END
753       P:03DA P:03DA 0A000C            BCLR    #ST_EXP,X:<STATUS
754       P:03DB P:03DB 0A00A9            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                        0003EB
755    
756       P:03DD P:03DD 0D0366            JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
757       P:03DE P:03DE 0D0490            JSR     <C_CSHUT                          ; Close shutter if open-close bit is set
758       P:03DF P:03DF 0A0024            BSET    #ST_RDC,X:<STATUS
759       P:03E0 P:03E0 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD
760       P:03E1 P:03E1 0A0004            BCLR    #ST_RDC,X:<STATUS
761       P:03E2 P:03E2 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
762       P:03E3 P:03E3 0A00A9            JSET    #ST_ABRT,X:<STATUS,SNX_FINI       ; got abort underway?
                        0003EB
763       P:03E5 P:03E5 200013            CLR     A
764       P:03E6 P:03E6 58BE00            MOVE                          Y:<IFLPCNT,A0
765       P:03E7 P:03E7 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
766       P:03E8 P:03E8 583E00            MOVE                          A0,Y:<IFLPCNT
767       P:03E9 P:03E9 200003            TST     A
768       P:03EA P:03EA 0E23D3            JNE     SN_LP                             ; End of IFRAMES loop
769                             SNX_FINI
770       P:03EB P:03EB 0A30A1            JSET    #FIND,X:IMAGE_MODE,*+3
                        0003EE
771       P:03ED P:03ED 0D0492            JSR     <CSHUT                            ; Close the shutter unless in find mode
772       P:03EE P:03EE 0AF080            JMP     CLEANUP                           ; clean up after command.
                        000456
773    
774                             SDOT_PROC                                           ; Used by slow dots and strips
775       P:03F0 P:03F0 5EB800            MOVE                          Y:<SROWS,A
776       P:03F1 P:03F1 5E1C00            MOVE                          A,Y:<NP_READ ; Make sure that NP_READ=SROWS
777       P:03F2 P:03F2 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for strips
778       P:03F3 P:03F3 0A3082            JCLR    #SDOTS,X:IMAGE_MODE,*+3           ; But if sdots mode,
                        0003F6
779       P:03F5 P:03F5 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
780       P:03F6 P:03F6 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for SDOTS and st
rips
781       P:03F7 P:03F7 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
782                                       IF      @SCP("50","0")
783                                       ELSE
784       P:03F8 P:03F8 063280            DO      #SDELAY,SDOT_DELAY1
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 16



                        0003FF
785       P:03FA P:03FA 44F400            MOVE              #25000,X0
                        0061A8
786       P:03FC P:03FC 06C400            DO      X0,SDOT_DELAY0
                        0003FE
787       P:03FE P:03FE 000000            NOP
788                              SDOT_DELAY0
789       P:03FF P:03FF 000000            NOP
790                              SDOT_DELAY1
791       P:0400 P:0400 000000            NOP
792                                       ENDIF
793    
794       P:0401 P:0401 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        00044A
795       P:0403 P:0403 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
796       P:0404 P:0404 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
797                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
798       P:0405 P:0405 58BA00            MOVE                          Y:<IFRAMES,A0
799       P:0406 P:0406 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
800       P:0407 P:0407 0D0489  SD_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
801       P:0408 P:0408 0A00A8            JSET    #TRIGGER,X:STATUS,SDX_END         ; If no triggering jump to expose image function
                        00040D
802       P:040A P:040A 67F400            MOVE              #SDX_END,R7             ; Store the Address into R7
                        00040D
803       P:040C P:040C 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
804       P:040D P:040D 0D0366  SDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
805       P:040E P:040E 0D0490            JSR     <C_CSHUT                          ; Close shutter if open-close is set
806       P:040F P:040F 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD.
807                                                                                 ; No FT or parallel skip since STORAGE=1
808       P:0410 P:0410 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
809       P:0411 P:0411 200013            CLR     A
810       P:0412 P:0412 58BE00            MOVE                          Y:<IFLPCNT,A0
811       P:0413 P:0413 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
812       P:0414 P:0414 583E00            MOVE                          A0,Y:<IFLPCNT
813       P:0415 P:0415 200003            TST     A
814       P:0416 P:0416 0E2407            JNE     SD_LP                             ; End of IFRAMES loop
815       P:0417 P:0417 0D0492            JSR     <CSHUT                            ; Unconditionally close shutter
816       P:0418 P:0418 0AF080            JMP     CLEANUP                           ; clean up after command.
                        000456
817    
818                             FPO_PROC                                            ; Used by fast and pipelined occultation modes
819       P:041A P:041A 5E9C00            MOVE                          Y:<NP_READ,A
820       P:041B P:041B 5E3800            MOVE                          A,Y:<SROWS  ; Make sure that SROWS=NP_READ
821       P:041C P:041C 0D0386            JSR     UB_CONV                           ; Fill in unbinned SROWS in UBSROWS
822       P:041D P:041D 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for both of these modes
823       P:041E P:041E 0A3102            BCLR    #STORAGE,X:<ISTATUS               ; Storage clocks only during readout
824       P:041F P:041F 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
825       P:0420 P:0420 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        00044A
826       P:0422 P:0422 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
827       P:0423 P:0423 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
828                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
829       P:0424 P:0424 0D0489            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
830       P:0425 P:0425 58BA00            MOVE                          Y:<IFRAMES,A0
831       P:0426 P:0426 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
832       P:0427 P:0427 0A00A8  FP_LP     JSET    #TRIGGER,X:STATUS,FPO_END         ; If no triggering jump to expose image function
                        00042C
833       P:0429 P:0429 67F400            MOVE              #FPO_END,R7             ; Store the Address into R7
                        00042C
834       P:042B P:042B 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
835       P:042C P:042C 0D0366  FPO_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 17



836       P:042D P:042D 4DB900            MOVE                          Y:<UBSROWS,X1 ; Shift down UBSROWS unbinned rows
837       P:042E P:042E 0BF080            JSR     ISHIFT                            ; Clock down subframe height
                        00045E
838       P:0430 P:0430 0A30A8            JSET    #P_OCC,X:IMAGE_MODE,FPO_RD        ; Shift the rest of the way for F_OCC
                        00043A
839                                                                                 ; Go straight to readout if P_OCC
840       P:0432 P:0432 4CF000            MOVE                          Y:S_SIZE,X0
                        00003B
841       P:0434 P:0434 208E00            MOVE              X0,A                    ; Get only least significant 24 bits
842       P:0435 P:0435 4CB900            MOVE                          Y:<UBSROWS,X0
843       P:0436 P:0436 200044            SUB     X0,A                              ;
844       P:0437 P:0437 21C500            MOVE              A,X1                    ; X1 = S_SIZE - UBSROWS
845       P:0438 P:0438 0BF080            JSR     SSHIFT                            ; Clock storage the rest of the way
                        000467
846       P:043A P:043A 0D0134  FPO_RD    JSR     <RCCD1                            ; Finally, read out the CCD.  Skip the FT
847       P:043B P:043B 0A30A6            JSET    #F_OCC,X:IMAGE_MODE,FPO_SK        ; Shift back up by UBSROWS if P_OCC
                        000440
848       P:043D P:043D 4DB900            MOVE                          Y:<UBSROWS,X1 ; Shift UBSROWS unbinned rows back up
849       P:043E P:043E 0BF080            JSR     RSHIFT                            ; Clock subframe height back up
                        000470
850       P:0440 P:0440 0D0370  FPO_SK    JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
851       P:0441 P:0441 200013            CLR     A
852       P:0442 P:0442 58BE00            MOVE                          Y:<IFLPCNT,A0
853       P:0443 P:0443 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
854       P:0444 P:0444 583E00            MOVE                          A0,Y:<IFLPCNT
855       P:0445 P:0445 200003            TST     A
856       P:0446 P:0446 0E2427            JNE     FP_LP                             ; End of IFRAMES loop
857       P:0447 P:0447 0D0492            JSR     <CSHUT                            ; Unconditionally close shutter
858       P:0448 P:0448 0AF080            JMP     CLEANUP                           ; clean up after command.
                        000456
859    
860                             ; Support subroutines and code fragments used in the various mode code
861                             ; IMG_INI, CLEANUP, ISHIFT, SSHIFT, RSHIFT
862                             ;  Image initialization subroutine.  Sets up status bits & PCI card
863    
864       P:044A P:044A 09F480  IMG_INI   MOVEP             #$020102,Y:WRFO         ; Transmit header word
                        020102
865       P:044C P:044C 060FA0            REP     #15                               ; Delay for transmission
866       P:044D P:044D 000000            NOP
867       P:044E P:044E 09F480            MOVEP             #'IIA',Y:WRFO           ; Initialize Image Address
                        494941
868       P:0450 P:0450 060FA0            REP     #15
869       P:0451 P:0451 000000            NOP
870                             ;        BSET    #ST_RDC,X:<STATUS       ; Set status to reading out
871       P:0452 P:0452 0D05FB            JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
872       P:0453 P:0453 0AA421            BSET    #WW,X:PBD                         ; Set WW = 1 for 16-bit image data
873       P:0454 P:0454 000000            NOP
874       P:0455 P:0455 00000C            RTS
875    
876                             ; Cleanup code fragment (not a subroutine) for the end all modes.  JMP to it.
877    
878       P:0456 P:0456 0AA401  CLEANUP   BCLR    #WW,X:PBD                         ; Clear WW to 0 for 32-bit commands
879                             ;        BCLR    #ST_RDC,X:<STATUS       ; Clear status to NOT reading out
880       P:0457 P:0457 0A0009            BCLR    #ST_ABRT,X:<STATUS                ; Clear status of any abort flag
881                             ; Restore the controller to non-image data transfer and idling if necessary
882       P:0458 P:0458 0A0082            JCLR    #IDLMODE,X:<STATUS,START          ; Don't idle after readout
                        000008
883       P:045A P:045A 44F400            MOVE              #IDLE,X0
                        00020F
884       P:045C P:045C 440000            MOVE              X0,X:<IDL_ADR
885       P:045D P:045D 0C0008            JMP     <START                            ; Wait for a new command
886    
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timmisc.s  Page 18



887                             ; Shift image and storage areas down by the number of rows in X1
888                             ISHIFT
889       P:045E P:045E 06C500            DO      X1,ISH_LOOP                       ; Number of rows to shift is in X1
                        000462
890       P:0460 P:0460 306300            MOVE              #<IS_CLEAR,R0           ; Ganged clocks with DG running
891       P:0461 P:0461 0D01E7            JSR     <CLOCK                            ; Parallel clocking
892       P:0462 P:0462 000000            NOP
893                             ISH_LOOP
894       P:0463 P:0463 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                        00006C
895       P:0465 P:0465 0D01E7            JSR     <CLOCK
896       P:0466 P:0466 00000C            RTS                                       ; End of ISHIFT
897    
898                             ; Shift storage area only down by the number of rows in X1
899                             SSHIFT
900       P:0467 P:0467 06C500            DO      X1,SSH_LOOP                       ; Number of rows to shift is in X1
                        00046B
901       P:0469 P:0469 305100            MOVE              #<S_CLEAR,R0            ; Storage clocks only with DG running
902       P:046A P:046A 0D01E7            JSR     <CLOCK                            ; Parallel clocking
903       P:046B P:046B 000000            NOP
904                             SSH_LOOP
905       P:046C P:046C 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                        00006C
906       P:046E P:046E 0D01E7            JSR     <CLOCK
907       P:046F P:046F 00000C            RTS                                       ; End of SSHIFT
908    
909                             ; Used by pipelined occultation mode to move the storage area back up to
910                             ; the seam following read of a subframe
911                             RSHIFT
912       P:0470 P:0470 06C500            DO      X1,RVS_SHIFT                      ; Number of rows to read out
                        000474
913       P:0472 P:0472 304900            MOVE              #<R_S_PARALLEL,R0       ; Reverse parallel waveform
914       P:0473 P:0473 0D01E7            JSR     <CLOCK                            ; Parallel clocking
915       P:0474 P:0474 000000            NOP
916                             RVS_SHIFT
917       P:0475 P:0475 00000C            RTS                                       ; End of RSHIFT
918                                       INCLUDE "timCCDmisc.s"                    ; Generic
919                             ; This file is for utilities that are in common to all the timing board
920                             ;   programs, located starting at P:$200 in external SRAM
921    
922                                     COMMENT *
923    
924                             The following commands are supported in this "timmisc.s" file
925                             PAL_DLY                 Subroutine to delay by about 8 microseconds
926                             SET_DAC                 Transfer DAC values in (R0) table to the DACs
927                             FASTSKP                 Compute number of waveform table entries in a readout
928                                                             for fast clocking
929                             SYNTHETIC_IMAGE         Generate a synthetic image for system testing
930                             OSHUT                   Subroutine call for opening the shutter
931                             CSHUT                   Subroutine call for closing the shutter
932                             OPEN_SHUTTER            Command for opening the shutter
933                             CLOSE_SHUTTER           Command for closing the shutter
934                             SET_EXP_TIME            Write desired exposure time to timing board variable
935                             RD_EXP_TIME             Read elapsed exposure time
936                             START_EXPOSURE          Start an exposure - 'DON' reply, clear FPA, open
937                                                     shutter, expose, close shutter, delay Y:SH_DLY, readout
938                             PAUSE_EXPOSURE          Close shutter, stop exposure timer
939                             RESUME_EXPOSURE         Open shutter if necessary, resume exposure timer
940                             ABORT_EXPOSURE          Close shutter, stop exposure timer
941                             INF                     Return version and timing information
942                             IDL                     Put FPA to clocking when not processing commands or
943                                                     reading out
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timCCDmisc.s  Page 19



944                             STP                     Put FPA to not clocking when not processing commands or
945                                                     reading out
946                             READ_CONTROLLER_CONFIGURATION
947    
948                             PWR_OFF                 Turn off ananlog power supply voltages to backplane
949                             PWR_ON                  Turn on analog power supply voltages to backplane
950                             SETBIAS                 Command to call SET_BIASES and reply 'DON'
951                             SET_BIASES              Subroutine to turn on all bias and clock voltages
952                                                     by reading them from the waveform tables and writing
953                                                     them to the DACs
954                             SER_ANA                 Direct the timing board DSP's synchronous serial
955                                                     transmitter to the analog boards (clock driver, video)
956                             SER_UTL                 Direct the timing board DSP's synchronous serial
957                                                     transmitter to the utility board
958                             CLR_SWS                 Clear the analog switches in the clock driver and
959                                                     video boards to lower their power consumption, as a
960                                                     command with a 'DON' reply
961                             CLEAR_SWITCHES          A subroutine call for CLR_WSW
962                             ST_GAIN                 Set the video processor gain to one of four values
963                             WR_CNTRL
964                             SET_DC
965                             SET_BIAS_NUMBER
966                             SET_MUX
967    
968                                     *
969    
970                             ;  ** Place this file after the custom timmisc.s file so it continues
971                             ;       to be written in the P:$200 address space  ****
972    
973                             ; Hardware control bit definitions
974       000004                SHUTTER   EQU     4                                 ; Shutter control bit = TIM-LATCH0, A30
975    
976    
977                             ; Delay for serial writes to the PALs and DACs by 8 microsec
978       P:0476 P:0476 06FA80  PAL_DLY   DO      #250,DLY                          ; Wait 8 usec for serial data transmission
                        000478
979       P:0478 P:0478 000000            NOP
980       P:0479 P:0479 000000  DLY       NOP
981       P:047A P:047A 00000C            RTS
982    
983                             ;  Update the DACs
984       P:047B P:047B 4CD800  SET_DAC   MOVE                          Y:(R0)+,X0  ; Get the number of table entries
985       P:047C P:047C 06C400            DO      X0,SET_L0                         ; Repeat X0 times
                        000480
986       P:047E P:047E 08D8EF            MOVEP             Y:(R0)+,X:SSITX         ; Send out the waveform
987       P:047F P:047F 0D0476            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
988       P:0480 P:0480 000000            NOP                                       ; Do loop restriction
989                             SET_L0
990       P:0481 P:0481 00000C            RTS                                       ; Return from subroutine
991    
992                             ; Subroutine for computing number of fast clocks needed
993       P:0482 P:0482 2000A8  FASTSKP   MPY     X0,X1,B                           ; X1 = number of pixels to skip,
994                                                                                 ; X0 = number of waveform table entries
995       P:0483 P:0483 20002A            ASR     B                                 ; Correct for multiplication left shift
996       P:0484 P:0484 212E00            MOVE              B0,A                    ; Get only least significant 24 bits
997       P:0485 P:0485 458000            MOVE              X:<ONE,X1
998       P:0486 P:0486 200064            SUB     X1,A                              ; Subtract 1
999       P:0487 P:0487 21C500            MOVE              A,X1                    ; X1 = X0 * X1 - 1
1000      P:0488 P:0488 00000C            RTS
1001   
1002                            ; Subroutine with two entry points.  C_OSHUT is conditional on SHUT
1003                            ; Open the shutter conditionally based on the shutter status bit
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timCCDmisc.s  Page 20



1004                            ; Open the shutter by setting the backplane bit TIM-LATCH0
1005      P:0489 P:0489 0A008B  C_OSHUT   JCLR    #SHUT,X:STATUS,OSH_RTN
                        00048F
1006      P:048B P:048B 0A0023  OSHUT     BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
1007      P:048C P:048C 0A0004            BCLR    #SHUTTER,X:<LATCH                 ; Clear hardware shutter bit to open
1008      P:048D P:048D 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                        000000
1009      P:048F P:048F 00000C  OSH_RTN   RTS
1010   
1011                            ; Subroutine with two entry points.  C_CSHUT is conditional on OPEN_CLOSE
1012                            ; Close the shutter conditionally based on the open-close ISTATUS bit
1013                            ; Close the shutter by clearing the backplane bit TIM-LATCH0
1014      P:0490 P:0490 0A3181  C_CSHUT   JCLR    #OPEN_CLOSE,X:ISTATUS,CSH_RTN     ; Don't close if always open
                        0004A2
1015      P:0492 P:0492 0A0003  CSHUT     BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
1016      P:0493 P:0493 0A0024            BSET    #SHUTTER,X:<LATCH                 ; Set hardware shutter bit to close
1017      P:0494 P:0494 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                        000000
1018      P:0496 P:0496 5E8900            MOVE                          Y:<SH_DEL,A
1019      P:0497 P:0497 200003            TST     A
1020      P:0498 P:0498 0EF4A1            JLE     <S_DEL0
1021      P:0499 P:0499 44F400            MOVE              #25000,X0
                        0061A8
1022      P:049B P:049B 06CE00            DO      A,S_DEL0                          ; Delay by Y:SH_DEL milliseconds
                        0004A0
1023      P:049D P:049D 06C400            DO      X0,S_DEL1
                        00049F
1024      P:049F P:049F 000000            NOP
1025      P:04A0 P:04A0 000000  S_DEL1    NOP
1026      P:04A1 P:04A1 000000  S_DEL0    NOP
1027      P:04A2 P:04A2 00000C  CSH_RTN   RTS
1028   
1029                            ; Open the shutter from the timing board, executed as a command
1030                            OPEN_SHUTTER
1031      P:04A3 P:04A3 0D048B            JSR     <OSHUT
1032      P:04A4 P:04A4 0C0000            JMP     <FINISH
1033   
1034                            ; Close the shutter from the timing board, executed as a command
1035                            CLOSE_SHUTTER
1036      P:04A5 P:04A5 0D0492            JSR     <CSHUT
1037      P:04A6 P:04A6 0C0000            JMP     <FINISH
1038   
1039                            ; Set the desired exposure time
1040                            SET_EXP_TIME
1041      P:04A7 P:04A7 44DC00            MOVE              X:(R4)+,X0
1042      P:04A8 P:04A8 440000            MOVE              X0,X:<EXP_TIM           ; Write to magic address
1043      P:04A9 P:04A9 440000            MOVE              X0,X:<TGT_TIM
1044      P:04AA P:04AA 0C0000            JMP     <FINISH
1045   
1046   
1047                            ; Abort exposure - close the shutter, stop the timer and resume idle mode
1048                            ABORT_EXPOSURE
1049      P:04AB P:04AB 0A00AC            JSET    #ST_EXP,X:<STATUS,DO_ABEXP
                        0004AE
1050                            ; assume we got here via the idle rcv loop
1051      P:04AD P:04AD 0C0000            JMP     <FINISH
1052                            DO_ABEXP
1053      P:04AE P:04AE 0A9E00            BCLR    #TIM_BIT,X:TCSR                   ; Disable the DSP exposure timer
1054                            ;
1055                            ; The place to return must be in R7-
1056      P:04AF P:04AF 0AE780            JMP     (R7)                              ; 'return' from EXPOSE
1057                            ;       JSR     <CSHUT                  ; Close the shutter
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timCCDmisc.s  Page 21



1058                            ;       JCLR    #IDLMODE,X:<STATUS,FINISH ; Check whether to idle after readout
1059                            ;       MOVE    #IDLE,X0                ; Idle after readout
1060                            ;       MOVE    X0,X:<IDL_ADR
1061                            ;       JMP     <FINISH
1062   
1063                            ;       Process INF according to the single addressing parameter
1064                            GET_INFO
1065      P:04B0 P:04B0 56DC00            MOVE              X:(R4)+,A               ; 0-4 is generic, >= 0x100 tim specific
1066      P:04B1 P:04B1 44F400            MOVE              #IVERSION,X0
                        04507F
1067      P:04B3 P:04B3 46F400            MOVE              #>GET_VERSION,Y0
                        000000
1068      P:04B5 P:04B5 200055            CMP     Y0,A
1069      P:04B6 P:04B6 0EA000            JEQ     <FINISH1
1070      P:04B7 P:04B7 44F400            MOVE              #IFLAVOR,X0
                        612020
1071      P:04B9 P:04B9 46F400            MOVE              #>GET_FLAVOR,Y0
                        000001
1072      P:04BB P:04BB 200055            CMP     Y0,A
1073      P:04BC P:04BC 0EA000            JEQ     <FINISH1
1074      P:04BD P:04BD 44F400            MOVE              #ITIME0,X0
                        00B3CC
1075      P:04BF P:04BF 46F400            MOVE              #>GET_TIME0,Y0
                        000002
1076      P:04C1 P:04C1 200055            CMP     Y0,A
1077      P:04C2 P:04C2 0EA000            JEQ     <FINISH1                          ; Is it Time0?
1078      P:04C3 P:04C3 44F400            MOVE              #ITIME1,X0
                        005078
1079      P:04C5 P:04C5 46F400            MOVE              #>GET_TIME1,Y0
                        000003
1080      P:04C7 P:04C7 200055            CMP     Y0,A
1081      P:04C8 P:04C8 0EA000            JEQ     <FINISH1                          ; Is it Time1?
1082      P:04C9 P:04C9 240000            MOVE              #ISVNREV,X0
1083      P:04CA P:04CA 46F400            MOVE              #>GET_SVNREV,Y0
                        000004
1084      P:04CC P:04CC 200055            CMP     Y0,A
1085      P:04CD P:04CD 0EA000            JEQ     <FINISH1                          ; Is it Svn rev?
1086      P:04CE P:04CE 44F400            MOVE              #TIMCAPABLE,X0
                        0001FB
1087      P:04D0 P:04D0 46F400            MOVE              #>GET_CAPABLE,Y0
                        000100
1088      P:04D2 P:04D2 200055            CMP     Y0,A
1089      P:04D3 P:04D3 0EA000            JEQ     <FINISH1                          ; Is it Tim Capabilities?
1090      P:04D4 P:04D4 44F400            MOVE              #INT_TIM,X0
                        1D0000
1091      P:04D6 P:04D6 46F400            MOVE              #>GET_INT_TIM,Y0
                        000101
1092      P:04D8 P:04D8 200055            CMP     Y0,A
1093      P:04D9 P:04D9 0EA000            JEQ     <FINISH1                          ; Is it Integration time?
1094      P:04DA P:04DA 44F400            MOVE              #R_DELAY,X0
                        000000
1095      P:04DC P:04DC 46F400            MOVE              #>GET_R_DELAY,Y0
                        000102
1096      P:04DE P:04DE 200055            CMP     Y0,A
1097      P:04DF P:04DF 0EA000            JEQ     <FINISH1                          ; Is it Serial time?
1098      P:04E0 P:04E0 44F400            MOVE              #SI_DELAY,X0
                        8C0000
1099      P:04E2 P:04E2 46F400            MOVE              #>GET_SI_DELAY,Y0
                        000103
1100      P:04E4 P:04E4 200055            CMP     Y0,A
1101      P:04E5 P:04E5 0EA000            JEQ     <FINISH1                          ; Is it Parallel time?
1102      P:04E6 P:04E6 0C0000            JMP     <ERROR
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timCCDmisc.s  Page 22



1103   
1104   
1105                            ; Set software to IDLE mode
1106      P:04E7 P:04E7 44F400  IDL       MOVE              #IDLE,X0                ; Exercise clocks when idling
                        00020F
1107      P:04E9 P:04E9 440000            MOVE              X0,X:<IDL_ADR
1108      P:04EA P:04EA 0A0022            BSET    #IDLMODE,X:<STATUS                ; Idle after readout
1109      P:04EB P:04EB 0C0000            JMP     <FINISH                           ; Need to send header and 'DON'
1110   
1111                            ; Come to here on a 'STP' command so 'DON' can be sent
1112      P:04EC P:04EC 44F400  STP       MOVE              #TST_RCV,X0             ; Wait for commands during exposure
                        000000
1113      P:04EE P:04EE 440000            MOVE              X0,X:<IDL_ADR           ;  instead of exercising clocks
1114      P:04EF P:04EF 0A0002            BCLR    #IDLMODE,X:<STATUS                ; Don't idle after readout
1115      P:04F0 P:04F0 0C0000            JMP     <FINISH
1116   
1117                            ; Let the host computer read the controller configuration
1118                            READ_CONTROLLER_CONFIGURATION
1119      P:04F1 P:04F1 4C8A00            MOVE                          Y:<CONFIG,X0 ; Just transmit the configuration
1120      P:04F2 P:04F2 0C0000            JMP     <FINISH1
1121   
1122                            ; Power off
1123      P:04F3 P:04F3 0D0542  PWR_OFF   JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1124      P:04F4 P:04F4 0AA202            BCLR    #LVEN,X:PBDDR                     ; Set these signals to DSP inputs
1125      P:04F5 P:04F5 0AA20D            BCLR    #PWRST,X:PBDDR
1126      P:04F6 P:04F6 0AA203            BCLR    #HVEN,X:PBDDR
1127      P:04F7 P:04F7 0AA422            BSET    #LVEN,X:PBD                       ; LVEN = HVEN = 1 => Power reset
1128      P:04F8 P:04F8 0AA42D            BSET    #PWRST,X:PBD
1129      P:04F9 P:04F9 0AA423            BSET    #HVEN,X:PBD
1130      P:04FA P:04FA 0C0000            JMP     <FINISH
1131   
1132                            ; Start power-on cycle
1133      P:04FB P:04FB 0AA222  PWR_ON    BSET    #LVEN,X:PBDDR                     ; Set these signals to DSP outputs
1134      P:04FC P:04FC 0AA22D            BSET    #PWRST,X:PBDDR
1135      P:04FD P:04FD 0AA223            BSET    #HVEN,X:PBDDR
1136      P:04FE P:04FE 0D0542            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1137   
1138                            ; Ramp up the low voltages (+/- 6.5V, 16.5V) and then delay
1139      P:04FF P:04FF 0AA402            BCLR    #LVEN,X:PBD                       ; LVEN = Low => Turn on +/- 6.5V,
1140      P:0500 P:0500 0AA40D            BCLR    #PWRST,X:PBD
1141      P:0501 P:0501 44F400            MOVE              #60000,X0
                        00EA60
1142      P:0503 P:0503 06C400            DO      X0,WT_PON1                        ; Wait 10 millisec or so for settling
                        000508
1143      P:0505 P:0505 07708E            MOVE              A,P:RSTWDT              ; Reset watchdog timer
                        006000
1144      P:0507 P:0507 07708E            MOVE              A,P:RSTWDT
                        006000
1145                            WT_PON1
1146   
1147                            ; Ramp up the high +36 volt power line and then delay
1148      P:0509 P:0509 0AA403            BCLR    #HVEN,X:PBD                       ; HVEN = Low => Turn on +36V
1149      P:050A P:050A 44F400            MOVE              #60000,X0
                        00EA60
1150      P:050C P:050C 06C400            DO      X0,WT_PON2                        ; Wait 10 millisec or so for settling
                        000511
1151      P:050E P:050E 07708E            MOVE              A,P:RSTWDT              ; Reset watchdog timer
                        006000
1152      P:0510 P:0510 07708E            MOVE              A,P:RSTWDT
                        006000
1153                            WT_PON2
1154      P:0512 P:0512 0D0519            JSR     <SET_BIASES                       ; Turn on the DC bias supplies
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timCCDmisc.s  Page 23



1155      P:0513 P:0513 44F400            MOVE              #IDLE,X0
                        00020F
1156      P:0515 P:0515 440000            MOVE              X0,X:<IDL_ADR
1157      P:0516 P:0516 0C0000            JMP     <FINISH                           ; All done with 'DON'
1158   
1159      P:0517 P:0517 0D0519  SETBIAS   JSR     <SET_BIASES
1160      P:0518 P:0518 0C0000            JMP     <FINISH
1161   
1162                            ; Set all the DC bias voltages and video processor offset values, reading
1163                            ;   them from the table labeled DACS in this file
1164                            SET_BIASES
1165      P:0519 P:0519 0D0532            JSR     <SER_ANA
1166      P:051A P:051A 0A0020            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
1167      P:051B P:051B 0A0022            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
1168      P:051C P:051C 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Disable clear of DAC and enable clocks
                        000000
1169      P:051E P:051E 0D0476            JSR     <PAL_DLY                          ; Delay for all this to happen
1170      P:051F P:051F 0D0476            JSR     <PAL_DLY                          ; Delay for all this to happen
1171   
1172                            ; Disable simultaneous update of clock driver boards
1173      P:0520 P:0520 0A0001            BCLR    #1,X:<LATCH
1174      P:0521 P:0521 09F081            MOVEP             X:LATCH,Y:WRLATCH
                        000000
1175   
1176                            ; Read DAC values from a table, and set DACs
1177      P:0523 P:0523 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                        000100
1178      P:0525 P:0525 0D047B            JSR     <SET_DAC
1179   
1180                            ; Set all video processor analog switches to open to disable them (1 => OFF)
1181      P:0526 P:0526 56F400            MOVE              #$000FFF,A
                        000FFF
1182      P:0528 P:0528 566600            MOVE              A,X:(R6)                ; Send out the waveform
1183      P:0529 P:0529 000000            NOP
1184   
1185                            ; Let the DAC voltages all ramp up before exiting
1186      P:052A P:052A 56F400            MOVE              #400,A                  ; Delay 4 millisec
                        000190
1187      P:052C P:052C 06CE00            DO      A,L_SBI1
                        00052F
1188      P:052E P:052E 0D0476            JSR     <PAL_DLY                          ; Delay for all this to happen
1189      P:052F P:052F 000000            NOP
1190                            L_SBI1
1191      P:0530 P:0530 0D0539            JSR     <SER_UTL                          ; SSI -> utility board communication
1192      P:0531 P:0531 00000C            RTS
1193   
1194                            ; Enable serial communication to the analog boards
1195      P:0532 P:0532 0AA420  SER_ANA   BSET    #0,X:PBD                          ; Set H0 for analog boards SSI
1196      P:0533 P:0533 08F4A1            MOVEP             #$0000,X:PCC            ; Software reset of SSI
                        000000
1197      P:0535 P:0535 0AAD0A            BCLR    #10,X:CRB                         ; SSI -> continuous clock for analog
1198      P:0536 P:0536 08F4A1            MOVEP             #$0160,X:PCC            ; Re-enable the SSI
                        000160
1199      P:0538 P:0538 00000C            RTS
1200   
1201                            ; Enable serial communication to the utility board
1202      P:0539 P:0539 08F4A1  SER_UTL   MOVEP             #$0000,X:PCC            ; Software reset of SSI
                        000000
1203      P:053B P:053B 0AAD2A            BSET    #10,X:CRB                         ; SSI -> gated clock for util board
1204      P:053C P:053C 08F4A1            MOVEP             #$0160,X:PCC            ; Enable the SSI
                        000160
1205      P:053E P:053E 0AA400            BCLR    #0,X:PBD                          ; Clear H0 for utility board SSI
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timCCDmisc.s  Page 24



1206      P:053F P:053F 00000C            RTS
1207   
1208      P:0540 P:0540 0D0542  CLR_SWS   JSR     <CLEAR_SWITCHES
1209      P:0541 P:0541 0C0000            JMP     <FINISH
1210   
1211                            ; Clear all video processor analog switches to lower their power dissipation
1212                            CLEAR_SWITCHES
1213      P:0542 P:0542 0D0532            JSR     <SER_ANA                          ; Set SSI to analog board communication
1214      P:0543 P:0543 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                        0C3000
1215      P:0545 P:0545 20001B            CLR     B
1216      P:0546 P:0546 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC writes
1217      P:0547 P:0547 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writes
                        001000
1218      P:0549 P:0549 060F80            DO      #15,L_VIDEO                       ; Fifteen video processor boards maximum
                        000550
1219      P:054B P:054B 08CE2F            MOVEP             A,X:SSITX               ; Gain, integrate speed
1220      P:054C P:054C 200040            ADD     X0,A
1221      P:054D P:054D 577000            MOVE              B,X:WRSS
                        00FF80
1222      P:054F P:054F 0D0476            JSR     <PAL_DLY                          ; Delay for the serial data transmission
1223      P:0550 P:0550 200068            ADD     X1,B
1224                            L_VIDEO
1225      P:0551 P:0551 0A0000            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
1226      P:0552 P:0552 0A0002            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
1227      P:0553 P:0553 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                        000000
1228      P:0555 P:0555 44F400            MOVE              #IDLE,X0
                        00020F
1229      P:0557 P:0557 440000            MOVE              X0,X:<IDL_ADR
1230      P:0558 P:0558 0D0539            JSR     <SER_UTL                          ; Return SSI to utility board
1231      P:0559 P:0559 00000C            RTS
1232   
1233                            ; Set the clock multiplexers
1234      P:055A P:055A 0D0532  SET_MUX   JSR     <SER_ANA                          ; Set SSI to analog board communication
1235      P:055B P:055B 56DC00            MOVE              X:(R4)+,A               ; Clock driver board number
1236      P:055C P:055C 0614A0            REP     #20
1237      P:055D P:055D 200033            LSL     A
1238      P:055E P:055E 44F400            MOVE              #$003000,X0
                        003000
1239      P:0560 P:0560 200042            OR      X0,A
1240      P:0561 P:0561 21C500            MOVE              A,X1                    ; Move here for storage
1241   
1242                            ; Get the first MUX number
1243      P:0562 P:0562 56DC00            MOVE              X:(R4)+,A               ; Get the first MUX number
1244      P:0563 P:0563 0AF0A9            JLT     ERR_SM1
                        0005A5
1245      P:0565 P:0565 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                        000018
1246      P:0567 P:0567 200045            CMP     X0,A
1247      P:0568 P:0568 0AF0A1            JGE     ERR_SM1
                        0005A5
1248      P:056A P:056A 21CF00            MOVE              A,B
1249      P:056B P:056B 44F400            MOVE              #>7,X0
                        000007
1250      P:056D P:056D 20004E            AND     X0,B
1251      P:056E P:056E 44F400            MOVE              #>$18,X0
                        000018
1252      P:0570 P:0570 200046            AND     X0,A
1253      P:0571 P:0571 0E2574            JNE     <SMX_1                            ; Test for 0 <= MUX number <= 7
1254      P:0572 P:0572 0ACD63            BSET    #3,B1
1255      P:0573 P:0573 0C057F            JMP     <SMX_A
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timCCDmisc.s  Page 25



1256      P:0574 P:0574 44F400  SMX_1     MOVE              #>$08,X0
                        000008
1257      P:0576 P:0576 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1258      P:0577 P:0577 0E257A            JNE     <SMX_2
1259      P:0578 P:0578 0ACD64            BSET    #4,B1
1260      P:0579 P:0579 0C057F            JMP     <SMX_A
1261      P:057A P:057A 44F400  SMX_2     MOVE              #>$10,X0
                        000010
1262      P:057C P:057C 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1263      P:057D P:057D 0E25A5            JNE     <ERR_SM1
1264      P:057E P:057E 0ACD65            BSET    #5,B1
1265      P:057F P:057F 20006A  SMX_A     OR      X1,B1                             ; Add prefix to MUX numbers
1266      P:0580 P:0580 21A700            MOVE              B1,Y1
1267   
1268                            ; Add on the second MUX number
1269      P:0581 P:0581 56DC00            MOVE              X:(R4)+,A               ; Get the next MUX number
1270      P:0582 P:0582 0AF0A9            JLT     ERR_SM2
                        0005A6
1271      P:0584 P:0584 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                        000018
1272      P:0586 P:0586 200045            CMP     X0,A
1273      P:0587 P:0587 0AF0A1            JGE     ERR_SM2
                        0005A6
1274      P:0589 P:0589 0606A0            REP     #6
1275      P:058A P:058A 200033            LSL     A
1276      P:058B P:058B 21CF00            MOVE              A,B
1277      P:058C P:058C 44F400            MOVE              #$1C0,X0
                        0001C0
1278      P:058E P:058E 20004E            AND     X0,B
1279      P:058F P:058F 44F400            MOVE              #>$600,X0
                        000600
1280      P:0591 P:0591 200046            AND     X0,A
1281      P:0592 P:0592 0E2595            JNE     <SMX_3                            ; Test for 0 <= MUX number <= 7
1282      P:0593 P:0593 0ACD69            BSET    #9,B1
1283      P:0594 P:0594 0C05A0            JMP     <SMX_B
1284      P:0595 P:0595 44F400  SMX_3     MOVE              #>$200,X0
                        000200
1285      P:0597 P:0597 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1286      P:0598 P:0598 0E259B            JNE     <SMX_4
1287      P:0599 P:0599 0ACD6A            BSET    #10,B1
1288      P:059A P:059A 0C05A0            JMP     <SMX_B
1289      P:059B P:059B 44F400  SMX_4     MOVE              #>$400,X0
                        000400
1290      P:059D P:059D 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1291      P:059E P:059E 0E25A6            JNE     <ERR_SM2
1292      P:059F P:059F 0ACD6B            BSET    #11,B1
1293      P:05A0 P:05A0 200078  SMX_B     ADD     Y1,B                              ; Add prefix to MUX numbers
1294   
1295      P:05A1 P:05A1 08CD2F            MOVEP             B1,X:SSITX
1296      P:05A2 P:05A2 0D0476            JSR     <PAL_DLY                          ; Delay for all this to happen
1297      P:05A3 P:05A3 0D0539            JSR     <SER_UTL                          ; Return SSI to utility board communication
1298      P:05A4 P:05A4 0C0000            JMP     <FINISH
1299      P:05A5 P:05A5 56DC00  ERR_SM1   MOVE              X:(R4)+,A
1300      P:05A6 P:05A6 0D0539  ERR_SM2   JSR     <SER_UTL                          ; Return SSI to utility board communication
1301      P:05A7 P:05A7 0C0000            JMP     <ERROR
1302   
1303   
1304                            ; Set the video processor gain and integrator speed for all video boards
1305                            ;  Command syntax is  SGN  #GAIN  #SPEED, #GAIN = 1, 2, 5 or 10
1306                            ;                                         #SPEED = 0 for slow, 1 for fast
1307      P:05A8 P:05A8 0D0532  ST_GAIN   JSR     <SER_ANA                          ; Set SSI to analog board communication
1308      P:05A9 P:05A9 56DC00            MOVE              X:(R4)+,A               ; Gain value (1,2,5 or 10)
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timCCDmisc.s  Page 26



1309      P:05AA P:05AA 44F400            MOVE              #>1,X0
                        000001
1310      P:05AC P:05AC 200045            CMP     X0,A                              ; Check for gain = x1
1311      P:05AD P:05AD 0E25B1            JNE     <STG2
1312      P:05AE P:05AE 57F400            MOVE              #>$77,B
                        000077
1313      P:05B0 P:05B0 0C05C5            JMP     <STG_A
1314      P:05B1 P:05B1 44F400  STG2      MOVE              #>2,X0                  ; Check for gain = x2
                        000002
1315      P:05B3 P:05B3 200045            CMP     X0,A
1316      P:05B4 P:05B4 0E25B8            JNE     <STG5
1317      P:05B5 P:05B5 57F400            MOVE              #>$BB,B
                        0000BB
1318      P:05B7 P:05B7 0C05C5            JMP     <STG_A
1319      P:05B8 P:05B8 44F400  STG5      MOVE              #>5,X0                  ; Check for gain = x5
                        000005
1320      P:05BA P:05BA 200045            CMP     X0,A
1321      P:05BB P:05BB 0E25BF            JNE     <STG10
1322      P:05BC P:05BC 57F400            MOVE              #>$DD,B
                        0000DD
1323      P:05BE P:05BE 0C05C5            JMP     <STG_A
1324      P:05BF P:05BF 44F400  STG10     MOVE              #>10,X0                 ; Check for gain = x10
                        00000A
1325      P:05C1 P:05C1 200045            CMP     X0,A
1326      P:05C2 P:05C2 0E2000            JNE     <ERROR
1327      P:05C3 P:05C3 57F400            MOVE              #>$EE,B
                        0000EE
1328   
1329      P:05C5 P:05C5 56DC00  STG_A     MOVE              X:(R4)+,A               ; Integrator Speed (0 for slow, 1 for fast)
1330      P:05C6 P:05C6 0ACC00            JCLR    #0,A1,STG_B
                        0005CA
1331      P:05C8 P:05C8 0ACD68            BSET    #8,B1
1332      P:05C9 P:05C9 0ACD69            BSET    #9,B1
1333      P:05CA P:05CA 44F400  STG_B     MOVE              #$0C3C00,X0
                        0C3C00
1334      P:05CC P:05CC 20004A            OR      X0,B
1335      P:05CD P:05CD 5F0000            MOVE                          B,Y:<GAIN   ; Store the GAIN value for later us
1336   
1337                            ; Send this same value to 15 video processor boards whether they exist or not
1338      P:05CE P:05CE 241000            MOVE              #$100000,X0             ; Increment value
1339      P:05CF P:05CF 060F80            DO      #15,STG_LOOP
                        0005D4
1340      P:05D1 P:05D1 577000            MOVE              B,X:SSITX               ; Transmit the SSI word
                        00FFEF
1341      P:05D3 P:05D3 0D0476            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
1342      P:05D4 P:05D4 200048            ADD     X0,B                              ; Increment the video processor board number
1343                            STG_LOOP
1344   
1345      P:05D5 P:05D5 0D0539            JSR     <SER_UTL                          ; Return SSI to utility board communication
1346      P:05D6 P:05D6 0C0000            JMP     <FINISH
1347      P:05D7 P:05D7 56DC00  ERR_SGN   MOVE              X:(R4)+,A
1348      P:05D8 P:05D8 0D0539            JSR     <SER_UTL                          ; Return SSI to utility board communication
1349      P:05D9 P:05D9 0C0000            JMP     <ERROR
1350   
1351                            ; Write an arbitraty control word over the SSI link to any register, any board
1352                            ; Command syntax is  WRC number, number is 24-bit number to be sent to any board
1353                            ;WR_CNTRL
1354                            ;       JSR     <SER_ANA        ; Set SSI to analog board communication
1355                            ;       JSR     <PAL_DLY        ; Wait for the number to be sent
1356                            ;        MOVEP  X:(R4)+,X:SSITX ; Send out the waveform
1357                            ;       JSR     <PAL_DLY        ; Wait for SSI and PAL to be empty
1358                            ;       JSR     <SER_UTL        ; Return SSI to utility board communication
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timCCDmisc.s  Page 27



1359                            ;       JMP     <FINISH
1360   
1361   
1362   
1363                            ; Specify subarray readout coordinates, one rectangle only
1364                            ; Call this subroutine BEFORE SET_SUBARRAY_POSITIONS since it
1365                            ; initializes NBOXES
1366                            SET_SUBARRAY_SIZES
1367      P:05DA P:05DA 200013            CLR     A
1368      P:05DB P:05DB 5E1900            MOVE                          A,Y:<NBOXES ; Number of subimage boxes = 0 to start
1369      P:05DC P:05DC 44DC00            MOVE              X:(R4)+,X0
1370      P:05DD P:05DD 4C1A00            MOVE                          X0,Y:<NR_BIAS ; Number of bias pixels to read
1371      P:05DE P:05DE 44DC00            MOVE              X:(R4)+,X0
1372      P:05DF P:05DF 4C1B00            MOVE                          X0,Y:<NS_READ ; Number of columns in subimage read
1373      P:05E0 P:05E0 44DC00            MOVE              X:(R4)+,X0
1374      P:05E1 P:05E1 4C1C00            MOVE                          X0,Y:<NP_READ ; Number of rows in subimage read
1375      P:05E2 P:05E2 0C0000            JMP     <FINISH
1376   
1377                            ; Call this routine once for every subarray to be added to the table
1378                            ; Note that the way the variables are arranged the subframes all are the
1379                            ; same dimensions.  They also cannot overlap in the row direction.
1380                            ; SET_SUBARRAY_SIZES must be called first to initialize NBOXES
1381                            SET_SUBARRAY_POSITIONS
1382      P:05E3 P:05E3 4C9900            MOVE                          Y:<NBOXES,X0 ; Next available slot
1383      P:05E4 P:05E4 458000            MOVE              X:<THREE,X1
1384      P:05E5 P:05E5 2000A0            MPY     X0,X1,A
1385      P:05E6 P:05E6 200022            ASR     A
1386      P:05E7 P:05E7 210C00            MOVE              A0,A1
1387      P:05E8 P:05E8 44F400            MOVE              #>24,X0
                        000018
1388      P:05EA P:05EA 200045            CMP     X0,A
1389      P:05EB P:05EB 0E7000            JGT     <ERROR                            ; Error if number of boxes > 9
1390      P:05EC P:05EC 44F400            MOVE              #READ_TABLE,X0
                        00001D
1391      P:05EE P:05EE 200040            ADD     X0,A
1392      P:05EF P:05EF 219700            MOVE              A1,R7
1393      P:05F0 P:05F0 44DC00            MOVE              X:(R4)+,X0
1394      P:05F1 P:05F1 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of rows (parallels) to clear
1395      P:05F2 P:05F2 44DC00            MOVE              X:(R4)+,X0
1396      P:05F3 P:05F3 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears before
1397      P:05F4 P:05F4 44DC00            MOVE              X:(R4)+,X0              ;  the box readout
1398      P:05F5 P:05F5 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears after
1399      P:05F6 P:05F6 5E9900            MOVE                          Y:<NBOXES,A ;  the box readout
1400      P:05F7 P:05F7 448000            MOVE              X:<ONE,X0
1401      P:05F8 P:05F8 200040            ADD     X0,A                              ; Update the next available slot position
1402      P:05F9 P:05F9 5E1900            MOVE                          A,Y:<NBOXES
1403      P:05FA P:05FA 0C0000            JMP     <FINISH
1404   
1405                            ; Alert the PCI interface board that images are coming soon
1406                            ; This tells the PCI card how many pixels to expect for each SEX command
1407                            ; This is fairly complex.  The first value sent is NSR*NPR (NAXIS1*NAXIS2).
1408                            ; The second value is IFRAMES, but if NBOXES > 0, it is IFRAMES*NBOXES
1409                            PCI_READ_IMAGE
1410      P:05FB P:05FB 44F400            MOVE              #$020104,X0             ; Send header word to the FO transmitter
                        020104
1411      P:05FD P:05FD 0D0616            JSR     <XMT_FO
1412      P:05FE P:05FE 44F400            MOVE              #'RDA',X0
                        524441
1413      P:0600 P:0600 0D0616            JSR     <XMT_FO
1414      P:0601 P:0601 4CF000            MOVE                          Y:NSR,X0    ; NSR = NAXIS1
                        000001
1415      P:0603 P:0603 4DF000            MOVE                          Y:NPR,X1    ; NPR = NAXIS2
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  timCCDmisc.s  Page 28



                        000002
1416      P:0605 P:0605 2000A8            MPY     X0,X1,B
1417      P:0606 P:0606 20002A            ASR     B                                 ; Correct for multiplication left shift
1418      P:0607 P:0607 212400            MOVE              B0,X0
1419      P:0608 P:0608 0D0616            JSR     <XMT_FO                           ; Send NSR*NPR to PCI card
1420      P:0609 P:0609 4CF000            MOVE                          Y:IFRAMES,X0 ; IFRAMES = NAXIS3
                        00003A
1421      P:060B P:060B 5E9900            MOVE                          Y:<NBOXES,A ; If NBOXES = 0, transmit that to PCI
1422      P:060C P:060C 200003            TST     A
1423      P:060D P:060D 0AF0AA            JEQ     XMT
                        000613
1424      P:060F P:060F 4D9900            MOVE                          Y:<NBOXES,X1 ; If NBOXES = 0, transmit that to PCI
1425      P:0610 P:0610 2000A8            MPY     X0,X1,B                           ; If not, multiply by NBOXES, then send
1426      P:0611 P:0611 20002A            ASR     B                                 ; Correct for multiplication left shift
1427      P:0612 P:0612 212400            MOVE              B0,X0                   ; Get only least significant 24 bits
1428      P:0613 P:0613 000000  XMT       NOP
1429      P:0614 P:0614 0D0616            JSR     <XMT_FO
1430      P:0615 P:0615 00000C            RTS
1431   
1432      P:0616 P:0616 09C400  XMT_FO    MOVEP             X0,Y:WRFO
1433      P:0617 P:0617 060FA0            REP     #15
1434      P:0618 P:0618 000000            NOP
1435      P:0619 P:0619 00000C            RTS
1436   
1437                            ; Check for program overflow
1438                                      IF      @CVS(N,*)-$200>MISC_LEN
1440                                      ENDIF                                     ;  will not overflow
1441   
1442   
1443                            ;**************************************************************************
1444                            ;                                                                         *
1445                            ;    Permanent address register assignments                               *
1446                            ;        R1 - Address of SSI receiver contents                            *
1447                            ;        R2 - Address of SCI receiver contents                            *
1448                            ;        R3 - Pointer to current top of command buffer                    *
1449                            ;        R4 - Pointer to processed contents of command buffer             *
1450                            ;        R5 - Temporary register for processing SSI and SCI contents      *
1451                            ;        R6 - CCD clock driver address for CCD #0 = $FF80                 *
1452                            ;                It is also the A/D address of analog board #0            *
1453                            ;                                                                         *
1454                            ;    Other registers                                                      *
1455                            ;        R0, R7 - Temporary registers used all over the place.            *
1456                            ;        R5 - Can be used as a temporary register but is circular,        *
1457                            ;               modulo 32.                                                *
1458                            ;**************************************************************************
1459   
1460                            ;  Specify execution and load addresses
1461                                      IF      @SCP("HOST","HOST")
1462      P:0130 P:0130                   ORG     P:APL_ADR,P:APL_ADR               ; Download address
1463                                      ELSE
1465                                      ENDIF
1466   
1467                            ;  ***********************   CCD  READOUT   ***********************
1468                            ; RDCCD is now a subroutine
1469   
1470                            RDCCD
1471      P:0130 P:0130 0A31A2            JSET    #STORAGE,X:ISTATUS,RCCD1
                        000134
1472                            ; Do the frame transfer if STORAGE==0, else skip it.
1473      P:0132 P:0132 4DBB00            MOVE                          Y:<S_SIZE,X1
1474      P:0133 P:0133 0D045E            JSR     ISHIFT                            ; Do the frame transfer
1475   
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  tim.s  Page 29



1476                            ; Calculate some readout parameters.
1477                            ; This is also an alternative entry point for skipping the frame transfer
1478                            ; STORAGE also selects ganged or storage only parallels during readout
1479                            ; NO_SKIP skips over the section that parallel skips to the subframe start
1480   
1481      P:0134 P:0134 5E9900  RCCD1     MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1482      P:0135 P:0135 200003            TST     A
1483      P:0136 P:0136 0E2140            JNE     <SUB_IMG
1484      P:0137 P:0137 5C1600            MOVE                          A1,Y:<NP_SKIP ; Zero these all out.  Full frame
1485      P:0138 P:0138 5C1700            MOVE                          A1,Y:<NS_SKP1
1486      P:0139 P:0139 5C1800            MOVE                          A1,Y:<NS_SKP2
1487      P:013A P:013A 5E8100            MOVE                          Y:<NSR,A    ; NSERIALS_READ = NSR
1488      P:013B P:013B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                        00013E
1489      P:013D P:013D 200022            ASR     A                                 ; Split serials require / 2
1490      P:013E P:013E 5E1000            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1491      P:013F P:013F 0C014F            JMP     <SETUP
1492   
1493                            ; Loop over the required number of subimage boxes if NBOXES > 0
1494      P:0140 P:0140 67F400  SUB_IMG   MOVE              #READ_TABLE,R7          ; Parameter table for subimage readout
                        00001D
1495      P:0142 P:0142 061940            DO      Y:<NBOXES,L_NBOXES                ; Loop over number of boxes
                        0001E0
1496      P:0144 P:0144 4CDF00            MOVE                          Y:(R7)+,X0
1497      P:0145 P:0145 4C1600            MOVE                          X0,Y:<NP_SKIP
1498      P:0146 P:0146 4CDF00            MOVE                          Y:(R7)+,X0
1499      P:0147 P:0147 4C1700            MOVE                          X0,Y:<NS_SKP1
1500      P:0148 P:0148 4CDF00            MOVE                          Y:(R7)+,X0
1501      P:0149 P:0149 4C1800            MOVE                          X0,Y:<NS_SKP2
1502      P:014A P:014A 5E9B00            MOVE                          Y:<NS_READ,A
1503      P:014B P:014B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                        00014E
1504      P:014D P:014D 200022            ASR     A
1505      P:014E P:014E 5E1000            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1506   
1507                            ; Calculate the fast readout parameters
1508      P:014F P:014F 0D0342  SETUP     JSR     <SETUP_SUBROUTINE
1509   
1510                            ; Skip over the required number of rows for subimage readout
1511                            ; If #NO_SKIP == 0 skip rows up to first subframe, storage clocks only
1512      P:0150 P:0150 0A31A0            JSET    #NO_SKIP,X:ISTATUS,CLR_SR
                        00015A
1513      P:0152 P:0152 5E9600            MOVE                          Y:<NP_SKIP,A ; Number of rows NP_SKIP to skip
1514      P:0153 P:0153 200003            TST     A
1515      P:0154 P:0154 0EA15A            JEQ     <CLR_SR                           ; If zero, skip this shift
1516      P:0155 P:0155 061640            DO      Y:<NP_SKIP,L_SKIP1                ; Clock number of rows to skip
                        000159
1517      P:0157 P:0157 305100            MOVE              #<S_CLEAR,R0            ; SR kept clear with DG
1518      P:0158 P:0158 0D01E7            JSR     <CLOCK
1519      P:0159 P:0159 000000            NOP
1520                            L_SKIP1
1521   
1522                            ; Clear out the accumulated charge from the serial shift register
1523                            ; Leave this commented-out code in until we can test it with a subframe
1524                            ; CLR_SR MOVE   #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1525                            ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1526                            ;       NOP
1527                            ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1528                            ;       DO      Y:<NSCLR,*+3            ; Number of waveform entries total
1529                            ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1530                            ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1531   
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  tim.s  Page 30



1532      P:015A P:015A 60F400  CLR_SR    MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel skip
                        00006C
1533      P:015C P:015C 0D01E7            JSR     <CLOCK
1534   
1535                            ; Parallel shift the image into the serial shift register
1536      P:015D P:015D 4C8200            MOVE                          Y:<NPR,X0   ; Number of rows set by host computer
1537      P:015E P:015E 5E9900            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1538      P:015F P:015F 200003            TST     A
1539      P:0160 P:0160 0EA162            JEQ     *+2
1540      P:0161 P:0161 4C9C00            MOVE                          Y:<NP_READ,X0 ; If NBOXES .NE. 0 use subimage table
1541   
1542                            ; Main loop over each line to be read out
1543                            ; If split parallels have to divide NPR by two to be loop counter
1544                            ; Subimages implicitly assumes that parallels are not split
1545      P:0162 P:0162 0A0086            JCLR    #SPLIT_P,X:STATUS,PLOOP           ; skip this if not split parallels
                        000168
1546      P:0164 P:0164 5EF000            MOVE                          Y:NPR,A     ; Get NPR
                        000002
1547      P:0166 P:0166 200022            ASR     A                                 ; Divide by 2
1548      P:0167 P:0167 21C400            MOVE              A,X0                    ; Overwrite loop counter in X0
1549   
1550                            ; Finally start the row loop
1551      P:0168 P:0168 06C400  PLOOP     DO      X0,LPR                            ; Number of rows to read out
                        0001DF
1552   
1553                            ; Check for a command once per line. Only the ABORT command is allowed
1554      P:016A P:016A 0D0000            JSR     <GET_RCV                          ; Was a command received?
1555      P:016B P:016B 0E0170            JCC     <CONT_RD                          ; If no, continue reading out
1556      P:016C P:016C 0C0000            JMP     <CHK_SSI                          ; If yes, go process it
1557   
1558                            ; Abort the readout currently underway
1559                            ABR_RDC
1560      P:016D P:016D 0A0029            BSET    #ST_ABRT,X:<STATUS
1561      P:016E P:016E 0A0084            JCLR    #ST_RDC,X:<STATUS,ABORT_EXPOSURE
                        0004AB
1562                            ; already in readout- so just fall thru and continue,
1563                            ; having set the ST_ABRT flag.
1564                            ; currently we just let this readout segment run to the end and
1565                            ; handle the abort in the outer xxx_PROC code- this has
1566                            ; the advantage of ending the overall exposure on a frame boundary
1567                            ; in the case of 3-d images.
1568                            ; A more abrupt ending of the RDCCD code could be arranged if needed.
1569   
1570                            ;       ENDDO                           ; Properly terminate row loop
1571                            ;       MOVE    Y:<NBOXES,A             ; NBOXES = 0 => full image readout
1572                            ;       TST     A
1573                            ;       JEQ     *+2
1574                            ;       ENDDO                           ; Properly terminate box loop
1575                            ;       RTS                             ; Return early from subroutine
1576   
1577                            ; Move the row into the serial register.
1578      P:0170 P:0170 060640  CONT_RD   DO      Y:<NPBIN,LPR_I                    ; Transfer # of rows, with binning
                        000177
1579      P:0172 P:0172 305A00            MOVE              #<IS_PARALLEL,R0
1580      P:0173 P:0173 0A31A2            JSET    #STORAGE,X:ISTATUS,GANGED         ; if STORAGE == 1 ganged parallels
                        000176
1581      P:0175 P:0175 304000            MOVE              #<S_PARALLEL,R0         ; if STORAGE == 0 store clocks only
1582      P:0176 P:0176 0D01E7  GANGED    JSR     <CLOCK                            ; Parallel clocking
1583      P:0177 P:0177 000000            NOP
1584                            LPR_I
1585   
1586                            ; Skip over NS_SKP1 columns for subimage readout
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  tim.s  Page 31



1587      P:0178 P:0178 5E9700            MOVE                          Y:<NS_SKP1,A ; Number of columns to skip
1588      P:0179 P:0179 200003            TST     A
1589      P:017A P:017A 0EA183            JEQ     <L_READ
1590      P:017B P:017B 0505A1            MOVE              #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1591      P:017C P:017C 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1592      P:017D P:017D 000000            NOP
1593      P:017E P:017E 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1594      P:017F P:017F 061240            DO      Y:<NSKIP1,LS_SKIP1                ; Number of waveform entries total
                        000181
1595      P:0181 P:0181 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1596                            LS_SKIP1
1597      P:0182 P:0182 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1598   
1599                            ; Finally read some real pixels - this is the serial binning routine
1600      P:0183 P:0183 200013  L_READ    CLR     A
1601      P:0184 P:0184 20001B            CLR     B
1602      P:0185 P:0185 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1603      P:0186 P:0186 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                        000006
1604      P:0188 P:0188 200005            CMP     B,A                               ; else do special waveforms via NO_BIN
1605      P:0189 P:0189 0E719A            JGT     <NO_BIN                           ; Skip over general serial binning software
1606      P:018A P:018A 00000B            DEC     B                                 ; serial binning factor minus 1
1607      P:018B P:018B 212700            MOVE              B0,Y1
1608      P:018C P:018C 061040            DO      Y:<NSERIALS_READ,LSR_BIN          ; Number of pixels to read out
                        000198
1609      P:018E P:018E 688E00            MOVE                          Y:<INITIAL_CLOCK,R0 ; (already /2 if split serials)
1610      P:018F P:018F 0D01E7            JSR     <CLOCK
1611                            ;       DO      Y:<NSBIN,LSR_I          ; Bin serially NSBIN times
1612      P:0190 P:0190 06C700            DO      Y1,LSR_I                          ; Bin serially NSBIN times
                        000194
1613      P:0192 P:0192 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1614      P:0193 P:0193 0D01E7            JSR     <CLOCK                            ;   shift register
1615      P:0194 P:0194 000000            NOP
1616                            LSR_I
1617      P:0195 P:0195 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                        0000BB
1618      P:0197 P:0197 0D01E7            JSR     <CLOCK
1619                            ;       MOVE    Y1,Y:<INTERVAL          ; HACK.  Use for debugging
1620      P:0198 P:0198 000000            NOP
1621                            LSR_BIN
1622      P:0199 P:0199 0C01A4            JMP     <OVER_RD                          ; All done binning
1623   
1624                            ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1625      P:019A P:019A 588C00  NO_BIN    MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1626      P:019B P:019B 00000A            DEC     A                                 ; waveform - 1 into M1
1627      P:019C P:019C 04C8A1            MOVE              A0,M1                   ; Modularity
1628      P:019D P:019D 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1629      P:019E P:019E 000000            NOP
1630      P:019F P:019F 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1631      P:01A0 P:01A0 061340            DO      Y:<NREAD,LSR                      ; Number of waveform entries total
                        0001A2
1632      P:01A2 P:01A2 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1633                            LSR
1634      P:01A3 P:01A3 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1635   
1636                            ; If NR_BIAS=0 clobber SR with DG and skip to end of row loop
1637      P:01A4 P:01A4 5E9A00  OVER_RD   MOVE                          Y:<NR_BIAS,A ; Is NR_BIAS zero?
1638      P:01A5 P:01A5 200003            TST     A
1639      P:01A6 P:01A6 0E21AC            JNE     <OVR_RD1                          ; no, go to the NS_SKP2 section
1640      P:01A7 P:01A7 60F400            MOVE              #DUMP_SERIAL,R0         ; yes, clobber SR with DG
                        00006C
1641      P:01A9 P:01A9 0D01E7            JSR     <CLOCK
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  tim.s  Page 32



1642      P:01AA P:01AA 0AF080            JMP     END_ROW                           ; and go to the end of the row loop
                        0001DF
1643                            ; Skip over NS_SKP2 columns for subimage readout to get to overscan region
1644      P:01AC P:01AC 5E9800  OVR_RD1   MOVE                          Y:<NS_SKP2,A ; Number of columns to skip
1645      P:01AD P:01AD 200003            TST     A
1646      P:01AE P:01AE 0EA1B7            JEQ     <L_BIAS
1647      P:01AF P:01AF 0505A1            MOVE              #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1648      P:01B0 P:01B0 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1649      P:01B1 P:01B1 000000            NOP
1650      P:01B2 P:01B2 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1651      P:01B3 P:01B3 061440            DO      Y:<NSKIP2,LS_SKIP2                ; Number of waveform entries total
                        0001B5
1652      P:01B5 P:01B5 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1653                            LS_SKIP2
1654      P:01B6 P:01B6 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1655   
1656                            ; And read the bias pixels if in subimage readout mode
1657                            ; I think this means that if NBOXES==0 you have to have NSR include bias px.
1658      P:01B7 P:01B7 5E9900  L_BIAS    MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1659      P:01B8 P:01B8 200003            TST     A
1660      P:01B9 P:01B9 0EA1DF            JEQ     <END_ROW
1661   
1662                            ; Finally read some real bias pixels
1663      P:01BA P:01BA 200013            CLR     A
1664      P:01BB P:01BB 20001B            CLR     B
1665      P:01BC P:01BC 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1666      P:01BD P:01BD 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                        000006
1667      P:01BF P:01BF 200005            CMP     B,A                               ; else do special waveforms via NO_BIN_BIAS
1668      P:01C0 P:01C0 0E71D5            JGT     <NO_BIN_BIAS                      ; Skip over general serial binning software
1669      P:01C1 P:01C1 00000B            DEC     B                                 ; serial binning factor minus 1
1670      P:01C2 P:01C2 212700            MOVE              B0,Y1
1671      P:01C3 P:01C3 5E9A00            MOVE                          Y:<NR_BIAS,A
1672      P:01C4 P:01C4 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                        0001C7
1673      P:01C6 P:01C6 200022            ASR     A                                 ; Split serials require / 2
1674      P:01C7 P:01C7 06CE00            DO      A,LBIAS_BIN                       ; Number of pixels to read out
                        0001D3
1675      P:01C9 P:01C9 688E00            MOVE                          Y:<INITIAL_CLOCK,R0
1676      P:01CA P:01CA 0D01E7            JSR     <CLOCK
1677      P:01CB P:01CB 06C700            DO      Y1,LBIAS_I                        ; Bin serially NSBIN times
                        0001CF
1678                            ;       DO      Y:<NSBIN,LBIAS_I        ; Bin serially NSBIN times
1679      P:01CD P:01CD 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1680      P:01CE P:01CE 0D01E7            JSR     <CLOCK                            ;   shift register
1681      P:01CF P:01CF 000000            NOP
1682                            LBIAS_I
1683      P:01D0 P:01D0 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                        0000BB
1684      P:01D2 P:01D2 0D01E7            JSR     <CLOCK
1685      P:01D3 P:01D3 000000            NOP
1686                            LBIAS_BIN
1687      P:01D4 P:01D4 0C01DF            JMP     <END_ROW                          ; All done binning
1688   
1689                            ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1690                            ; NBIAS is already divided by 2 in SETUP_SUBROUTINE if split serials.
1691                            NO_BIN_BIAS
1692      P:01D5 P:01D5 588C00            MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1693      P:01D6 P:01D6 00000A            DEC     A                                 ; waveform - 1 into M1
1694      P:01D7 P:01D7 04C8A1            MOVE              A0,M1                   ; Modularity
1695      P:01D8 P:01D8 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1696      P:01D9 P:01D9 000000            NOP
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  tim.s  Page 33



1697      P:01DA P:01DA 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1698      P:01DB P:01DB 061540            DO      Y:<NBIAS,*+3                      ; Number of waveform entries total
                        0001DD
1699      P:01DD P:01DD FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1700      P:01DE P:01DE 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1701      P:01DF P:01DF 000000  END_ROW   NOP
1702      P:01E0 P:01E0 000000  LPR       NOP                                       ; End of parallel loop
1703      P:01E1 P:01E1 000000  L_NBOXES  NOP                                       ; End of subimage boxes loop
1704      P:01E2 P:01E2 000000            NOP
1705      P:01E3 P:01E3 60F400            MOVE              #DCRST_LAST,R0          ; get DC Restore going
                        0000B8
1706      P:01E5 P:01E5 0D01E7            JSR     <CLOCK
1707      P:01E6 P:01E6 00000C            RTS
1708   
1709                            ; ***************** END OF CCD READOUT SUBROUTINE  ************
1710   
1711                            ; Core subroutine for clocking out CCD charge
1712                            ; Must keep in tim.s to insure that it is in fast P memory
1713   
1714      P:01E7 P:01E7 4CD800  CLOCK     MOVE                          Y:(R0)+,X0  ; # of waveform entries
1715      P:01E8 P:01E8 5ED800            MOVE                          Y:(R0)+,A   ; Start the pipeline
1716      P:01E9 P:01E9 06C400            DO      X0,CLK1                           ; Repeat X0 times
                        0001EB
1717      P:01EB P:01EB FA0600            MOVE              A,X:(R6)    Y:(R0)+,A   ; Send out the waveform
1718                            CLK1
1719      P:01EC P:01EC 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1720      P:01ED P:01ED 00000C            RTS                                       ; Return from subroutine
1721   
1722                            ; Check for program overflow
1723                                      IF      @CVS(N,*)>$200
1725                                      ENDIF                                     ;  will not overflow
1726   
1727                            ; ***********  DATA AREAS - READOUT PARAMETERS AND WAVEFORMS  ************
1728                                      IF      @SCP("HOST","HOST")
1729      X:0030 X:0030                   ORG     X:IMGVAR_ADR,X:IMGVAR_ADR
1730      X:0030 X:0030         IMAGE_MODE DC     0
1731      X:0031 X:0031         ISTATUS   DC      0
1732      X:0032 X:0032         DSP_VERS  DC      VERSION                           ; code version must stay in loc,n 32!!
1733      X:0033 X:0033         DSP_FLAV  DC      FLAVOR                            ;  type of dsp support must stay in loc,n 33!!
1734                            ; The next three locations are for tracking the readout timing for gain
1735                            ; calculation, exp-int calculation, and greed factor calculation
1736                            ; They are locations 0x34, 35, and 36
1737      X:0034 X:0034         INTTIM    DC      INT_TIM                           ; per-pixel integration in Leach units
1738      X:0035 X:0035         RDELAY    DC      R_DELAY                           ; serial overlap in Leach units
1739      X:0036 X:0036         SIDELAY   DC      SI_DELAY                          ; parallel overlap in Leach units
1740      X:0037 X:0037         BINBIT    DC      2                                 ; Bit representation of bin factor, bits 1-5
1741                                                                                ; 2 = bit 1 set. Bit zero not used.
1742                                      ENDIF
1743   
1744                            ; Command table - make sure there are exactly 32 entries in it
1745                                      IF      @SCP("HOST","HOST")
1746      X:0080 X:0080                   ORG     X:COM_TBL,X:COM_TBL               ; Download address
1747                                      ELSE
1749                                      ENDIF
1750      X:0080 X:0080                   DC      'IDL',IDL                         ; Put CCD in IDLE mode
1751      X:0082 X:0082                   DC      'STP',STP                         ; Exit IDLE mode
1752      X:0084 X:0084                   DC      'SBV',SETBIAS                     ; Set DC bias supply voltages
1753      X:0086 X:0086                   DC      'RDC',RDCCD                       ; Begin CCD readout
1754      X:0088 X:0088                   DC      'CLR',CLEAR                       ; Fast clear the CCD
1755      X:008A X:008A                   DC      'SGN',ST_GAIN                     ; Set video processor gain
1756      X:008C X:008C                   DC      'SMX',SET_MUX                     ; Set clock driver MUX output
1757   
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  tim.s  Page 34



1758      X:008E X:008E                   DC      'ABR',ABR_RDC                     ; Abort readout
1759      X:0090 X:0090                   DC      'CRD',CONT_RD                     ; Continue reading out
1760      X:0092 X:0092                   DC      'CSW',CLR_SWS                     ; Clear analog switches to lower power
1761      X:0094 X:0094                   DC      'SOS',SEL_OS                      ; Select output source
1762      X:0096 X:0096                   DC      'RCC',READ_CONTROLLER_CONFIGURATION
1763      X:0098 X:0098                   DC      'SSS',SET_SUBARRAY_SIZES
1764      X:009A X:009A                   DC      'SSP',SET_SUBARRAY_POSITIONS
1765      X:009C X:009C                   DC      'DON',START                       ; Nothing special
1766      X:009E X:009E                   DC      'OSH',OPEN_SHUTTER
1767      X:00A0 X:00A0                   DC      'CSH',CLOSE_SHUTTER
1768      X:00A2 X:00A2                   DC      'PON',PWR_ON                      ; Turn on all camera biases and clocks
1769      X:00A4 X:00A4                   DC      'POF',PWR_OFF                     ; Turn +/- 15V power supplies off
1770      X:00A6 X:00A6                   DC      'SET',SET_EXP_TIME                ; Set exposure time
1771      X:00A8 X:00A8                   DC      'SEX',START_FT_EXPOSURE           ; Goes to mode-dependent jump table
1772      X:00AA X:00AA                   DC      'AEX',ABORT_EXPOSURE
1773      X:00AC X:00AC                   DC      'STG',SET_TRIGGER                 ;  Set Trigger Mode on or off
1774      X:00AE X:00AE                   DC      'SIP',SET_IMAGE_PARAM
1775      X:00B0 X:00B0                   DC      'SRC',SET_ROWS_COLUMNS            ; Set NSR, NPR, and binning
1776      X:00B2 X:00B2                   DC      'INF',GET_INFO                    ; info command for versioning and more
1777      X:00B4 X:00B4                   DC      ,0,START,0,START,0,START,0,START
1778   
1779                                      IF      @SCP("HOST","HOST")
1780      Y:0000 Y:0000                   ORG     Y:0,Y:0                           ; Download address
1781                                      ELSE
1783                                      ENDIF
1784   
1785                            ; NSR, NPR, NSBIN, and NPBIN are set by SET_ROWS_COLUMNS
1786      Y:0000 Y:0000         GAIN      DC      0                                 ; Video processor gain and integrator speed
1787      Y:0001 Y:0001         NSR       DC      1072                              ; Number Serial Read, prescan + image + bias
1788      Y:0002 Y:0002         NPR       DC      1030                              ; Number Parallel Read
1789      Y:0003 Y:0003         NS_CLR    DC      1070                              ; To clear serial register, twice
1790      Y:0004 Y:0004         NPCLR     DC      2057                              ; To clear parallel register, twice
1791      Y:0005 Y:0005         NSBIN     DC      1                                 ; Serial binning parameter
1792      Y:0006 Y:0006         NPBIN     DC      1                                 ; Parallel binning parameter
1793      Y:0007 Y:0007         NROWS     DC      1030                              ; Number of physical rows in CCD
1794      Y:0008 Y:0008         NCOLS     DC      1072                              ; Number of physical columns in CCD
1795   
1796                            ; Miscellaneous definitions
1797                            ; Delete TST_DAT since it isn't used.  Need the space so S_SIZE doesn't barf.
1798                            ; TST_DAT       DC      0               ; Temporary definition for test images
1799                            ;SH_DEL DC      3               ; Delay in milliseconds between shutter closing
1800                                                                                ;   and image readout.  Actual delay is 1.5x
1801                                                                                ;   as long as advertised, e.g. 4.5 ms for 3.
1802      Y:0009 Y:0009         SH_DEL    DC      4                                 ; Change needed to kill shift streak after DCRes
1803      Y:000A Y:000A         CONFIG    DC      CC                                ; Controller configuration
1804                            ; Readout peculiarity parameters
1805                             SERIAL_SKIP
1806      Y:000B Y:000B                   DC      SERIAL_SKIP_LEFT                  ; Serial skipping waveforms
1807      Y:000C Y:000C         SERWAVLEN DC      5                                 ; Serial read waveform table length
1808                             SERIAL_CLOCK
1809      Y:000D Y:000D                   DC      SERIAL_CLOCK_LEFT                 ; Serial waveform table
1810                             INITIAL_CLOCK
1811      Y:000E Y:000E                   DC      INITIAL_CLOCK_LEFT                ; Serial waveform table
1812                             PARALLEL_CLOCK
1813      Y:000F Y:000F                   DC      IS_PARALLEL                       ; Addr. of parallel clocking
1814   
1815                             NSERIALS_READ
1816      Y:0010 Y:0010                   DC      0                                 ; Number of serials to read
1817      Y:0011 Y:0011         NSCLR     DC      0                                 ; Number of waveforms in fast mode
1818      Y:0012 Y:0012         NSKIP1    DC      0                                 ; Number of waveforms in fast mode
1819      Y:0013 Y:0013         NREAD     DC      0                                 ; Number of waveforms in fast mode
1820      Y:0014 Y:0014         NSKIP2    DC      0                                 ; Number of waveforms in fast mode
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  tim.s  Page 35



1821      Y:0015 Y:0015         NBIAS     DC      0                                 ; Number of waveforms in fast mode
1822   
1823                            ; These three parameters are read from the READ_TABLE when needed by the
1824                            ;   RDCCD routine as it loops through the required number of boxes
1825      Y:0016 Y:0016         NP_SKIP   DC      0                                 ; Number of rows to skip
1826      Y:0017 Y:0017         NS_SKP1   DC      0                                 ; Number of serials to clear before read
1827      Y:0018 Y:0018         NS_SKP2   DC      0                                 ; Number of serials to clear after read
1828   
1829                            ; Subimage readout parameters. Ten subimage boxes maximum.
1830                            ; All subimage boxes are the same size, NS_READ x NP_READ
1831                            ; NR_BIAS, NS_READ, and NP_READ are set by SET_SUBARRAY_SIZES
1832                            ; The READ_TABLE entries and implicitly NBOXES are set by SET_SUBARRAY_POSITIONS
1833      Y:0019 Y:0019         NBOXES    DC      0                                 ; Number of boxes to read
1834      Y:001A Y:001A         NR_BIAS   DC      0                                 ; Number of bias pixels to read
1835      Y:001B Y:001B         NS_READ   DC      0                                 ; Number of columns per box
1836      Y:001C Y:001C         NP_READ   DC      0                                 ; Number of rows per box
1837      Y:001D Y:001D         READ_TABLE DC     0,0,0                             ; #1 = Number of rows to clear,
1838      Y:0020 Y:0020                   DC      0,0,0                             ; #2 = Number of columns to skip before
1839      Y:0023 Y:0023                   DC      0,0,0                             ;   subimage read
1840      Y:0026 Y:0026                   DC      0,0,0                             ; #3 = Number of columns to clear after
1841      Y:0029 Y:0029                   DC      0,0,0                             ;   subimage read to get to overscan area
1842      Y:002C Y:002C                   DC      0,0,0
1843      Y:002F Y:002F                   DC      0,0,0
1844      Y:0032 Y:0032                   DC      0,0,0
1845      Y:0035 Y:0035                   DC      0,0,0
1846   
1847                            ; IMAGE_MODE, SROWS, IFRAMES, and INTERVAL are set by SET_IMAGE_PARAM
1848                            ; UBSROWS is set later on by UB_CONV.  S_SIZE is hardwired.
1849      Y:0038 Y:0038         SROWS     DC      1                                 ; Number of Storage image rows to Loop over
1850      Y:0039 Y:0039         UBSROWS   DC      1                                 ; SROWS in unbinned pixels.  Set by UB_CONV
1851      Y:003A Y:003A         IFRAMES   DC      1                                 ; Number of Series frames to Loop over
1852      Y:003B Y:003B         S_SIZE    DC      1033                              ; Number of rows in the Storage Array
1853                                                                                ; NOTE: Not equal to # rows in image area!
1854      Y:003C Y:003C         INTERVAL  DC      7                                 ; Interval to pause for soft trigger
1855      Y:003D Y:003D         AMPVAL    DC      0                                 ; Amplifier selected
1856      Y:003E Y:003E         IFLPCNT   DC      0                                 ; 24-bit IFRAMES loop counter for timmisc.s
1857      Y:003F Y:003F         TESTLOC1  DC      0                                 ; Test location
1858                            ; NOTE:  TESTLOC1 is address 63 in the Y memory.  There are addressing problems
1859                            ; starting at the next address (64).
1860   
1861                            ; Include the waveform table
1862                                      INCLUDE "HIPO_Blue.waveforms.s"           ; Readout and clocking waveforms
1863                            ; Waveform tables and definitions for the e2v CCD47 1K sq. frame
1864                            ; transfer CCD for HIPO.
1865                            ;
1866   
1867                            ; CCD clock voltage definitions
1868      000000                VIDEO     EQU     $000000                           ; Video processor board select = 0
1869      002000                CLK2      EQU     $002000                           ; Clock driver board select = 2
1870      003000                CLK3      EQU     $003000                           ; Clock driver board select = 3
1871      000800                CLK_ZERO  EQU     $000800                           ; Zero volts on clock driver line
1872      000800                BIAS_ZERO EQU     $000800                           ;
1873   
1874                            ; Select INT_TIM by value of 1D macro defined in Makefile or
1875                            ; environment. If one of the values indicated is not set, INT_TIM will be
1876                            ; undefined and the assemble will fail.
1877                            ; see the Confluence page for gwaves timing board port,
1878                            ; at the end of dated entry for July 1 2010
1879                            ; http://jumar.lowell.edu/confluence/display/GWAVES/Notes+On+Port+of++Timing+Board+DSP+to+Gen-iii+GW
AVES+CCD
1880                            ;
1881                            ; Please keep the tooltip commentn remarks as and where they are,
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 36



1882                            ; right before the EQU
1883   
1884                                      IF      @SCP("1D","04")
1888                                      ENDIF
1889                                      IF      @SCP("1D","08")
1893                                      ENDIF
1894                                      IF      @SCP("1D","15")
1898                                      ENDIF
1899                                      IF      @SCP("1D","1D")
1900                            ; 1.8 us/px - use gain 4.75, best overall
1901                            ; <tooltip comment1> Covers full dynamic range of CCD
1902      1D0000                INT_TIM   EQU     $1D0000
1903                                      ENDIF
1904                                      IF      @SCP("1D","47")
1908                                      ENDIF
1909                                      IF      @SCP("1D","6D")
1913                                      ENDIF
1914                                      IF      @SCP("1D","92")
1918                                      ENDIF
1919                            ;ADC_TIM                EQU     $0C0000 ; Slow ADC TIME
1920                            ; <tooltip comment1> Not a standard DSP
1921      000000                ADC_TIM   EQU     $000000                           ; Fast ADC TIME
1922   
1923                            ; Delay numbers in clocking
1924                            ; Select SI_DELAY by value of 8C macro defined in Makefile or
1925                            ; environment. If one of the values indicated is not set, SI_DELAY will be
1926                            ; undefined and the assemble will fail.
1927                            ; see the Confluence page for gwaves timing board port,
1928                            ; at the end of dated entry for July 1 2010
1929                            ; http://jumar.lowell.edu/confluence/display/GWAVES/Notes+On+Port+of++Timing+Board+DSP+to+Gen-iii+GW
AVES+CCD
1930                            ; Please keep the tooltip commentn remarks as and where they are,
1931                            ; right before the EQU
1932   
1933                                      IF      @SCP("8C","86")
1937                                      ENDIF
1938                                      IF      @SCP("8C","89")
1942                                      ENDIF
1943                                      IF      @SCP("8C","8B")
1947                                      ENDIF
1948                                      IF      @SCP("8C","8C")
1949                            ;
1950                            ; <tooltip comment2> OK for full well flats
1951      8C0000                SI_DELAY  EQU     $8C0000
1952                                      ENDIF
1953                                      IF      @SCP("8C","C0")
1957                                      ENDIF
1958   
1959                            ; Select R_DELAY by value of 00 macro defined in Makefile or
1960                            ; environment. If one of the values indicated is not set, R_DELAY will be
1961                            ; undefined and the assemble will fail.
1962                            ; see the Confluence page for gwaves timing board port,
1963                            ; at the end of dated entry for July 1 2010
1964                            ; http://jumar.lowell.edu/confluence/display/GWAVES/Notes+On+Port+of++Timing+Board+DSP+to+Gen-iii+GW
AVES+CCD
1965   
1966                                      IF      @SCP("00","00")
1967                            ; Fast serial register transfer delay
1968      000000                R_DELAY   EQU     $000000
1969                                      ENDIF
1970                                      IF      @SCP("00","08")
1973                                      ENDIF
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 37



1974   
1975      000000                SKIP_DELAY EQU    $000000                           ; Serial register skipping delay
1976   
1977                            ; Clock voltages in volts                       Old     New     Data Sheet
1978      2.500000E+000         RG_HI     EQU     +2.5                              ; Reset                  1.5     3.0     4
1979      -9.500000E+000        RG_LO     EQU     -9.5                              ;                       -3.0    -9.0    -8
1980      1.500000E+000         R_HI      EQU     +1.5                              ; Serials                4.65    4.5     2
1981      -8.500000E+000        R_LO      EQU     -8.5                              ;                       -6.6    -6.5    -8
1982      2.500000E+000         SI_HI     EQU     +2.5                              ; Parallels              3.7     4.0     4
1983      -9.500000E+000        SI_LO     EQU     -9.5                              ;                       -6.9    -7.0    -8
1984      2.500000E+000         DG_HI     EQU     +2.5                              ; Dump Gate
1985      -9.500000E+000        DG_LO     EQU     -9.5                              ;                                       -8
1986   
1987                            ; DC Bias voltages in volts                     Old     New     Data Sheet
1988      2.050000E+001         VODL      EQU     20.5                              ; Output Drain Left     25.1    24      21
1989      2.050000E+001         VODR      EQU     20.5                              ; Output Drain Right    25.1    24
1990      9.000000E+000         VRDL      EQU     9.00                              ; Reset Drain Left      12.2    11      10
1991      9.000000E+000         VRDR      EQU     9.00                              ; Reset Drain Right
1992      -6.500000E+000        VOG       EQU     -6.5                              ; Output Gate           -1.2    -3      -5
1993      -9.500000E+000        VABG      EQU     -9.5                              ; Anti-blooming gate    -5.0    -5      -8
1994      000700                OFFSET    EQU     $700
1995      000700                OFFSET0   EQU     $700                              ; Left Side Of Frame
1996      0006EF                OFFSET1   EQU     $6EF                              ; Right Side Of Frame
1997   
1998                            ; Define switch state bits for the lower CCD clock driver bank CLK2
1999      000001                H1L       EQU     1                                 ; Serial #1 Left, Pin 1 - clock 0
2000      000002                H2L       EQU     2                                 ; Serial #2 Left, Pin 2 - clock 1
2001      000004                H3L       EQU     4                                 ; Serial #3 Left, Pin 3 - clock 2
2002      000008                H1R       EQU     8                                 ; Serial #1 Right, Pin 4 - clock 3
2003      000010                H2R       EQU     $10                               ; Serial #2 Right, Pin 5 - clock 4
2004      000020                H3R       EQU     $20                               ; Serial #2 Right, Pin 6 - clock 5
2005      000100                RGL       EQU     $100                              ; Reset Gate Left, Pin 9 - clock 8
2006      000200                RGR       EQU     $200                              ; Reset Gate Right, Pin 10 - clock 9
2007   
2008                            ; Pins 9-12 are not used
2009   
2010                            ; Define switch state bits for the upper CCD clock driver bank CLK3
2011      000001                I1        EQU     1                                 ; Image, phase #1, Pin 13 - clock 12
2012      000002                I2        EQU     2                                 ; Image, phase #2, Pin 14 - clock 13
2013      000004                I3        EQU     4                                 ; Image, phase #3, Pin 15 - clock 14
2014      000008                S1        EQU     8                                 ; Storage, phase #1, Pin 16 - clock 15
2015      000010                S2        EQU     $10                               ; Storage, phase #2, Pin 17 - clock 16
2016      000020                S3        EQU     $20                               ; Storage, phase #3, Pin 18 - clock 17
2017      000100                DG        EQU     $100                              ; Dump Gate, Pin 34 - clock 20
2018   
2019                            ;  ***  Definitions for Y: memory waveform tables  *****
2020                            ; Clock only the Storage clocks : S1->S2->S3
2021                            S_PARALLEL
2022      Y:0040 Y:0040                   DC      END_S_PARALLEL-S_PARALLEL-2
2023      Y:0041 Y:0041                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
2024      Y:0042 Y:0042                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2025                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
2026      Y:0043 Y:0043                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00
2027      Y:0044 Y:0044                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00
2028      Y:0045 Y:0045                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3
2029      Y:0046 Y:0046                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3
2030      Y:0047 Y:0047                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3
2031      Y:0048 Y:0048                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
2032                            END_S_PARALLEL
2033   
2034                            ; Reverse clock only the Storage clocks : S1->S3->S2->S1
2035                            ; Use in pipelined occultation mode
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 38



2036                            R_S_PARALLEL
2037      Y:0049 Y:0049                   DC      END_R_S_PARALLEL-R_S_PARALLEL-2
2038      Y:004A Y:004A                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2039      Y:004B Y:004B                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3
2040      Y:004C Y:004C                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3
2041      Y:004D Y:004D                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3
2042      Y:004E Y:004E                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00
2043      Y:004F Y:004F                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00
2044      Y:0050 Y:0050                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
2045                            END_R_S_PARALLEL
2046   
2047                            ; Clock only the Storage clocks : S1->S2->S3 with DG
2048                            S_CLEAR
2049      Y:0051 Y:0051                   DC      END_S_CLEAR-S_CLEAR-2
2050      Y:0052 Y:0052                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
2051      Y:0053 Y:0053                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2052                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
2053      Y:0054 Y:0054                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00+DG
2054      Y:0055 Y:0055                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00+DG
2055      Y:0056 Y:0056                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3+DG
2056      Y:0057 Y:0057                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3+DG
2057      Y:0058 Y:0058                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3+DG
2058      Y:0059 Y:0059                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
2059                            END_S_CLEAR
2060                            ; 2 microsecond delay before readout starts may be needed here
2061                            ;       DC      CLK3+$600000+I1+00+00+S1+00+0000
2062   
2063                            ; Clock both the Storage and Image clocks : I1->I2->I3 and S1->S2->S3
2064                            IS_PARALLEL
2065      Y:005A Y:005A                   DC      END_IS_PARALLEL-IS_PARALLEL-2
2066      Y:005B Y:005B                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
2067      Y:005C Y:005C                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2068                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
2069      Y:005D Y:005D                   DC      CLK3+SI_DELAY+I1+I2+00+S1+S2+00
2070      Y:005E Y:005E                   DC      CLK3+SI_DELAY+00+I2+00+00+S2+00
2071      Y:005F Y:005F                   DC      CLK3+SI_DELAY+00+I2+I3+00+S2+S3
2072      Y:0060 Y:0060                   DC      CLK3+SI_DELAY+00+00+I3+00+00+S3
2073      Y:0061 Y:0061                   DC      CLK3+SI_DELAY+I1+00+I3+S1+00+S3
2074      Y:0062 Y:0062                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
2075                            END_IS_PARALLEL
2076   
2077                            ; Clock both the Storage and Image clocks : I1->I2->I3 and S1->S2->S3
2078                            IS_CLEAR
2079      Y:0063 Y:0063                   DC      IS_CLEAR_END-IS_CLEAR-2
2080      Y:0064 Y:0064                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
2081      Y:0065 Y:0065                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2082                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+00 ; Probably not needed
2083      Y:0066 Y:0066                   DC      CLK3+SI_DELAY+I1+I2+00+S1+S2+00+DG
2084      Y:0067 Y:0067                   DC      CLK3+SI_DELAY+00+I2+00+00+S2+00+DG
2085      Y:0068 Y:0068                   DC      CLK3+SI_DELAY+00+I2+I3+00+S2+S3+DG
2086      Y:0069 Y:0069                   DC      CLK3+SI_DELAY+00+00+I3+00+00+S3+DG
2087      Y:006A Y:006A                   DC      CLK3+SI_DELAY+I1+00+I3+S1+00+S3+DG
2088      Y:006B Y:006B                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
2089                            IS_CLEAR_END
2090   
2091                            DUMP_SERIAL
2092      Y:006C Y:006C                   DC      END_DUMP_SERIAL-DUMP_SERIAL-2
2093      Y:006D Y:006D                   DC      CLK2+SI_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2094      Y:006E Y:006E                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
2095      Y:006F Y:006F                   DC      CLK2+SI_DELAY+RGL+RGR+000+000+000+000+000+000
2096      Y:0070 Y:0070                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+00
2097      Y:0071 Y:0071                   DC      CLK2+SI_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 39



2098                            END_DUMP_SERIAL
2099                                    COMMENT *
2100                            ; Michigan AIMO clocking - this is vestigial and commented out
2101                            PARALLEL DC     PARALLEL_CLEAR-PARALLEL-2
2102                                    DC      CLK2+$000000+RGL+RGR+H1L+H1R+H2L+H2R+00+000+000+00
2103                                    DC      CLK3+P_DELAY+00+00+I3
2104                                    DC      CLK3+P_DELAY+00+00+I3
2105                                    DC      CLK3+P_DELAY+I1+00+I3
2106                                    DC      CLK3+P_DELAY+I1+00+00
2107                                    DC      CLK3+P_DELAY+I1+I2+00
2108                                    DC      CLK3+P_DELAY+00+I2+00
2109                                    DC      CLK3+P_DELAY+00+I2+I3
2110                                    DC      CLK3+P_DELAY+00+00+I3
2111                                    DC      CLK3+P_DELAY+00+00+I3
2112                                    DC      CLK3+P_DELAY+00+00+00
2113                                    *
2114   
2115                            ; For serial clocking we know that the serial registers are laid out as
2116                            ; follows for a backside part per communication with Paul Jorden:
2117   
2118                            ;          Right Side               Left Side
2119                            ;       OG  3  2  1  3 .........  3  2  1  3  OG
2120   
2121                            ; Left amp is   2 -> 1 -> 3
2122                            ; Right amp is  1 -> 2 -> 3
2123   
2124                            ; For a frontside part the left and right are reversed.
2125                            ; Parallel phase 3 dumps into serial 1 and 2.
2126   
2127                            ; Between serial clock code lumps the serials are left as follows:
2128                            ; LEFT  Phase 2 L and R both high
2129                            ; RIGHT Phase 1 L and R both high
2130                            ; SPLIT H1R and H2L are high
2131   
2132                            ; Video processor bit definition
2133                            ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2134   
2135                            SERIAL_IDLE                                         ; Split serial
2136      Y:0072 Y:0072                   DC      END_SERIAL_IDLE-SERIAL_IDLE-2
2137      Y:0073 Y:0073                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2138      Y:0074 Y:0074                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2139      Y:0075 Y:0075                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2140      Y:0076 Y:0076                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2141      Y:0077 Y:0077                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2142      Y:0078 Y:0078                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2143      Y:0079 Y:0079                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2144      Y:007A Y:007A                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2145      Y:007B Y:007B                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2146      Y:007C Y:007C                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2147      Y:007D Y:007D                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2148      Y:007E Y:007E                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2149                            ; Not needed, so comment out
2150                            ;       DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2151                            END_SERIAL_IDLE
2152   
2153                            ; The following waveforms are for binned operation.  This is tricky with the
2154                            ; CCD47 because it doesn't have a summing well.  The reset level integration
2155                            ; has to happen before serial 3 drops for the first time and the data level
2156                            ; integration has to happen after it drops for the last time.  The initial
2157                            ; clocks go through the reset integration, the serial clocks are the
2158                            ; intervening clocks for additional pixels binned with the first one, and
2159                            ; the video process is left to do the last clock and data integration.
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 40



2160   
2161                            INITIAL_CLOCK_SPLIT                                 ; Both amplifiers
2162      Y:007F Y:007F                   DC      END_INITIAL_CLOCK_SPLIT-INITIAL_CLOCK_SPLIT-2
2163      Y:0080 Y:0080                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2164      Y:0081 Y:0081                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2165      Y:0082 Y:0082                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2166      Y:0083 Y:0083                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2167      Y:0084 Y:0084                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2168      Y:0085 Y:0085                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2169      Y:0086 Y:0086                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2170      Y:0087 Y:0087                   DC      $00F020                           ; Transmit A/D data to host
2171      Y:0088 Y:0088                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2172      Y:0089 Y:0089                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2173      Y:008A Y:008A                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2174                            END_INITIAL_CLOCK_SPLIT
2175   
2176                            INITIAL_CLOCK_RIGHT                                 ; Serial right, Swap S1L and S2L
2177      Y:008B Y:008B                   DC      END_INITIAL_CLOCK_RIGHT-INITIAL_CLOCK_RIGHT-2
2178      Y:008C Y:008C                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2179      Y:008D Y:008D                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2180      Y:008E Y:008E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2181      Y:008F Y:008F                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2182      Y:0090 Y:0090                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2183      Y:0091 Y:0091                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2184      Y:0092 Y:0092                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2185      Y:0093 Y:0093                   DC      $00F021                           ; Transmit A/D data to host
2186      Y:0094 Y:0094                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2187      Y:0095 Y:0095                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2188      Y:0096 Y:0096                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2189                            END_INITIAL_CLOCK_RIGHT
2190   
2191                            INITIAL_CLOCK_LEFT                                  ; Serial left, Swap S1R and S2R
2192      Y:0097 Y:0097                   DC      END_INITIAL_CLOCK_LEFT-INITIAL_CLOCK_LEFT-2
2193      Y:0098 Y:0098                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2194      Y:0099 Y:0099                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2195      Y:009A Y:009A                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2196      Y:009B Y:009B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2197      Y:009C Y:009C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2198      Y:009D Y:009D                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2199      Y:009E Y:009E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2200      Y:009F Y:009F                   DC      $00F000                           ; Transmit A/D data to host
2201      Y:00A0 Y:00A0                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2202      Y:00A1 Y:00A1                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2203      Y:00A2 Y:00A2                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2204                            END_INITIAL_CLOCK_LEFT
2205   
2206                            SERIAL_CLOCK_SPLIT                                  ; Both amplifiers
2207      Y:00A3 Y:00A3                   DC      END_SERIAL_CLOCK_SPLIT-SERIAL_CLOCK_SPLIT-2
2208      Y:00A4 Y:00A4                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2209      Y:00A5 Y:00A5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2210      Y:00A6 Y:00A6                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2211      Y:00A7 Y:00A7                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2212      Y:00A8 Y:00A8                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2213      Y:00A9 Y:00A9                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2214                            END_SERIAL_CLOCK_SPLIT
2215   
2216                            SERIAL_CLOCK_RIGHT                                  ; Serial right, Swap S1L and S2L
2217      Y:00AA Y:00AA                   DC      END_SERIAL_CLOCK_RIGHT-SERIAL_CLOCK_RIGHT-2
2218      Y:00AB Y:00AB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2219      Y:00AC Y:00AC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2220      Y:00AD Y:00AD                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2221      Y:00AE Y:00AE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 41



2222      Y:00AF Y:00AF                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2223      Y:00B0 Y:00B0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2224                            END_SERIAL_CLOCK_RIGHT
2225   
2226                            SERIAL_CLOCK_LEFT                                   ; Serial left, Swap S1R and S2R
2227      Y:00B1 Y:00B1                   DC      END_SERIAL_CLOCK_LEFT-SERIAL_CLOCK_LEFT-2
2228      Y:00B2 Y:00B2                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2229      Y:00B3 Y:00B3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2230      Y:00B4 Y:00B4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2231      Y:00B5 Y:00B5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2232      Y:00B6 Y:00B6                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2233      Y:00B7 Y:00B7                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2234                            END_SERIAL_CLOCK_LEFT
2235   
2236                            ; need two if you want to call CLOCK
2237                            DCRST_LAST
2238      Y:00B8 Y:00B8                   DC      DCRST_LAST_END-DCRST_LAST-2
2239      Y:00B9 Y:00B9                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
2240      Y:00BA Y:00BA                   DC      VIDEO+%0011000                    ; Reset integ. and DC restore
2241                            DCRST_LAST_END
2242   
2243                            VIDEO_PROCESS
2244      Y:00BB Y:00BB                   DC      END_VIDEO_PROCESS-VIDEO_PROCESS-2
2245                            CCLK_1                                              ; The following line is overwritten by timmisc.s
2246      Y:00BC Y:00BC                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2247      Y:00BD Y:00BD                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2248      Y:00BE Y:00BE                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2249                            CCLK_2                                              ; The following line is overwritten by timmisc.s
, but is correct as is.
2250                            ; Actually it shouldn't be needed so comment it out.
2251                            ;       DC      CLK2+S_DLY+S1R+S2R+000+S1L+S2L+000+000+000+000+000
2252                            END_VIDEO_PROCESS
2253   
2254                            ; Starting Y: address of circular waveforms for no-overhead access
2255      0000C0                STRT_CIR  EQU     $C0
2256      000620                ROM_DISP  EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+STRT_CIR
2257      000660                DAC_DISP  EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+$100
2258   
2259                            ; Check for Y: data memory overflow
2260                                      IF      @CVS(N,*)>STRT_CIR
2262                                      ENDIF                                     ;  will not overflow
2263   
2264                            ; The fast serial code with the circulating address register must start
2265                            ;   on a boundary that is a multiple of the address register modulus.
2266   
2267                                      IF      @SCP("HOST","HOST")
2268      Y:00C0 Y:00C0                   ORG     Y:STRT_CIR,Y:STRT_CIR             ; Download address
2269                                      ELSE
2271                                      ENDIF
2272   
2273                            ; This is an area to copy in the serial fast binned waveforms from high Y memory
2274                            ; It is 0x28 = 40 locations long, enough to put in a binned-by-five waveform
2275                            ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2276                            SERIAL_READ
2277      Y:00C0 Y:00C0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2278      Y:00C1 Y:00C1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2279      Y:00C2 Y:00C2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2280      Y:00C3 Y:00C3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2281      Y:00C4 Y:00C4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2282      Y:00C5 Y:00C5                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2283                            SXMIT
2284      Y:00C6 Y:00C6                   DC      $00F000                           ; Transmit A/D data to host
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 42



2285      Y:00C7 Y:00C7                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2286      Y:00C8 Y:00C8                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2287      Y:00C9 Y:00C9                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2288      Y:00CA Y:00CA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2289      Y:00CB Y:00CB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2290      Y:00CC Y:00CC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2291      Y:00CD Y:00CD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2292      Y:00CE Y:00CE                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2293      Y:00CF Y:00CF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2294      Y:00D0 Y:00D0                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2295      Y:00D1 Y:00D1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2296      Y:00D2 Y:00D2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2297      Y:00D3 Y:00D3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2298      Y:00D4 Y:00D4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2299      Y:00D5 Y:00D5                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2300      Y:00D6 Y:00D6                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2301      Y:00D7 Y:00D7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2302      Y:00D8 Y:00D8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2303      Y:00D9 Y:00D9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2304      Y:00DA Y:00DA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2305      Y:00DB Y:00DB                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2306      Y:00DC Y:00DC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2307      Y:00DD Y:00DD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2308      Y:00DE Y:00DE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2309      Y:00DF Y:00DF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2310      Y:00E0 Y:00E0                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2311      Y:00E1 Y:00E1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2312      Y:00E2 Y:00E2                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2313      Y:00E3 Y:00E3                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2314      Y:00E4 Y:00E4                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2315                            END_SERIAL
2316   
2317                            ; Serial clocking waveform for skipping
2318                                      IF      @SCP("HOST","HOST")
2319      Y:00E8 Y:00E8                   ORG     Y:STRT_CIR+$28,Y:STRT_CIR+$28     ; Download address
2320                                      ELSE
2322                                      ENDIF
2323   
2324                            ; There are three serial skip waveforms that must all be the same length
2325                            SERIAL_SKIP_LEFT
2326                            ;       DC      END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-2
2327      Y:00E8 Y:00E8                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2328      Y:00E9 Y:00E9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2329      Y:00EA Y:00EA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2330      Y:00EB Y:00EB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2331      Y:00EC Y:00EC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2332      Y:00ED Y:00ED                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2333                            END_SERIAL_SKIP_LEFT
2334   
2335                                      IF      @SCP("HOST","HOST")
2336      Y:00F0 Y:00F0                   ORG     Y:STRT_CIR+$30,Y:STRT_CIR+$30     ; Download address
2337                                      ELSE
2339                                      ENDIF
2340   
2341                            SERIAL_SKIP_RIGHT
2342                            ;       DC      END_SERIAL_SKIP_RIGHT-SERIAL_SKIP_RIGHT-2
2343      Y:00F0 Y:00F0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2344      Y:00F1 Y:00F1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2345      Y:00F2 Y:00F2                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2346      Y:00F3 Y:00F3                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2347      Y:00F4 Y:00F4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2348      Y:00F5 Y:00F5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 43



2349                            END_SERIAL_SKIP_RIGHT
2350   
2351                                      IF      @SCP("HOST","HOST")
2352      Y:00F8 Y:00F8                   ORG     Y:STRT_CIR+$38,Y:STRT_CIR+$38     ; Download address
2353                                      ELSE
2355                                      ENDIF
2356   
2357                            SERIAL_SKIP_SPLIT
2358                            ;       DC      END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-2
2359      Y:00F8 Y:00F8                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2360      Y:00F9 Y:00F9                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2361      Y:00FA Y:00FA                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2362      Y:00FB Y:00FB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2363      Y:00FC Y:00FC                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2364      Y:00FD Y:00FD                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2365                            END_SERIAL_SKIP_SPLIT
2366   
2367                            ; Put all the following code in SRAM.
2368                                      IF      @SCP("HOST","HOST")
2369      Y:0100 Y:0100                   ORG     Y:$100,Y:$100                     ; Download address
2370                                      ELSE
2372                                      ENDIF
2373   
2374                            ; Initialization of clock driver and video processor DACs and switches
2375      Y:0100 Y:0100         DACS      DC      END_DACS-DACS-1
2376      Y:0101 Y:0101                   DC      (CLK2<<8)+(0<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S1 Left High, pin 1
2377      Y:0102 Y:0102                   DC      (CLK2<<8)+(1<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S1 Left Low
2378      Y:0103 Y:0103                   DC      (CLK2<<8)+(2<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S2 Left Right High, pin 2
2379      Y:0104 Y:0104                   DC      (CLK2<<8)+(3<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S2 Left Low
2380      Y:0105 Y:0105                   DC      (CLK2<<8)+(4<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S3 Left High, pin 3
2381      Y:0106 Y:0106                   DC      (CLK2<<8)+(5<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S3 Left Low
2382      Y:0107 Y:0107                   DC      (CLK2<<8)+(6<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S1 Right High, pin 4
2383      Y:0108 Y:0108                   DC      (CLK2<<8)+(7<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S1 Right Low
2384      Y:0109 Y:0109                   DC      (CLK2<<8)+(8<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S2 Right High, pin 5
2385      Y:010A Y:010A                   DC      (CLK2<<8)+(9<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S2 Right Low
2386      Y:010B Y:010B                   DC      (CLK2<<8)+(10<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S3 Right High, pin 6
2387      Y:010C Y:010C                   DC      (CLK2<<8)+(11<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S3 Right Low
2388      Y:010D Y:010D                   DC      (CLK2<<8)+(12<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 7
2389      Y:010E Y:010E                   DC      (CLK2<<8)+(13<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2390      Y:010F Y:010F                   DC      (CLK2<<8)+(14<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 8
2391      Y:0110 Y:0110                   DC      (CLK2<<8)+(15<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2392      Y:0111 Y:0111                   DC      (CLK2<<8)+(16<<14)+@CVI((RG_HI+10.0)/20.0*4095) ; RG Left High, pin 9
2393      Y:0112 Y:0112                   DC      (CLK2<<8)+(17<<14)+@CVI((RG_LO+10.0)/20.0*4095) ; RG Left Low
2394      Y:0113 Y:0113                   DC      (CLK2<<8)+(18<<14)+@CVI((RG_HI+10.0)/20.0*4095) ; RG Right High, pin 10
2395      Y:0114 Y:0114                   DC      (CLK2<<8)+(19<<14)+@CVI((RG_LO+10.0)/20.0*4095) ; RG Rightd Low
2396      Y:0115 Y:0115                   DC      (CLK2<<8)+(20<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 11
2397      Y:0116 Y:0116                   DC      (CLK2<<8)+(21<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2398      Y:0117 Y:0117                   DC      (CLK2<<8)+(22<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 12
2399      Y:0118 Y:0118                   DC      (CLK2<<8)+(23<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2400      Y:0119 Y:0119                   DC      (CLK2<<8)+(24<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; I1 High, pin 13
2401      Y:011A Y:011A                   DC      (CLK2<<8)+(25<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; I1 Low
2402      Y:011B Y:011B                   DC      (CLK2<<8)+(26<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; I2 High, pin 14
2403      Y:011C Y:011C                   DC      (CLK2<<8)+(27<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; I2 Low
2404      Y:011D Y:011D                   DC      (CLK2<<8)+(28<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; I3 High, pin 15
2405      Y:011E Y:011E                   DC      (CLK2<<8)+(29<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; I3 Low
2406      Y:011F Y:011F                   DC      (CLK2<<8)+(30<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; S1 High, pin 16
2407      Y:0120 Y:0120                   DC      (CLK2<<8)+(31<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; S1 Low
2408      Y:0121 Y:0121                   DC      (CLK2<<8)+(32<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; S2 High, pin 17
2409      Y:0122 Y:0122                   DC      (CLK2<<8)+(33<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; S2 Low
2410      Y:0123 Y:0123                   DC      (CLK2<<8)+(34<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; S3 High, pin 18
2411      Y:0124 Y:0124                   DC      (CLK2<<8)+(35<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; S3 Low
2412      Y:0125 Y:0125                   DC      (CLK2<<8)+(36<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 19
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 44



2413      Y:0126 Y:0126                   DC      (CLK2<<8)+(37<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2414      Y:0127 Y:0127                   DC      (CLK2<<8)+(38<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 33
2415      Y:0128 Y:0128                   DC      (CLK2<<8)+(39<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2416      Y:0129 Y:0129                   DC      (CLK2<<8)+(40<<14)+@CVI((DG_HI+10.0)/20.0*4095) ; DG High, pin 34
2417      Y:012A Y:012A                   DC      (CLK2<<8)+(41<<14)+@CVI((DG_LO+10.0)/20.0*4095) ; DG Low
2418      Y:012B Y:012B                   DC      (CLK2<<8)+(42<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 35
2419      Y:012C Y:012C                   DC      (CLK2<<8)+(43<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2420      Y:012D Y:012D                   DC      (CLK2<<8)+(44<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 36
2421      Y:012E Y:012E                   DC      (CLK2<<8)+(45<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2422      Y:012F Y:012F                   DC      (CLK2<<8)+(46<<14)+@CVI((VABG+10.0)/20.0*4095) ; Anti-Blooming Gate High, pin 37
2423      Y:0130 Y:0130                   DC      (CLK2<<8)+(47<<14)+@CVI((VABG+10.0)/20.0*4095) ; Anti-Blooming Gate Low
2424   
2425                            ; Set gain and integrator speed
2426      Y:0131 Y:0131                   DC      $0c3fdd                           ; Gain, speed
2427   
2428                            ;       DC      $0c3f77                 ; Gain x1, fast integ speed, board #0
2429                            ;       DC      $0c3fbb                 ; Gain x2, fast integ speed, board #0
2430                            ;       DC      $0c3fdd                 ; Gain x4.75, fast integ speed, board #0
2431                            ;       DC      $0c3fee                 ; Gain x9.50, fast integ speed, board #0
2432                            ;       DC      $0c3cee                 ; Gain x9.50, slow integ speed, board #0
2433   
2434                            ; Input offset voltages for DC coupling. Target is U4#6 = 24 volts
2435      Y:0132 Y:0132                   DC      $0c0800                           ; Input offset, ch. A
2436      Y:0133 Y:0133                   DC      $0c8800                           ; Input offset, ch. B
2437   
2438                            ; Output offset voltages
2439      Y:0134 Y:0134                   DC      $0c4000+OFFSET0                   ; Output video offset, ch. A
2440      Y:0135 Y:0135                   DC      $0cc000+OFFSET1                   ; Output video offset, ch. B
2441   
2442                            ; Output and reset drain DC bias voltages
2443      Y:0136 Y:0136                   DC      $0d0000+@CVI((VODL-7.50)/22.5*4095) ; VODL pin #1
2444      Y:0137 Y:0137                   DC      $0d4000+@CVI((VODR-7.50)/22.5*4095) ; VODR pin #2
2445      Y:0138 Y:0138                   DC      $0d8000+@CVI((VRDL-5.00)/15.0*4095) ; VRDL pin #3
2446      Y:0139 Y:0139                   DC      $0dc000+@CVI((VRDR-5.00)/15.0*4095) ; VRDR pin #4
2447   
2448   
2449                            ; Output and anti-blooming gates
2450      Y:013A Y:013A                   DC      $0f0000+BIAS_ZERO                 ; Unused pin #9
2451      Y:013B Y:013B                   DC      $0f4000+BIAS_ZERO                 ; Unused pin #10
2452      Y:013C Y:013C                   DC      $0f8000+@CVI((VOG+10.0)/20.0*4095) ; Unused pin #11
2453      Y:013D Y:013D                   DC      $0fc000+@CVI((VABG+10.0)/20.0*4095) ; Unused pin #12
2454                            END_DACS
2455   
2456   
2457                            ;       These are the 15 fast serial read waveforms for left, right,
2458                            ;       and split reads for serial binning factors from 1 to 5.
2459   
2460                            ;       Unbinned waveforms
2461                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2462                            SERIAL_READ_LEFT_1
2463      Y:013E Y:013E                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2464      Y:013F Y:013F                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2465      Y:0140 Y:0140                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2466      Y:0141 Y:0141                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2467      Y:0142 Y:0142                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2468      Y:0143 Y:0143                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2469                            SXMIT_LEFT_1
2470      Y:0144 Y:0144                   DC      $00F000                           ; Transmit A/D data to host
2471      Y:0145 Y:0145                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2472      Y:0146 Y:0146                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2473      Y:0147 Y:0147                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2474      Y:0148 Y:0148                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 45



2475      Y:0149 Y:0149                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2476      Y:014A Y:014A                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2477                            END_SERIAL_READ_LEFT_1
2478   
2479                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2480                            SERIAL_READ_RIGHT_1
2481      Y:014B Y:014B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2482      Y:014C Y:014C                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2483      Y:014D Y:014D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2484      Y:014E Y:014E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2485      Y:014F Y:014F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2486      Y:0150 Y:0150                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2487                            SXMIT_RIGHT_1
2488      Y:0151 Y:0151                   DC      $00F021                           ; Transmit A/D data to host
2489      Y:0152 Y:0152                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2490      Y:0153 Y:0153                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2491      Y:0154 Y:0154                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2492      Y:0155 Y:0155                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2493      Y:0156 Y:0156                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2494      Y:0157 Y:0157                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2495                            END_SERIAL_READ_RIGHT_1
2496   
2497                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2498                            SERIAL_READ_SPLIT_1
2499      Y:0158 Y:0158                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2500      Y:0159 Y:0159                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2501      Y:015A Y:015A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2502      Y:015B Y:015B                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2503      Y:015C Y:015C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2504      Y:015D Y:015D                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2505                            SXMIT_SPLIT_1
2506      Y:015E Y:015E                   DC      $00F020                           ; Transmit A/D data to host
2507      Y:015F Y:015F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2508      Y:0160 Y:0160                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2509      Y:0161 Y:0161                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2510      Y:0162 Y:0162                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2511      Y:0163 Y:0163                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2512      Y:0164 Y:0164                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2513                            END_SERIAL_READ_SPLIT_1
2514   
2515                            ; Bin by 2 waveforms
2516                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2517                            SERIAL_READ_LEFT_2
2518      Y:0165 Y:0165                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2519      Y:0166 Y:0166                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2520      Y:0167 Y:0167                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2521      Y:0168 Y:0168                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2522      Y:0169 Y:0169                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2523      Y:016A Y:016A                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2524                            SXMIT_LEFT_2
2525      Y:016B Y:016B                   DC      $00F000                           ; Transmit A/D data to host
2526      Y:016C Y:016C                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2527      Y:016D Y:016D                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2528      Y:016E Y:016E                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2529      Y:016F Y:016F                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2530      Y:0170 Y:0170                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2531      Y:0171 Y:0171                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2532      Y:0172 Y:0172                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2533      Y:0173 Y:0173                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2534      Y:0174 Y:0174                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2535      Y:0175 Y:0175                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2536      Y:0176 Y:0176                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 46



2537      Y:0177 Y:0177                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2538                            END_SERIAL_READ_LEFT_2
2539   
2540                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2541                            SERIAL_READ_RIGHT_2
2542      Y:0178 Y:0178                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2543      Y:0179 Y:0179                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2544      Y:017A Y:017A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2545      Y:017B Y:017B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2546      Y:017C Y:017C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2547      Y:017D Y:017D                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2548                            SXMIT_RIGHT_2
2549      Y:017E Y:017E                   DC      $00F021                           ; Transmit A/D data to host
2550      Y:017F Y:017F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2551      Y:0180 Y:0180                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2552      Y:0181 Y:0181                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2553      Y:0182 Y:0182                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2554      Y:0183 Y:0183                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2555      Y:0184 Y:0184                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2556      Y:0185 Y:0185                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2557      Y:0186 Y:0186                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2558      Y:0187 Y:0187                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2559      Y:0188 Y:0188                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2560      Y:0189 Y:0189                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2561      Y:018A Y:018A                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2562                            END_SERIAL_READ_RIGHT_2
2563   
2564                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2565                            SERIAL_READ_SPLIT_2
2566      Y:018B Y:018B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2567      Y:018C Y:018C                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2568      Y:018D Y:018D                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2569      Y:018E Y:018E                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2570      Y:018F Y:018F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2571      Y:0190 Y:0190                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2572                            SXMIT_SPLIT_2
2573      Y:0191 Y:0191                   DC      $00F020                           ; Transmit A/D data to host
2574      Y:0192 Y:0192                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2575      Y:0193 Y:0193                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2576      Y:0194 Y:0194                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2577      Y:0195 Y:0195                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2578      Y:0196 Y:0196                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2579      Y:0197 Y:0197                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2580      Y:0198 Y:0198                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2581      Y:0199 Y:0199                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2582      Y:019A Y:019A                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2583      Y:019B Y:019B                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2584      Y:019C Y:019C                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2585      Y:019D Y:019D                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2586                            END_SERIAL_READ_SPLIT_2
2587   
2588   
2589                            ;       Binned by 3 waveforms
2590                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2591                            SERIAL_READ_LEFT_3
2592      Y:019E Y:019E                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2593      Y:019F Y:019F                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2594      Y:01A0 Y:01A0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2595      Y:01A1 Y:01A1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2596      Y:01A2 Y:01A2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2597      Y:01A3 Y:01A3                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2598                            SXMIT_LEFT_3
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 47



2599      Y:01A4 Y:01A4                   DC      $00F000                           ; Transmit A/D data to host
2600      Y:01A5 Y:01A5                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2601      Y:01A6 Y:01A6                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2602      Y:01A7 Y:01A7                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2603      Y:01A8 Y:01A8                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2604      Y:01A9 Y:01A9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2605      Y:01AA Y:01AA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2606      Y:01AB Y:01AB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2607      Y:01AC Y:01AC                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2608      Y:01AD Y:01AD                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2609      Y:01AE Y:01AE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2610      Y:01AF Y:01AF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2611      Y:01B0 Y:01B0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2612      Y:01B1 Y:01B1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2613      Y:01B2 Y:01B2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2614      Y:01B3 Y:01B3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2615      Y:01B4 Y:01B4                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2616      Y:01B5 Y:01B5                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2617      Y:01B6 Y:01B6                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2618                            END_SERIAL_READ_LEFT_3
2619   
2620                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2621                            SERIAL_READ_RIGHT_3
2622      Y:01B7 Y:01B7                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2623      Y:01B8 Y:01B8                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2624      Y:01B9 Y:01B9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2625      Y:01BA Y:01BA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2626      Y:01BB Y:01BB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2627      Y:01BC Y:01BC                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2628                            SXMIT_RIGHT_3
2629      Y:01BD Y:01BD                   DC      $00F021                           ; Transmit A/D data to host
2630      Y:01BE Y:01BE                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2631      Y:01BF Y:01BF                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2632      Y:01C0 Y:01C0                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2633      Y:01C1 Y:01C1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2634      Y:01C2 Y:01C2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2635      Y:01C3 Y:01C3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2636      Y:01C4 Y:01C4                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2637      Y:01C5 Y:01C5                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2638      Y:01C6 Y:01C6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2639      Y:01C7 Y:01C7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2640      Y:01C8 Y:01C8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2641      Y:01C9 Y:01C9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2642      Y:01CA Y:01CA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2643      Y:01CB Y:01CB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2644      Y:01CC Y:01CC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2645      Y:01CD Y:01CD                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2646      Y:01CE Y:01CE                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2647      Y:01CF Y:01CF                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2648                            END_SERIAL_READ_RIGHT_3
2649   
2650                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2651                            SERIAL_READ_SPLIT_3
2652      Y:01D0 Y:01D0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2653      Y:01D1 Y:01D1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2654      Y:01D2 Y:01D2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2655      Y:01D3 Y:01D3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2656      Y:01D4 Y:01D4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2657      Y:01D5 Y:01D5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2658                            SXMIT_SPLIT_3
2659      Y:01D6 Y:01D6                   DC      $00F020                           ; Transmit A/D data to host
2660      Y:01D7 Y:01D7                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 48



2661      Y:01D8 Y:01D8                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2662      Y:01D9 Y:01D9                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2663      Y:01DA Y:01DA                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2664      Y:01DB Y:01DB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2665      Y:01DC Y:01DC                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2666      Y:01DD Y:01DD                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2667      Y:01DE Y:01DE                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2668      Y:01DF Y:01DF                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2669      Y:01E0 Y:01E0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2670      Y:01E1 Y:01E1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2671      Y:01E2 Y:01E2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2672      Y:01E3 Y:01E3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2673      Y:01E4 Y:01E4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2674      Y:01E5 Y:01E5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2675      Y:01E6 Y:01E6                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2676      Y:01E7 Y:01E7                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2677      Y:01E8 Y:01E8                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2678                            END_SERIAL_READ_SPLIT_3
2679   
2680                            ;       Binned by 4 waveforms
2681                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2682                            SERIAL_READ_LEFT_4
2683      Y:01E9 Y:01E9                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2684      Y:01EA Y:01EA                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2685      Y:01EB Y:01EB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2686      Y:01EC Y:01EC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2687      Y:01ED Y:01ED                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2688      Y:01EE Y:01EE                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2689                            SXMIT_LEFT_4
2690      Y:01EF Y:01EF                   DC      $00F000                           ; Transmit A/D data to host
2691      Y:01F0 Y:01F0                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2692      Y:01F1 Y:01F1                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2693      Y:01F2 Y:01F2                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2694      Y:01F3 Y:01F3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2695      Y:01F4 Y:01F4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2696      Y:01F5 Y:01F5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2697      Y:01F6 Y:01F6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2698      Y:01F7 Y:01F7                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2699      Y:01F8 Y:01F8                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2700      Y:01F9 Y:01F9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2701      Y:01FA Y:01FA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2702      Y:01FB Y:01FB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2703      Y:01FC Y:01FC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2704      Y:01FD Y:01FD                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2705      Y:01FE Y:01FE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2706      Y:01FF Y:01FF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2707      Y:0200 Y:0200                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2708      Y:0201 Y:0201                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2709      Y:0202 Y:0202                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2710      Y:0203 Y:0203                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2711      Y:0204 Y:0204                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2712      Y:0205 Y:0205                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2713      Y:0206 Y:0206                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2714      Y:0207 Y:0207                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2715                            END_SERIAL_READ_LEFT_4
2716   
2717                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2718                            SERIAL_READ_RIGHT_4
2719      Y:0208 Y:0208                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2720      Y:0209 Y:0209                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2721      Y:020A Y:020A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2722      Y:020B Y:020B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 49



2723      Y:020C Y:020C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2724      Y:020D Y:020D                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2725                            SXMIT_RIGHT_4
2726      Y:020E Y:020E                   DC      $00F021                           ; Transmit A/D data to host
2727      Y:020F Y:020F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2728      Y:0210 Y:0210                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2729      Y:0211 Y:0211                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2730      Y:0212 Y:0212                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2731      Y:0213 Y:0213                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2732      Y:0214 Y:0214                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2733      Y:0215 Y:0215                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2734      Y:0216 Y:0216                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2735      Y:0217 Y:0217                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2736      Y:0218 Y:0218                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2737      Y:0219 Y:0219                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2738      Y:021A Y:021A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2739      Y:021B Y:021B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2740      Y:021C Y:021C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2741      Y:021D Y:021D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2742      Y:021E Y:021E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2743      Y:021F Y:021F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2744      Y:0220 Y:0220                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2745      Y:0221 Y:0221                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2746      Y:0222 Y:0222                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2747      Y:0223 Y:0223                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2748      Y:0224 Y:0224                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2749      Y:0225 Y:0225                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2750      Y:0226 Y:0226                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2751                            END_SERIAL_READ_RIGHT_4
2752   
2753                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2754                            SERIAL_READ_SPLIT_4
2755      Y:0227 Y:0227                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2756      Y:0228 Y:0228                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2757      Y:0229 Y:0229                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2758      Y:022A Y:022A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2759      Y:022B Y:022B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2760      Y:022C Y:022C                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2761                            SXMIT_SPLIT_4
2762      Y:022D Y:022D                   DC      $00F020                           ; Transmit A/D data to host
2763      Y:022E Y:022E                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2764      Y:022F Y:022F                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2765      Y:0230 Y:0230                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2766      Y:0231 Y:0231                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2767      Y:0232 Y:0232                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2768      Y:0233 Y:0233                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2769      Y:0234 Y:0234                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2770      Y:0235 Y:0235                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2771      Y:0236 Y:0236                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2772      Y:0237 Y:0237                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2773      Y:0238 Y:0238                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2774      Y:0239 Y:0239                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2775      Y:023A Y:023A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2776      Y:023B Y:023B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2777      Y:023C Y:023C                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2778      Y:023D Y:023D                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2779      Y:023E Y:023E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2780      Y:023F Y:023F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2781      Y:0240 Y:0240                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2782      Y:0241 Y:0241                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2783      Y:0242 Y:0242                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2784      Y:0243 Y:0243                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 50



2785      Y:0244 Y:0244                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2786      Y:0245 Y:0245                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2787                            END_SERIAL_READ_SPLIT_4
2788   
2789                            ;       Binned by 5 waveforms
2790                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2791                            SERIAL_READ_LEFT_5
2792      Y:0246 Y:0246                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2793      Y:0247 Y:0247                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2794      Y:0248 Y:0248                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2795      Y:0249 Y:0249                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2796      Y:024A Y:024A                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2797      Y:024B Y:024B                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2798                            SXMIT_LEFT_5
2799      Y:024C Y:024C                   DC      $00F000                           ; Transmit A/D data to host
2800      Y:024D Y:024D                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2801      Y:024E Y:024E                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2802      Y:024F Y:024F                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2803      Y:0250 Y:0250                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2804      Y:0251 Y:0251                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2805      Y:0252 Y:0252                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2806      Y:0253 Y:0253                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2807      Y:0254 Y:0254                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2808      Y:0255 Y:0255                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2809      Y:0256 Y:0256                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2810      Y:0257 Y:0257                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2811      Y:0258 Y:0258                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2812      Y:0259 Y:0259                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2813      Y:025A Y:025A                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2814      Y:025B Y:025B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2815      Y:025C Y:025C                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2816      Y:025D Y:025D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2817      Y:025E Y:025E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2818      Y:025F Y:025F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2819      Y:0260 Y:0260                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2820      Y:0261 Y:0261                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2821      Y:0262 Y:0262                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2822      Y:0263 Y:0263                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2823      Y:0264 Y:0264                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2824      Y:0265 Y:0265                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2825      Y:0266 Y:0266                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2826      Y:0267 Y:0267                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2827      Y:0268 Y:0268                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2828      Y:0269 Y:0269                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2829      Y:026A Y:026A                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2830                            END_SERIAL_READ_LEFT_5
2831   
2832                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2833                            SERIAL_READ_RIGHT_5
2834      Y:026B Y:026B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2835      Y:026C Y:026C                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2836      Y:026D Y:026D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2837      Y:026E Y:026E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2838      Y:026F Y:026F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2839      Y:0270 Y:0270                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2840                            SXMIT_RIGHT_5
2841      Y:0271 Y:0271                   DC      $00F021                           ; Transmit A/D data to host
2842      Y:0272 Y:0272                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2843      Y:0273 Y:0273                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2844      Y:0274 Y:0274                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2845      Y:0275 Y:0275                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2846      Y:0276 Y:0276                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 51



2847      Y:0277 Y:0277                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2848      Y:0278 Y:0278                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2849      Y:0279 Y:0279                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2850      Y:027A Y:027A                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2851      Y:027B Y:027B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2852      Y:027C Y:027C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2853      Y:027D Y:027D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2854      Y:027E Y:027E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2855      Y:027F Y:027F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2856      Y:0280 Y:0280                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2857      Y:0281 Y:0281                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2858      Y:0282 Y:0282                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2859      Y:0283 Y:0283                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2860      Y:0284 Y:0284                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2861      Y:0285 Y:0285                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2862      Y:0286 Y:0286                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2863      Y:0287 Y:0287                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2864      Y:0288 Y:0288                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2865      Y:0289 Y:0289                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2866      Y:028A Y:028A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2867      Y:028B Y:028B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2868      Y:028C Y:028C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2869      Y:028D Y:028D                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2870      Y:028E Y:028E                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2871      Y:028F Y:028F                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2872                            END_SERIAL_READ_RIGHT_5
2873   
2874                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2875                            SERIAL_READ_SPLIT_5
2876      Y:0290 Y:0290                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2877      Y:0291 Y:0291                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2878      Y:0292 Y:0292                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2879      Y:0293 Y:0293                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2880      Y:0294 Y:0294                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2881      Y:0295 Y:0295                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2882                            SXMIT_SPLIT_5
2883      Y:0296 Y:0296                   DC      $00F020                           ; Transmit A/D data to host
2884      Y:0297 Y:0297                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2885      Y:0298 Y:0298                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2886      Y:0299 Y:0299                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2887      Y:029A Y:029A                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2888      Y:029B Y:029B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2889      Y:029C Y:029C                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2890      Y:029D Y:029D                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2891      Y:029E Y:029E                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2892      Y:029F Y:029F                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2893      Y:02A0 Y:02A0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2894      Y:02A1 Y:02A1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2895      Y:02A2 Y:02A2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2896      Y:02A3 Y:02A3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2897      Y:02A4 Y:02A4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2898      Y:02A5 Y:02A5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2899      Y:02A6 Y:02A6                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2900      Y:02A7 Y:02A7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2901      Y:02A8 Y:02A8                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2902      Y:02A9 Y:02A9                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2903      Y:02AA Y:02AA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2904      Y:02AB Y:02AB                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2905      Y:02AC Y:02AC                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2906      Y:02AD Y:02AD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2907      Y:02AE Y:02AE                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2908      Y:02AF Y:02AF                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   112-10-12  17:20:30  HIPO_Blue.waveforms.s  Page 52



2909      Y:02B0 Y:02B0                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2910      Y:02B1 Y:02B1                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2911      Y:02B2 Y:02B2                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2912      Y:02B3 Y:02B3                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2913      Y:02B4 Y:02B4                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2914                            END_SERIAL_READ_SPLIT_5
2915   
2916   
2917                                      IF      @SCP("HOST","EEPROM")
2921                                      ENDIF
2922   
2923                               ENDSEC                                    ; End of section TIMEEV57
2924   
2925                     ;  End of program
2926                               END

0    Errors
0    Warnings


