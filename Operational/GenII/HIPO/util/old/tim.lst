Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  tim.s  Page 1



1                        ; This file is used to generate DSP code for the TimII second generation
2                        ;   timing board. This is Rev. 3.00 software.
3                        ;
4                        ; This file contains two subroutines and X and Y data areas.  The two
5                        ; subroutines are RDCCD (with secondary entry point RCCD1) and CLOCK.
6                        ; These need to be in fast P memory.  The boot code and tim.s are there.
7                        ; tim.s includes timmisc.s and timCCDmisc.s at the
8                        ; beginning and the waveforms file at the end in Y memory.
9      
10                                 PAGE    132                               ; Printronix page width - 132 columns
11     
12                       ; Define a section name so it doesn't conflict with other application programs
13                                 SECTION TIMEEV57
14     
15                       ; Include a header file that defines global parameters
16                                 INCLUDE "timhdr.s"
17                              COMMENT *
18     
19                       This is a header file that is shared between the fiber optic timing board
20                       boot and application code files
21                               *
22     
23                                 PAGE    132                               ; Printronix page width - 132 columns
24     
25                       ; Some basic structural definitions
26        000130         APL_ADR   EQU     $130                              ; P: memory location where application code begins
27        0000D0         APL_LEN   EQU     $200-APL_ADR                      ; Maximum length of application program
28        000030         IMGVAR_ADR EQU    $30                               ;  Special Image Mode variables Starting Address in X:
29     
30                       ; CHANGING MISC_LEN FROM 0X280 TO A LARGER NUMBER BREAKS THE ROM COPY APPROACH!
31                       ; However if all you do is download there is a lot more memory available.
32        000450         MISC_LEN  EQU     $450                              ; Maximum length of "miscellanous" code
33                       ;MISC_LEN EQU   $3F0    ; Maximum length of "miscellanous" code
34                       ; MISC_LEN EQU  $280    ; Maximum length of "miscellanous" code
35     
36        000040         COM_LEN   EQU     $40                               ; Length of memory for application commands
37        00003C         TIM_ISR   EQU     $3C                               ; DSP timer interrupt service routine address
38        00003E         PGM_CON   EQU     $3E                               ; Program continues on here
39        000080         COM_TBL   EQU     $80                               ; Starting address of command table in X: memory
40        000500         N_W_APL   EQU     $500                              ; Number of words in each application
41        000028         NUM_COM   EQU     40                                ; Number of entries in command table
42     
43        000000         RST_ISR   EQU     $00                               ; Hardware reset interrupt
44        000006         ROM_ID    EQU     $06                               ; Location of program Identification = SWI interrupt
45        000008         START     EQU     $08                               ; Starting address of program
46        000060         RCV_BUF   EQU     $60                               ; Starting address of receiver buffer in X:
47        00000F         TBL_ADR   EQU     $0F                               ; (IR) Waveform tables starting address
48     
49        004000         ROM_OFF   EQU     $4000                             ; Boot program offset address in EEPROM
50        004200         LD_X      EQU     $4200                             ; Assembler loads X: starting at this EEPROM address
51        00C600         RD_X      EQU     $C600                             ; DSP reads X: from this EEPROM address
52     
53                       ; Define DSP port addresses
54        00FF80         WRSS      EQU     $FF80                             ; Write clock driver and VP switch states
55        00FFC0         RDFO      EQU     $FFC0                             ; Read serial receiver fiber optic contents
56        00FFC0         WRFO      EQU     $FFC0                             ; Write to fiber optic serial transmitter
57        00FFA0         RDAD      EQU     $FFA0                             ; Read A/D datum into DSP
58        00FFA0         RDAD0     EQU     $FFA0                             ; Address for reading A/D #0
59        00FFA1         RDAD1     EQU     $FFA1                             ; Address for reading A/D #1
60        00FFC1         WRLATCH   EQU     $FFC1                             ; Write to timing board latch
61        006000         RSTWDT    EQU     $6000                             ; Address to reset the timing board watchdog timer
62        00FFFE         BCR       EQU     $FFFE                             ; Bus (=Port A) Control Register -> Wait States
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timhdr.s  Page 2



63        00FFE0         PBC       EQU     $FFE0                             ; Port B Control Register
64        00FFE2         PBDDR     EQU     $FFE2                             ; Port B Data Direction Register
65        00FFE4         PBD       EQU     $FFE4                             ; Port B Data Register
66        00FFE1         PCC       EQU     $FFE1                             ; Port C Control Register
67        00FFE3         PCDDR     EQU     $FFE3                             ; PortC Data Direction Register
68        00FFE5         PCD       EQU     $FFE5                             ; Port C Data Register
69        00FFFF         IPR       EQU     $FFFF                             ; Interrupt Priority Register
70        00FFEF         SSITX     EQU     $FFEF                             ; SSI Transmit and Receive data register
71        00FFEF         SSIRX     EQU     $FFEF                             ; SSI Transmit and Receive data register
72        00FFEE         SSISR     EQU     $FFEE                             ; SSI Status Register
73        00FFEC         CRA       EQU     $FFEC                             ; SSI Control Register A
74        00FFED         CRB       EQU     $FFED                             ; SSI Control Regsiter B
75        00FFDE         TCSR      EQU     $FFDE                             ; Timer control and status register
76        00FFDF         TCR       EQU     $FFDF                             ; Timer count register
77     
78                       ; Hardware bit definitions all over the place
79        000006         SSI_TDE   EQU     6                                 ; SSI Transmitter data register empty
80        000007         SSI_RDF   EQU     7                                 ; SSI Receiver data register full
81        000002         LVEN      EQU     2                                 ; Low voltage enable (+/-15 volt nominal)
82        000003         HVEN      EQU     3                                 ; Enable high voltage (+32V nominal)
83        000005         TIM_U_RST EQU     5                                 ; Timing to utility board reset bit number in U25
84        00000D         PWRST     EQU     13                                ; Power control board reset
85        000007         RST_FIFO  EQU     7                                 ; Reset FIFO bit number in control latch U25
86        000009         EF        EQU     9                                 ; FIFO empty flag, low true
87        000000         TIM_BIT   EQU     0                                 ; Timer status bit
88        000001         WW        EQU     1                                 ; Word width = 1 for 16-bit image data, 0 for 24-bit
89        000000         CDAC      EQU     0                                 ; Bit number in U25 for clearing DACs
90        000002         ENCK      EQU     2                                 ; Bit number in U25 for enabling analog switches
91        000001         DUALCLK   EQU     1                                 ; Set to clock two halves of clock driver board togethe
r
92     
93                       ; Software status bits, defined at X:<STATUS = X:0
94        000000         ST_RCV    EQU     0                                 ; Set if FO, cleared if SSI
95        00000A         TST_IMG   EQU     10                                ; Set if controller is to generate a test image
96        00000B         SHUT      EQU     11                                ; Set if opening shutter at beginning of exposure
97     
98                       ; Software status bits, defined at X:<STATUS = X:0
99        000002         IDLMODE   EQU     2                                 ; Set if need to idle after readout
100       000003         ST_SHUT   EQU     3                                 ; Set to indicate shutter is closed, clear for open
101       000004         ST_RDC    EQU     4                                 ; Set if executing 'RDC' command - reading out
102       000005         SPLIT_S   EQU     5                                 ; Set if split serial
103       000006         SPLIT_P   EQU     6                                 ; Set if split parallel
104       000007         MPP       EQU     7                                 ; Set if parallels are in MPP mode
105       000008         TRIGGER   EQU     8                                 ; Set if a Hardware triggered exposure
106    
107    
108                      ; Image mode bits, defined at X:<IMAGE_MODE
109    
110       000000         FDOTS     EQU     0                                 ; Fast Dots
111       000001         FIND      EQU     1                                 ; Find
112       000002         SDOTS     EQU     2                                 ; Slow Dots
113       000003         SERIES    EQU     3                                 ; Series
114       000004         SINGLE    EQU     4                                 ; Single
115       000005         STRIP     EQU     5                                 ; Stripscan
116       000006         F_OCC     EQU     6                                 ; Fast occultation, keep as 6 for compatibility
117       000007         B_OCC     EQU     7                                 ; Basic occultation
118       000008         P_OCC     EQU     8                                 ; Pipelined occultation
119    
120                      ; Image Status, define at X:<ISTATUS
121       000000         NO_SKIP   EQU     0                                 ; Set for slow dots, fast and pipelined occultation mod
e
122                                                                          ; to avoid parallel skipping to the subframe boundary.
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timhdr.s  Page 3



123       000001         OPEN_CLOSE EQU    1                                 ; Set if shutter opens/closes each image
124                                                                          ; Clear if shutter stays open for many images
125       000002         STORAGE   EQU     2                                 ; Set if storage area is to be clocked
126    
127    
128                      ; Specify controller configuration bits of the X:STATUS word
129                      ;   to describe the software capabilities of this application file
130                      ; The bit is set (=1) if the capability is supported by the controller
131    
132    
133                              COMMENT *
134    
135                      BIT #'s         FUNCTION
136                      2,1,0           Video Processor
137                                              000     CCD Rev. 3
138                                              001     CCD Gen I
139                                              010     IR Rev. 4
140                                              011     IR Coadder
141    
142                      4,3             Timing Board
143                                              00      Rev. 4, Gen II
144                                              01      Gen I
145    
146                      6,5             Utility Board
147                                              00      No utility board
148                                              01      Utility Rev. 3
149    
150                      7               Shutter
151                                              0       No shutter support
152                                              1       Yes shutter support
153    
154                      9,8             Temperature readout
155                                              00      No temperature readout
156                                              01      Polynomial Diode calibration
157                                              10      Linear temperature sensor calibration
158    
159                      10              Subarray readout
160                                              0       Not supported
161                                              1       Yes supported
162    
163                      11              Binning
164                                              0       Not supported
165                                              1       Yes supported
166    
167                      12              Split-Serial readout
168                                              0       Not supported
169                                              1       Yes supported
170    
171                      13              Split-Parallel readout
172                                              0       Not supported
173                                              1       Yes supported
174    
175                      14              MPP = Inverted parallel clocks
176                                              0       Not supported
177                                              1       Yes supported
178    
179                      16,15           Clock Driver Board
180                                              00      Rev. 3
181                                              11      No clock driver board (Gen I)
182    
183                      19,18,17                Special implementations
184                                              000     Somewhere else
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timhdr.s  Page 4



185                                              001     Mount Laguna Observatory
186                                              010     NGST Aladdin
187                                              xxx     Other
188                              *
189    
190                      CCDVIDREV3B
191       000000                   EQU     $000000                           ; CCD Video Processor Rev. 3
192       000001         VIDGENI   EQU     $000001                           ; CCD Video Processor Gen I
193       000002         IRREV4    EQU     $000002                           ; IR Video Processor Rev. 4
194       000003         COADDER   EQU     $000003                           ; IR Coadder
195       000000         TIMREV4   EQU     $000000                           ; Timing Rev. 4
196       000008         TIMGENI   EQU     $000008                           ; Timing Gen I
197       000020         UTILREV3  EQU     $000020                           ; Utility Rev. 3 supported
198       000080         SHUTTER_CC EQU    $000080                           ; Shutter supported
199       000100         TEMP_POLY EQU     $000100                           ; Polynomial calibration
200                      TEMP_LINEAR
201       000200                   EQU     $000200                           ; Linear calibration
202       000400         SUBARRAY  EQU     $000400                           ; Subarray readout supported
203       000800         BINNING   EQU     $000800                           ; Binning supported
204                      SPLIT_SERIAL
205       001000                   EQU     $001000                           ; Split serial supported
206                      SPLIT_PARALLEL
207       002000                   EQU     $002000                           ; Split parallel supported
208       004000         MPP_CC    EQU     $004000                           ; Inverted clocks supported
209       018000         CLKDRVGENI EQU    $018000                           ; No clock driver board - Gen I
210       020000         MLO       EQU     $020000                           ; Set if Mount Laguna Observatory
211       040000         NGST      EQU     $040000                           ; NGST Aladdin implementation
212                                INCLUDE "infospec.s"
213                      ; General DSP info field specifications.
214                      ; These values are 'addresses' and used as the argument for the INF command.
215    
216                      GET_VERSION
217       000000                   EQU     0                                 ; IVERSION field
218       000001         GET_FLAVOR EQU    1                                 ; IFLAVOR field
219       000002         GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
220       000003         GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
221       000004         GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if available)
222    
223                                INCLUDE "timinfospec.s"
224                      ; TIM DSP info field specifications.
225                      ; These values are 'addresses' and used as the argument for the INF command.
226    
227                      GET_CAPABLE
228       000100                   EQU     $100                              ; ICAPABLE field (what dsp supports).
229                      GET_INT_TIM
230       000101                   EQU     $101                              ; Integration time per pixel in leach units
231                      GET_R_DELAY
232       000102                   EQU     $102                              ; Serial overlap in leach units
233                      GET_SI_DELAY
234       000103                   EQU     $103                              ; Parallel overlap in leach units
235    
236                                INCLUDE "timinfo.s"
237                      ; DSP Version
238       04407F         IVERSION  EQU     278655                            ; 1.4/1
239    
240       612020         IFLAVOR   EQU     'a  '                             ; a
241    
242       00D401         ITIME0    EQU     54273                             ; lo order time: 2008 8 18  19:56:49 GMT
243    
244       0048A9         ITIME1    EQU     18601                             ; hi order time: 2008 8 18  19:56:49 GMT
245    
246       000FDB         ISVNREV   EQU     4059
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timinfo.s  Page 5



247                                                                          ; most recent code svn rev
248    
249                      ; tim capability definitions
250                      FINDCAPABLE
251       000001                   EQU     1                                 ; Find exposure mode
252                      SNGLCAPABLE
253       000002                   EQU     2                                 ; Single exposure mode
254                      SERICAPABLE
255       000004                   EQU     4                                 ; Series exposure mode
256                      BASCCAPABLE
257       000008                   EQU     8                                 ; Basic occ exposure mode
258                      FASTCAPABLE
259       000010                   EQU     16                                ; Fast occ exposure mode
260                      PIPECAPABLE
261       000020                   EQU     32                                ; Pipeline occ exposure mode
262                      FDOTCAPABLE
263       000040                   EQU     64                                ; Fast dots exposure mode
264                      SDOTCAPABLE
265       000080                   EQU     128                               ; Slow dots exposure mode
266                      STRPCAPABLE
267       000100                   EQU     256                               ; Slow dots exposure mode
268       0001FB         TIMCAPABLE EQU    FINDCAPABLE+SNGLCAPABLE+STRPCAPABLE+BASCCAPABLE+FASTCAPABLE+PIPECAPABLE+FDOTCAPABLE+SDOTC
APABLE
269    
270       000000         APL_NUM   EQU     0                                 ; Application number from 0 to 3
271    
272       001420         CC        EQU     CCDVIDREV3B+TIMREV4+UTILREV3+SUBARRAY+SPLIT_SERIAL
273    
274                      ; Include miscellaneous timing commands
275                                INCLUDE "timmisc.s"                       ; Custom
276                      ; This file is for utilities that are in common to all the timing board
277                      ;   programs, located starting at P:$200 in external SRAM
278    
279    
280                      ;  ****************  PROGRAM CODE IN SRAM PROGRAM SPACE    *******************
281                      ; Put all the following code in SRAM, starting at P:$200.
282                                IF      @SCP("HOST","HOST")
283       P:0200 P:0200                   ORG     P:$200,P:$200                     ; Download address
284                                       ELSE
286                                       ENDIF
287    
288                             ; Fast clear of CCD, executed as a command
289       P:0200 P:0200 0D0202  CLEAR     JSR     <CLR_CCD
290       P:0201 P:0201 0C0000            JMP     <FINISH
291    
292                             ; Fast clear image before each exposure, executed as a subroutine.  Uses DG
293       P:0202 P:0202 060440  CLR_CCD   DO      Y:<NPCLR,LPCLR                    ; Loop over number of lines in image
                        000207
294       P:0204 P:0204 60F400            MOVE              #IS_CLEAR,R0            ; Address of parallel transfer waveform
                        000060
295       P:0206 P:0206 0D01E9            JSR     <CLOCK                            ; Go clock out the CCD charge
296       P:0207 P:0207 000000            NOP                                       ; Do loop restriction
297                             LPCLR
298       P:0208 P:0208 60F400            MOVE              #DUMP_SERIAL,R0
                        000068
299       P:020A P:020A 0D01E9            JSR     <CLOCK                            ; and wipe out the dregs in the SR
300       P:020B P:020B 44F400            MOVE              #TST_RCV,X0             ; Wait for commands during exposure
                        000000
301       P:020D P:020D 440000            MOVE              X0,X:<IDL_ADR           ;  instead of idling
302       P:020E P:020E 00000C            RTS
303    
304                             ; Keep the CCD idling when not reading out
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timmisc.s  Page 6



305       P:020F P:020F 060140  IDLE      DO      Y:<NSR,IDL1                       ; Loop over number of pixels per line
                        000217
306       P:0211 P:0211 306E00            MOVE              #<SERIAL_IDLE,R0        ; Serial transfer on pixel
307       P:0212 P:0212 0D01E9            JSR     <CLOCK                            ; Go to it
308       P:0213 P:0213 0D0000            JSR     <GET_RCV                          ; Check for FO or SSI commands
309       P:0214 P:0214 0E0217            JCC     <NO_COM                           ; Continue IDLE if no commands received
310       P:0215 P:0215 00008C            ENDDO                                     ; Cancel the DO loop
311       P:0216 P:0216 0C0000            JMP     <CHK_SSI                          ; Go process header and command
312       P:0217 P:0217 000000  NO_COM    NOP
313                             IDL1
314       P:0218 P:0218 306000            MOVE              #<IS_CLEAR,R0           ; Address of parallel clocking waveform
315       P:0219 P:0219 0D01E9            JSR     <CLOCK                            ; Go clock out the CCD charge
316       P:021A P:021A 0C020F            JMP     <IDLE
317    
318    
319                             ; Select which readouts to process
320                             ;   'SOS'  Amplifier_name
321                             ;       Amplifier_name = '__L', '__R', '_LR'
322    
323       P:021B P:021B 44DC00  SEL_OS    MOVE              X:(R4)+,X0              ; Get amplifier(s) name
324       P:021C P:021C 0D021E            JSR     <SELECT_OUTPUT_SOURCE
325       P:021D P:021D 0C0000            JMP     <FINISH1
326    
327                             ; A massive subroutine for setting all the addresses depending on the
328                             ; output source(s) selection and binning parameter.  Most of the
329                             ; waveforms are in fast Y memory (< 0xFF) but there isn't enough
330                             ; space for the fast serial binning waveforms for binning factors
331                             ; 1 through 5.  These are in high Y memory and have to be copied in.
332    
333                             SELECT_OUTPUT_SOURCE
334                             ; Set all the waveform addresses depending on which readout/binning mode
335       P:021E P:021E 56F400            MOVE              #'__L',A                ; LEFT Amplifier = readout #0
                        5F5F4C
336       P:0220 P:0220 200045            CMP     X0,A
337       P:0221 P:0221 0E226C            JNE     <CMP_R
338       P:0222 P:0222 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
339       P:0223 P:0223 56F400            MOVE              #SERIAL_SKIP_LEFT,A
                        0000E8
340       P:0225 P:0225 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
341       P:0227 P:0227 56F400            MOVE              #INITIAL_CLOCK_LEFT,A
                        000093
342       P:0229 P:0229 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
343       P:022B P:022B 56F400            MOVE              #SERIAL_CLOCK_LEFT,A
                        0000AD
344       P:022D P:022D 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
345       P:022F P:022F 56F400            MOVE              #(CLK2+$030000+000+000+000+000+H2L+H2R+000+000),A
                        032012
346       P:0231 P:0231 5E7000            MOVE                          A,Y:CCLK_1
                        0000B5
347       P:0233 P:0233 0A7005            BCLR    #SPLIT_S,X:STATUS
                        000000
348                             ; Now go through copying in the serial read waveform if binning more than 5.
349       P:0235 P:0235 200013            CLR     A
350       P:0236 P:0236 20001B            CLR     B
351       P:0237 P:0237 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
352       P:0238 P:0238 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
353       P:0239 P:0239 50F400            MOVE              #>5,A0
                        000005
354       P:023B P:023B 200005            CMP     B,A
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timmisc.s  Page 7



355       P:023C P:023C 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
356       P:023D P:023D 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
357       P:023E P:023E 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
358       P:023F P:023F 0A3781  TRY_1_L   JCLR    #1,X:<BINBIT,TRY_2_L
                        000248
359                             ;       MOVE    #1,A0                   ; HACK
360                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
361       P:0241 P:0241 60F400            MOVE              #SERIAL_READ_LEFT_1,R0  ; Here if left amp, bin by 1
                        00013E
362       P:0243 P:0243 51F400            MOVE              #(END_SERIAL_READ_LEFT_1-SERIAL_READ_LEFT_1),B0
                        00000D
363       P:0245 P:0245 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
364       P:0246 P:0246 0D030D            JSR     <WAVECPY                          ; Copy the waveform
365       P:0247 P:0247 0C0307            JMP     <CMP_END
366       P:0248 P:0248 0A3782  TRY_2_L   JCLR    #2,X:<BINBIT,TRY_3_L
                        000251
367       P:024A P:024A 60F400            MOVE              #SERIAL_READ_LEFT_2,R0  ; Here if left amp, bin by 2
                        000165
368       P:024C P:024C 51F400            MOVE              #(END_SERIAL_READ_LEFT_2-SERIAL_READ_LEFT_2),B0
                        000013
369       P:024E P:024E 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
370       P:024F P:024F 0D030D            JSR     <WAVECPY                          ; Copy the waveform
371       P:0250 P:0250 0C0307            JMP     <CMP_END
372       P:0251 P:0251 0A3783  TRY_3_L   JCLR    #3,X:<BINBIT,TRY_4_L
                        00025A
373       P:0253 P:0253 60F400            MOVE              #SERIAL_READ_LEFT_3,R0  ; Here if left amp, bin by 3
                        00019E
374       P:0255 P:0255 51F400            MOVE              #(END_SERIAL_READ_LEFT_3-SERIAL_READ_LEFT_3),B0
                        000019
375       P:0257 P:0257 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
376       P:0258 P:0258 0D030D            JSR     <WAVECPY                          ; Copy the waveform
377       P:0259 P:0259 0C0307            JMP     <CMP_END
378       P:025A P:025A 0A3784  TRY_4_L   JCLR    #4,X:<BINBIT,TRY_5_L
                        000263
379       P:025C P:025C 60F400            MOVE              #SERIAL_READ_LEFT_4,R0  ; Here if left amp, bin by 4
                        0001E9
380       P:025E P:025E 51F400            MOVE              #(END_SERIAL_READ_LEFT_4-SERIAL_READ_LEFT_4),B0
                        00001F
381       P:0260 P:0260 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
382       P:0261 P:0261 0D030D            JSR     <WAVECPY                          ; Copy the waveform
383       P:0262 P:0262 0C0307            JMP     <CMP_END
384       P:0263 P:0263 0A3785  TRY_5_L   JCLR    #5,X:<BINBIT,CMP_END
                        000307
385       P:0265 P:0265 60F400            MOVE              #SERIAL_READ_LEFT_5,R0  ; Here if left amp, bin by 5
                        000246
386       P:0267 P:0267 51F400            MOVE              #(END_SERIAL_READ_LEFT_5-SERIAL_READ_LEFT_5),B0
                        000025
387       P:0269 P:0269 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
388       P:026A P:026A 0D030D            JSR     <WAVECPY                          ; Copy the waveform
389       P:026B P:026B 0C0307            JMP     <CMP_END
390    
391       P:026C P:026C 56F400  CMP_R     MOVE              #'__R',A                ; RIGHT Amplifier = readout #1
                        5F5F52
392       P:026E P:026E 200045            CMP     X0,A
393       P:026F P:026F 0E22BA            JNE     <CMP_LR
394       P:0270 P:0270 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
395       P:0271 P:0271 56F400            MOVE              #SERIAL_SKIP_RIGHT,A
                        0000F0
396       P:0273 P:0273 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
397       P:0275 P:0275 56F400            MOVE              #INITIAL_CLOCK_RIGHT,A
                        000087
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timmisc.s  Page 8



398       P:0277 P:0277 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
399       P:0279 P:0279 56F400            MOVE              #SERIAL_CLOCK_RIGHT,A
                        0000A6
400       P:027B P:027B 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
401       P:027D P:027D 56F400            MOVE              #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),A
                        032009
402       P:027F P:027F 5E7000            MOVE                          A,Y:CCLK_1
                        0000B5
403       P:0281 P:0281 0A7005            BCLR    #SPLIT_S,X:STATUS
                        000000
404                             ; Now go through copying in the serial read waveform if binning more than 5.
405       P:0283 P:0283 200013            CLR     A
406       P:0284 P:0284 20001B            CLR     B
407       P:0285 P:0285 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
408       P:0286 P:0286 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
409       P:0287 P:0287 50F400            MOVE              #>5,A0
                        000005
410       P:0289 P:0289 200005            CMP     B,A
411       P:028A P:028A 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
412       P:028B P:028B 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
413       P:028C P:028C 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
414       P:028D P:028D 0A3781  TRY_1_R   JCLR    #1,X:<BINBIT,TRY_2_R
                        000296
415                             ;       MOVE    #2,A0                   ; HACK
416                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
417       P:028F P:028F 60F400            MOVE              #SERIAL_READ_RIGHT_1,R0 ; Here if right amp, bin by 1
                        00014B
418       P:0291 P:0291 51F400            MOVE              #(END_SERIAL_READ_RIGHT_1-SERIAL_READ_RIGHT_1),B0
                        00000D
419       P:0293 P:0293 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
420       P:0294 P:0294 0D030D            JSR     <WAVECPY                          ; Copy the waveform
421       P:0295 P:0295 0C0307            JMP     <CMP_END
422       P:0296 P:0296 0A3782  TRY_2_R   JCLR    #2,X:<BINBIT,TRY_3_R
                        00029F
423       P:0298 P:0298 60F400            MOVE              #SERIAL_READ_RIGHT_2,R0 ; Here if right amp, bin by 2
                        000178
424       P:029A P:029A 51F400            MOVE              #(END_SERIAL_READ_RIGHT_2-SERIAL_READ_RIGHT_2),B0
                        000013
425       P:029C P:029C 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
426       P:029D P:029D 0D030D            JSR     <WAVECPY                          ; Copy the waveform
427       P:029E P:029E 0C0307            JMP     <CMP_END
428       P:029F P:029F 0A3783  TRY_3_R   JCLR    #3,X:<BINBIT,TRY_4_R
                        0002A8
429       P:02A1 P:02A1 60F400            MOVE              #SERIAL_READ_RIGHT_3,R0 ; Here if right amp, bin by 3
                        0001B7
430       P:02A3 P:02A3 51F400            MOVE              #(END_SERIAL_READ_RIGHT_3-SERIAL_READ_RIGHT_3),B0
                        000019
431       P:02A5 P:02A5 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
432       P:02A6 P:02A6 0D030D            JSR     <WAVECPY                          ; Copy the waveform
433       P:02A7 P:02A7 0C0307            JMP     <CMP_END
434       P:02A8 P:02A8 0A3784  TRY_4_R   JCLR    #4,X:<BINBIT,TRY_5_R
                        0002B1
435       P:02AA P:02AA 60F400            MOVE              #SERIAL_READ_RIGHT_4,R0 ; Here if right amp, bin by 4
                        000208
436       P:02AC P:02AC 51F400            MOVE              #(END_SERIAL_READ_RIGHT_4-SERIAL_READ_RIGHT_4),B0
                        00001F
437       P:02AE P:02AE 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
438       P:02AF P:02AF 0D030D            JSR     <WAVECPY                          ; Copy the waveform
439       P:02B0 P:02B0 0C0307            JMP     <CMP_END
440       P:02B1 P:02B1 0A3785  TRY_5_R   JCLR    #5,X:<BINBIT,CMP_END
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timmisc.s  Page 9



                        000307
441       P:02B3 P:02B3 60F400            MOVE              #SERIAL_READ_RIGHT_5,R0 ; Here if right amp, bin by 5
                        00026B
442       P:02B5 P:02B5 51F400            MOVE              #(END_SERIAL_READ_RIGHT_5-SERIAL_READ_RIGHT_5),B0
                        000025
443       P:02B7 P:02B7 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
444       P:02B8 P:02B8 0D030D            JSR     <WAVECPY                          ; Copy the waveform
445       P:02B9 P:02B9 0C0307            JMP     <CMP_END
446    
447       P:02BA P:02BA 56F400  CMP_LR    MOVE              #'_LR',A                ; LEFT and RIGHT = readouts #0 and #1
                        5F4C52
448       P:02BC P:02BC 200045            CMP     X0,A
449       P:02BD P:02BD 0E230A            JNE     <CMP_ERROR
450       P:02BE P:02BE 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
451       P:02BF P:02BF 56F400            MOVE              #SERIAL_SKIP_SPLIT,A
                        0000F8
452       P:02C1 P:02C1 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
453       P:02C3 P:02C3 56F400            MOVE              #INITIAL_CLOCK_SPLIT,A
                        00007B
454       P:02C5 P:02C5 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
455       P:02C7 P:02C7 56F400            MOVE              #SERIAL_CLOCK_SPLIT,A
                        00009F
456       P:02C9 P:02C9 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
457       P:02CB P:02CB 56F400            MOVE              #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),A
                        03200A
458       P:02CD P:02CD 5E7000            MOVE                          A,Y:CCLK_1
                        0000B5
459       P:02CF P:02CF 0A7025            BSET    #SPLIT_S,X:STATUS
                        000000
460                             ; Now go through copying in the serial read waveform if binning more than 5.
461       P:02D1 P:02D1 200013            CLR     A
462       P:02D2 P:02D2 20001B            CLR     B
463       P:02D3 P:02D3 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
464       P:02D4 P:02D4 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
465       P:02D5 P:02D5 50F400            MOVE              #>5,A0
                        000005
466       P:02D7 P:02D7 200005            CMP     B,A
467       P:02D8 P:02D8 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
468       P:02D9 P:02D9 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
469       P:02DA P:02DA 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
470       P:02DB P:02DB 0A3781  TRY_1_S   JCLR    #1,X:<BINBIT,TRY_2_S
                        0002E4
471                             ;       MOVE    #3,A0                   ; HACK
472                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
473       P:02DD P:02DD 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if split amp, bin by 1
                        000158
474       P:02DF P:02DF 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                        00000D
475       P:02E1 P:02E1 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
476       P:02E2 P:02E2 0D030D            JSR     <WAVECPY                          ; Copy the waveform
477       P:02E3 P:02E3 0C0307            JMP     <CMP_END
478       P:02E4 P:02E4 0A3782  TRY_2_S   JCLR    #2,X:<BINBIT,TRY_3_S
                        0002ED
479       P:02E6 P:02E6 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if split amp, bin by 2
                        00018B
480       P:02E8 P:02E8 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                        000013
481       P:02EA P:02EA 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
482       P:02EB P:02EB 0D030D            JSR     <WAVECPY                          ; Copy the waveform
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timmisc.s  Page 10



483       P:02EC P:02EC 0C0307            JMP     <CMP_END
484       P:02ED P:02ED 0A3783  TRY_3_S   JCLR    #3,X:<BINBIT,TRY_4_S
                        0002F6
485       P:02EF P:02EF 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if split amp, bin by 3
                        0001D0
486       P:02F1 P:02F1 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                        000019
487       P:02F3 P:02F3 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
488       P:02F4 P:02F4 0D030D            JSR     <WAVECPY                          ; Copy the waveform
489       P:02F5 P:02F5 0C0307            JMP     <CMP_END
490       P:02F6 P:02F6 0A3784  TRY_4_S   JCLR    #4,X:<BINBIT,TRY_5_S
                        0002FF
491       P:02F8 P:02F8 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if split amp, bin by 4
                        000227
492       P:02FA P:02FA 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                        00001F
493       P:02FC P:02FC 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
494       P:02FD P:02FD 0D030D            JSR     <WAVECPY                          ; Copy the waveform
495       P:02FE P:02FE 0C0307            JMP     <CMP_END
496       P:02FF P:02FF 0A3785  TRY_5_S   JCLR    #5,X:<BINBIT,CMP_END
                        000307
497       P:0301 P:0301 60F400            MOVE              #SERIAL_READ_SPLIT_5,R0 ; Here if split amp, bin by 5
                        000290
498       P:0303 P:0303 51F400            MOVE              #(END_SERIAL_READ_SPLIT_5-SERIAL_READ_SPLIT_5),B0
                        000025
499       P:0305 P:0305 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
500       P:0306 P:0306 0D030D            JSR     <WAVECPY                          ; Copy the waveform
501    
502       P:0307 P:0307 44F400  CMP_END   MOVE              #'DON',X0
                        444F4E
503       P:0309 P:0309 00000C            RTS
504                             CMP_ERROR
505       P:030A P:030A 44F400            MOVE              #'ERR',X0
                        455252
506       P:030C P:030C 00000C            RTS
507    
508                             ; Short function to copy in waveforms from high Y to fast Y memory.
509                             ; R0 is the source address, R7 the destination, and X0 is intermediary reg.
510                             WAVECPY
511       P:030D P:030D 06C900            DO      B0,WAVELP                         ; Copy the waveform; B0 is SERWAVLEN already
                        000311
512       P:030F P:030F 4CD800            MOVE                          Y:(R0)+,X0
513       P:0310 P:0310 4C5F00            MOVE                          X0,Y:(R7)+
514       P:0311 P:0311 000000            NOP
515                             WAVELP
516       P:0312 P:0312 000000            NOP
517       P:0313 P:0313 00000C            RTS
518    
519                             ; Short function to set the correct bit in BINBIT based on NSBIN
520                             ; Called only if NSBIN is less than 6.
521    
522                             SET_BINBIT
523                             ;       MOVE    Y:<TESTLOC1,A0                  ; HACK - test if this code is executed
524                             ;       INC     A                               ; HACK
525                             ;       MOVE    A0,Y:<TESTLOC1                  ; HACK
526       P:0314 P:0314 50F400            MOVE              #>1,A0                  ; Put a bit in A and shift to right spot
                        000001
527       P:0316 P:0316 060540            DO      Y:<NSBIN,BINLOOP                  ; Bit zero position not used, 1-5 used
                        000318
528       P:0318 P:0318 200032            ASL     A
529                             BINLOOP
530       P:0319 P:0319 503700            MOVE              A0,X:<BINBIT            ; set bit 1-5 for SELECT_OUTPUT_SOURCE jump tabl
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timmisc.s  Page 11



e
531       P:031A P:031A 00000C            RTS
532    
533    
534                             ; Set the number of rows and columns and binning factors
535                             SET_ROWS_COLUMNS
536       P:031B P:031B 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NSR = NAXIS1
537       P:031C P:031C 4C7000            MOVE                          X0,Y:NSR
                        000001
538       P:031E P:031E 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NPR = NAXIS2
539       P:031F P:031F 4C7000            MOVE                          X0,Y:NPR
                        000002
540       P:0321 P:0321 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NSBIN
541       P:0322 P:0322 4C7000            MOVE                          X0,Y:NSBIN
                        000005
542       P:0324 P:0324 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NPBIN
543       P:0325 P:0325 4C7000            MOVE                          X0,Y:NPBIN
                        000006
544       P:0327 P:0327 4CBD00            MOVE                          Y:<AMPVAL,X0 ; Get ampval in X0 for SOS call
545       P:0328 P:0328 0D021E            JSR     <SELECT_OUTPUT_SOURCE             ; Update serial read waveform in case binning ch
anged
546       P:0329 P:0329 0C0000            JMP     <FINISH
547    
548                             ; Set the variables for the time-resolved modes
549                             SET_IMAGE_PARAM
550       P:032A P:032A 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Image mode
551       P:032B P:032B 447000            MOVE              X0,X:IMAGE_MODE
                        000030
552       P:032D P:032D 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Iframes = NAXIS3
553       P:032E P:032E 4C7000            MOVE                          X0,Y:IFRAMES
                        00003A
554       P:0330 P:0330 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Srows
555       P:0331 P:0331 4C7000            MOVE                          X0,Y:SROWS
                        000038
556       P:0333 P:0333 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Interval
557                             ;       MOVE    X0,Y:INTERVAL           ; HACK - Using Interval as a test location
558       P:0334 P:0334 0C0000            JMP     <FINISH
559    
560    
561                             ; Set the hardware trigger bit, executed as a command
562                             SET_TRIGGER
563       P:0335 P:0335 44DC00            MOVE              X:(R4)+,X0              ; Get the trigger value
564       P:0336 P:0336 56F400            MOVE              #'_ON',A
                        5F4F4E
565       P:0338 P:0338 200045            CMP     X0,A
566       P:0339 P:0339 0AF0A2            JNE     NO_TRIGGER
                        000340
567       P:033B P:033B 0AA4AB            JSET    #11,X:PBD,TRIG_CLR                ; Is Trigger running?
                        00033E
568       P:033D P:033D 0C0000            JMP     <ERROR                            ; Yes! report Error!  Why do this?
569                             TRIG_CLR
570       P:033E P:033E 0A0028            BSET    #TRIGGER,X:<STATUS                ; Set status bit, hardware trigger
571       P:033F P:033F 0C0000            JMP     <FINISH
572                             NO_TRIGGER
573       P:0340 P:0340 0A0008            BCLR    #TRIGGER,X:<STATUS                ; Clear Status bit, software timing
574       P:0341 P:0341 0C0000            JMP     <FINISH
575    
576                             ; Calculate the fast read parameters for each readout box
577                             SETUP_SUBROUTINE
578       P:0342 P:0342 4C8C00            MOVE                          Y:<SERWAVLEN,X0 ; # of waveforms
579       P:0343 P:0343 4D9000            MOVE                          Y:<NSERIALS_READ,X1 ; Number of pixels to read
580       P:0344 P:0344 0D0468            JSR     <FASTSKP                          ; Compute number of clocks required
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timmisc.s  Page 12



581       P:0345 P:0345 4D1300            MOVE                          X1,Y:<NREAD ; Number of waveforms per line
582       P:0346 P:0346 5E9A00            MOVE                          Y:<NR_BIAS,A ; Number of pixels to read
583       P:0347 P:0347 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                        00034A
584       P:0349 P:0349 200022            ASR     A
585       P:034A P:034A 21C500            MOVE              A,X1                    ; Number of waveforms per line
586       P:034B P:034B 0D0468            JSR     <FASTSKP                          ; Compute number of clocks required
587       P:034C P:034C 4D1500            MOVE                          X1,Y:<NBIAS ; Number of waveforms per line
588       P:034D P:034D 44F400            MOVE              #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT),X0 ; # of waveforms
                        000006
589       P:034F P:034F 4D8300            MOVE                          Y:<NS_CLR,X1 ; Number of pixels to skip
590       P:0350 P:0350 0D0468            JSR     <FASTSKP                          ; Compute number of clocks required
591       P:0351 P:0351 4D1100            MOVE                          X1,Y:<NSCLR ; Number of waveforms per line
592       P:0352 P:0352 4D9700            MOVE                          Y:<NS_SKP1,X1 ; Number of pixels to skip
593       P:0353 P:0353 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
594       P:0354 P:0354 2000F0            MPY     Y1,X1,A
595       P:0355 P:0355 200022            ASR     A
596       P:0356 P:0356 210500            MOVE              A0,X1
597       P:0357 P:0357 0D0468            JSR     <FASTSKP                          ; Compute number of clocks required
598       P:0358 P:0358 4D1200            MOVE                          X1,Y:<NSKIP1 ; Number of waveforms per line
599       P:0359 P:0359 4D9800            MOVE                          Y:<NS_SKP2,X1 ; Number of pixels to skip
600       P:035A P:035A 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
601       P:035B P:035B 2000F0            MPY     Y1,X1,A
602       P:035C P:035C 200022            ASR     A
603       P:035D P:035D 210500            MOVE              A0,X1
604       P:035E P:035E 0D0468            JSR     <FASTSKP                          ; Compute number of clocks required
605       P:035F P:035F 4D1400            MOVE                          X1,Y:<NSKIP2 ; Number of waveforms per line
606       P:0360 P:0360 4D9600            MOVE                          Y:<NP_SKIP,X1
607       P:0361 P:0361 4F8600            MOVE                          Y:<NPBIN,Y1
608       P:0362 P:0362 2000F0            MPY     X1,Y1,A
609       P:0363 P:0363 200022            ASR     A
610       P:0364 P:0364 581600            MOVE                          A0,Y:<NP_SKIP
611       P:0365 P:0365 00000C            RTS
612    
613                             ; Returns immediately if hardware triggering is not being used
614                             ; Blocks until the trigger is found to be high twice in a row.
615                             ; Waits until the trigger goes high
616                             WAIT_UNTIL_TRIGGER
617       P:0366 P:0366 0A0088            JCLR    #TRIGGER,X:STATUS,UNTIL_TRIGGER_RETURN
                        00036F
618       P:0368 P:0368 000000            NOP
619       P:0369 P:0369 0AA48B            JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER      ; Is Trigger Low?
                        000366
620       P:036B P:036B 000000            NOP                                       ; Pause
621       P:036C P:036C 0AA48B            JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER      ; Is Trigger still Low?
                        000366
622       P:036E P:036E 000000            NOP
623                             UNTIL_TRIGGER_RETURN
624       P:036F P:036F 00000C            RTS
625    
626                             ; Returns immediately if hardware triggering is not being used
627                             ; Blocks until the trigger is found to be low twice in a row.
628                             ; Waits while the trigger is high
629                             WAIT_WHILE_TRIGGER
630       P:0370 P:0370 0A0088            JCLR    #TRIGGER,X:STATUS,WHILE_TRIGGER_RETURN
                        000379
631       P:0372 P:0372 000000            NOP
632       P:0373 P:0373 0AA4AB            JSET    #11,X:PBD,WAIT_WHILE_TRIGGER      ; Is Trigger High?
                        000370
633       P:0375 P:0375 000000            NOP                                       ; Pause
634       P:0376 P:0376 0AA4AB            JSET    #11,X:PBD,WAIT_WHILE_TRIGGER      ; Is Trigger still High?
                        000370
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timmisc.s  Page 13



635       P:0378 P:0378 000000            NOP
636                             WHILE_TRIGGER_RETURN
637       P:0379 P:0379 00000C            RTS
638    
639                             ; Like WAIT_WHILE_TRIGGER but clears the CCD while waiting
640                             ; Pro:  Clears CCD while waiting.  Con: timing rattiness of 1 parallel time
641                             ; Returns immediately if hardware triggering is not being used
642                             ; Blocks until the trigger is found to be low twice in a row.
643                             ; Waits while the trigger is high
644                             CLEAR_WHILE_TRIGGER
645       P:037A P:037A 0A0088            JCLR    #TRIGGER,X:STATUS,CLEAR_TRIG_RETURN
                        000385
646       P:037C P:037C 60F400            MOVE              #IS_CLEAR,R0            ; Address of parallel transfer waveform
                        000060
647       P:037E P:037E 0D01E9            JSR     <CLOCK                            ; Go clock out the CCD charge
648       P:037F P:037F 0AA4AB            JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER     ; Is Trigger High?
                        00037A
649       P:0381 P:0381 000000            NOP                                       ; Pause
650       P:0382 P:0382 0AA4AB            JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER     ; Is Trigger still High?
                        00037A
651       P:0384 P:0384 000000            NOP
652                             CLEAR_TRIG_RETURN
653       P:0385 P:0385 00000C            RTS
654    
655                             ; Subroutine to compute SROWS in unbinned pixels and store in UBSROWS
656    
657                             UB_CONV
658       P:0386 P:0386 4CB800            MOVE                          Y:<SROWS,X0
659       P:0387 P:0387 4D8600            MOVE                          Y:<NPBIN,X1 ; Adjust for for parallel binning factor
660       P:0388 P:0388 2000A0            MPY     X0,X1,A
661       P:0389 P:0389 200022            ASR     A
662       P:038A P:038A 583900            MOVE                          A0,Y:<UBSROWS ; Put unbinned number in UBSROWS
663       P:038B P:038B 00000C            RTS
664    
665                             ; Key code segments for the HIPO modes.
666                             ; Jump table to the various modes - see also timhdr.s
667                             START_FT_EXPOSURE
668       P:038C P:038C 0A30A1            JSET    #FIND,X:IMAGE_MODE,SINGLE_PROC
                        0003BD
669       P:038E P:038E 0A30A4            JSET    #SINGLE,X:IMAGE_MODE,SINGLE_PROC
                        0003BD
670                             ;       JSET    #SERIES,X:IMAGE_MODE,SERIES_PROC        ; defunct.  Use basic occ.
671       P:0390 P:0390 0A30A0            JSET    #FDOTS,X:IMAGE_MODE,FDOT_PROC
                        00039F
672       P:0392 P:0392 0A30A2            JSET    #SDOTS,X:IMAGE_MODE,SDOT_PROC     ; slow dots & strips use sdot_proc
                        0003DE
673       P:0394 P:0394 0A30A5            JSET    #STRIP,X:IMAGE_MODE,SDOT_PROC
                        0003DE
674       P:0396 P:0396 0A30A7            JSET    #B_OCC,X:IMAGE_MODE,SINGLE_PROC   ; basic occ uses single_proc
                        0003BD
675       P:0398 P:0398 0A30A6            JSET    #F_OCC,X:IMAGE_MODE,FPO_PROC      ; fast & pipelined occ use occ_proc
                        0003FF
676       P:039A P:039A 0A30A8            JSET    #P_OCC,X:IMAGE_MODE,FPO_PROC
                        0003FF
677       P:039C P:039C 44F400            MOVE              #'ERR',X0               ; error if not a valid mode
                        455252
678       P:039E P:039E 0C0000            JMP     <ERROR
679    
680                             FDOT_PROC                                           ; used by fdots only
681                             ; Start by replacing SROWS (binned rows) with unbinned rows.  Will get rewritten on next SEX command
682                             ; Leave the DO loop in here - no reason to change it - won't exceed 65535 dots, for sure!
683       P:039F P:039F 0D0386            JSR     UB_CONV                           ; Fill in unbinned SROWS
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timmisc.s  Page 14



684       P:03A0 P:03A0 5E8200            MOVE                          Y:<NPR,A
685       P:03A1 P:03A1 5E1C00            MOVE                          A,Y:<NP_READ ; Make sure that NP_READ=NPR in case of subfram
e
686       P:03A2 P:03A2 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
687       P:03A3 P:03A3 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for FDOTS
688       P:03A4 P:03A4 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
689       P:03A5 P:03A5 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        00042F
690       P:03A7 P:03A7 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
691       P:03A8 P:03A8 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
692                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
693       P:03A9 P:03A9 0D046F            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
694       P:03AA P:03AA 063A40            DO      Y:<IFRAMES,FDOT_LOOP              ; Loop over the number of FDOTS
                        0003B5
695       P:03AC P:03AC 0A00A8            JSET    #TRIGGER,X:STATUS,FDX_END         ; If no triggering jump to expose image function
                        0003B1
696       P:03AE P:03AE 67F400            MOVE              #FDX_END,R7             ; Store the Address into R7
                        0003B1
697       P:03B0 P:03B0 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
698       P:03B1 P:03B1 0D0366  FDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
699       P:03B2 P:03B2 4DB900            MOVE                          Y:<UBSROWS,X1 ; Number of unbinned rows per shift
700       P:03B3 P:03B3 0D0444            JSR     <ISHIFT                           ; Clock out the waveforms
701       P:03B4 P:03B4 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
702       P:03B5 P:03B5 000000            NOP
703                             FDOT_LOOP
704       P:03B6 P:03B6 0D0476            JSR     <C_CSHUT                          ; Conditionally close shutter
705       P:03B7 P:03B7 063A40            DO      Y:<IFRAMES,FDOT_LP1               ; Loop over the number of FDOTS during readout
                        0003BA
706       P:03B9 P:03B9 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD
707       P:03BA P:03BA 000000            NOP
708                             FDOT_LP1
709                             ;       JSR     <WAIT_UNTIL_TRIGGER             ; If taking more than one set of dots sync. trigger.
  Vestigial?
710       P:03BB P:03BB 0AF080            JMP     CLEANUP                           ; clean up after command.
                        00043C
711    
712                             SINGLE_PROC                                         ; Used by find, single, and basic occ
713       P:03BD P:03BD 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for find & basic occ
714       P:03BE P:03BE 0A3084            JCLR    #SINGLE,X:IMAGE_MODE,*+3          ; But if single mode,
                        0003C1
715       P:03C0 P:03C0 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
716       P:03C1 P:03C1 0A3102            BCLR    #STORAGE,X:<ISTATUS               ; Do the FT, no storage clocks only during reado
ut
717       P:03C2 P:03C2 0A3100            BCLR    #NO_SKIP,X:<ISTATUS               ; Do parallel skip up to the subframe boundary
718       P:03C3 P:03C3 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        00042F
719       P:03C5 P:03C5 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
720       P:03C6 P:03C6 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
721                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
722       P:03C7 P:03C7 58BA00            MOVE                          Y:<IFRAMES,A0
723       P:03C8 P:03C8 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
724       P:03C9 P:03C9 0D046F  SN_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
725       P:03CA P:03CA 0A00A8            JSET    #TRIGGER,X:STATUS,SNX_END         ; If no triggering jump to expose image function
                        0003CF
726       P:03CC P:03CC 67F400            MOVE              #SNX_END,R7             ; Store the Address into R7
                        0003CF
727       P:03CE P:03CE 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
728       P:03CF P:03CF 0D0366  SNX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
729       P:03D0 P:03D0 0D0476            JSR     <C_CSHUT                          ; Close shutter if open-close bit is set
730       P:03D1 P:03D1 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD
731       P:03D2 P:03D2 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timmisc.s  Page 15



732       P:03D3 P:03D3 200013            CLR     A
733       P:03D4 P:03D4 58BE00            MOVE                          Y:<IFLPCNT,A0
734       P:03D5 P:03D5 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
735       P:03D6 P:03D6 583E00            MOVE                          A0,Y:<IFLPCNT
736       P:03D7 P:03D7 200003            TST     A
737       P:03D8 P:03D8 0E23C9            JNE     SN_LP                             ; End of IFRAMES loop
738       P:03D9 P:03D9 0A30A1            JSET    #FIND,X:IMAGE_MODE,*+3
                        0003DC
739       P:03DB P:03DB 0D0478            JSR     <CSHUT                            ; Close the shutter unless in find mode
740       P:03DC P:03DC 0AF080            JMP     CLEANUP                           ; clean up after command.
                        00043C
741    
742                             SDOT_PROC                                           ; Used by slow dots and strips
743       P:03DE P:03DE 5EB800            MOVE                          Y:<SROWS,A
744       P:03DF P:03DF 5E1C00            MOVE                          A,Y:<NP_READ ; Make sure that NP_READ=SROWS
745       P:03E0 P:03E0 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for strips
746       P:03E1 P:03E1 0A3082            JCLR    #SDOTS,X:IMAGE_MODE,*+3           ; But if sdots mode,
                        0003E4
747       P:03E3 P:03E3 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
748       P:03E4 P:03E4 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for SDOTS and st
rips
749       P:03E5 P:03E5 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
750       P:03E6 P:03E6 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        00042F
751       P:03E8 P:03E8 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
752       P:03E9 P:03E9 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
753                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
754       P:03EA P:03EA 58BA00            MOVE                          Y:<IFRAMES,A0
755       P:03EB P:03EB 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
756       P:03EC P:03EC 0D046F  SD_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
757       P:03ED P:03ED 0A00A8            JSET    #TRIGGER,X:STATUS,SDX_END         ; If no triggering jump to expose image function
                        0003F2
758       P:03EF P:03EF 67F400            MOVE              #SDX_END,R7             ; Store the Address into R7
                        0003F2
759       P:03F1 P:03F1 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
760       P:03F2 P:03F2 0D0366  SDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
761       P:03F3 P:03F3 0D0476            JSR     <C_CSHUT                          ; Close shutter if open-close is set
762       P:03F4 P:03F4 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD.
763                                                                                 ; No FT or parallel skip since STORAGE=1
764       P:03F5 P:03F5 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
765       P:03F6 P:03F6 200013            CLR     A
766       P:03F7 P:03F7 58BE00            MOVE                          Y:<IFLPCNT,A0
767       P:03F8 P:03F8 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
768       P:03F9 P:03F9 583E00            MOVE                          A0,Y:<IFLPCNT
769       P:03FA P:03FA 200003            TST     A
770       P:03FB P:03FB 0E23EC            JNE     SD_LP                             ; End of IFRAMES loop
771       P:03FC P:03FC 0D0478            JSR     <CSHUT                            ; Unconditionally close shutter
772       P:03FD P:03FD 0AF080            JMP     CLEANUP                           ; clean up after command.
                        00043C
773    
774                             FPO_PROC                                            ; Used by fast and pipelined occultation modes
775       P:03FF P:03FF 5E9C00            MOVE                          Y:<NP_READ,A
776       P:0400 P:0400 5E3800            MOVE                          A,Y:<SROWS  ; Make sure that SROWS=NP_READ
777       P:0401 P:0401 0D0386            JSR     UB_CONV                           ; Fill in unbinned SROWS in UBSROWS
778       P:0402 P:0402 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for both of these modes
779       P:0403 P:0403 0A3102            BCLR    #STORAGE,X:<ISTATUS               ; Storage clocks only during readout
780       P:0404 P:0404 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
781       P:0405 P:0405 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        00042F
782       P:0407 P:0407 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timmisc.s  Page 16



783       P:0408 P:0408 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
784                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
785       P:0409 P:0409 0D046F            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
786       P:040A P:040A 58BA00            MOVE                          Y:<IFRAMES,A0
787       P:040B P:040B 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
788       P:040C P:040C 0A00A8  FP_LP     JSET    #TRIGGER,X:STATUS,FPO_END         ; If no triggering jump to expose image function
                        000411
789       P:040E P:040E 67F400            MOVE              #FPO_END,R7             ; Store the Address into R7
                        000411
790       P:0410 P:0410 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
791       P:0411 P:0411 0D0366  FPO_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
792       P:0412 P:0412 4DB900            MOVE                          Y:<UBSROWS,X1 ; Shift down UBSROWS unbinned rows
793       P:0413 P:0413 0BF080            JSR     ISHIFT                            ; Clock down subframe height
                        000444
794       P:0415 P:0415 0A30A8            JSET    #P_OCC,X:IMAGE_MODE,FPO_RD        ; Shift the rest of the way for F_OCC
                        00041F
795                                                                                 ; Go straight to readout if P_OCC
796       P:0417 P:0417 4CF000            MOVE                          Y:S_SIZE,X0
                        00003B
797       P:0419 P:0419 208E00            MOVE              X0,A                    ; Get only least significant 24 bits
798       P:041A P:041A 4CB900            MOVE                          Y:<UBSROWS,X0
799       P:041B P:041B 200044            SUB     X0,A                              ;
800       P:041C P:041C 21C500            MOVE              A,X1                    ; X1 = S_SIZE - UBSROWS
801       P:041D P:041D 0BF080            JSR     SSHIFT                            ; Clock storage the rest of the way
                        00044D
802       P:041F P:041F 0D0134  FPO_RD    JSR     <RCCD1                            ; Finally, read out the CCD.  Skip the FT
803       P:0420 P:0420 0A30A6            JSET    #F_OCC,X:IMAGE_MODE,FPO_SK        ; Shift back up by UBSROWS if P_OCC
                        000425
804       P:0422 P:0422 4DB900            MOVE                          Y:<UBSROWS,X1 ; Shift UBSROWS unbinned rows back up
805       P:0423 P:0423 0BF080            JSR     RSHIFT                            ; Clock subframe height back up
                        000456
806       P:0425 P:0425 0D0370  FPO_SK    JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
807       P:0426 P:0426 200013            CLR     A
808       P:0427 P:0427 58BE00            MOVE                          Y:<IFLPCNT,A0
809       P:0428 P:0428 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
810       P:0429 P:0429 583E00            MOVE                          A0,Y:<IFLPCNT
811       P:042A P:042A 200003            TST     A
812       P:042B P:042B 0E240C            JNE     FP_LP                             ; End of IFRAMES loop
813       P:042C P:042C 0D0478            JSR     <CSHUT                            ; Unconditionally close shutter
814       P:042D P:042D 0AF080            JMP     CLEANUP                           ; clean up after command.
                        00043C
815    
816                             ; Support subroutines and code fragments used in the various mode code
817                             ; IMG_INI, CLEANUP, ISHIFT, SSHIFT, RSHIFT
818                             ;  Image initialization subroutine.  Sets up status bits & PCI card
819    
820       P:042F P:042F 09F480  IMG_INI   MOVEP             #$020102,Y:WRFO         ; Transmit header word
                        020102
821       P:0431 P:0431 060FA0            REP     #15                               ; Delay for transmission
822       P:0432 P:0432 000000            NOP
823       P:0433 P:0433 09F480            MOVEP             #'IIA',Y:WRFO           ; Initialize Image Address
                        494941
824       P:0435 P:0435 060FA0            REP     #15
825       P:0436 P:0436 000000            NOP
826       P:0437 P:0437 0A0024            BSET    #ST_RDC,X:<STATUS                 ; Set status to reading out
827       P:0438 P:0438 0D05E5            JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
828       P:0439 P:0439 0AA421            BSET    #WW,X:PBD                         ; Set WW = 1 for 16-bit image data
829       P:043A P:043A 000000            NOP
830       P:043B P:043B 00000C            RTS
831    
832                             ; Cleanup code fragment (not a subroutine) for the end all modes.  JMP to it.
833    
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timmisc.s  Page 17



834       P:043C P:043C 0AA401  CLEANUP   BCLR    #WW,X:PBD                         ; Clear WW to 0 for 32-bit commands
835       P:043D P:043D 0A0004            BCLR    #ST_RDC,X:<STATUS                 ; Clear status to NOT reading out
836                             ; Restore the controller to non-image data transfer and idling if necessary
837       P:043E P:043E 0A0082            JCLR    #IDLMODE,X:<STATUS,START          ; Don't idle after readout
                        000008
838       P:0440 P:0440 44F400            MOVE              #IDLE,X0
                        00020F
839       P:0442 P:0442 440000            MOVE              X0,X:<IDL_ADR
840       P:0443 P:0443 0C0008            JMP     <START                            ; Wait for a new command
841    
842                             ; Shift image and storage areas down by the number of rows in X1
843                             ISHIFT
844       P:0444 P:0444 06C500            DO      X1,ISH_LOOP                       ; Number of rows to shift is in X1
                        000448
845       P:0446 P:0446 306000            MOVE              #<IS_CLEAR,R0           ; Ganged clocks with DG running
846       P:0447 P:0447 0D01E9            JSR     <CLOCK                            ; Parallel clocking
847       P:0448 P:0448 000000            NOP
848                             ISH_LOOP
849       P:0449 P:0449 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                        000068
850       P:044B P:044B 0D01E9            JSR     <CLOCK
851       P:044C P:044C 00000C            RTS                                       ; End of ISHIFT
852    
853                             ; Shift storage area only down by the number of rows in X1
854                             SSHIFT
855       P:044D P:044D 06C500            DO      X1,SSH_LOOP                       ; Number of rows to shift is in X1
                        000451
856       P:044F P:044F 305000            MOVE              #<S_CLEAR,R0            ; Storage clocks only with DG running
857       P:0450 P:0450 0D01E9            JSR     <CLOCK                            ; Parallel clocking
858       P:0451 P:0451 000000            NOP
859                             SSH_LOOP
860       P:0452 P:0452 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                        000068
861       P:0454 P:0454 0D01E9            JSR     <CLOCK
862       P:0455 P:0455 00000C            RTS                                       ; End of SSHIFT
863    
864                             ; Used by pipelined occultation mode to move the storage area back up to
865                             ; the seam following read of a subframe
866                             RSHIFT
867       P:0456 P:0456 06C500            DO      X1,RVS_SHIFT                      ; Number of rows to read out
                        00045A
868       P:0458 P:0458 304800            MOVE              #<R_S_PARALLEL,R0       ; Reverse parallel waveform
869       P:0459 P:0459 0D01E9            JSR     <CLOCK                            ; Parallel clocking
870       P:045A P:045A 000000            NOP
871                             RVS_SHIFT
872       P:045B P:045B 00000C            RTS                                       ; End of RSHIFT
873                                       INCLUDE "timCCDmisc.s"                    ; Generic
874                             ; This file is for utilities that are in common to all the timing board
875                             ;   programs, located starting at P:$200 in external SRAM
876    
877                                     COMMENT *
878    
879                             The following commands are supported in this "timmisc.s" file
880                             PAL_DLY                 Subroutine to delay by about 8 microseconds
881                             SET_DAC                 Transfer DAC values in (R0) table to the DACs
882                             FASTSKP                 Compute number of waveform table entries in a readout
883                                                             for fast clocking
884                             SYNTHETIC_IMAGE         Generate a synthetic image for system testing
885                             OSHUT                   Subroutine call for opening the shutter
886                             CSHUT                   Subroutine call for closing the shutter
887                             OPEN_SHUTTER            Command for opening the shutter
888                             CLOSE_SHUTTER           Command for closing the shutter
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timCCDmisc.s  Page 18



889                             SET_EXP_TIME            Write desired exposure time to timing board variable
890                             RD_EXP_TIME             Read elapsed exposure time
891                             START_EXPOSURE          Start an exposure - 'DON' reply, clear FPA, open
892                                                     shutter, expose, close shutter, delay Y:SH_DLY, readout
893                             PAUSE_EXPOSURE          Close shutter, stop exposure timer
894                             RESUME_EXPOSURE         Open shutter if necessary, resume exposure timer
895                             ABORT_EXPOSURE          Close shutter, stop exposure timer
896                             INF                     Return version and timing information
897                             IDL                     Put FPA to clocking when not processing commands or
898                                                     reading out
899                             STP                     Put FPA to not clocking when not processing commands or
900                                                     reading out
901                             READ_CONTROLLER_CONFIGURATION
902    
903                             PWR_OFF                 Turn off ananlog power supply voltages to backplane
904                             PWR_ON                  Turn on analog power supply voltages to backplane
905                             SETBIAS                 Command to call SET_BIASES and reply 'DON'
906                             SET_BIASES              Subroutine to turn on all bias and clock voltages
907                                                     by reading them from the waveform tables and writing
908                                                     them to the DACs
909                             SER_ANA                 Direct the timing board DSP's synchronous serial
910                                                     transmitter to the analog boards (clock driver, video)
911                             SER_UTL                 Direct the timing board DSP's synchronous serial
912                                                     transmitter to the utility board
913                             CLR_SWS                 Clear the analog switches in the clock driver and
914                                                     video boards to lower their power consumption, as a
915                                                     command with a 'DON' reply
916                             CLEAR_SWITCHES          A subroutine call for CLR_WSW
917                             ST_GAIN                 Set the video processor gain to one of four values
918                             WR_CNTRL
919                             SET_DC
920                             SET_BIAS_NUMBER
921                             SET_MUX
922    
923                                     *
924    
925                             ;  ** Place this file after the custom timmisc.s file so it continues
926                             ;       to be written in the P:$200 address space  ****
927    
928                             ; Hardware control bit definitions
929       000004                SHUTTER   EQU     4                                 ; Shutter control bit = TIM-LATCH0, A30
930    
931    
932                             ; Delay for serial writes to the PALs and DACs by 8 microsec
933       P:045C P:045C 06FA80  PAL_DLY   DO      #250,DLY                          ; Wait 8 usec for serial data transmission
                        00045E
934       P:045E P:045E 000000            NOP
935       P:045F P:045F 000000  DLY       NOP
936       P:0460 P:0460 00000C            RTS
937    
938                             ;  Update the DACs
939       P:0461 P:0461 4CD800  SET_DAC   MOVE                          Y:(R0)+,X0  ; Get the number of table entries
940       P:0462 P:0462 06C400            DO      X0,SET_L0                         ; Repeat X0 times
                        000466
941       P:0464 P:0464 08D8EF            MOVEP             Y:(R0)+,X:SSITX         ; Send out the waveform
942       P:0465 P:0465 0D045C            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
943       P:0466 P:0466 000000            NOP                                       ; Do loop restriction
944                             SET_L0
945       P:0467 P:0467 00000C            RTS                                       ; Return from subroutine
946    
947                             ; Subroutine for computing number of fast clocks needed
948       P:0468 P:0468 2000A8  FASTSKP   MPY     X0,X1,B                           ; X1 = number of pixels to skip,
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timCCDmisc.s  Page 19



949                                                                                 ; X0 = number of waveform table entries
950       P:0469 P:0469 20002A            ASR     B                                 ; Correct for multiplication left shift
951       P:046A P:046A 212E00            MOVE              B0,A                    ; Get only least significant 24 bits
952       P:046B P:046B 458000            MOVE              X:<ONE,X1
953       P:046C P:046C 200064            SUB     X1,A                              ; Subtract 1
954       P:046D P:046D 21C500            MOVE              A,X1                    ; X1 = X0 * X1 - 1
955       P:046E P:046E 00000C            RTS
956    
957                             ; Subroutine with two entry points.  C_OSHUT is conditional on SHUT
958                             ; Open the shutter conditionally based on the shutter status bit
959                             ; Open the shutter by setting the backplane bit TIM-LATCH0
960       P:046F P:046F 0A008B  C_OSHUT   JCLR    #SHUT,X:STATUS,OSH_RTN
                        000475
961       P:0471 P:0471 0A0023  OSHUT     BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
962       P:0472 P:0472 0A0004            BCLR    #SHUTTER,X:<LATCH                 ; Clear hardware shutter bit to open
963       P:0473 P:0473 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                        000000
964       P:0475 P:0475 00000C  OSH_RTN   RTS
965    
966                             ; Subroutine with two entry points.  C_CSHUT is conditional on OPEN_CLOSE
967                             ; Close the shutter conditionally based on the open-close ISTATUS bit
968                             ; Close the shutter by clearing the backplane bit TIM-LATCH0
969       P:0476 P:0476 0A3181  C_CSHUT   JCLR    #OPEN_CLOSE,X:ISTATUS,CSH_RTN     ; Don't close if always open
                        000488
970       P:0478 P:0478 0A0003  CSHUT     BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
971       P:0479 P:0479 0A0024            BSET    #SHUTTER,X:<LATCH                 ; Set hardware shutter bit to close
972       P:047A P:047A 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                        000000
973       P:047C P:047C 5E8900            MOVE                          Y:<SH_DEL,A
974       P:047D P:047D 200003            TST     A
975       P:047E P:047E 0EF487            JLE     <S_DEL0
976       P:047F P:047F 44F400            MOVE              #25000,X0
                        0061A8
977       P:0481 P:0481 06CE00            DO      A,S_DEL0                          ; Delay by Y:SH_DEL milliseconds
                        000486
978       P:0483 P:0483 06C400            DO      X0,S_DEL1
                        000485
979       P:0485 P:0485 000000            NOP
980       P:0486 P:0486 000000  S_DEL1    NOP
981       P:0487 P:0487 000000  S_DEL0    NOP
982       P:0488 P:0488 00000C  CSH_RTN   RTS
983    
984                             ; Open the shutter from the timing board, executed as a command
985                             OPEN_SHUTTER
986       P:0489 P:0489 0D0471            JSR     <OSHUT
987       P:048A P:048A 0C0000            JMP     <FINISH
988    
989                             ; Close the shutter from the timing board, executed as a command
990                             CLOSE_SHUTTER
991       P:048B P:048B 0D0478            JSR     <CSHUT
992       P:048C P:048C 0C0000            JMP     <FINISH
993    
994                             ; Set the desired exposure time
995                             SET_EXP_TIME
996       P:048D P:048D 44DC00            MOVE              X:(R4)+,X0
997       P:048E P:048E 440000            MOVE              X0,X:<EXP_TIM           ; Write to magic address
998       P:048F P:048F 440000            MOVE              X0,X:<TGT_TIM
999       P:0490 P:0490 0C0000            JMP     <FINISH
1000   
1001   
1002                            ; Abort exposure - close the shutter, stop the timer and resume idle mode
1003                            ABORT_EXPOSURE
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timCCDmisc.s  Page 20



1004      P:0491 P:0491 0A9E00            BCLR    #TIM_BIT,X:TCSR                   ; Disable the DSP exposure timer
1005      P:0492 P:0492 0D0478            JSR     <CSHUT                            ; Close the shutter
1006      P:0493 P:0493 0A0082            JCLR    #IDLMODE,X:<STATUS,FINISH         ; Check whether to idle after readout
                        000000
1007      P:0495 P:0495 44F400            MOVE              #IDLE,X0                ; Idle after readout
                        00020F
1008      P:0497 P:0497 440000            MOVE              X0,X:<IDL_ADR
1009      P:0498 P:0498 0C0000            JMP     <FINISH
1010   
1011                            ;       Process INF according to the single addressing parameter
1012                            GET_INFO
1013      P:0499 P:0499 56DC00            MOVE              X:(R4)+,A               ; 0-4 is generic, >= 0x100 tim specific
1014      P:049A P:049A 44F400            MOVE              #IVERSION,X0
                        04407F
1015      P:049C P:049C 46F400            MOVE              #>GET_VERSION,Y0
                        000000
1016      P:049E P:049E 200055            CMP     Y0,A
1017      P:049F P:049F 0EA000            JEQ     <FINISH1
1018      P:04A0 P:04A0 44F400            MOVE              #IFLAVOR,X0
                        612020
1019      P:04A2 P:04A2 46F400            MOVE              #>GET_FLAVOR,Y0
                        000001
1020      P:04A4 P:04A4 200055            CMP     Y0,A
1021      P:04A5 P:04A5 0EA000            JEQ     <FINISH1
1022      P:04A6 P:04A6 44F400            MOVE              #ITIME0,X0
                        00D401
1023      P:04A8 P:04A8 46F400            MOVE              #>GET_TIME0,Y0
                        000002
1024      P:04AA P:04AA 200055            CMP     Y0,A
1025      P:04AB P:04AB 0EA000            JEQ     <FINISH1                          ; Is it Time0?
1026      P:04AC P:04AC 44F400            MOVE              #ITIME1,X0
                        0048A9
1027      P:04AE P:04AE 46F400            MOVE              #>GET_TIME1,Y0
                        000003
1028      P:04B0 P:04B0 200055            CMP     Y0,A
1029      P:04B1 P:04B1 0EA000            JEQ     <FINISH1                          ; Is it Time1?
1030      P:04B2 P:04B2 44F400            MOVE              #ISVNREV,X0
                        000FDB
1031      P:04B4 P:04B4 46F400            MOVE              #>GET_SVNREV,Y0
                        000004
1032      P:04B6 P:04B6 200055            CMP     Y0,A
1033      P:04B7 P:04B7 0EA000            JEQ     <FINISH1                          ; Is it Svn rev?
1034      P:04B8 P:04B8 44F400            MOVE              #TIMCAPABLE,X0
                        0001FB
1035      P:04BA P:04BA 46F400            MOVE              #>GET_CAPABLE,Y0
                        000100
1036      P:04BC P:04BC 200055            CMP     Y0,A
1037      P:04BD P:04BD 0EA000            JEQ     <FINISH1                          ; Is it Tim Capabilities?
1038      P:04BE P:04BE 44F400            MOVE              #INT_TIM,X0
                        080000
1039      P:04C0 P:04C0 46F400            MOVE              #>GET_INT_TIM,Y0
                        000101
1040      P:04C2 P:04C2 200055            CMP     Y0,A
1041      P:04C3 P:04C3 0EA000            JEQ     <FINISH1                          ; Is it Integration time?
1042      P:04C4 P:04C4 44F400            MOVE              #R_DELAY,X0
                        000000
1043      P:04C6 P:04C6 46F400            MOVE              #>GET_R_DELAY,Y0
                        000102
1044      P:04C8 P:04C8 200055            CMP     Y0,A
1045      P:04C9 P:04C9 0EA000            JEQ     <FINISH1                          ; Is it Serial time?
1046      P:04CA P:04CA 44F400            MOVE              #SI_DELAY,X0
                        860000
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timCCDmisc.s  Page 21



1047      P:04CC P:04CC 46F400            MOVE              #>GET_SI_DELAY,Y0
                        000103
1048      P:04CE P:04CE 200055            CMP     Y0,A
1049      P:04CF P:04CF 0EA000            JEQ     <FINISH1                          ; Is it Parallel time?
1050      P:04D0 P:04D0 0C0000            JMP     <ERROR
1051   
1052   
1053                            ; Set software to IDLE mode
1054      P:04D1 P:04D1 44F400  IDL       MOVE              #IDLE,X0                ; Exercise clocks when idling
                        00020F
1055      P:04D3 P:04D3 440000            MOVE              X0,X:<IDL_ADR
1056      P:04D4 P:04D4 0A0022            BSET    #IDLMODE,X:<STATUS                ; Idle after readout
1057      P:04D5 P:04D5 0C0000            JMP     <FINISH                           ; Need to send header and 'DON'
1058   
1059                            ; Come to here on a 'STP' command so 'DON' can be sent
1060      P:04D6 P:04D6 44F400  STP       MOVE              #TST_RCV,X0             ; Wait for commands during exposure
                        000000
1061      P:04D8 P:04D8 440000            MOVE              X0,X:<IDL_ADR           ;  instead of exercising clocks
1062      P:04D9 P:04D9 0A0002            BCLR    #IDLMODE,X:<STATUS                ; Don't idle after readout
1063      P:04DA P:04DA 0C0000            JMP     <FINISH
1064   
1065                            ; Let the host computer read the controller configuration
1066                            READ_CONTROLLER_CONFIGURATION
1067      P:04DB P:04DB 4C8A00            MOVE                          Y:<CONFIG,X0 ; Just transmit the configuration
1068      P:04DC P:04DC 0C0000            JMP     <FINISH1
1069   
1070                            ; Power off
1071      P:04DD P:04DD 0D052C  PWR_OFF   JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1072      P:04DE P:04DE 0AA202            BCLR    #LVEN,X:PBDDR                     ; Set these signals to DSP inputs
1073      P:04DF P:04DF 0AA20D            BCLR    #PWRST,X:PBDDR
1074      P:04E0 P:04E0 0AA203            BCLR    #HVEN,X:PBDDR
1075      P:04E1 P:04E1 0AA422            BSET    #LVEN,X:PBD                       ; LVEN = HVEN = 1 => Power reset
1076      P:04E2 P:04E2 0AA42D            BSET    #PWRST,X:PBD
1077      P:04E3 P:04E3 0AA423            BSET    #HVEN,X:PBD
1078      P:04E4 P:04E4 0C0000            JMP     <FINISH
1079   
1080                            ; Start power-on cycle
1081      P:04E5 P:04E5 0AA222  PWR_ON    BSET    #LVEN,X:PBDDR                     ; Set these signals to DSP outputs
1082      P:04E6 P:04E6 0AA22D            BSET    #PWRST,X:PBDDR
1083      P:04E7 P:04E7 0AA223            BSET    #HVEN,X:PBDDR
1084      P:04E8 P:04E8 0D052C            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1085   
1086                            ; Ramp up the low voltages (+/- 6.5V, 16.5V) and then delay
1087      P:04E9 P:04E9 0AA402            BCLR    #LVEN,X:PBD                       ; LVEN = Low => Turn on +/- 6.5V,
1088      P:04EA P:04EA 0AA40D            BCLR    #PWRST,X:PBD
1089      P:04EB P:04EB 44F400            MOVE              #60000,X0
                        00EA60
1090      P:04ED P:04ED 06C400            DO      X0,WT_PON1                        ; Wait 10 millisec or so for settling
                        0004F2
1091      P:04EF P:04EF 07708E            MOVE              A,P:RSTWDT              ; Reset watchdog timer
                        006000
1092      P:04F1 P:04F1 07708E            MOVE              A,P:RSTWDT
                        006000
1093                            WT_PON1
1094   
1095                            ; Ramp up the high +36 volt power line and then delay
1096      P:04F3 P:04F3 0AA403            BCLR    #HVEN,X:PBD                       ; HVEN = Low => Turn on +36V
1097      P:04F4 P:04F4 44F400            MOVE              #60000,X0
                        00EA60
1098      P:04F6 P:04F6 06C400            DO      X0,WT_PON2                        ; Wait 10 millisec or so for settling
                        0004FB
1099      P:04F8 P:04F8 07708E            MOVE              A,P:RSTWDT              ; Reset watchdog timer
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timCCDmisc.s  Page 22



                        006000
1100      P:04FA P:04FA 07708E            MOVE              A,P:RSTWDT
                        006000
1101                            WT_PON2
1102      P:04FC P:04FC 0D0503            JSR     <SET_BIASES                       ; Turn on the DC bias supplies
1103      P:04FD P:04FD 44F400            MOVE              #IDLE,X0
                        00020F
1104      P:04FF P:04FF 440000            MOVE              X0,X:<IDL_ADR
1105      P:0500 P:0500 0C0000            JMP     <FINISH                           ; All done with 'DON'
1106   
1107      P:0501 P:0501 0D0503  SETBIAS   JSR     <SET_BIASES
1108      P:0502 P:0502 0C0000            JMP     <FINISH
1109   
1110                            ; Set all the DC bias voltages and video processor offset values, reading
1111                            ;   them from the table labeled DACS in this file
1112                            SET_BIASES
1113      P:0503 P:0503 0D051C            JSR     <SER_ANA
1114      P:0504 P:0504 0A0020            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
1115      P:0505 P:0505 0A0022            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
1116      P:0506 P:0506 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Disable clear of DAC and enable clocks
                        000000
1117      P:0508 P:0508 0D045C            JSR     <PAL_DLY                          ; Delay for all this to happen
1118      P:0509 P:0509 0D045C            JSR     <PAL_DLY                          ; Delay for all this to happen
1119   
1120                            ; Disable simultaneous update of clock driver boards
1121      P:050A P:050A 0A0001            BCLR    #1,X:<LATCH
1122      P:050B P:050B 09F081            MOVEP             X:LATCH,Y:WRLATCH
                        000000
1123   
1124                            ; Read DAC values from a table, and set DACs
1125      P:050D P:050D 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                        000100
1126      P:050F P:050F 0D0461            JSR     <SET_DAC
1127   
1128                            ; Set all video processor analog switches to open to disable them (1 => OFF)
1129      P:0510 P:0510 56F400            MOVE              #$000FFF,A
                        000FFF
1130      P:0512 P:0512 566600            MOVE              A,X:(R6)                ; Send out the waveform
1131      P:0513 P:0513 000000            NOP
1132   
1133                            ; Let the DAC voltages all ramp up before exiting
1134      P:0514 P:0514 56F400            MOVE              #400,A                  ; Delay 4 millisec
                        000190
1135      P:0516 P:0516 06CE00            DO      A,L_SBI1
                        000519
1136      P:0518 P:0518 0D045C            JSR     <PAL_DLY                          ; Delay for all this to happen
1137      P:0519 P:0519 000000            NOP
1138                            L_SBI1
1139      P:051A P:051A 0D0523            JSR     <SER_UTL                          ; SSI -> utility board communication
1140      P:051B P:051B 00000C            RTS
1141   
1142                            ; Enable serial communication to the analog boards
1143      P:051C P:051C 0AA420  SER_ANA   BSET    #0,X:PBD                          ; Set H0 for analog boards SSI
1144      P:051D P:051D 08F4A1            MOVEP             #$0000,X:PCC            ; Software reset of SSI
                        000000
1145      P:051F P:051F 0AAD0A            BCLR    #10,X:CRB                         ; SSI -> continuous clock for analog
1146      P:0520 P:0520 08F4A1            MOVEP             #$0160,X:PCC            ; Re-enable the SSI
                        000160
1147      P:0522 P:0522 00000C            RTS
1148   
1149                            ; Enable serial communication to the utility board
1150      P:0523 P:0523 08F4A1  SER_UTL   MOVEP             #$0000,X:PCC            ; Software reset of SSI
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timCCDmisc.s  Page 23



                        000000
1151      P:0525 P:0525 0AAD2A            BSET    #10,X:CRB                         ; SSI -> gated clock for util board
1152      P:0526 P:0526 08F4A1            MOVEP             #$0160,X:PCC            ; Enable the SSI
                        000160
1153      P:0528 P:0528 0AA400            BCLR    #0,X:PBD                          ; Clear H0 for utility board SSI
1154      P:0529 P:0529 00000C            RTS
1155   
1156      P:052A P:052A 0D052C  CLR_SWS   JSR     <CLEAR_SWITCHES
1157      P:052B P:052B 0C0000            JMP     <FINISH
1158   
1159                            ; Clear all video processor analog switches to lower their power dissipation
1160                            CLEAR_SWITCHES
1161      P:052C P:052C 0D051C            JSR     <SER_ANA                          ; Set SSI to analog board communication
1162      P:052D P:052D 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                        0C3000
1163      P:052F P:052F 20001B            CLR     B
1164      P:0530 P:0530 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC writes
1165      P:0531 P:0531 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writes
                        001000
1166      P:0533 P:0533 060F80            DO      #15,L_VIDEO                       ; Fifteen video processor boards maximum
                        00053A
1167      P:0535 P:0535 08CE2F            MOVEP             A,X:SSITX               ; Gain, integrate speed
1168      P:0536 P:0536 200040            ADD     X0,A
1169      P:0537 P:0537 577000            MOVE              B,X:WRSS
                        00FF80
1170      P:0539 P:0539 0D045C            JSR     <PAL_DLY                          ; Delay for the serial data transmission
1171      P:053A P:053A 200068            ADD     X1,B
1172                            L_VIDEO
1173      P:053B P:053B 0A0000            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
1174      P:053C P:053C 0A0002            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
1175      P:053D P:053D 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                        000000
1176      P:053F P:053F 44F400            MOVE              #IDLE,X0
                        00020F
1177      P:0541 P:0541 440000            MOVE              X0,X:<IDL_ADR
1178      P:0542 P:0542 0D0523            JSR     <SER_UTL                          ; Return SSI to utility board
1179      P:0543 P:0543 00000C            RTS
1180   
1181                            ; Set the clock multiplexers
1182      P:0544 P:0544 0D051C  SET_MUX   JSR     <SER_ANA                          ; Set SSI to analog board communication
1183      P:0545 P:0545 56DC00            MOVE              X:(R4)+,A               ; Clock driver board number
1184      P:0546 P:0546 0614A0            REP     #20
1185      P:0547 P:0547 200033            LSL     A
1186      P:0548 P:0548 44F400            MOVE              #$003000,X0
                        003000
1187      P:054A P:054A 200042            OR      X0,A
1188      P:054B P:054B 21C500            MOVE              A,X1                    ; Move here for storage
1189   
1190                            ; Get the first MUX number
1191      P:054C P:054C 56DC00            MOVE              X:(R4)+,A               ; Get the first MUX number
1192      P:054D P:054D 0AF0A9            JLT     ERR_SM1
                        00058F
1193      P:054F P:054F 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                        000018
1194      P:0551 P:0551 200045            CMP     X0,A
1195      P:0552 P:0552 0AF0A1            JGE     ERR_SM1
                        00058F
1196      P:0554 P:0554 21CF00            MOVE              A,B
1197      P:0555 P:0555 44F400            MOVE              #>7,X0
                        000007
1198      P:0557 P:0557 20004E            AND     X0,B
1199      P:0558 P:0558 44F400            MOVE              #>$18,X0
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timCCDmisc.s  Page 24



                        000018
1200      P:055A P:055A 200046            AND     X0,A
1201      P:055B P:055B 0E255E            JNE     <SMX_1                            ; Test for 0 <= MUX number <= 7
1202      P:055C P:055C 0ACD63            BSET    #3,B1
1203      P:055D P:055D 0C0569            JMP     <SMX_A
1204      P:055E P:055E 44F400  SMX_1     MOVE              #>$08,X0
                        000008
1205      P:0560 P:0560 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1206      P:0561 P:0561 0E2564            JNE     <SMX_2
1207      P:0562 P:0562 0ACD64            BSET    #4,B1
1208      P:0563 P:0563 0C0569            JMP     <SMX_A
1209      P:0564 P:0564 44F400  SMX_2     MOVE              #>$10,X0
                        000010
1210      P:0566 P:0566 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1211      P:0567 P:0567 0E258F            JNE     <ERR_SM1
1212      P:0568 P:0568 0ACD65            BSET    #5,B1
1213      P:0569 P:0569 20006A  SMX_A     OR      X1,B1                             ; Add prefix to MUX numbers
1214      P:056A P:056A 21A700            MOVE              B1,Y1
1215   
1216                            ; Add on the second MUX number
1217      P:056B P:056B 56DC00            MOVE              X:(R4)+,A               ; Get the next MUX number
1218      P:056C P:056C 0AF0A9            JLT     ERR_SM2
                        000590
1219      P:056E P:056E 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                        000018
1220      P:0570 P:0570 200045            CMP     X0,A
1221      P:0571 P:0571 0AF0A1            JGE     ERR_SM2
                        000590
1222      P:0573 P:0573 0606A0            REP     #6
1223      P:0574 P:0574 200033            LSL     A
1224      P:0575 P:0575 21CF00            MOVE              A,B
1225      P:0576 P:0576 44F400            MOVE              #$1C0,X0
                        0001C0
1226      P:0578 P:0578 20004E            AND     X0,B
1227      P:0579 P:0579 44F400            MOVE              #>$600,X0
                        000600
1228      P:057B P:057B 200046            AND     X0,A
1229      P:057C P:057C 0E257F            JNE     <SMX_3                            ; Test for 0 <= MUX number <= 7
1230      P:057D P:057D 0ACD69            BSET    #9,B1
1231      P:057E P:057E 0C058A            JMP     <SMX_B
1232      P:057F P:057F 44F400  SMX_3     MOVE              #>$200,X0
                        000200
1233      P:0581 P:0581 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1234      P:0582 P:0582 0E2585            JNE     <SMX_4
1235      P:0583 P:0583 0ACD6A            BSET    #10,B1
1236      P:0584 P:0584 0C058A            JMP     <SMX_B
1237      P:0585 P:0585 44F400  SMX_4     MOVE              #>$400,X0
                        000400
1238      P:0587 P:0587 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1239      P:0588 P:0588 0E2590            JNE     <ERR_SM2
1240      P:0589 P:0589 0ACD6B            BSET    #11,B1
1241      P:058A P:058A 200078  SMX_B     ADD     Y1,B                              ; Add prefix to MUX numbers
1242   
1243      P:058B P:058B 08CD2F            MOVEP             B1,X:SSITX
1244      P:058C P:058C 0D045C            JSR     <PAL_DLY                          ; Delay for all this to happen
1245      P:058D P:058D 0D0523            JSR     <SER_UTL                          ; Return SSI to utility board communication
1246      P:058E P:058E 0C0000            JMP     <FINISH
1247      P:058F P:058F 56DC00  ERR_SM1   MOVE              X:(R4)+,A
1248      P:0590 P:0590 0D0523  ERR_SM2   JSR     <SER_UTL                          ; Return SSI to utility board communication
1249      P:0591 P:0591 0C0000            JMP     <ERROR
1250   
1251   
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timCCDmisc.s  Page 25



1252                            ; Set the video processor gain and integrator speed for all video boards
1253                            ;  Command syntax is  SGN  #GAIN  #SPEED, #GAIN = 1, 2, 5 or 10
1254                            ;                                         #SPEED = 0 for slow, 1 for fast
1255      P:0592 P:0592 0D051C  ST_GAIN   JSR     <SER_ANA                          ; Set SSI to analog board communication
1256      P:0593 P:0593 56DC00            MOVE              X:(R4)+,A               ; Gain value (1,2,5 or 10)
1257      P:0594 P:0594 44F400            MOVE              #>1,X0
                        000001
1258      P:0596 P:0596 200045            CMP     X0,A                              ; Check for gain = x1
1259      P:0597 P:0597 0E259B            JNE     <STG2
1260      P:0598 P:0598 57F400            MOVE              #>$77,B
                        000077
1261      P:059A P:059A 0C05AF            JMP     <STG_A
1262      P:059B P:059B 44F400  STG2      MOVE              #>2,X0                  ; Check for gain = x2
                        000002
1263      P:059D P:059D 200045            CMP     X0,A
1264      P:059E P:059E 0E25A2            JNE     <STG5
1265      P:059F P:059F 57F400            MOVE              #>$BB,B
                        0000BB
1266      P:05A1 P:05A1 0C05AF            JMP     <STG_A
1267      P:05A2 P:05A2 44F400  STG5      MOVE              #>5,X0                  ; Check for gain = x5
                        000005
1268      P:05A4 P:05A4 200045            CMP     X0,A
1269      P:05A5 P:05A5 0E25A9            JNE     <STG10
1270      P:05A6 P:05A6 57F400            MOVE              #>$DD,B
                        0000DD
1271      P:05A8 P:05A8 0C05AF            JMP     <STG_A
1272      P:05A9 P:05A9 44F400  STG10     MOVE              #>10,X0                 ; Check for gain = x10
                        00000A
1273      P:05AB P:05AB 200045            CMP     X0,A
1274      P:05AC P:05AC 0E2000            JNE     <ERROR
1275      P:05AD P:05AD 57F400            MOVE              #>$EE,B
                        0000EE
1276   
1277      P:05AF P:05AF 56DC00  STG_A     MOVE              X:(R4)+,A               ; Integrator Speed (0 for slow, 1 for fast)
1278      P:05B0 P:05B0 0ACC00            JCLR    #0,A1,STG_B
                        0005B4
1279      P:05B2 P:05B2 0ACD68            BSET    #8,B1
1280      P:05B3 P:05B3 0ACD69            BSET    #9,B1
1281      P:05B4 P:05B4 44F400  STG_B     MOVE              #$0C3C00,X0
                        0C3C00
1282      P:05B6 P:05B6 20004A            OR      X0,B
1283      P:05B7 P:05B7 5F0000            MOVE                          B,Y:<GAIN   ; Store the GAIN value for later us
1284   
1285                            ; Send this same value to 15 video processor boards whether they exist or not
1286      P:05B8 P:05B8 241000            MOVE              #$100000,X0             ; Increment value
1287      P:05B9 P:05B9 060F80            DO      #15,STG_LOOP
                        0005BE
1288      P:05BB P:05BB 577000            MOVE              B,X:SSITX               ; Transmit the SSI word
                        00FFEF
1289      P:05BD P:05BD 0D045C            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
1290      P:05BE P:05BE 200048            ADD     X0,B                              ; Increment the video processor board number
1291                            STG_LOOP
1292   
1293      P:05BF P:05BF 0D0523            JSR     <SER_UTL                          ; Return SSI to utility board communication
1294      P:05C0 P:05C0 0C0000            JMP     <FINISH
1295      P:05C1 P:05C1 56DC00  ERR_SGN   MOVE              X:(R4)+,A
1296      P:05C2 P:05C2 0D0523            JSR     <SER_UTL                          ; Return SSI to utility board communication
1297      P:05C3 P:05C3 0C0000            JMP     <ERROR
1298   
1299                            ; Write an arbitraty control word over the SSI link to any register, any board
1300                            ; Command syntax is  WRC number, number is 24-bit number to be sent to any board
1301                            ;WR_CNTRL
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timCCDmisc.s  Page 26



1302                            ;       JSR     <SER_ANA        ; Set SSI to analog board communication
1303                            ;       JSR     <PAL_DLY        ; Wait for the number to be sent
1304                            ;        MOVEP  X:(R4)+,X:SSITX ; Send out the waveform
1305                            ;       JSR     <PAL_DLY        ; Wait for SSI and PAL to be empty
1306                            ;       JSR     <SER_UTL        ; Return SSI to utility board communication
1307                            ;       JMP     <FINISH
1308   
1309   
1310   
1311                            ; Specify subarray readout coordinates, one rectangle only
1312                            ; Call this subroutine BEFORE SET_SUBARRAY_POSITIONS since it
1313                            ; initializes NBOXES
1314                            SET_SUBARRAY_SIZES
1315      P:05C4 P:05C4 200013            CLR     A
1316      P:05C5 P:05C5 5E1900            MOVE                          A,Y:<NBOXES ; Number of subimage boxes = 0 to start
1317      P:05C6 P:05C6 44DC00            MOVE              X:(R4)+,X0
1318      P:05C7 P:05C7 4C1A00            MOVE                          X0,Y:<NR_BIAS ; Number of bias pixels to read
1319      P:05C8 P:05C8 44DC00            MOVE              X:(R4)+,X0
1320      P:05C9 P:05C9 4C1B00            MOVE                          X0,Y:<NS_READ ; Number of columns in subimage read
1321      P:05CA P:05CA 44DC00            MOVE              X:(R4)+,X0
1322      P:05CB P:05CB 4C1C00            MOVE                          X0,Y:<NP_READ ; Number of rows in subimage read
1323      P:05CC P:05CC 0C0000            JMP     <FINISH
1324   
1325                            ; Call this routine once for every subarray to be added to the table
1326                            ; Note that the way the variables are arranged the subframes all are the
1327                            ; same dimensions.  They also cannot overlap in the row direction.
1328                            ; SET_SUBARRAY_SIZES must be called first to initialize NBOXES
1329                            SET_SUBARRAY_POSITIONS
1330      P:05CD P:05CD 4C9900            MOVE                          Y:<NBOXES,X0 ; Next available slot
1331      P:05CE P:05CE 458000            MOVE              X:<THREE,X1
1332      P:05CF P:05CF 2000A0            MPY     X0,X1,A
1333      P:05D0 P:05D0 200022            ASR     A
1334      P:05D1 P:05D1 210C00            MOVE              A0,A1
1335      P:05D2 P:05D2 44F400            MOVE              #>24,X0
                        000018
1336      P:05D4 P:05D4 200045            CMP     X0,A
1337      P:05D5 P:05D5 0E7000            JGT     <ERROR                            ; Error if number of boxes > 9
1338      P:05D6 P:05D6 44F400            MOVE              #READ_TABLE,X0
                        00001D
1339      P:05D8 P:05D8 200040            ADD     X0,A
1340      P:05D9 P:05D9 219700            MOVE              A1,R7
1341      P:05DA P:05DA 44DC00            MOVE              X:(R4)+,X0
1342      P:05DB P:05DB 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of rows (parallels) to clear
1343      P:05DC P:05DC 44DC00            MOVE              X:(R4)+,X0
1344      P:05DD P:05DD 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears before
1345      P:05DE P:05DE 44DC00            MOVE              X:(R4)+,X0              ;  the box readout
1346      P:05DF P:05DF 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears after
1347      P:05E0 P:05E0 5E9900            MOVE                          Y:<NBOXES,A ;  the box readout
1348      P:05E1 P:05E1 448000            MOVE              X:<ONE,X0
1349      P:05E2 P:05E2 200040            ADD     X0,A                              ; Update the next available slot position
1350      P:05E3 P:05E3 5E1900            MOVE                          A,Y:<NBOXES
1351      P:05E4 P:05E4 0C0000            JMP     <FINISH
1352   
1353                            ; Alert the PCI interface board that images are coming soon
1354                            ; This tells the PCI card how many pixels to expect for each SEX command
1355                            ; This is fairly complex.  The first value sent is NSR*NPR (NAXIS1*NAXIS2).
1356                            ; The second value is IFRAMES, but if NBOXES > 0, it is IFRAMES*NBOXES
1357                            PCI_READ_IMAGE
1358      P:05E5 P:05E5 44F400            MOVE              #$020104,X0             ; Send header word to the FO transmitter
                        020104
1359      P:05E7 P:05E7 0D0600            JSR     <XMT_FO
1360      P:05E8 P:05E8 44F400            MOVE              #'RDA',X0
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  timCCDmisc.s  Page 27



                        524441
1361      P:05EA P:05EA 0D0600            JSR     <XMT_FO
1362      P:05EB P:05EB 4CF000            MOVE                          Y:NSR,X0    ; NSR = NAXIS1
                        000001
1363      P:05ED P:05ED 4DF000            MOVE                          Y:NPR,X1    ; NPR = NAXIS2
                        000002
1364      P:05EF P:05EF 2000A8            MPY     X0,X1,B
1365      P:05F0 P:05F0 20002A            ASR     B                                 ; Correct for multiplication left shift
1366      P:05F1 P:05F1 212400            MOVE              B0,X0
1367      P:05F2 P:05F2 0D0600            JSR     <XMT_FO                           ; Send NSR*NPR to PCI card
1368      P:05F3 P:05F3 4CF000            MOVE                          Y:IFRAMES,X0 ; IFRAMES = NAXIS3
                        00003A
1369      P:05F5 P:05F5 5E9900            MOVE                          Y:<NBOXES,A ; If NBOXES = 0, transmit that to PCI
1370      P:05F6 P:05F6 200003            TST     A
1371      P:05F7 P:05F7 0AF0AA            JEQ     XMT
                        0005FD
1372      P:05F9 P:05F9 4D9900            MOVE                          Y:<NBOXES,X1 ; If NBOXES = 0, transmit that to PCI
1373      P:05FA P:05FA 2000A8            MPY     X0,X1,B                           ; If not, multiply by NBOXES, then send
1374      P:05FB P:05FB 20002A            ASR     B                                 ; Correct for multiplication left shift
1375      P:05FC P:05FC 212400            MOVE              B0,X0                   ; Get only least significant 24 bits
1376      P:05FD P:05FD 000000  XMT       NOP
1377      P:05FE P:05FE 0D0600            JSR     <XMT_FO
1378      P:05FF P:05FF 00000C            RTS
1379   
1380      P:0600 P:0600 09C400  XMT_FO    MOVEP             X0,Y:WRFO
1381      P:0601 P:0601 060FA0            REP     #15
1382      P:0602 P:0602 000000            NOP
1383      P:0603 P:0603 00000C            RTS
1384   
1385                            ; Check for program overflow
1386                                      IF      @CVS(N,*)-$200>MISC_LEN
1388                                      ENDIF                                     ;  will not overflow
1389   
1390   
1391                            ;**************************************************************************
1392                            ;                                                                         *
1393                            ;    Permanent address register assignments                               *
1394                            ;        R1 - Address of SSI receiver contents                            *
1395                            ;        R2 - Address of SCI receiver contents                            *
1396                            ;        R3 - Pointer to current top of command buffer                    *
1397                            ;        R4 - Pointer to processed contents of command buffer             *
1398                            ;        R5 - Temporary register for processing SSI and SCI contents      *
1399                            ;        R6 - CCD clock driver address for CCD #0 = $FF80                 *
1400                            ;                It is also the A/D address of analog board #0            *
1401                            ;                                                                         *
1402                            ;    Other registers                                                      *
1403                            ;        R0, R7 - Temporary registers used all over the place.            *
1404                            ;        R5 - Can be used as a temporary register but is circular,        *
1405                            ;               modulo 32.                                                *
1406                            ;**************************************************************************
1407   
1408                            ;  Specify execution and load addresses
1409                                      IF      @SCP("HOST","HOST")
1410      P:0130 P:0130                   ORG     P:APL_ADR,P:APL_ADR               ; Download address
1411                                      ELSE
1413                                      ENDIF
1414   
1415                            ;  ***********************   CCD  READOUT   ***********************
1416                            ; RDCCD is now a subroutine
1417   
1418                            RDCCD
1419      P:0130 P:0130 0A31A2            JSET    #STORAGE,X:ISTATUS,RCCD1
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  tim.s  Page 28



                        000134
1420                            ; Do the frame transfer if STORAGE==0, else skip it.
1421      P:0132 P:0132 4DBB00            MOVE                          Y:<S_SIZE,X1
1422      P:0133 P:0133 0D0444            JSR     ISHIFT                            ; Do the frame transfer
1423   
1424                            ; Calculate some readout parameters.
1425                            ; This is also an alternative entry point for skipping the frame transfer
1426                            ; STORAGE also selects ganged or storage only parallels during readout
1427                            ; NO_SKIP skips over the section that parallel skips to the subframe start
1428   
1429      P:0134 P:0134 5E9900  RCCD1     MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1430      P:0135 P:0135 200003            TST     A
1431      P:0136 P:0136 0E2140            JNE     <SUB_IMG
1432      P:0137 P:0137 5C1600            MOVE                          A1,Y:<NP_SKIP ; Zero these all out.  Full frame
1433      P:0138 P:0138 5C1700            MOVE                          A1,Y:<NS_SKP1
1434      P:0139 P:0139 5C1800            MOVE                          A1,Y:<NS_SKP2
1435      P:013A P:013A 5E8100            MOVE                          Y:<NSR,A    ; NSERIALS_READ = NSR
1436      P:013B P:013B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                        00013E
1437      P:013D P:013D 200022            ASR     A                                 ; Split serials require / 2
1438      P:013E P:013E 5E1000            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1439      P:013F P:013F 0C014F            JMP     <SETUP
1440   
1441                            ; Loop over the required number of subimage boxes if NBOXES > 0
1442      P:0140 P:0140 67F400  SUB_IMG   MOVE              #READ_TABLE,R7          ; Parameter table for subimage readout
                        00001D
1443      P:0142 P:0142 061940            DO      Y:<NBOXES,L_NBOXES                ; Loop over number of boxes
                        0001E5
1444      P:0144 P:0144 4CDF00            MOVE                          Y:(R7)+,X0
1445      P:0145 P:0145 4C1600            MOVE                          X0,Y:<NP_SKIP
1446      P:0146 P:0146 4CDF00            MOVE                          Y:(R7)+,X0
1447      P:0147 P:0147 4C1700            MOVE                          X0,Y:<NS_SKP1
1448      P:0148 P:0148 4CDF00            MOVE                          Y:(R7)+,X0
1449      P:0149 P:0149 4C1800            MOVE                          X0,Y:<NS_SKP2
1450      P:014A P:014A 5E9B00            MOVE                          Y:<NS_READ,A
1451      P:014B P:014B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                        00014E
1452      P:014D P:014D 200022            ASR     A
1453      P:014E P:014E 5E1000            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1454   
1455                            ; Calculate the fast readout parameters
1456      P:014F P:014F 0D0342  SETUP     JSR     <SETUP_SUBROUTINE
1457   
1458                            ; Skip over the required number of rows for subimage readout
1459                            ; If #NO_SKIP == 0 skip rows up to first subframe, storage clocks only
1460      P:0150 P:0150 0A31A0            JSET    #NO_SKIP,X:ISTATUS,CLR_SR
                        00015A
1461      P:0152 P:0152 5E9600            MOVE                          Y:<NP_SKIP,A ; Number of rows NP_SKIP to skip
1462      P:0153 P:0153 200003            TST     A
1463      P:0154 P:0154 0EA15A            JEQ     <CLR_SR                           ; If zero, skip this shift
1464      P:0155 P:0155 061640            DO      Y:<NP_SKIP,L_SKIP1                ; Clock number of rows to skip
                        000159
1465      P:0157 P:0157 305000            MOVE              #<S_CLEAR,R0            ; SR kept clear with DG
1466      P:0158 P:0158 0D01E9            JSR     <CLOCK
1467      P:0159 P:0159 000000            NOP
1468                            L_SKIP1
1469   
1470                            ; Clear out the accumulated charge from the serial shift register
1471                            ; Leave this commented-out code in until we can test it with a subframe
1472                            ; CLR_SR MOVE   #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1473                            ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1474                            ;       NOP
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  tim.s  Page 29



1475                            ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1476                            ;       DO      Y:<NSCLR,*+3            ; Number of waveform entries total
1477                            ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1478                            ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1479   
1480      P:015A P:015A 60F400  CLR_SR    MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel skip
                        000068
1481      P:015C P:015C 0D01E9            JSR     <CLOCK
1482   
1483                            ; Parallel shift the image into the serial shift register
1484      P:015D P:015D 4C8200            MOVE                          Y:<NPR,X0   ; Number of rows set by host computer
1485      P:015E P:015E 5E9900            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1486      P:015F P:015F 200003            TST     A
1487      P:0160 P:0160 0EA162            JEQ     *+2
1488      P:0161 P:0161 4C9C00            MOVE                          Y:<NP_READ,X0 ; If NBOXES .NE. 0 use subimage table
1489   
1490                            ; Main loop over each line to be read out
1491                            ; If split parallels have to divide NPR by two to be loop counter
1492                            ; Subimages implicitly assumes that parallels are not split
1493      P:0162 P:0162 0A0086            JCLR    #SPLIT_P,X:STATUS,PLOOP           ; skip this if not split parallels
                        000168
1494      P:0164 P:0164 5EF000            MOVE                          Y:NPR,A     ; Get NPR
                        000002
1495      P:0166 P:0166 200022            ASR     A                                 ; Divide by 2
1496      P:0167 P:0167 21C400            MOVE              A,X0                    ; Overwrite loop counter in X0
1497   
1498                            ; Finally start the row loop
1499      P:0168 P:0168 06C400  PLOOP     DO      X0,LPR                            ; Number of rows to read out
                        0001E4
1500   
1501                            ; Check for a command once per line. Only the ABORT command is allowed
1502      P:016A P:016A 0D0000            JSR     <GET_RCV                          ; Was a command received?
1503      P:016B P:016B 0E0175            JCC     <CONT_RD                          ; If no, continue reading out
1504      P:016C P:016C 0C0000            JMP     <CHK_SSI                          ; If yes, go process it
1505   
1506                            ; Abort the readout currently underway
1507      P:016D P:016D 0A0084  ABR_RDC   JCLR    #ST_RDC,X:<STATUS,ABORT_EXPOSURE
                        000491
1508      P:016F P:016F 00008C            ENDDO                                     ; Properly terminate row loop
1509      P:0170 P:0170 5E9900            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1510      P:0171 P:0171 200003            TST     A
1511      P:0172 P:0172 0EA174            JEQ     *+2
1512      P:0173 P:0173 00008C            ENDDO                                     ; Properly terminate box loop
1513      P:0174 P:0174 00000C            RTS                                       ; Return early from subroutine
1514   
1515                            ; Move the row into the serial register.
1516      P:0175 P:0175 060640  CONT_RD   DO      Y:<NPBIN,LPR_I                    ; Transfer # of rows, with binning
                        00017C
1517      P:0177 P:0177 305800            MOVE              #<IS_PARALLEL,R0
1518      P:0178 P:0178 0A31A2            JSET    #STORAGE,X:ISTATUS,GANGED         ; if STORAGE == 1 ganged parallels
                        00017B
1519      P:017A P:017A 304000            MOVE              #<S_PARALLEL,R0         ; if STORAGE == 0 store clocks only
1520      P:017B P:017B 0D01E9  GANGED    JSR     <CLOCK                            ; Parallel clocking
1521      P:017C P:017C 000000            NOP
1522                            LPR_I
1523   
1524                            ; Skip over NS_SKP1 columns for subimage readout
1525      P:017D P:017D 5E9700            MOVE                          Y:<NS_SKP1,A ; Number of columns to skip
1526      P:017E P:017E 200003            TST     A
1527      P:017F P:017F 0EA188            JEQ     <L_READ
1528      P:0180 P:0180 0505A1            MOVE              #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1529      P:0181 P:0181 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  tim.s  Page 30



1530      P:0182 P:0182 000000            NOP
1531      P:0183 P:0183 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1532      P:0184 P:0184 061240            DO      Y:<NSKIP1,LS_SKIP1                ; Number of waveform entries total
                        000186
1533      P:0186 P:0186 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1534                            LS_SKIP1
1535      P:0187 P:0187 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1536   
1537                            ; Finally read some real pixels - this is the serial binning routine
1538      P:0188 P:0188 200013  L_READ    CLR     A
1539      P:0189 P:0189 20001B            CLR     B
1540      P:018A P:018A 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1541      P:018B P:018B 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                        000006
1542      P:018D P:018D 200005            CMP     B,A                               ; else do special waveforms via NO_BIN
1543      P:018E P:018E 0E719F            JGT     <NO_BIN                           ; Skip over general serial binning software
1544      P:018F P:018F 00000B            DEC     B                                 ; serial binning factor minus 1
1545      P:0190 P:0190 212700            MOVE              B0,Y1
1546      P:0191 P:0191 061040            DO      Y:<NSERIALS_READ,LSR_BIN          ; Number of pixels to read out
                        00019D
1547      P:0193 P:0193 688E00            MOVE                          Y:<INITIAL_CLOCK,R0 ; (already /2 if split serials)
1548      P:0194 P:0194 0D01E9            JSR     <CLOCK
1549                            ;       DO      Y:<NSBIN,LSR_I          ; Bin serially NSBIN times
1550      P:0195 P:0195 06C700            DO      Y1,LSR_I                          ; Bin serially NSBIN times
                        000199
1551      P:0197 P:0197 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1552      P:0198 P:0198 0D01E9            JSR     <CLOCK                            ;   shift register
1553      P:0199 P:0199 000000            NOP
1554                            LSR_I
1555      P:019A P:019A 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                        0000B4
1556      P:019C P:019C 0D01E9            JSR     <CLOCK
1557                            ;       MOVE    Y1,Y:<INTERVAL          ; HACK.  Use for debugging
1558      P:019D P:019D 000000            NOP
1559                            LSR_BIN
1560      P:019E P:019E 0C01A9            JMP     <OVER_RD                          ; All done binning
1561   
1562                            ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1563      P:019F P:019F 588C00  NO_BIN    MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1564      P:01A0 P:01A0 00000A            DEC     A                                 ; waveform - 1 into M1
1565      P:01A1 P:01A1 04C8A1            MOVE              A0,M1                   ; Modularity
1566      P:01A2 P:01A2 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1567      P:01A3 P:01A3 000000            NOP
1568      P:01A4 P:01A4 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1569      P:01A5 P:01A5 061340            DO      Y:<NREAD,LSR                      ; Number of waveform entries total
                        0001A7
1570      P:01A7 P:01A7 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1571                            LSR
1572      P:01A8 P:01A8 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1573   
1574                            ; If NR_BIAS=0 clobber SR with DG and skip to end of row loop
1575      P:01A9 P:01A9 5E9A00  OVER_RD   MOVE                          Y:<NR_BIAS,A ; Is NR_BIAS zero?
1576      P:01AA P:01AA 200003            TST     A
1577      P:01AB P:01AB 0E21B1            JNE     <OVR_RD1                          ; no, go to the NS_SKP2 section
1578      P:01AC P:01AC 60F400            MOVE              #DUMP_SERIAL,R0         ; yes, clobber SR with DG
                        000068
1579      P:01AE P:01AE 0D01E9            JSR     <CLOCK
1580      P:01AF P:01AF 0AF080            JMP     END_ROW                           ; and go to the end of the row loop
                        0001E4
1581                            ; Skip over NS_SKP2 columns for subimage readout to get to overscan region
1582      P:01B1 P:01B1 5E9800  OVR_RD1   MOVE                          Y:<NS_SKP2,A ; Number of columns to skip
1583      P:01B2 P:01B2 200003            TST     A
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  tim.s  Page 31



1584      P:01B3 P:01B3 0EA1BC            JEQ     <L_BIAS
1585      P:01B4 P:01B4 0505A1            MOVE              #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1586      P:01B5 P:01B5 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1587      P:01B6 P:01B6 000000            NOP
1588      P:01B7 P:01B7 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1589      P:01B8 P:01B8 061440            DO      Y:<NSKIP2,LS_SKIP2                ; Number of waveform entries total
                        0001BA
1590      P:01BA P:01BA FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1591                            LS_SKIP2
1592      P:01BB P:01BB 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1593   
1594                            ; And read the bias pixels if in subimage readout mode
1595                            ; I think this means that if NBOXES==0 you have to have NSR include bias px.
1596      P:01BC P:01BC 5E9900  L_BIAS    MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1597      P:01BD P:01BD 200003            TST     A
1598      P:01BE P:01BE 0EA1E4            JEQ     <END_ROW
1599   
1600                            ; Finally read some real bias pixels
1601      P:01BF P:01BF 200013            CLR     A
1602      P:01C0 P:01C0 20001B            CLR     B
1603      P:01C1 P:01C1 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1604      P:01C2 P:01C2 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                        000006
1605      P:01C4 P:01C4 200005            CMP     B,A                               ; else do special waveforms via NO_BIN_BIAS
1606      P:01C5 P:01C5 0E71DA            JGT     <NO_BIN_BIAS                      ; Skip over general serial binning software
1607      P:01C6 P:01C6 00000B            DEC     B                                 ; serial binning factor minus 1
1608      P:01C7 P:01C7 212700            MOVE              B0,Y1
1609      P:01C8 P:01C8 5E9A00            MOVE                          Y:<NR_BIAS,A
1610      P:01C9 P:01C9 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                        0001CC
1611      P:01CB P:01CB 200022            ASR     A                                 ; Split serials require / 2
1612      P:01CC P:01CC 06CE00            DO      A,LBIAS_BIN                       ; Number of pixels to read out
                        0001D8
1613      P:01CE P:01CE 688E00            MOVE                          Y:<INITIAL_CLOCK,R0
1614      P:01CF P:01CF 0D01E9            JSR     <CLOCK
1615      P:01D0 P:01D0 06C700            DO      Y1,LBIAS_I                        ; Bin serially NSBIN times
                        0001D4
1616                            ;       DO      Y:<NSBIN,LBIAS_I        ; Bin serially NSBIN times
1617      P:01D2 P:01D2 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1618      P:01D3 P:01D3 0D01E9            JSR     <CLOCK                            ;   shift register
1619      P:01D4 P:01D4 000000            NOP
1620                            LBIAS_I
1621      P:01D5 P:01D5 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                        0000B4
1622      P:01D7 P:01D7 0D01E9            JSR     <CLOCK
1623      P:01D8 P:01D8 000000            NOP
1624                            LBIAS_BIN
1625      P:01D9 P:01D9 0C01E4            JMP     <END_ROW                          ; All done binning
1626   
1627                            ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1628                            ; NBIAS is already divided by 2 in SETUP_SUBROUTINE if split serials.
1629                            NO_BIN_BIAS
1630      P:01DA P:01DA 588C00            MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1631      P:01DB P:01DB 00000A            DEC     A                                 ; waveform - 1 into M1
1632      P:01DC P:01DC 04C8A1            MOVE              A0,M1                   ; Modularity
1633      P:01DD P:01DD 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1634      P:01DE P:01DE 000000            NOP
1635      P:01DF P:01DF 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1636      P:01E0 P:01E0 061540            DO      Y:<NBIAS,*+3                      ; Number of waveform entries total
                        0001E2
1637      P:01E2 P:01E2 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1638      P:01E3 P:01E3 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  tim.s  Page 32



1639      P:01E4 P:01E4 000000  END_ROW   NOP
1640      P:01E5 P:01E5 000000  LPR       NOP                                       ; End of parallel loop
1641      P:01E6 P:01E6 000000  L_NBOXES  NOP                                       ; End of subimage boxes loop
1642      P:01E7 P:01E7 000000            NOP
1643      P:01E8 P:01E8 00000C            RTS
1644   
1645                            ; ***************** END OF CCD READOUT SUBROUTINE  ************
1646   
1647                            ; Core subroutine for clocking out CCD charge
1648                            ; Must keep in tim.s to insure that it is in fast P memory
1649   
1650      P:01E9 P:01E9 4CD800  CLOCK     MOVE                          Y:(R0)+,X0  ; # of waveform entries
1651      P:01EA P:01EA 5ED800            MOVE                          Y:(R0)+,A   ; Start the pipeline
1652      P:01EB P:01EB 06C400            DO      X0,CLK1                           ; Repeat X0 times
                        0001ED
1653      P:01ED P:01ED FA0600            MOVE              A,X:(R6)    Y:(R0)+,A   ; Send out the waveform
1654                            CLK1
1655      P:01EE P:01EE 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1656      P:01EF P:01EF 00000C            RTS                                       ; Return from subroutine
1657   
1658                            ; Check for program overflow
1659                                      IF      @CVS(N,*)>$200
1661                                      ENDIF                                     ;  will not overflow
1662   
1663                            ; ***********  DATA AREAS - READOUT PARAMETERS AND WAVEFORMS  ************
1664                                      IF      @SCP("HOST","HOST")
1665      X:0030 X:0030                   ORG     X:IMGVAR_ADR,X:IMGVAR_ADR
1666      X:0030 X:0030         IMAGE_MODE DC     0
1667      X:0031 X:0031         ISTATUS   DC      0
1668      X:0032 X:0032         DSP_VERS  DC      VERSION                           ; code version must stay in loc,n 32!!
1669      X:0033 X:0033         DSP_FLAV  DC      FLAVOR                            ;  type of dsp support must stay in loc,n 33!!
1670                            ; The next three locations are for tracking the readout timing for gain
1671                            ; calculation, exp-int calculation, and greed factor calculation
1672                            ; They are locations 0x34, 35, and 36
1673      X:0034 X:0034         INTTIM    DC      INT_TIM                           ; per-pixel integration in Leach units
1674      X:0035 X:0035         RDELAY    DC      R_DELAY                           ; serial overlap in Leach units
1675      X:0036 X:0036         SIDELAY   DC      SI_DELAY                          ; parallel overlap in Leach units
1676      X:0037 X:0037         BINBIT    DC      2                                 ; Bit representation of bin factor, bits 1-5
1677                                                                                ; 2 = bit 1 set. Bit zero not used.
1678                                      ENDIF
1679   
1680                            ; Command table - make sure there are exactly 32 entries in it
1681                                      IF      @SCP("HOST","HOST")
1682      X:0080 X:0080                   ORG     X:COM_TBL,X:COM_TBL               ; Download address
1683                                      ELSE
1685                                      ENDIF
1686      X:0080 X:0080                   DC      'IDL',IDL                         ; Put CCD in IDLE mode
1687      X:0082 X:0082                   DC      'STP',STP                         ; Exit IDLE mode
1688      X:0084 X:0084                   DC      'SBV',SETBIAS                     ; Set DC bias supply voltages
1689      X:0086 X:0086                   DC      'RDC',RDCCD                       ; Begin CCD readout
1690      X:0088 X:0088                   DC      'CLR',CLEAR                       ; Fast clear the CCD
1691      X:008A X:008A                   DC      'SGN',ST_GAIN                     ; Set video processor gain
1692      X:008C X:008C                   DC      'SMX',SET_MUX                     ; Set clock driver MUX output
1693   
1694      X:008E X:008E                   DC      'ABR',ABR_RDC                     ; Abort readout
1695      X:0090 X:0090                   DC      'CRD',CONT_RD                     ; Continue reading out
1696      X:0092 X:0092                   DC      'CSW',CLR_SWS                     ; Clear analog switches to lower power
1697      X:0094 X:0094                   DC      'SOS',SEL_OS                      ; Select output source
1698      X:0096 X:0096                   DC      'RCC',READ_CONTROLLER_CONFIGURATION
1699      X:0098 X:0098                   DC      'SSS',SET_SUBARRAY_SIZES
1700      X:009A X:009A                   DC      'SSP',SET_SUBARRAY_POSITIONS
1701      X:009C X:009C                   DC      'DON',START                       ; Nothing special
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  tim.s  Page 33



1702      X:009E X:009E                   DC      'OSH',OPEN_SHUTTER
1703      X:00A0 X:00A0                   DC      'CSH',CLOSE_SHUTTER
1704      X:00A2 X:00A2                   DC      'PON',PWR_ON                      ; Turn on all camera biases and clocks
1705      X:00A4 X:00A4                   DC      'POF',PWR_OFF                     ; Turn +/- 15V power supplies off
1706      X:00A6 X:00A6                   DC      'SET',SET_EXP_TIME                ; Set exposure time
1707      X:00A8 X:00A8                   DC      'SEX',START_FT_EXPOSURE           ; Goes to mode-dependent jump table
1708      X:00AA X:00AA                   DC      'AEX',ABORT_EXPOSURE
1709      X:00AC X:00AC                   DC      'STG',SET_TRIGGER                 ;  Set Trigger Mode on or off
1710      X:00AE X:00AE                   DC      'SIP',SET_IMAGE_PARAM
1711      X:00B0 X:00B0                   DC      'SRC',SET_ROWS_COLUMNS            ; Set NSR, NPR, and binning
1712      X:00B2 X:00B2                   DC      'INF',GET_INFO                    ; info command for versioning and more
1713      X:00B4 X:00B4                   DC      ,0,START,0,START,0,START,0,START
1714   
1715                                      IF      @SCP("HOST","HOST")
1716      Y:0000 Y:0000                   ORG     Y:0,Y:0                           ; Download address
1717                                      ELSE
1719                                      ENDIF
1720   
1721                            ; NSR, NPR, NSBIN, and NPBIN are set by SET_ROWS_COLUMNS
1722      Y:0000 Y:0000         GAIN      DC      0                                 ; Video processor gain and integrator speed
1723      Y:0001 Y:0001         NSR       DC      1072                              ; Number Serial Read, prescan + image + bias
1724      Y:0002 Y:0002         NPR       DC      1030                              ; Number Parallel Read
1725      Y:0003 Y:0003         NS_CLR    DC      1070                              ; To clear serial register, twice
1726      Y:0004 Y:0004         NPCLR     DC      2057                              ; To clear parallel register, twice
1727      Y:0005 Y:0005         NSBIN     DC      1                                 ; Serial binning parameter
1728      Y:0006 Y:0006         NPBIN     DC      1                                 ; Parallel binning parameter
1729      Y:0007 Y:0007         NROWS     DC      1030                              ; Number of physical rows in CCD
1730      Y:0008 Y:0008         NCOLS     DC      1072                              ; Number of physical columns in CCD
1731   
1732                            ; Miscellaneous definitions
1733                            ; Delete TST_DAT since it isn't used.  Need the space so S_SIZE doesn't barf.
1734                            ; TST_DAT       DC      0               ; Temporary definition for test images
1735      Y:0009 Y:0009         SH_DEL    DC      3                                 ; Delay in milliseconds between shutter closing
1736                                                                                ;   and image readout.  Actual delay is 1.5x
1737                                                                                ;   as long as advertised, e.g. 4.5 ms for 3.
1738      Y:000A Y:000A         CONFIG    DC      CC                                ; Controller configuration
1739                            ; Readout peculiarity parameters
1740                             SERIAL_SKIP
1741      Y:000B Y:000B                   DC      SERIAL_SKIP_LEFT                  ; Serial skipping waveforms
1742      Y:000C Y:000C         SERWAVLEN DC      5                                 ; Serial read waveform table length
1743                             SERIAL_CLOCK
1744      Y:000D Y:000D                   DC      SERIAL_CLOCK_LEFT                 ; Serial waveform table
1745                             INITIAL_CLOCK
1746      Y:000E Y:000E                   DC      INITIAL_CLOCK_LEFT                ; Serial waveform table
1747                             PARALLEL_CLOCK
1748      Y:000F Y:000F                   DC      IS_PARALLEL                       ; Addr. of parallel clocking
1749   
1750                             NSERIALS_READ
1751      Y:0010 Y:0010                   DC      0                                 ; Number of serials to read
1752      Y:0011 Y:0011         NSCLR     DC      0                                 ; Number of waveforms in fast mode
1753      Y:0012 Y:0012         NSKIP1    DC      0                                 ; Number of waveforms in fast mode
1754      Y:0013 Y:0013         NREAD     DC      0                                 ; Number of waveforms in fast mode
1755      Y:0014 Y:0014         NSKIP2    DC      0                                 ; Number of waveforms in fast mode
1756      Y:0015 Y:0015         NBIAS     DC      0                                 ; Number of waveforms in fast mode
1757   
1758                            ; These three parameters are read from the READ_TABLE when needed by the
1759                            ;   RDCCD routine as it loops through the required number of boxes
1760      Y:0016 Y:0016         NP_SKIP   DC      0                                 ; Number of rows to skip
1761      Y:0017 Y:0017         NS_SKP1   DC      0                                 ; Number of serials to clear before read
1762      Y:0018 Y:0018         NS_SKP2   DC      0                                 ; Number of serials to clear after read
1763   
1764                            ; Subimage readout parameters. Ten subimage boxes maximum.
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  tim.s  Page 34



1765                            ; All subimage boxes are the same size, NS_READ x NP_READ
1766                            ; NR_BIAS, NS_READ, and NP_READ are set by SET_SUBARRAY_SIZES
1767                            ; The READ_TABLE entries and implicitly NBOXES are set by SET_SUBARRAY_POSITIONS
1768      Y:0019 Y:0019         NBOXES    DC      0                                 ; Number of boxes to read
1769      Y:001A Y:001A         NR_BIAS   DC      0                                 ; Number of bias pixels to read
1770      Y:001B Y:001B         NS_READ   DC      0                                 ; Number of columns per box
1771      Y:001C Y:001C         NP_READ   DC      0                                 ; Number of rows per box
1772      Y:001D Y:001D         READ_TABLE DC     0,0,0                             ; #1 = Number of rows to clear,
1773      Y:0020 Y:0020                   DC      0,0,0                             ; #2 = Number of columns to skip before
1774      Y:0023 Y:0023                   DC      0,0,0                             ;   subimage read
1775      Y:0026 Y:0026                   DC      0,0,0                             ; #3 = Number of columns to clear after
1776      Y:0029 Y:0029                   DC      0,0,0                             ;   subimage read to get to overscan area
1777      Y:002C Y:002C                   DC      0,0,0
1778      Y:002F Y:002F                   DC      0,0,0
1779      Y:0032 Y:0032                   DC      0,0,0
1780      Y:0035 Y:0035                   DC      0,0,0
1781   
1782                            ; IMAGE_MODE, SROWS, IFRAMES, and INTERVAL are set by SET_IMAGE_PARAM
1783                            ; UBSROWS is set later on by UB_CONV.  S_SIZE is hardwired.
1784      Y:0038 Y:0038         SROWS     DC      1                                 ; Number of Storage image rows to Loop over
1785      Y:0039 Y:0039         UBSROWS   DC      1                                 ; SROWS in unbinned pixels.  Set by UB_CONV
1786      Y:003A Y:003A         IFRAMES   DC      1                                 ; Number of Series frames to Loop over
1787      Y:003B Y:003B         S_SIZE    DC      1033                              ; Number of rows in the Storage Array
1788                                                                                ; NOTE: Not equal to # rows in image area!
1789      Y:003C Y:003C         INTERVAL  DC      7                                 ; Interval to pause for soft trigger
1790      Y:003D Y:003D         AMPVAL    DC      0                                 ; Amplifier selected
1791      Y:003E Y:003E         IFLPCNT   DC      0                                 ; 24-bit IFRAMES loop counter for timmisc.s
1792      Y:003F Y:003F         TESTLOC1  DC      0                                 ; Test location
1793                            ; NOTE:  TESTLOC1 is address 63 in the Y memory.  There are addressing problems
1794                            ; starting at the next address (64).
1795   
1796                            ; Include the waveform table
1797                                      INCLUDE "HIPO_Red.waveforms.s"            ; Readout and clocking waveforms
1798                            ; Waveform tables and definitions for the e2v CCD47 1K sq. frame
1799                            ; transfer CCD for HIPO.
1800                            ;
1801   
1802                            ; CCD clock voltage definitions
1803      000000                VIDEO     EQU     $000000                           ; Video processor board select = 0
1804      002000                CLK2      EQU     $002000                           ; Clock driver board select = 2
1805      003000                CLK3      EQU     $003000                           ; Clock driver board select = 3
1806      000800                CLK_ZERO  EQU     $000800                           ; Zero volts on clock driver line
1807      000800                BIAS_ZERO EQU     $000800                           ;
1808   
1809                            ; For HIPO uncomment one of these lines at a time
1810                            ;INT_TIM        EQU     $040000 ; 0.85 us/px - use gain 4.75, experimental
1811      080000                INT_TIM   EQU     $080000                           ; 1.0 us/px - use gain 4.75, doesn't clip
1812                            ;INT_TIM        EQU     $080000 ; 1.0 us/px - use gain 9.5, clips @ PRAM
1813                            ;INT_TIM        EQU     $150000 ; 1.5 us/px - use gain 9.5, clips @ ADC
1814                            ;INT_TIM                EQU     $1D0000 ; 1.8 us/px - use gain 4.75, best overall
1815                            ;INT_TIM        EQU     $470000 ; 3.5 us/px - use gain 2, slower & quieter
1816                            ;INT_TIM        EQU     $920000 ; 6.5 us/px - use gain 1, slower & quieter
1817                            ;INT_TIM        EQU     $6D0000 ; 5.0 us/px - use gain 2 or 4.75, clips @ ADC
1818   
1819                            ;ADC_TIM                EQU     $0C0000 ; Slow ADC TIME
1820      000000                ADC_TIM   EQU     $000000                           ; Fast ADC TIME
1821                            ; Delay numbers in clocking
1822                            ;SI_DELAY       EQU     $C00000 ; Started with 0x36 Parallel clock delay
1823                            ;SI_DELAY       EQU     $860000 ; Fast Storage/Image Delay
1824      860000                SI_DELAY  EQU     $860000                           ; Slower Storage/Image Delay
1825                            ;R_DELAY                EQU     $080000 ; Serial register transfer delay
1826      000000                R_DELAY   EQU     $000000                           ; Fast serial regisiter transfer delay
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 35



1827      000000                SKIP_DELAY EQU    $000000                           ; Serial register skipping delay
1828   
1829                            ; Clock voltages in volts                       Old     New     Data Sheet
1830      2.500000E+000         RG_HI     EQU     +2.5                              ; Reset                  1.5     3.0     4
1831      -9.500000E+000        RG_LO     EQU     -9.5                              ;                       -3.0    -9.0    -8
1832      1.500000E+000         R_HI      EQU     +1.5                              ; Serials                4.65    4.5     2
1833      -8.500000E+000        R_LO      EQU     -8.5                              ;                       -6.6    -6.5    -8
1834      2.500000E+000         SI_HI     EQU     +2.5                              ; Parallels              3.7     4.0     4
1835      -9.500000E+000        SI_LO     EQU     -9.5                              ;                       -6.9    -7.0    -8
1836      2.500000E+000         DG_HI     EQU     +2.5                              ; Dump Gate
1837      -9.500000E+000        DG_LO     EQU     -9.5                              ;                                       -8
1838   
1839                            ; DC Bias voltages in volts                     Old     New     Data Sheet
1840      2.050000E+001         VODL      EQU     20.5                              ; Output Drain Left     25.1    24      21
1841      2.050000E+001         VODR      EQU     20.5                              ; Output Drain Right    25.1    24
1842      9.000000E+000         VRDL      EQU     9.00                              ; Reset Drain Left      12.2    11      10
1843      9.000000E+000         VRDR      EQU     9.00                              ; Reset Drain Right
1844      -6.500000E+000        VOG       EQU     -6.5                              ; Output Gate           -1.2    -3      -5
1845      -9.500000E+000        VABG      EQU     -9.5                              ; Anti-blooming gate    -5.0    -5      -8
1846      000700                OFFSET    EQU     $700
1847      000700                OFFSET0   EQU     $700                              ; Left Side Of Frame
1848      0006EF                OFFSET1   EQU     $6EF                              ; Right Side Of Frame
1849   
1850                            ; Define switch state bits for the lower CCD clock driver bank CLK2
1851      000001                H1L       EQU     1                                 ; Serial #1 Left, Pin 1 - clock 0
1852      000002                H2L       EQU     2                                 ; Serial #2 Left, Pin 2 - clock 1
1853      000004                H3L       EQU     4                                 ; Serial #3 Left, Pin 3 - clock 2
1854      000008                H1R       EQU     8                                 ; Serial #1 Right, Pin 4 - clock 3
1855      000010                H2R       EQU     $10                               ; Serial #2 Right, Pin 5 - clock 4
1856      000020                H3R       EQU     $20                               ; Serial #2 Right, Pin 6 - clock 5
1857      000100                RGL       EQU     $100                              ; Reset Gate Left, Pin 9 - clock 8
1858      000200                RGR       EQU     $200                              ; Reset Gate Right, Pin 10 - clock 9
1859   
1860                            ; Pins 9-12 are not used
1861   
1862                            ; Define switch state bits for the upper CCD clock driver bank CLK3
1863      000001                I1        EQU     1                                 ; Image, phase #1, Pin 13 - clock 12
1864      000002                I2        EQU     2                                 ; Image, phase #2, Pin 14 - clock 13
1865      000004                I3        EQU     4                                 ; Image, phase #3, Pin 15 - clock 14
1866      000008                S1        EQU     8                                 ; Storage, phase #1, Pin 16 - clock 15
1867      000010                S2        EQU     $10                               ; Storage, phase #2, Pin 17 - clock 16
1868      000020                S3        EQU     $20                               ; Storage, phase #3, Pin 18 - clock 17
1869      000100                DG        EQU     $100                              ; Dump Gate, Pin 34 - clock 20
1870   
1871                            ;  ***  Definitions for Y: memory waveform tables  *****
1872                            ; Clock only the Storage clocks : S1->S2->S3
1873                            S_PARALLEL
1874      Y:0040 Y:0040                   DC      END_S_PARALLEL-S_PARALLEL-2
1875      Y:0041 Y:0041                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1876                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
1877      Y:0042 Y:0042                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00
1878      Y:0043 Y:0043                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00
1879      Y:0044 Y:0044                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3
1880      Y:0045 Y:0045                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3
1881      Y:0046 Y:0046                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3
1882      Y:0047 Y:0047                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
1883                            END_S_PARALLEL
1884   
1885                            ; Reverse clock only the Storage clocks : S1->S3->S2->S1
1886                            ; Use in pipelined occultation mode
1887                            R_S_PARALLEL
1888      Y:0048 Y:0048                   DC      END_R_S_PARALLEL-R_S_PARALLEL-2
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 36



1889      Y:0049 Y:0049                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1890      Y:004A Y:004A                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3
1891      Y:004B Y:004B                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3
1892      Y:004C Y:004C                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3
1893      Y:004D Y:004D                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00
1894      Y:004E Y:004E                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00
1895      Y:004F Y:004F                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
1896                            END_R_S_PARALLEL
1897   
1898                            ; Clock only the Storage clocks : S1->S2->S3 with DG
1899                            S_CLEAR
1900      Y:0050 Y:0050                   DC      END_S_CLEAR-S_CLEAR-2
1901      Y:0051 Y:0051                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1902                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
1903      Y:0052 Y:0052                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00+DG
1904      Y:0053 Y:0053                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00+DG
1905      Y:0054 Y:0054                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3+DG
1906      Y:0055 Y:0055                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3+DG
1907      Y:0056 Y:0056                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3+DG
1908      Y:0057 Y:0057                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
1909                            END_S_CLEAR
1910                            ; 2 microsecond delay before readout starts may be needed here
1911                            ;       DC      CLK3+$600000+I1+00+00+S1+00+0000
1912   
1913                            ; Clock both the Storage and Image clocks : I1->I2->I3 and S1->S2->S3
1914                            IS_PARALLEL
1915      Y:0058 Y:0058                   DC      END_IS_PARALLEL-IS_PARALLEL-2
1916      Y:0059 Y:0059                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1917                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
1918      Y:005A Y:005A                   DC      CLK3+SI_DELAY+I1+I2+00+S1+S2+00
1919      Y:005B Y:005B                   DC      CLK3+SI_DELAY+00+I2+00+00+S2+00
1920      Y:005C Y:005C                   DC      CLK3+SI_DELAY+00+I2+I3+00+S2+S3
1921      Y:005D Y:005D                   DC      CLK3+SI_DELAY+00+00+I3+00+00+S3
1922      Y:005E Y:005E                   DC      CLK3+SI_DELAY+I1+00+I3+S1+00+S3
1923      Y:005F Y:005F                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
1924                            END_IS_PARALLEL
1925   
1926                            ; Clock both the Storage and Image clocks : I1->I2->I3 and S1->S2->S3
1927                            IS_CLEAR
1928      Y:0060 Y:0060                   DC      IS_CLEAR_END-IS_CLEAR-2
1929      Y:0061 Y:0061                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1930                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+00 ; Probably not needed
1931      Y:0062 Y:0062                   DC      CLK3+SI_DELAY+I1+I2+00+S1+S2+00+DG
1932      Y:0063 Y:0063                   DC      CLK3+SI_DELAY+00+I2+00+00+S2+00+DG
1933      Y:0064 Y:0064                   DC      CLK3+SI_DELAY+00+I2+I3+00+S2+S3+DG
1934      Y:0065 Y:0065                   DC      CLK3+SI_DELAY+00+00+I3+00+00+S3+DG
1935      Y:0066 Y:0066                   DC      CLK3+SI_DELAY+I1+00+I3+S1+00+S3+DG
1936      Y:0067 Y:0067                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
1937                            IS_CLEAR_END
1938   
1939                            DUMP_SERIAL
1940      Y:0068 Y:0068                   DC      END_DUMP_SERIAL-DUMP_SERIAL-2
1941      Y:0069 Y:0069                   DC      CLK2+SI_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1942      Y:006A Y:006A                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
1943      Y:006B Y:006B                   DC      CLK2+SI_DELAY+RGL+RGR+000+000+000+000+000+000
1944      Y:006C Y:006C                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+00
1945      Y:006D Y:006D                   DC      CLK2+SI_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1946                            END_DUMP_SERIAL
1947                                    COMMENT *
1948                            ; Michigan AIMO clocking - this is vestigial and commented out
1949                            PARALLEL DC     PARALLEL_CLEAR-PARALLEL-2
1950                                    DC      CLK2+$000000+RGL+RGR+H1L+H1R+H2L+H2R+00+000+000+00
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 37



1951                                    DC      CLK3+P_DELAY+00+00+I3
1952                                    DC      CLK3+P_DELAY+00+00+I3
1953                                    DC      CLK3+P_DELAY+I1+00+I3
1954                                    DC      CLK3+P_DELAY+I1+00+00
1955                                    DC      CLK3+P_DELAY+I1+I2+00
1956                                    DC      CLK3+P_DELAY+00+I2+00
1957                                    DC      CLK3+P_DELAY+00+I2+I3
1958                                    DC      CLK3+P_DELAY+00+00+I3
1959                                    DC      CLK3+P_DELAY+00+00+I3
1960                                    DC      CLK3+P_DELAY+00+00+00
1961                                    *
1962   
1963                            ; For serial clocking we know that the serial registers are laid out as
1964                            ; follows for a backside part per communication with Paul Jorden:
1965   
1966                            ;          Right Side               Left Side
1967                            ;       OG  3  2  1  3 .........  3  2  1  3  OG
1968   
1969                            ; Left amp is   2 -> 1 -> 3
1970                            ; Right amp is  1 -> 2 -> 3
1971   
1972                            ; For a frontside part the left and right are reversed.
1973                            ; Parallel phase 3 dumps into serial 1 and 2.
1974   
1975                            ; Between serial clock code lumps the serials are left as follows:
1976                            ; LEFT  Phase 2 L and R both high
1977                            ; RIGHT Phase 1 L and R both high
1978                            ; SPLIT H1R and H2L are high
1979   
1980                            ; Video processor bit definition
1981                            ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
1982   
1983                            SERIAL_IDLE                                         ; Split serial
1984      Y:006E Y:006E                   DC      END_SERIAL_IDLE-SERIAL_IDLE-2
1985      Y:006F Y:006F                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1986      Y:0070 Y:0070                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
1987      Y:0071 Y:0071                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
1988      Y:0072 Y:0072                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
1989      Y:0073 Y:0073                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
1990      Y:0074 Y:0074                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
1991      Y:0075 Y:0075                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
1992      Y:0076 Y:0076                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
1993      Y:0077 Y:0077                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
1994      Y:0078 Y:0078                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
1995      Y:0079 Y:0079                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
1996      Y:007A Y:007A                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
1997                            ; Not needed, so comment out
1998                            ;       DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
1999                            END_SERIAL_IDLE
2000   
2001                            ; The following waveforms are for binned operation.  This is tricky with the
2002                            ; CCD47 because it doesn't have a summing well.  The reset level integration
2003                            ; has to happen before serial 3 drops for the first time and the data level
2004                            ; integration has to happen after it drops for the last time.  The initial
2005                            ; clocks go through the reset integration, the serial clocks are the
2006                            ; intervening clocks for additional pixels binned with the first one, and
2007                            ; the video process is left to do the last clock and data integration.
2008   
2009                            INITIAL_CLOCK_SPLIT                                 ; Both amplifiers
2010      Y:007B Y:007B                   DC      END_INITIAL_CLOCK_SPLIT-INITIAL_CLOCK_SPLIT-2
2011      Y:007C Y:007C                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2012      Y:007D Y:007D                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 38



2013      Y:007E Y:007E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2014      Y:007F Y:007F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2015      Y:0080 Y:0080                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2016      Y:0081 Y:0081                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2017      Y:0082 Y:0082                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2018      Y:0083 Y:0083                   DC      $00F020                           ; Transmit A/D data to host
2019      Y:0084 Y:0084                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2020      Y:0085 Y:0085                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2021      Y:0086 Y:0086                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2022                            END_INITIAL_CLOCK_SPLIT
2023   
2024                            INITIAL_CLOCK_RIGHT                                 ; Serial right, Swap S1L and S2L
2025      Y:0087 Y:0087                   DC      END_INITIAL_CLOCK_RIGHT-INITIAL_CLOCK_RIGHT-2
2026      Y:0088 Y:0088                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2027      Y:0089 Y:0089                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2028      Y:008A Y:008A                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2029      Y:008B Y:008B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2030      Y:008C Y:008C                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2031      Y:008D Y:008D                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2032      Y:008E Y:008E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2033      Y:008F Y:008F                   DC      $00F021                           ; Transmit A/D data to host
2034      Y:0090 Y:0090                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2035      Y:0091 Y:0091                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2036      Y:0092 Y:0092                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2037                            END_INITIAL_CLOCK_RIGHT
2038   
2039                            INITIAL_CLOCK_LEFT                                  ; Serial left, Swap S1R and S2R
2040      Y:0093 Y:0093                   DC      END_INITIAL_CLOCK_LEFT-INITIAL_CLOCK_LEFT-2
2041      Y:0094 Y:0094                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2042      Y:0095 Y:0095                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2043      Y:0096 Y:0096                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2044      Y:0097 Y:0097                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2045      Y:0098 Y:0098                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2046      Y:0099 Y:0099                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2047      Y:009A Y:009A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2048      Y:009B Y:009B                   DC      $00F000                           ; Transmit A/D data to host
2049      Y:009C Y:009C                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2050      Y:009D Y:009D                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2051      Y:009E Y:009E                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2052                            END_INITIAL_CLOCK_LEFT
2053   
2054                            SERIAL_CLOCK_SPLIT                                  ; Both amplifiers
2055      Y:009F Y:009F                   DC      END_SERIAL_CLOCK_SPLIT-SERIAL_CLOCK_SPLIT-2
2056      Y:00A0 Y:00A0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2057      Y:00A1 Y:00A1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2058      Y:00A2 Y:00A2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2059      Y:00A3 Y:00A3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2060      Y:00A4 Y:00A4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2061      Y:00A5 Y:00A5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2062                            END_SERIAL_CLOCK_SPLIT
2063   
2064                            SERIAL_CLOCK_RIGHT                                  ; Serial right, Swap S1L and S2L
2065      Y:00A6 Y:00A6                   DC      END_SERIAL_CLOCK_RIGHT-SERIAL_CLOCK_RIGHT-2
2066      Y:00A7 Y:00A7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2067      Y:00A8 Y:00A8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2068      Y:00A9 Y:00A9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2069      Y:00AA Y:00AA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2070      Y:00AB Y:00AB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2071      Y:00AC Y:00AC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2072                            END_SERIAL_CLOCK_RIGHT
2073   
2074                            SERIAL_CLOCK_LEFT                                   ; Serial left, Swap S1R and S2R
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 39



2075      Y:00AD Y:00AD                   DC      END_SERIAL_CLOCK_LEFT-SERIAL_CLOCK_LEFT-2
2076      Y:00AE Y:00AE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2077      Y:00AF Y:00AF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2078      Y:00B0 Y:00B0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2079      Y:00B1 Y:00B1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2080      Y:00B2 Y:00B2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2081      Y:00B3 Y:00B3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2082                            END_SERIAL_CLOCK_LEFT
2083   
2084                            VIDEO_PROCESS
2085      Y:00B4 Y:00B4                   DC      END_VIDEO_PROCESS-VIDEO_PROCESS-2
2086                            CCLK_1                                              ; The following line is overwritten by timmisc.s
2087      Y:00B5 Y:00B5                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2088      Y:00B6 Y:00B6                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2089      Y:00B7 Y:00B7                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2090                            CCLK_2                                              ; The following line is overwritten by timmisc.s
, but is correct as is.
2091                            ; Actually it shouldn't be needed so comment it out.
2092                            ;       DC      CLK2+S_DLY+S1R+S2R+000+S1L+S2L+000+000+000+000+000
2093                            END_VIDEO_PROCESS
2094   
2095                            ; Starting Y: address of circular waveforms for no-overhead access
2096      0000C0                STRT_CIR  EQU     $C0
2097      000620                ROM_DISP  EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+STRT_CIR
2098      000660                DAC_DISP  EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+$100
2099   
2100                            ; Check for Y: data memory overflow
2101                                      IF      @CVS(N,*)>STRT_CIR
2103                                      ENDIF                                     ;  will not overflow
2104   
2105                            ; The fast serial code with the circulating address register must start
2106                            ;   on a boundary that is a multiple of the address register modulus.
2107   
2108                                      IF      @SCP("HOST","HOST")
2109      Y:00C0 Y:00C0                   ORG     Y:STRT_CIR,Y:STRT_CIR             ; Download address
2110                                      ELSE
2112                                      ENDIF
2113   
2114                            ; This is an area to copy in the serial fast binned waveforms from high Y memory
2115                            ; It is 0x28 = 40 locations long, enough to put in a binned-by-five waveform
2116                            ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2117                            SERIAL_READ
2118      Y:00C0 Y:00C0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2119      Y:00C1 Y:00C1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2120      Y:00C2 Y:00C2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2121      Y:00C3 Y:00C3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2122      Y:00C4 Y:00C4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2123      Y:00C5 Y:00C5                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2124                            SXMIT
2125      Y:00C6 Y:00C6                   DC      $00F000                           ; Transmit A/D data to host
2126      Y:00C7 Y:00C7                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2127      Y:00C8 Y:00C8                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2128      Y:00C9 Y:00C9                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2129      Y:00CA Y:00CA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2130      Y:00CB Y:00CB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2131      Y:00CC Y:00CC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2132      Y:00CD Y:00CD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2133      Y:00CE Y:00CE                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2134      Y:00CF Y:00CF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2135      Y:00D0 Y:00D0                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2136      Y:00D1 Y:00D1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2137      Y:00D2 Y:00D2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 40



2138      Y:00D3 Y:00D3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2139      Y:00D4 Y:00D4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2140      Y:00D5 Y:00D5                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2141      Y:00D6 Y:00D6                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2142      Y:00D7 Y:00D7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2143      Y:00D8 Y:00D8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2144      Y:00D9 Y:00D9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2145      Y:00DA Y:00DA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2146      Y:00DB Y:00DB                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2147      Y:00DC Y:00DC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2148      Y:00DD Y:00DD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2149      Y:00DE Y:00DE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2150      Y:00DF Y:00DF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2151      Y:00E0 Y:00E0                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2152      Y:00E1 Y:00E1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2153      Y:00E2 Y:00E2                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2154      Y:00E3 Y:00E3                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2155      Y:00E4 Y:00E4                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2156                            END_SERIAL
2157   
2158                            ; Serial clocking waveform for skipping
2159                                      IF      @SCP("HOST","HOST")
2160      Y:00E8 Y:00E8                   ORG     Y:STRT_CIR+$28,Y:STRT_CIR+$28     ; Download address
2161                                      ELSE
2163                                      ENDIF
2164   
2165                            ; There are three serial skip waveforms that must all be the same length
2166                            SERIAL_SKIP_LEFT
2167                            ;       DC      END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-2
2168      Y:00E8 Y:00E8                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2169      Y:00E9 Y:00E9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2170      Y:00EA Y:00EA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2171      Y:00EB Y:00EB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2172      Y:00EC Y:00EC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2173      Y:00ED Y:00ED                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2174                            END_SERIAL_SKIP_LEFT
2175   
2176                                      IF      @SCP("HOST","HOST")
2177      Y:00F0 Y:00F0                   ORG     Y:STRT_CIR+$30,Y:STRT_CIR+$30     ; Download address
2178                                      ELSE
2180                                      ENDIF
2181   
2182                            SERIAL_SKIP_RIGHT
2183                            ;       DC      END_SERIAL_SKIP_RIGHT-SERIAL_SKIP_RIGHT-2
2184      Y:00F0 Y:00F0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2185      Y:00F1 Y:00F1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2186      Y:00F2 Y:00F2                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2187      Y:00F3 Y:00F3                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2188      Y:00F4 Y:00F4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2189      Y:00F5 Y:00F5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2190                            END_SERIAL_SKIP_RIGHT
2191   
2192                                      IF      @SCP("HOST","HOST")
2193      Y:00F8 Y:00F8                   ORG     Y:STRT_CIR+$38,Y:STRT_CIR+$38     ; Download address
2194                                      ELSE
2196                                      ENDIF
2197   
2198                            SERIAL_SKIP_SPLIT
2199                            ;       DC      END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-2
2200      Y:00F8 Y:00F8                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2201      Y:00F9 Y:00F9                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2202      Y:00FA Y:00FA                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 41



2203      Y:00FB Y:00FB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2204      Y:00FC Y:00FC                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2205      Y:00FD Y:00FD                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2206                            END_SERIAL_SKIP_SPLIT
2207   
2208                            ; Put all the following code in SRAM.
2209                                      IF      @SCP("HOST","HOST")
2210      Y:0100 Y:0100                   ORG     Y:$100,Y:$100                     ; Download address
2211                                      ELSE
2213                                      ENDIF
2214   
2215                            ; Initialization of clock driver and video processor DACs and switches
2216      Y:0100 Y:0100         DACS      DC      END_DACS-DACS-1
2217      Y:0101 Y:0101                   DC      (CLK2<<8)+(0<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S1 Left High, pin 1
2218      Y:0102 Y:0102                   DC      (CLK2<<8)+(1<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S1 Left Low
2219      Y:0103 Y:0103                   DC      (CLK2<<8)+(2<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S2 Left Right High, pin 2
2220      Y:0104 Y:0104                   DC      (CLK2<<8)+(3<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S2 Left Low
2221      Y:0105 Y:0105                   DC      (CLK2<<8)+(4<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S3 Left High, pin 3
2222      Y:0106 Y:0106                   DC      (CLK2<<8)+(5<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S3 Left Low
2223      Y:0107 Y:0107                   DC      (CLK2<<8)+(6<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S1 Right High, pin 4
2224      Y:0108 Y:0108                   DC      (CLK2<<8)+(7<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S1 Right Low
2225      Y:0109 Y:0109                   DC      (CLK2<<8)+(8<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S2 Right High, pin 5
2226      Y:010A Y:010A                   DC      (CLK2<<8)+(9<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S2 Right Low
2227      Y:010B Y:010B                   DC      (CLK2<<8)+(10<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S3 Right High, pin 6
2228      Y:010C Y:010C                   DC      (CLK2<<8)+(11<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S3 Right Low
2229      Y:010D Y:010D                   DC      (CLK2<<8)+(12<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 7
2230      Y:010E Y:010E                   DC      (CLK2<<8)+(13<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2231      Y:010F Y:010F                   DC      (CLK2<<8)+(14<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 8
2232      Y:0110 Y:0110                   DC      (CLK2<<8)+(15<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2233      Y:0111 Y:0111                   DC      (CLK2<<8)+(16<<14)+@CVI((RG_HI+10.0)/20.0*4095) ; RG Left High, pin 9
2234      Y:0112 Y:0112                   DC      (CLK2<<8)+(17<<14)+@CVI((RG_LO+10.0)/20.0*4095) ; RG Left Low
2235      Y:0113 Y:0113                   DC      (CLK2<<8)+(18<<14)+@CVI((RG_HI+10.0)/20.0*4095) ; RG Right High, pin 10
2236      Y:0114 Y:0114                   DC      (CLK2<<8)+(19<<14)+@CVI((RG_LO+10.0)/20.0*4095) ; RG Rightd Low
2237      Y:0115 Y:0115                   DC      (CLK2<<8)+(20<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 11
2238      Y:0116 Y:0116                   DC      (CLK2<<8)+(21<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2239      Y:0117 Y:0117                   DC      (CLK2<<8)+(22<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 12
2240      Y:0118 Y:0118                   DC      (CLK2<<8)+(23<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2241      Y:0119 Y:0119                   DC      (CLK2<<8)+(24<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; I1 High, pin 13
2242      Y:011A Y:011A                   DC      (CLK2<<8)+(25<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; I1 Low
2243      Y:011B Y:011B                   DC      (CLK2<<8)+(26<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; I2 High, pin 14
2244      Y:011C Y:011C                   DC      (CLK2<<8)+(27<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; I2 Low
2245      Y:011D Y:011D                   DC      (CLK2<<8)+(28<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; I3 High, pin 15
2246      Y:011E Y:011E                   DC      (CLK2<<8)+(29<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; I3 Low
2247      Y:011F Y:011F                   DC      (CLK2<<8)+(30<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; S1 High, pin 16
2248      Y:0120 Y:0120                   DC      (CLK2<<8)+(31<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; S1 Low
2249      Y:0121 Y:0121                   DC      (CLK2<<8)+(32<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; S2 High, pin 17
2250      Y:0122 Y:0122                   DC      (CLK2<<8)+(33<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; S2 Low
2251      Y:0123 Y:0123                   DC      (CLK2<<8)+(34<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; S3 High, pin 18
2252      Y:0124 Y:0124                   DC      (CLK2<<8)+(35<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; S3 Low
2253      Y:0125 Y:0125                   DC      (CLK2<<8)+(36<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 19
2254      Y:0126 Y:0126                   DC      (CLK2<<8)+(37<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2255      Y:0127 Y:0127                   DC      (CLK2<<8)+(38<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 33
2256      Y:0128 Y:0128                   DC      (CLK2<<8)+(39<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2257      Y:0129 Y:0129                   DC      (CLK2<<8)+(40<<14)+@CVI((DG_HI+10.0)/20.0*4095) ; DG High, pin 34
2258      Y:012A Y:012A                   DC      (CLK2<<8)+(41<<14)+@CVI((DG_LO+10.0)/20.0*4095) ; DG Low
2259      Y:012B Y:012B                   DC      (CLK2<<8)+(42<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 35
2260      Y:012C Y:012C                   DC      (CLK2<<8)+(43<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2261      Y:012D Y:012D                   DC      (CLK2<<8)+(44<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 36
2262      Y:012E Y:012E                   DC      (CLK2<<8)+(45<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2263      Y:012F Y:012F                   DC      (CLK2<<8)+(46<<14)+@CVI((VABG+10.0)/20.0*4095) ; Anti-Blooming Gate High, pin 37
2264      Y:0130 Y:0130                   DC      (CLK2<<8)+(47<<14)+@CVI((VABG+10.0)/20.0*4095) ; Anti-Blooming Gate Low
2265   
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 42



2266                            ; Set gain and integrator speed
2267      Y:0131 Y:0131                   DC      $0c3fdd                           ; Gain, speed
2268   
2269                            ;       DC      $0c3f77                 ; Gain x1, fast integ speed, board #0
2270                            ;       DC      $0c3fbb                 ; Gain x2, fast integ speed, board #0
2271                            ;       DC      $0c3fdd                 ; Gain x4.75, fast integ speed, board #0
2272                            ;       DC      $0c3fee                 ; Gain x9.50, fast integ speed, board #0
2273                            ;       DC      $0c3cee                 ; Gain x9.50, slow integ speed, board #0
2274   
2275                            ; Input offset voltages for DC coupling. Target is U4#6 = 24 volts
2276      Y:0132 Y:0132                   DC      $0c0800                           ; Input offset, ch. A
2277      Y:0133 Y:0133                   DC      $0c8800                           ; Input offset, ch. B
2278   
2279                            ; Output offset voltages
2280      Y:0134 Y:0134                   DC      $0c4000+OFFSET0                   ; Output video offset, ch. A
2281      Y:0135 Y:0135                   DC      $0cc000+OFFSET1                   ; Output video offset, ch. B
2282   
2283                            ; Output and reset drain DC bias voltages
2284      Y:0136 Y:0136                   DC      $0d0000+@CVI((VODL-7.50)/22.5*4095) ; VODL pin #1
2285      Y:0137 Y:0137                   DC      $0d4000+@CVI((VODR-7.50)/22.5*4095) ; VODR pin #2
2286      Y:0138 Y:0138                   DC      $0d8000+@CVI((VRDL-5.00)/15.0*4095) ; VRDL pin #3
2287      Y:0139 Y:0139                   DC      $0dc000+@CVI((VRDR-5.00)/15.0*4095) ; VRDR pin #4
2288   
2289   
2290                            ; Output and anti-blooming gates
2291      Y:013A Y:013A                   DC      $0f0000+BIAS_ZERO                 ; Unused pin #9
2292      Y:013B Y:013B                   DC      $0f4000+BIAS_ZERO                 ; Unused pin #10
2293      Y:013C Y:013C                   DC      $0f8000+@CVI((VOG+10.0)/20.0*4095) ; Unused pin #11
2294      Y:013D Y:013D                   DC      $0fc000+@CVI((VABG+10.0)/20.0*4095) ; Unused pin #12
2295                            END_DACS
2296   
2297   
2298                            ;       These are the 15 fast serial read waveforms for left, right,
2299                            ;       and split reads for serial binning factors from 1 to 5.
2300   
2301                            ;       Unbinned waveforms
2302                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2303                            SERIAL_READ_LEFT_1
2304      Y:013E Y:013E                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2305      Y:013F Y:013F                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2306      Y:0140 Y:0140                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2307      Y:0141 Y:0141                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2308      Y:0142 Y:0142                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2309      Y:0143 Y:0143                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2310                            SXMIT_LEFT_1
2311      Y:0144 Y:0144                   DC      $00F000                           ; Transmit A/D data to host
2312      Y:0145 Y:0145                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2313      Y:0146 Y:0146                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2314      Y:0147 Y:0147                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2315      Y:0148 Y:0148                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2316      Y:0149 Y:0149                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2317      Y:014A Y:014A                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2318                            END_SERIAL_READ_LEFT_1
2319   
2320                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2321                            SERIAL_READ_RIGHT_1
2322      Y:014B Y:014B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2323      Y:014C Y:014C                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2324      Y:014D Y:014D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2325      Y:014E Y:014E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2326      Y:014F Y:014F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2327      Y:0150 Y:0150                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 43



2328                            SXMIT_RIGHT_1
2329      Y:0151 Y:0151                   DC      $00F021                           ; Transmit A/D data to host
2330      Y:0152 Y:0152                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2331      Y:0153 Y:0153                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2332      Y:0154 Y:0154                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2333      Y:0155 Y:0155                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2334      Y:0156 Y:0156                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2335      Y:0157 Y:0157                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2336                            END_SERIAL_READ_RIGHT_1
2337   
2338                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2339                            SERIAL_READ_SPLIT_1
2340      Y:0158 Y:0158                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2341      Y:0159 Y:0159                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2342      Y:015A Y:015A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2343      Y:015B Y:015B                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2344      Y:015C Y:015C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2345      Y:015D Y:015D                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2346                            SXMIT_SPLIT_1
2347      Y:015E Y:015E                   DC      $00F020                           ; Transmit A/D data to host
2348      Y:015F Y:015F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2349      Y:0160 Y:0160                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2350      Y:0161 Y:0161                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2351      Y:0162 Y:0162                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2352      Y:0163 Y:0163                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2353      Y:0164 Y:0164                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2354                            END_SERIAL_READ_SPLIT_1
2355   
2356                            ; Bin by 2 waveforms
2357                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2358                            SERIAL_READ_LEFT_2
2359      Y:0165 Y:0165                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2360      Y:0166 Y:0166                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2361      Y:0167 Y:0167                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2362      Y:0168 Y:0168                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2363      Y:0169 Y:0169                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2364      Y:016A Y:016A                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2365                            SXMIT_LEFT_2
2366      Y:016B Y:016B                   DC      $00F000                           ; Transmit A/D data to host
2367      Y:016C Y:016C                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2368      Y:016D Y:016D                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2369      Y:016E Y:016E                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2370      Y:016F Y:016F                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2371      Y:0170 Y:0170                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2372      Y:0171 Y:0171                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2373      Y:0172 Y:0172                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2374      Y:0173 Y:0173                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2375      Y:0174 Y:0174                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2376      Y:0175 Y:0175                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2377      Y:0176 Y:0176                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2378      Y:0177 Y:0177                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2379                            END_SERIAL_READ_LEFT_2
2380   
2381                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2382                            SERIAL_READ_RIGHT_2
2383      Y:0178 Y:0178                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2384      Y:0179 Y:0179                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2385      Y:017A Y:017A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2386      Y:017B Y:017B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2387      Y:017C Y:017C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2388      Y:017D Y:017D                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2389                            SXMIT_RIGHT_2
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 44



2390      Y:017E Y:017E                   DC      $00F021                           ; Transmit A/D data to host
2391      Y:017F Y:017F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2392      Y:0180 Y:0180                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2393      Y:0181 Y:0181                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2394      Y:0182 Y:0182                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2395      Y:0183 Y:0183                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2396      Y:0184 Y:0184                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2397      Y:0185 Y:0185                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2398      Y:0186 Y:0186                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2399      Y:0187 Y:0187                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2400      Y:0188 Y:0188                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2401      Y:0189 Y:0189                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2402      Y:018A Y:018A                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2403                            END_SERIAL_READ_RIGHT_2
2404   
2405                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2406                            SERIAL_READ_SPLIT_2
2407      Y:018B Y:018B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2408      Y:018C Y:018C                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2409      Y:018D Y:018D                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2410      Y:018E Y:018E                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2411      Y:018F Y:018F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2412      Y:0190 Y:0190                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2413                            SXMIT_SPLIT_2
2414      Y:0191 Y:0191                   DC      $00F020                           ; Transmit A/D data to host
2415      Y:0192 Y:0192                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2416      Y:0193 Y:0193                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2417      Y:0194 Y:0194                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2418      Y:0195 Y:0195                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2419      Y:0196 Y:0196                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2420      Y:0197 Y:0197                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2421      Y:0198 Y:0198                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2422      Y:0199 Y:0199                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2423      Y:019A Y:019A                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2424      Y:019B Y:019B                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2425      Y:019C Y:019C                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2426      Y:019D Y:019D                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2427                            END_SERIAL_READ_SPLIT_2
2428   
2429   
2430                            ;       Binned by 3 waveforms
2431                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2432                            SERIAL_READ_LEFT_3
2433      Y:019E Y:019E                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2434      Y:019F Y:019F                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2435      Y:01A0 Y:01A0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2436      Y:01A1 Y:01A1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2437      Y:01A2 Y:01A2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2438      Y:01A3 Y:01A3                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2439                            SXMIT_LEFT_3
2440      Y:01A4 Y:01A4                   DC      $00F000                           ; Transmit A/D data to host
2441      Y:01A5 Y:01A5                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2442      Y:01A6 Y:01A6                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2443      Y:01A7 Y:01A7                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2444      Y:01A8 Y:01A8                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2445      Y:01A9 Y:01A9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2446      Y:01AA Y:01AA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2447      Y:01AB Y:01AB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2448      Y:01AC Y:01AC                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2449      Y:01AD Y:01AD                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2450      Y:01AE Y:01AE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2451      Y:01AF Y:01AF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 45



2452      Y:01B0 Y:01B0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2453      Y:01B1 Y:01B1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2454      Y:01B2 Y:01B2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2455      Y:01B3 Y:01B3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2456      Y:01B4 Y:01B4                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2457      Y:01B5 Y:01B5                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2458      Y:01B6 Y:01B6                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2459                            END_SERIAL_READ_LEFT_3
2460   
2461                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2462                            SERIAL_READ_RIGHT_3
2463      Y:01B7 Y:01B7                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2464      Y:01B8 Y:01B8                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2465      Y:01B9 Y:01B9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2466      Y:01BA Y:01BA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2467      Y:01BB Y:01BB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2468      Y:01BC Y:01BC                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2469                            SXMIT_RIGHT_3
2470      Y:01BD Y:01BD                   DC      $00F021                           ; Transmit A/D data to host
2471      Y:01BE Y:01BE                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2472      Y:01BF Y:01BF                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2473      Y:01C0 Y:01C0                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2474      Y:01C1 Y:01C1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2475      Y:01C2 Y:01C2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2476      Y:01C3 Y:01C3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2477      Y:01C4 Y:01C4                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2478      Y:01C5 Y:01C5                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2479      Y:01C6 Y:01C6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2480      Y:01C7 Y:01C7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2481      Y:01C8 Y:01C8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2482      Y:01C9 Y:01C9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2483      Y:01CA Y:01CA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2484      Y:01CB Y:01CB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2485      Y:01CC Y:01CC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2486      Y:01CD Y:01CD                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2487      Y:01CE Y:01CE                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2488      Y:01CF Y:01CF                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2489                            END_SERIAL_READ_RIGHT_3
2490   
2491                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2492                            SERIAL_READ_SPLIT_3
2493      Y:01D0 Y:01D0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2494      Y:01D1 Y:01D1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2495      Y:01D2 Y:01D2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2496      Y:01D3 Y:01D3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2497      Y:01D4 Y:01D4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2498      Y:01D5 Y:01D5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2499                            SXMIT_SPLIT_3
2500      Y:01D6 Y:01D6                   DC      $00F020                           ; Transmit A/D data to host
2501      Y:01D7 Y:01D7                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2502      Y:01D8 Y:01D8                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2503      Y:01D9 Y:01D9                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2504      Y:01DA Y:01DA                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2505      Y:01DB Y:01DB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2506      Y:01DC Y:01DC                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2507      Y:01DD Y:01DD                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2508      Y:01DE Y:01DE                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2509      Y:01DF Y:01DF                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2510      Y:01E0 Y:01E0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2511      Y:01E1 Y:01E1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2512      Y:01E2 Y:01E2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2513      Y:01E3 Y:01E3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 46



2514      Y:01E4 Y:01E4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2515      Y:01E5 Y:01E5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2516      Y:01E6 Y:01E6                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2517      Y:01E7 Y:01E7                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2518      Y:01E8 Y:01E8                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2519                            END_SERIAL_READ_SPLIT_3
2520   
2521                            ;       Binned by 4 waveforms
2522                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2523                            SERIAL_READ_LEFT_4
2524      Y:01E9 Y:01E9                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2525      Y:01EA Y:01EA                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2526      Y:01EB Y:01EB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2527      Y:01EC Y:01EC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2528      Y:01ED Y:01ED                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2529      Y:01EE Y:01EE                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2530                            SXMIT_LEFT_4
2531      Y:01EF Y:01EF                   DC      $00F000                           ; Transmit A/D data to host
2532      Y:01F0 Y:01F0                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2533      Y:01F1 Y:01F1                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2534      Y:01F2 Y:01F2                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2535      Y:01F3 Y:01F3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2536      Y:01F4 Y:01F4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2537      Y:01F5 Y:01F5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2538      Y:01F6 Y:01F6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2539      Y:01F7 Y:01F7                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2540      Y:01F8 Y:01F8                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2541      Y:01F9 Y:01F9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2542      Y:01FA Y:01FA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2543      Y:01FB Y:01FB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2544      Y:01FC Y:01FC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2545      Y:01FD Y:01FD                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2546      Y:01FE Y:01FE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2547      Y:01FF Y:01FF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2548      Y:0200 Y:0200                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2549      Y:0201 Y:0201                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2550      Y:0202 Y:0202                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2551      Y:0203 Y:0203                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2552      Y:0204 Y:0204                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2553      Y:0205 Y:0205                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2554      Y:0206 Y:0206                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2555      Y:0207 Y:0207                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2556                            END_SERIAL_READ_LEFT_4
2557   
2558                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2559                            SERIAL_READ_RIGHT_4
2560      Y:0208 Y:0208                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2561      Y:0209 Y:0209                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2562      Y:020A Y:020A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2563      Y:020B Y:020B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2564      Y:020C Y:020C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2565      Y:020D Y:020D                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2566                            SXMIT_RIGHT_4
2567      Y:020E Y:020E                   DC      $00F021                           ; Transmit A/D data to host
2568      Y:020F Y:020F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2569      Y:0210 Y:0210                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2570      Y:0211 Y:0211                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2571      Y:0212 Y:0212                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2572      Y:0213 Y:0213                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2573      Y:0214 Y:0214                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2574      Y:0215 Y:0215                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2575      Y:0216 Y:0216                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 47



2576      Y:0217 Y:0217                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2577      Y:0218 Y:0218                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2578      Y:0219 Y:0219                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2579      Y:021A Y:021A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2580      Y:021B Y:021B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2581      Y:021C Y:021C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2582      Y:021D Y:021D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2583      Y:021E Y:021E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2584      Y:021F Y:021F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2585      Y:0220 Y:0220                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2586      Y:0221 Y:0221                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2587      Y:0222 Y:0222                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2588      Y:0223 Y:0223                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2589      Y:0224 Y:0224                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2590      Y:0225 Y:0225                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2591      Y:0226 Y:0226                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2592                            END_SERIAL_READ_RIGHT_4
2593   
2594                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2595                            SERIAL_READ_SPLIT_4
2596      Y:0227 Y:0227                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2597      Y:0228 Y:0228                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2598      Y:0229 Y:0229                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2599      Y:022A Y:022A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2600      Y:022B Y:022B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2601      Y:022C Y:022C                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2602                            SXMIT_SPLIT_4
2603      Y:022D Y:022D                   DC      $00F020                           ; Transmit A/D data to host
2604      Y:022E Y:022E                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2605      Y:022F Y:022F                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2606      Y:0230 Y:0230                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2607      Y:0231 Y:0231                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2608      Y:0232 Y:0232                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2609      Y:0233 Y:0233                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2610      Y:0234 Y:0234                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2611      Y:0235 Y:0235                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2612      Y:0236 Y:0236                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2613      Y:0237 Y:0237                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2614      Y:0238 Y:0238                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2615      Y:0239 Y:0239                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2616      Y:023A Y:023A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2617      Y:023B Y:023B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2618      Y:023C Y:023C                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2619      Y:023D Y:023D                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2620      Y:023E Y:023E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2621      Y:023F Y:023F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2622      Y:0240 Y:0240                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2623      Y:0241 Y:0241                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2624      Y:0242 Y:0242                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2625      Y:0243 Y:0243                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2626      Y:0244 Y:0244                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2627      Y:0245 Y:0245                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2628                            END_SERIAL_READ_SPLIT_4
2629   
2630                            ;       Binned by 5 waveforms
2631                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2632                            SERIAL_READ_LEFT_5
2633      Y:0246 Y:0246                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2634      Y:0247 Y:0247                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2635      Y:0248 Y:0248                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2636      Y:0249 Y:0249                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2637      Y:024A Y:024A                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 48



2638      Y:024B Y:024B                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2639                            SXMIT_LEFT_5
2640      Y:024C Y:024C                   DC      $00F000                           ; Transmit A/D data to host
2641      Y:024D Y:024D                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2642      Y:024E Y:024E                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2643      Y:024F Y:024F                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2644      Y:0250 Y:0250                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2645      Y:0251 Y:0251                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2646      Y:0252 Y:0252                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2647      Y:0253 Y:0253                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2648      Y:0254 Y:0254                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2649      Y:0255 Y:0255                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2650      Y:0256 Y:0256                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2651      Y:0257 Y:0257                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2652      Y:0258 Y:0258                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2653      Y:0259 Y:0259                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2654      Y:025A Y:025A                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2655      Y:025B Y:025B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2656      Y:025C Y:025C                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2657      Y:025D Y:025D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2658      Y:025E Y:025E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2659      Y:025F Y:025F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2660      Y:0260 Y:0260                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2661      Y:0261 Y:0261                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2662      Y:0262 Y:0262                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2663      Y:0263 Y:0263                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2664      Y:0264 Y:0264                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2665      Y:0265 Y:0265                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2666      Y:0266 Y:0266                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2667      Y:0267 Y:0267                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2668      Y:0268 Y:0268                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2669      Y:0269 Y:0269                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2670      Y:026A Y:026A                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2671                            END_SERIAL_READ_LEFT_5
2672   
2673                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2674                            SERIAL_READ_RIGHT_5
2675      Y:026B Y:026B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2676      Y:026C Y:026C                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2677      Y:026D Y:026D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2678      Y:026E Y:026E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2679      Y:026F Y:026F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2680      Y:0270 Y:0270                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2681                            SXMIT_RIGHT_5
2682      Y:0271 Y:0271                   DC      $00F021                           ; Transmit A/D data to host
2683      Y:0272 Y:0272                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2684      Y:0273 Y:0273                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2685      Y:0274 Y:0274                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2686      Y:0275 Y:0275                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2687      Y:0276 Y:0276                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2688      Y:0277 Y:0277                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2689      Y:0278 Y:0278                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2690      Y:0279 Y:0279                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2691      Y:027A Y:027A                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2692      Y:027B Y:027B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2693      Y:027C Y:027C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2694      Y:027D Y:027D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2695      Y:027E Y:027E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2696      Y:027F Y:027F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2697      Y:0280 Y:0280                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2698      Y:0281 Y:0281                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2699      Y:0282 Y:0282                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  HIPO_Red.waveforms.s  Page 49



2700      Y:0283 Y:0283                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2701      Y:0284 Y:0284                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2702      Y:0285 Y:0285                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2703      Y:0286 Y:0286                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2704      Y:0287 Y:0287                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2705      Y:0288 Y:0288                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2706      Y:0289 Y:0289                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2707      Y:028A Y:028A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2708      Y:028B Y:028B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2709      Y:028C Y:028C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2710      Y:028D Y:028D                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2711      Y:028E Y:028E                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2712      Y:028F Y:028F                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2713                            END_SERIAL_READ_RIGHT_5
2714   
2715                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2716                            SERIAL_READ_SPLIT_5
2717      Y:0290 Y:0290                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2718      Y:0291 Y:0291                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2719      Y:0292 Y:0292                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2720      Y:0293 Y:0293                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2721      Y:0294 Y:0294                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2722      Y:0295 Y:0295                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2723                            SXMIT_SPLIT_5
2724      Y:0296 Y:0296                   DC      $00F020                           ; Transmit A/D data to host
2725      Y:0297 Y:0297                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2726      Y:0298 Y:0298                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2727      Y:0299 Y:0299                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2728      Y:029A Y:029A                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2729      Y:029B Y:029B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2730      Y:029C Y:029C                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2731      Y:029D Y:029D                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2732      Y:029E Y:029E                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2733      Y:029F Y:029F                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2734      Y:02A0 Y:02A0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2735      Y:02A1 Y:02A1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2736      Y:02A2 Y:02A2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2737      Y:02A3 Y:02A3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2738      Y:02A4 Y:02A4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2739      Y:02A5 Y:02A5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2740      Y:02A6 Y:02A6                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2741      Y:02A7 Y:02A7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2742      Y:02A8 Y:02A8                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2743      Y:02A9 Y:02A9                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2744      Y:02AA Y:02AA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2745      Y:02AB Y:02AB                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2746      Y:02AC Y:02AC                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2747      Y:02AD Y:02AD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2748      Y:02AE Y:02AE                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2749      Y:02AF Y:02AF                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2750      Y:02B0 Y:02B0                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2751      Y:02B1 Y:02B1                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2752      Y:02B2 Y:02B2                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2753      Y:02B3 Y:02B3                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2754      Y:02B4 Y:02B4                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2755                            END_SERIAL_READ_SPLIT_5
2756   
2757   
2758                                      IF      @SCP("HOST","EEPROM")
2762                                      ENDIF
2763   
2764                               ENDSEC                                    ; End of section TIMEEV57
Motorola DSP56000 Assembler  Version 6.2.0   108-08-18  12:56:51  tim.s  Page 50



2765   
2766                     ;  End of program
2767                               END

0    Errors
0    Warnings


