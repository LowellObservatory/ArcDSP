Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  tim.s  Page 1



1                        ; This file is used to generate DSP code for the TimII second generation
2                        ;   timing board. This is Rev. 3.00 software.
3                        ;
4                        ; This file contains two subroutines and X and Y data areas.  The two
5                        ; subroutines are RDCCD (with secondary entry point RCCD1) and CLOCK.
6                        ; These need to be in fast P memory.  The boot code and tim.s are there.
7                        ; tim.s includes timmisc.s and timCCDmisc.s at the
8                        ; beginning and the waveforms file at the end in Y memory.
9      
10                                 PAGE    132                               ; Printronix page width - 132 columns
11     
12                       ; Define a section name so it doesn't conflict with other application programs
13                                 SECTION TIMEEV57
14     
15                       ; Include a header file that defines global parameters
16                                 INCLUDE "timhdr.s"
17                              COMMENT *
18     
19                       This is a header file that is shared between the fiber optic timing board
20                       boot and application code files
21                               *
22     
23                                 PAGE    132                               ; Printronix page width - 132 columns
24     
25                       ; Some basic structural definitions
26        000130         APL_ADR   EQU     $130                              ; P: memory location where application code begins
27        0000D0         APL_LEN   EQU     $200-APL_ADR                      ; Maximum length of application program
28        000030         IMGVAR_ADR EQU    $30                               ;  Special Image Mode variables Starting Address in X:
29     
30                       ; CHANGING MISC_LEN FROM 0X280 TO A LARGER NUMBER BREAKS THE ROM COPY APPROACH!
31                       ; However if all you do is download there is a lot more memory available.
32        000450         MISC_LEN  EQU     $450                              ; Maximum length of "miscellanous" code
33                       ;MISC_LEN EQU   $3F0    ; Maximum length of "miscellanous" code
34                       ; MISC_LEN EQU  $280    ; Maximum length of "miscellanous" code
35     
36        000040         COM_LEN   EQU     $40                               ; Length of memory for application commands
37        00003C         TIM_ISR   EQU     $3C                               ; DSP timer interrupt service routine address
38        00003E         PGM_CON   EQU     $3E                               ; Program continues on here
39        000080         COM_TBL   EQU     $80                               ; Starting address of command table in X: memory
40        000500         N_W_APL   EQU     $500                              ; Number of words in each application
41        000028         NUM_COM   EQU     40                                ; Number of entries in command table
42     
43        000000         RST_ISR   EQU     $00                               ; Hardware reset interrupt
44        000006         ROM_ID    EQU     $06                               ; Location of program Identification = SWI interrupt
45        000008         START     EQU     $08                               ; Starting address of program
46        000060         RCV_BUF   EQU     $60                               ; Starting address of receiver buffer in X:
47        00000F         TBL_ADR   EQU     $0F                               ; (IR) Waveform tables starting address
48     
49        004000         ROM_OFF   EQU     $4000                             ; Boot program offset address in EEPROM
50        004200         LD_X      EQU     $4200                             ; Assembler loads X: starting at this EEPROM address
51        00C600         RD_X      EQU     $C600                             ; DSP reads X: from this EEPROM address
52     
53                       ; Define DSP port addresses
54        00FF80         WRSS      EQU     $FF80                             ; Write clock driver and VP switch states
55        00FFC0         RDFO      EQU     $FFC0                             ; Read serial receiver fiber optic contents
56        00FFC0         WRFO      EQU     $FFC0                             ; Write to fiber optic serial transmitter
57        00FFA0         RDAD      EQU     $FFA0                             ; Read A/D datum into DSP
58        00FFA0         RDAD0     EQU     $FFA0                             ; Address for reading A/D #0
59        00FFA1         RDAD1     EQU     $FFA1                             ; Address for reading A/D #1
60        00FFC1         WRLATCH   EQU     $FFC1                             ; Write to timing board latch
61        006000         RSTWDT    EQU     $6000                             ; Address to reset the timing board watchdog timer
62        00FFFE         BCR       EQU     $FFFE                             ; Bus (=Port A) Control Register -> Wait States
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timhdr.s  Page 2



63        00FFE0         PBC       EQU     $FFE0                             ; Port B Control Register
64        00FFE2         PBDDR     EQU     $FFE2                             ; Port B Data Direction Register
65        00FFE4         PBD       EQU     $FFE4                             ; Port B Data Register
66        00FFE1         PCC       EQU     $FFE1                             ; Port C Control Register
67        00FFE3         PCDDR     EQU     $FFE3                             ; PortC Data Direction Register
68        00FFE5         PCD       EQU     $FFE5                             ; Port C Data Register
69        00FFFF         IPR       EQU     $FFFF                             ; Interrupt Priority Register
70        00FFEF         SSITX     EQU     $FFEF                             ; SSI Transmit and Receive data register
71        00FFEF         SSIRX     EQU     $FFEF                             ; SSI Transmit and Receive data register
72        00FFEE         SSISR     EQU     $FFEE                             ; SSI Status Register
73        00FFEC         CRA       EQU     $FFEC                             ; SSI Control Register A
74        00FFED         CRB       EQU     $FFED                             ; SSI Control Regsiter B
75        00FFDE         TCSR      EQU     $FFDE                             ; Timer control and status register
76        00FFDF         TCR       EQU     $FFDF                             ; Timer count register
77     
78                       ; Hardware bit definitions all over the place
79        000006         SSI_TDE   EQU     6                                 ; SSI Transmitter data register empty
80        000007         SSI_RDF   EQU     7                                 ; SSI Receiver data register full
81        000002         LVEN      EQU     2                                 ; Low voltage enable (+/-15 volt nominal)
82        000003         HVEN      EQU     3                                 ; Enable high voltage (+32V nominal)
83        000005         TIM_U_RST EQU     5                                 ; Timing to utility board reset bit number in U25
84        00000D         PWRST     EQU     13                                ; Power control board reset
85        000007         RST_FIFO  EQU     7                                 ; Reset FIFO bit number in control latch U25
86        000009         EF        EQU     9                                 ; FIFO empty flag, low true
87        000000         TIM_BIT   EQU     0                                 ; Timer status bit
88        000001         WW        EQU     1                                 ; Word width = 1 for 16-bit image data, 0 for 24-bit
89        000000         CDAC      EQU     0                                 ; Bit number in U25 for clearing DACs
90        000002         ENCK      EQU     2                                 ; Bit number in U25 for enabling analog switches
91        000001         DUALCLK   EQU     1                                 ; Set to clock two halves of clock driver board togethe
r
92     
93                       ; Software status bits, defined at X:<STATUS = X:0
94        000000         ST_RCV    EQU     0                                 ; Set if FO, cleared if SSI
95        00000A         TST_IMG   EQU     10                                ; Set if controller is to generate a test image
96        00000B         SHUT      EQU     11                                ; Set if opening shutter at beginning of exposure
97     
98                       ; Software status bits, defined at X:<STATUS = X:0
99        000002         IDLMODE   EQU     2                                 ; Set if need to idle after readout
100       000003         ST_SHUT   EQU     3                                 ; Set to indicate shutter is closed, clear for open
101       000004         ST_RDC    EQU     4                                 ; Set if executing 'RDC' command - reading out
102       000005         SPLIT_S   EQU     5                                 ; Set if split serial
103       000006         SPLIT_P   EQU     6                                 ; Set if split parallel
104       000007         MPP       EQU     7                                 ; Set if parallels are in MPP mode
105       000008         TRIGGER   EQU     8                                 ; Set if a Hardware triggered exposure
106    
107    
108                      ; Image mode bits, defined at X:<IMAGE_MODE
109    
110       000000         FDOTS     EQU     0                                 ; Fast Dots
111       000001         FIND      EQU     1                                 ; Find
112       000002         SDOTS     EQU     2                                 ; Slow Dots
113       000003         SERIES    EQU     3                                 ; Series
114       000004         SINGLE    EQU     4                                 ; Single
115       000005         STRIP     EQU     5                                 ; Stripscan
116       000006         F_OCC     EQU     6                                 ; Fast occultation, keep as 6 for compatibility
117       000007         B_OCC     EQU     7                                 ; Basic occultation
118       000008         P_OCC     EQU     8                                 ; Pipelined occultation
119    
120                      ; Image Status, define at X:<ISTATUS
121       000000         NO_SKIP   EQU     0                                 ; Set for slow dots, fast and pipelined occultation mod
e
122                                                                          ; to avoid parallel skipping to the subframe boundary.
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timhdr.s  Page 3



123       000001         OPEN_CLOSE EQU    1                                 ; Set if shutter opens/closes each image
124                                                                          ; Clear if shutter stays open for many images
125       000002         STORAGE   EQU     2                                 ; Set if storage area is to be clocked
126    
127    
128                      ; Specify controller configuration bits of the X:STATUS word
129                      ;   to describe the software capabilities of this application file
130                      ; The bit is set (=1) if the capability is supported by the controller
131    
132    
133                              COMMENT *
134    
135                      BIT #'s         FUNCTION
136                      2,1,0           Video Processor
137                                              000     CCD Rev. 3
138                                              001     CCD Gen I
139                                              010     IR Rev. 4
140                                              011     IR Coadder
141    
142                      4,3             Timing Board
143                                              00      Rev. 4, Gen II
144                                              01      Gen I
145    
146                      6,5             Utility Board
147                                              00      No utility board
148                                              01      Utility Rev. 3
149    
150                      7               Shutter
151                                              0       No shutter support
152                                              1       Yes shutter support
153    
154                      9,8             Temperature readout
155                                              00      No temperature readout
156                                              01      Polynomial Diode calibration
157                                              10      Linear temperature sensor calibration
158    
159                      10              Subarray readout
160                                              0       Not supported
161                                              1       Yes supported
162    
163                      11              Binning
164                                              0       Not supported
165                                              1       Yes supported
166    
167                      12              Split-Serial readout
168                                              0       Not supported
169                                              1       Yes supported
170    
171                      13              Split-Parallel readout
172                                              0       Not supported
173                                              1       Yes supported
174    
175                      14              MPP = Inverted parallel clocks
176                                              0       Not supported
177                                              1       Yes supported
178    
179                      16,15           Clock Driver Board
180                                              00      Rev. 3
181                                              11      No clock driver board (Gen I)
182    
183                      19,18,17                Special implementations
184                                              000     Somewhere else
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timhdr.s  Page 4



185                                              001     Mount Laguna Observatory
186                                              010     NGST Aladdin
187                                              xxx     Other
188                              *
189    
190                      CCDVIDREV3B
191       000000                   EQU     $000000                           ; CCD Video Processor Rev. 3
192       000001         VIDGENI   EQU     $000001                           ; CCD Video Processor Gen I
193       000002         IRREV4    EQU     $000002                           ; IR Video Processor Rev. 4
194       000003         COADDER   EQU     $000003                           ; IR Coadder
195       000000         TIMREV4   EQU     $000000                           ; Timing Rev. 4
196       000008         TIMGENI   EQU     $000008                           ; Timing Gen I
197       000020         UTILREV3  EQU     $000020                           ; Utility Rev. 3 supported
198       000080         SHUTTER_CC EQU    $000080                           ; Shutter supported
199       000100         TEMP_POLY EQU     $000100                           ; Polynomial calibration
200                      TEMP_LINEAR
201       000200                   EQU     $000200                           ; Linear calibration
202       000400         SUBARRAY  EQU     $000400                           ; Subarray readout supported
203       000800         BINNING   EQU     $000800                           ; Binning supported
204                      SPLIT_SERIAL
205       001000                   EQU     $001000                           ; Split serial supported
206                      SPLIT_PARALLEL
207       002000                   EQU     $002000                           ; Split parallel supported
208       004000         MPP_CC    EQU     $004000                           ; Inverted clocks supported
209       018000         CLKDRVGENI EQU    $018000                           ; No clock driver board - Gen I
210       020000         MLO       EQU     $020000                           ; Set if Mount Laguna Observatory
211       040000         NGST      EQU     $040000                           ; NGST Aladdin implementation
212                                INCLUDE "infospec.s"
213                      ; General DSP info field specifications.
214                      ; These values are 'addresses' and used as the argument for the INF command.
215    
216                      GET_VERSION
217       000000                   EQU     0                                 ; IVERSION field
218       000001         GET_FLAVOR EQU    1                                 ; IFLAVOR field
219       000002         GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
220       000003         GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
221       000004         GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if available)
222    
223                                INCLUDE "timinfospec.s"
224                      ; TIM DSP info field specifications.
225                      ; These values are 'addresses' and used as the argument for the INF command.
226    
227                      GET_CAPABLE
228       000100                   EQU     $100                              ; ICAPABLE field (what dsp supports).
229                      GET_INT_TIM
230       000101                   EQU     $101                              ; Integration time per pixel in leach units
231                      GET_R_DELAY
232       000102                   EQU     $102                              ; Serial overlap in leach units
233                      GET_SI_DELAY
234       000103                   EQU     $103                              ; Parallel overlap in leach units
235    
236                                INCLUDE "timinfo.s"
237                      ; DSP Version
238       04407F         IVERSION  EQU     278655                            ; 1.4/1
239    
240       612020         IFLAVOR   EQU     'a  '                             ; a
241    
242       00CBC8         ITIME0    EQU     52168                             ; lo order time: 2010 10 21  23:24:56 GMT
243    
244       004CC0         ITIME1    EQU     19648                             ; hi order time: 2010 10 21  23:24:56 GMT
245    
246       000000         ISVNREV   EQU     0                                 ; most recent code svn rev
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timinfo.s  Page 5



247    
248                      ; tim capability definitions
249                      FINDCAPABLE
250       000001                   EQU     1                                 ; Find exposure mode
251                      SNGLCAPABLE
252       000002                   EQU     2                                 ; Single exposure mode
253                      SERICAPABLE
254       000004                   EQU     4                                 ; Series exposure mode
255                      BASCCAPABLE
256       000008                   EQU     8                                 ; Basic occ exposure mode
257                      FASTCAPABLE
258       000010                   EQU     16                                ; Fast occ exposure mode
259                      PIPECAPABLE
260       000020                   EQU     32                                ; Pipeline occ exposure mode
261                      FDOTCAPABLE
262       000040                   EQU     64                                ; Fast dots exposure mode
263                      SDOTCAPABLE
264       000080                   EQU     128                               ; Slow dots exposure mode
265                      STRPCAPABLE
266       000100                   EQU     256                               ; Slow dots exposure mode
267       0001FB         TIMCAPABLE EQU    FINDCAPABLE+SNGLCAPABLE+STRPCAPABLE+BASCCAPABLE+FASTCAPABLE+PIPECAPABLE+FDOTCAPABLE+SDOTC
APABLE
268    
269       000000         APL_NUM   EQU     0                                 ; Application number from 0 to 3
270    
271       001420         CC        EQU     CCDVIDREV3B+TIMREV4+UTILREV3+SUBARRAY+SPLIT_SERIAL
272    
273                      ; Include miscellaneous timing commands
274                                INCLUDE "timmisc.s"                       ; Custom
275                      ; This file is for utilities that are in common to all the timing board
276                      ;   programs, located starting at P:$200 in external SRAM
277    
278                                IF      @SCP("50","50")
279       000032         SDELAY    EQU     50
280                                ENDIF
281                                IF      @SCP("50","200")
283                                ENDIF
284    
285                      ;  ****************  PROGRAM CODE IN SRAM PROGRAM SPACE    *******************
286                      ; Put all the following code in SRAM, starting at P:$200.
287                                IF      @SCP("HOST","HOST")
288       P:0200 P:0200                   ORG     P:$200,P:$200                     ; Download address
289                                       ELSE
291                                       ENDIF
292    
293                             ; Fast clear of CCD, executed as a command
294       P:0200 P:0200 0D0202  CLEAR     JSR     <CLR_CCD
295       P:0201 P:0201 0C0000            JMP     <FINISH
296    
297                             ; Fast clear image before each exposure, executed as a subroutine.  Uses DG
298       P:0202 P:0202 060440  CLR_CCD   DO      Y:<NPCLR,LPCLR                    ; Loop over number of lines in image
                        000207
299       P:0204 P:0204 60F400            MOVE              #IS_CLEAR,R0            ; Address of parallel transfer waveform
                        000060
300       P:0206 P:0206 0D01E9            JSR     <CLOCK                            ; Go clock out the CCD charge
301       P:0207 P:0207 000000            NOP                                       ; Do loop restriction
302                             LPCLR
303       P:0208 P:0208 60F400            MOVE              #DUMP_SERIAL,R0
                        000068
304       P:020A P:020A 0D01E9            JSR     <CLOCK                            ; and wipe out the dregs in the SR
305       P:020B P:020B 44F400            MOVE              #TST_RCV,X0             ; Wait for commands during exposure
                        000000
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 6



306       P:020D P:020D 440000            MOVE              X0,X:<IDL_ADR           ;  instead of idling
307       P:020E P:020E 00000C            RTS
308    
309                             ; Keep the CCD idling when not reading out
310       P:020F P:020F 060140  IDLE      DO      Y:<NSR,IDL1                       ; Loop over number of pixels per line
                        000217
311       P:0211 P:0211 306E00            MOVE              #<SERIAL_IDLE,R0        ; Serial transfer on pixel
312       P:0212 P:0212 0D01E9            JSR     <CLOCK                            ; Go to it
313       P:0213 P:0213 0D0000            JSR     <GET_RCV                          ; Check for FO or SSI commands
314       P:0214 P:0214 0E0217            JCC     <NO_COM                           ; Continue IDLE if no commands received
315       P:0215 P:0215 00008C            ENDDO                                     ; Cancel the DO loop
316       P:0216 P:0216 0C0000            JMP     <CHK_SSI                          ; Go process header and command
317       P:0217 P:0217 000000  NO_COM    NOP
318                             IDL1
319       P:0218 P:0218 306000            MOVE              #<IS_CLEAR,R0           ; Address of parallel clocking waveform
320       P:0219 P:0219 0D01E9            JSR     <CLOCK                            ; Go clock out the CCD charge
321       P:021A P:021A 0C020F            JMP     <IDLE
322    
323    
324                             ; Select which readouts to process
325                             ;   'SOS'  Amplifier_name
326                             ;       Amplifier_name = '__L', '__R', '_LR'
327    
328       P:021B P:021B 44DC00  SEL_OS    MOVE              X:(R4)+,X0              ; Get amplifier(s) name
329       P:021C P:021C 0D021E            JSR     <SELECT_OUTPUT_SOURCE
330       P:021D P:021D 0C0000            JMP     <FINISH1
331    
332                             ; A massive subroutine for setting all the addresses depending on the
333                             ; output source(s) selection and binning parameter.  Most of the
334                             ; waveforms are in fast Y memory (< 0xFF) but there isn't enough
335                             ; space for the fast serial binning waveforms for binning factors
336                             ; 1 through 5.  These are in high Y memory and have to be copied in.
337    
338                             SELECT_OUTPUT_SOURCE
339                             ; Set all the waveform addresses depending on which readout/binning mode
340       P:021E P:021E 56F400            MOVE              #'__L',A                ; LEFT Amplifier = readout #0
                        5F5F4C
341       P:0220 P:0220 200045            CMP     X0,A
342       P:0221 P:0221 0E226C            JNE     <CMP_R
343       P:0222 P:0222 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
344       P:0223 P:0223 56F400            MOVE              #SERIAL_SKIP_LEFT,A
                        0000E8
345       P:0225 P:0225 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
346       P:0227 P:0227 56F400            MOVE              #INITIAL_CLOCK_LEFT,A
                        000093
347       P:0229 P:0229 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
348       P:022B P:022B 56F400            MOVE              #SERIAL_CLOCK_LEFT,A
                        0000AD
349       P:022D P:022D 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
350       P:022F P:022F 56F400            MOVE              #(CLK2+$030000+000+000+000+000+H2L+H2R+000+000),A
                        032012
351       P:0231 P:0231 5E7000            MOVE                          A,Y:CCLK_1
                        0000B5
352       P:0233 P:0233 0A7005            BCLR    #SPLIT_S,X:STATUS
                        000000
353                             ; Now go through copying in the serial read waveform if binning more than 5.
354       P:0235 P:0235 200013            CLR     A
355       P:0236 P:0236 20001B            CLR     B
356       P:0237 P:0237 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 7



357       P:0238 P:0238 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
358       P:0239 P:0239 50F400            MOVE              #>5,A0
                        000005
359       P:023B P:023B 200005            CMP     B,A
360       P:023C P:023C 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
361       P:023D P:023D 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
362       P:023E P:023E 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
363       P:023F P:023F 0A3781  TRY_1_L   JCLR    #1,X:<BINBIT,TRY_2_L
                        000248
364                             ;       MOVE    #1,A0                   ; HACK
365                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
366       P:0241 P:0241 60F400            MOVE              #SERIAL_READ_LEFT_1,R0  ; Here if left amp, bin by 1
                        00013E
367       P:0243 P:0243 51F400            MOVE              #(END_SERIAL_READ_LEFT_1-SERIAL_READ_LEFT_1),B0
                        00000D
368       P:0245 P:0245 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
369       P:0246 P:0246 0D030D            JSR     <WAVECPY                          ; Copy the waveform
370       P:0247 P:0247 0C0307            JMP     <CMP_END
371       P:0248 P:0248 0A3782  TRY_2_L   JCLR    #2,X:<BINBIT,TRY_3_L
                        000251
372       P:024A P:024A 60F400            MOVE              #SERIAL_READ_LEFT_2,R0  ; Here if left amp, bin by 2
                        000165
373       P:024C P:024C 51F400            MOVE              #(END_SERIAL_READ_LEFT_2-SERIAL_READ_LEFT_2),B0
                        000013
374       P:024E P:024E 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
375       P:024F P:024F 0D030D            JSR     <WAVECPY                          ; Copy the waveform
376       P:0250 P:0250 0C0307            JMP     <CMP_END
377       P:0251 P:0251 0A3783  TRY_3_L   JCLR    #3,X:<BINBIT,TRY_4_L
                        00025A
378       P:0253 P:0253 60F400            MOVE              #SERIAL_READ_LEFT_3,R0  ; Here if left amp, bin by 3
                        00019E
379       P:0255 P:0255 51F400            MOVE              #(END_SERIAL_READ_LEFT_3-SERIAL_READ_LEFT_3),B0
                        000019
380       P:0257 P:0257 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
381       P:0258 P:0258 0D030D            JSR     <WAVECPY                          ; Copy the waveform
382       P:0259 P:0259 0C0307            JMP     <CMP_END
383       P:025A P:025A 0A3784  TRY_4_L   JCLR    #4,X:<BINBIT,TRY_5_L
                        000263
384       P:025C P:025C 60F400            MOVE              #SERIAL_READ_LEFT_4,R0  ; Here if left amp, bin by 4
                        0001E9
385       P:025E P:025E 51F400            MOVE              #(END_SERIAL_READ_LEFT_4-SERIAL_READ_LEFT_4),B0
                        00001F
386       P:0260 P:0260 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
387       P:0261 P:0261 0D030D            JSR     <WAVECPY                          ; Copy the waveform
388       P:0262 P:0262 0C0307            JMP     <CMP_END
389       P:0263 P:0263 0A3785  TRY_5_L   JCLR    #5,X:<BINBIT,CMP_END
                        000307
390       P:0265 P:0265 60F400            MOVE              #SERIAL_READ_LEFT_5,R0  ; Here if left amp, bin by 5
                        000246
391       P:0267 P:0267 51F400            MOVE              #(END_SERIAL_READ_LEFT_5-SERIAL_READ_LEFT_5),B0
                        000025
392       P:0269 P:0269 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
393       P:026A P:026A 0D030D            JSR     <WAVECPY                          ; Copy the waveform
394       P:026B P:026B 0C0307            JMP     <CMP_END
395    
396       P:026C P:026C 56F400  CMP_R     MOVE              #'__R',A                ; RIGHT Amplifier = readout #1
                        5F5F52
397       P:026E P:026E 200045            CMP     X0,A
398       P:026F P:026F 0E22BA            JNE     <CMP_LR
399       P:0270 P:0270 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
400       P:0271 P:0271 56F400            MOVE              #SERIAL_SKIP_RIGHT,A
                        0000F0
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 8



401       P:0273 P:0273 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
402       P:0275 P:0275 56F400            MOVE              #INITIAL_CLOCK_RIGHT,A
                        000087
403       P:0277 P:0277 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
404       P:0279 P:0279 56F400            MOVE              #SERIAL_CLOCK_RIGHT,A
                        0000A6
405       P:027B P:027B 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
406       P:027D P:027D 56F400            MOVE              #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),A
                        032009
407       P:027F P:027F 5E7000            MOVE                          A,Y:CCLK_1
                        0000B5
408       P:0281 P:0281 0A7005            BCLR    #SPLIT_S,X:STATUS
                        000000
409                             ; Now go through copying in the serial read waveform if binning more than 5.
410       P:0283 P:0283 200013            CLR     A
411       P:0284 P:0284 20001B            CLR     B
412       P:0285 P:0285 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
413       P:0286 P:0286 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
414       P:0287 P:0287 50F400            MOVE              #>5,A0
                        000005
415       P:0289 P:0289 200005            CMP     B,A
416       P:028A P:028A 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
417       P:028B P:028B 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
418       P:028C P:028C 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
419       P:028D P:028D 0A3781  TRY_1_R   JCLR    #1,X:<BINBIT,TRY_2_R
                        000296
420                             ;       MOVE    #2,A0                   ; HACK
421                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
422       P:028F P:028F 60F400            MOVE              #SERIAL_READ_RIGHT_1,R0 ; Here if right amp, bin by 1
                        00014B
423       P:0291 P:0291 51F400            MOVE              #(END_SERIAL_READ_RIGHT_1-SERIAL_READ_RIGHT_1),B0
                        00000D
424       P:0293 P:0293 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
425       P:0294 P:0294 0D030D            JSR     <WAVECPY                          ; Copy the waveform
426       P:0295 P:0295 0C0307            JMP     <CMP_END
427       P:0296 P:0296 0A3782  TRY_2_R   JCLR    #2,X:<BINBIT,TRY_3_R
                        00029F
428       P:0298 P:0298 60F400            MOVE              #SERIAL_READ_RIGHT_2,R0 ; Here if right amp, bin by 2
                        000178
429       P:029A P:029A 51F400            MOVE              #(END_SERIAL_READ_RIGHT_2-SERIAL_READ_RIGHT_2),B0
                        000013
430       P:029C P:029C 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
431       P:029D P:029D 0D030D            JSR     <WAVECPY                          ; Copy the waveform
432       P:029E P:029E 0C0307            JMP     <CMP_END
433       P:029F P:029F 0A3783  TRY_3_R   JCLR    #3,X:<BINBIT,TRY_4_R
                        0002A8
434       P:02A1 P:02A1 60F400            MOVE              #SERIAL_READ_RIGHT_3,R0 ; Here if right amp, bin by 3
                        0001B7
435       P:02A3 P:02A3 51F400            MOVE              #(END_SERIAL_READ_RIGHT_3-SERIAL_READ_RIGHT_3),B0
                        000019
436       P:02A5 P:02A5 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
437       P:02A6 P:02A6 0D030D            JSR     <WAVECPY                          ; Copy the waveform
438       P:02A7 P:02A7 0C0307            JMP     <CMP_END
439       P:02A8 P:02A8 0A3784  TRY_4_R   JCLR    #4,X:<BINBIT,TRY_5_R
                        0002B1
440       P:02AA P:02AA 60F400            MOVE              #SERIAL_READ_RIGHT_4,R0 ; Here if right amp, bin by 4
                        000208
441       P:02AC P:02AC 51F400            MOVE              #(END_SERIAL_READ_RIGHT_4-SERIAL_READ_RIGHT_4),B0
                        00001F
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 9



442       P:02AE P:02AE 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
443       P:02AF P:02AF 0D030D            JSR     <WAVECPY                          ; Copy the waveform
444       P:02B0 P:02B0 0C0307            JMP     <CMP_END
445       P:02B1 P:02B1 0A3785  TRY_5_R   JCLR    #5,X:<BINBIT,CMP_END
                        000307
446       P:02B3 P:02B3 60F400            MOVE              #SERIAL_READ_RIGHT_5,R0 ; Here if right amp, bin by 5
                        00026B
447       P:02B5 P:02B5 51F400            MOVE              #(END_SERIAL_READ_RIGHT_5-SERIAL_READ_RIGHT_5),B0
                        000025
448       P:02B7 P:02B7 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
449       P:02B8 P:02B8 0D030D            JSR     <WAVECPY                          ; Copy the waveform
450       P:02B9 P:02B9 0C0307            JMP     <CMP_END
451    
452       P:02BA P:02BA 56F400  CMP_LR    MOVE              #'_LR',A                ; LEFT and RIGHT = readouts #0 and #1
                        5F4C52
453       P:02BC P:02BC 200045            CMP     X0,A
454       P:02BD P:02BD 0E230A            JNE     <CMP_ERROR
455       P:02BE P:02BE 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
456       P:02BF P:02BF 56F400            MOVE              #SERIAL_SKIP_SPLIT,A
                        0000F8
457       P:02C1 P:02C1 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
458       P:02C3 P:02C3 56F400            MOVE              #INITIAL_CLOCK_SPLIT,A
                        00007B
459       P:02C5 P:02C5 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
460       P:02C7 P:02C7 56F400            MOVE              #SERIAL_CLOCK_SPLIT,A
                        00009F
461       P:02C9 P:02C9 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
462       P:02CB P:02CB 56F400            MOVE              #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),A
                        03200A
463       P:02CD P:02CD 5E7000            MOVE                          A,Y:CCLK_1
                        0000B5
464       P:02CF P:02CF 0A7025            BSET    #SPLIT_S,X:STATUS
                        000000
465                             ; Now go through copying in the serial read waveform if binning more than 5.
466       P:02D1 P:02D1 200013            CLR     A
467       P:02D2 P:02D2 20001B            CLR     B
468       P:02D3 P:02D3 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
469       P:02D4 P:02D4 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
470       P:02D5 P:02D5 50F400            MOVE              #>5,A0
                        000005
471       P:02D7 P:02D7 200005            CMP     B,A
472       P:02D8 P:02D8 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
473       P:02D9 P:02D9 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
474       P:02DA P:02DA 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
475       P:02DB P:02DB 0A3781  TRY_1_S   JCLR    #1,X:<BINBIT,TRY_2_S
                        0002E4
476                             ;       MOVE    #3,A0                   ; HACK
477                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
478       P:02DD P:02DD 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if split amp, bin by 1
                        000158
479       P:02DF P:02DF 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                        00000D
480       P:02E1 P:02E1 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
481       P:02E2 P:02E2 0D030D            JSR     <WAVECPY                          ; Copy the waveform
482       P:02E3 P:02E3 0C0307            JMP     <CMP_END
483       P:02E4 P:02E4 0A3782  TRY_2_S   JCLR    #2,X:<BINBIT,TRY_3_S
                        0002ED
484       P:02E6 P:02E6 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if split amp, bin by 2
                        00018B
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 10



485       P:02E8 P:02E8 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                        000013
486       P:02EA P:02EA 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
487       P:02EB P:02EB 0D030D            JSR     <WAVECPY                          ; Copy the waveform
488       P:02EC P:02EC 0C0307            JMP     <CMP_END
489       P:02ED P:02ED 0A3783  TRY_3_S   JCLR    #3,X:<BINBIT,TRY_4_S
                        0002F6
490       P:02EF P:02EF 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if split amp, bin by 3
                        0001D0
491       P:02F1 P:02F1 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                        000019
492       P:02F3 P:02F3 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
493       P:02F4 P:02F4 0D030D            JSR     <WAVECPY                          ; Copy the waveform
494       P:02F5 P:02F5 0C0307            JMP     <CMP_END
495       P:02F6 P:02F6 0A3784  TRY_4_S   JCLR    #4,X:<BINBIT,TRY_5_S
                        0002FF
496       P:02F8 P:02F8 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if split amp, bin by 4
                        000227
497       P:02FA P:02FA 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                        00001F
498       P:02FC P:02FC 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
499       P:02FD P:02FD 0D030D            JSR     <WAVECPY                          ; Copy the waveform
500       P:02FE P:02FE 0C0307            JMP     <CMP_END
501       P:02FF P:02FF 0A3785  TRY_5_S   JCLR    #5,X:<BINBIT,CMP_END
                        000307
502       P:0301 P:0301 60F400            MOVE              #SERIAL_READ_SPLIT_5,R0 ; Here if split amp, bin by 5
                        000290
503       P:0303 P:0303 51F400            MOVE              #(END_SERIAL_READ_SPLIT_5-SERIAL_READ_SPLIT_5),B0
                        000025
504       P:0305 P:0305 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
505       P:0306 P:0306 0D030D            JSR     <WAVECPY                          ; Copy the waveform
506    
507       P:0307 P:0307 44F400  CMP_END   MOVE              #'DON',X0
                        444F4E
508       P:0309 P:0309 00000C            RTS
509                             CMP_ERROR
510       P:030A P:030A 44F400            MOVE              #'ERR',X0
                        455252
511       P:030C P:030C 00000C            RTS
512    
513                             ; Short function to copy in waveforms from high Y to fast Y memory.
514                             ; R0 is the source address, R7 the destination, and X0 is intermediary reg.
515                             WAVECPY
516       P:030D P:030D 06C900            DO      B0,WAVELP                         ; Copy the waveform; B0 is SERWAVLEN already
                        000311
517       P:030F P:030F 4CD800            MOVE                          Y:(R0)+,X0
518       P:0310 P:0310 4C5F00            MOVE                          X0,Y:(R7)+
519       P:0311 P:0311 000000            NOP
520                             WAVELP
521       P:0312 P:0312 000000            NOP
522       P:0313 P:0313 00000C            RTS
523    
524                             ; Short function to set the correct bit in BINBIT based on NSBIN
525                             ; Called only if NSBIN is less than 6.
526    
527                             SET_BINBIT
528                             ;       MOVE    Y:<TESTLOC1,A0                  ; HACK - test if this code is executed
529                             ;       INC     A                               ; HACK
530                             ;       MOVE    A0,Y:<TESTLOC1                  ; HACK
531       P:0314 P:0314 50F400            MOVE              #>1,A0                  ; Put a bit in A and shift to right spot
                        000001
532       P:0316 P:0316 060540            DO      Y:<NSBIN,BINLOOP                  ; Bit zero position not used, 1-5 used
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 11



                        000318
533       P:0318 P:0318 200032            ASL     A
534                             BINLOOP
535       P:0319 P:0319 503700            MOVE              A0,X:<BINBIT            ; set bit 1-5 for SELECT_OUTPUT_SOURCE jump tabl
e
536       P:031A P:031A 00000C            RTS
537    
538    
539                             ; Set the number of rows and columns and binning factors
540                             SET_ROWS_COLUMNS
541       P:031B P:031B 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NSR = NAXIS1
542       P:031C P:031C 4C7000            MOVE                          X0,Y:NSR
                        000001
543       P:031E P:031E 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NPR = NAXIS2
544       P:031F P:031F 4C7000            MOVE                          X0,Y:NPR
                        000002
545       P:0321 P:0321 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NSBIN
546       P:0322 P:0322 4C7000            MOVE                          X0,Y:NSBIN
                        000005
547       P:0324 P:0324 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NPBIN
548       P:0325 P:0325 4C7000            MOVE                          X0,Y:NPBIN
                        000006
549       P:0327 P:0327 4CBD00            MOVE                          Y:<AMPVAL,X0 ; Get ampval in X0 for SOS call
550       P:0328 P:0328 0D021E            JSR     <SELECT_OUTPUT_SOURCE             ; Update serial read waveform in case binning ch
anged
551       P:0329 P:0329 0C0000            JMP     <FINISH
552    
553                             ; Set the variables for the time-resolved modes
554                             SET_IMAGE_PARAM
555       P:032A P:032A 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Image mode
556       P:032B P:032B 447000            MOVE              X0,X:IMAGE_MODE
                        000030
557       P:032D P:032D 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Iframes = NAXIS3
558       P:032E P:032E 4C7000            MOVE                          X0,Y:IFRAMES
                        00003A
559       P:0330 P:0330 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Srows
560       P:0331 P:0331 4C7000            MOVE                          X0,Y:SROWS
                        000038
561       P:0333 P:0333 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Interval
562                             ;       MOVE    X0,Y:INTERVAL           ; HACK - Using Interval as a test location
563       P:0334 P:0334 0C0000            JMP     <FINISH
564    
565    
566                             ; Set the hardware trigger bit, executed as a command
567                             SET_TRIGGER
568       P:0335 P:0335 44DC00            MOVE              X:(R4)+,X0              ; Get the trigger value
569       P:0336 P:0336 56F400            MOVE              #'_ON',A
                        5F4F4E
570       P:0338 P:0338 200045            CMP     X0,A
571       P:0339 P:0339 0AF0A2            JNE     NO_TRIGGER
                        000340
572       P:033B P:033B 0AA4AB            JSET    #11,X:PBD,TRIG_CLR                ; Is Trigger running?
                        00033E
573       P:033D P:033D 0C0000            JMP     <ERROR                            ; Yes! report Error!  Why do this?
574                             TRIG_CLR
575       P:033E P:033E 0A0028            BSET    #TRIGGER,X:<STATUS                ; Set status bit, hardware trigger
576       P:033F P:033F 0C0000            JMP     <FINISH
577                             NO_TRIGGER
578       P:0340 P:0340 0A0008            BCLR    #TRIGGER,X:<STATUS                ; Clear Status bit, software timing
579       P:0341 P:0341 0C0000            JMP     <FINISH
580    
581                             ; Calculate the fast read parameters for each readout box
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 12



582                             SETUP_SUBROUTINE
583       P:0342 P:0342 4C8C00            MOVE                          Y:<SERWAVLEN,X0 ; # of waveforms
584       P:0343 P:0343 4D9000            MOVE                          Y:<NSERIALS_READ,X1 ; Number of pixels to read
585       P:0344 P:0344 0D047A            JSR     <FASTSKP                          ; Compute number of clocks required
586       P:0345 P:0345 4D1300            MOVE                          X1,Y:<NREAD ; Number of waveforms per line
587       P:0346 P:0346 5E9A00            MOVE                          Y:<NR_BIAS,A ; Number of pixels to read
588       P:0347 P:0347 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                        00034A
589       P:0349 P:0349 200022            ASR     A
590       P:034A P:034A 21C500            MOVE              A,X1                    ; Number of waveforms per line
591       P:034B P:034B 0D047A            JSR     <FASTSKP                          ; Compute number of clocks required
592       P:034C P:034C 4D1500            MOVE                          X1,Y:<NBIAS ; Number of waveforms per line
593       P:034D P:034D 44F400            MOVE              #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT),X0 ; # of waveforms
                        000006
594       P:034F P:034F 4D8300            MOVE                          Y:<NS_CLR,X1 ; Number of pixels to skip
595       P:0350 P:0350 0D047A            JSR     <FASTSKP                          ; Compute number of clocks required
596       P:0351 P:0351 4D1100            MOVE                          X1,Y:<NSCLR ; Number of waveforms per line
597       P:0352 P:0352 4D9700            MOVE                          Y:<NS_SKP1,X1 ; Number of pixels to skip
598       P:0353 P:0353 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
599       P:0354 P:0354 2000F0            MPY     Y1,X1,A
600       P:0355 P:0355 200022            ASR     A
601       P:0356 P:0356 210500            MOVE              A0,X1
602       P:0357 P:0357 0D047A            JSR     <FASTSKP                          ; Compute number of clocks required
603       P:0358 P:0358 4D1200            MOVE                          X1,Y:<NSKIP1 ; Number of waveforms per line
604       P:0359 P:0359 4D9800            MOVE                          Y:<NS_SKP2,X1 ; Number of pixels to skip
605       P:035A P:035A 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
606       P:035B P:035B 2000F0            MPY     Y1,X1,A
607       P:035C P:035C 200022            ASR     A
608       P:035D P:035D 210500            MOVE              A0,X1
609       P:035E P:035E 0D047A            JSR     <FASTSKP                          ; Compute number of clocks required
610       P:035F P:035F 4D1400            MOVE                          X1,Y:<NSKIP2 ; Number of waveforms per line
611       P:0360 P:0360 4D9600            MOVE                          Y:<NP_SKIP,X1
612       P:0361 P:0361 4F8600            MOVE                          Y:<NPBIN,Y1
613       P:0362 P:0362 2000F0            MPY     X1,Y1,A
614       P:0363 P:0363 200022            ASR     A
615       P:0364 P:0364 581600            MOVE                          A0,Y:<NP_SKIP
616       P:0365 P:0365 00000C            RTS
617    
618                             ; Returns immediately if hardware triggering is not being used
619                             ; Blocks until the trigger is found to be high twice in a row.
620                             ; Waits until the trigger goes high
621                             WAIT_UNTIL_TRIGGER
622       P:0366 P:0366 0A0088            JCLR    #TRIGGER,X:STATUS,UNTIL_TRIGGER_RETURN
                        00036F
623       P:0368 P:0368 000000            NOP
624       P:0369 P:0369 0AA48B            JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER      ; Is Trigger Low?
                        000366
625       P:036B P:036B 000000            NOP                                       ; Pause
626       P:036C P:036C 0AA48B            JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER      ; Is Trigger still Low?
                        000366
627       P:036E P:036E 000000            NOP
628                             UNTIL_TRIGGER_RETURN
629       P:036F P:036F 00000C            RTS
630    
631                             ; Returns immediately if hardware triggering is not being used
632                             ; Blocks until the trigger is found to be low twice in a row.
633                             ; Waits while the trigger is high
634                             WAIT_WHILE_TRIGGER
635       P:0370 P:0370 0A0088            JCLR    #TRIGGER,X:STATUS,WHILE_TRIGGER_RETURN
                        000379
636       P:0372 P:0372 000000            NOP
637       P:0373 P:0373 0AA4AB            JSET    #11,X:PBD,WAIT_WHILE_TRIGGER      ; Is Trigger High?
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 13



                        000370
638       P:0375 P:0375 000000            NOP                                       ; Pause
639       P:0376 P:0376 0AA4AB            JSET    #11,X:PBD,WAIT_WHILE_TRIGGER      ; Is Trigger still High?
                        000370
640       P:0378 P:0378 000000            NOP
641                             WHILE_TRIGGER_RETURN
642       P:0379 P:0379 00000C            RTS
643    
644                             ; Like WAIT_WHILE_TRIGGER but clears the CCD while waiting
645                             ; Pro:  Clears CCD while waiting.  Con: timing rattiness of 1 parallel time
646                             ; Returns immediately if hardware triggering is not being used
647                             ; Blocks until the trigger is found to be low twice in a row.
648                             ; Waits while the trigger is high
649                             CLEAR_WHILE_TRIGGER
650       P:037A P:037A 0A0088            JCLR    #TRIGGER,X:STATUS,CLEAR_TRIG_RETURN
                        000385
651       P:037C P:037C 60F400            MOVE              #IS_CLEAR,R0            ; Address of parallel transfer waveform
                        000060
652       P:037E P:037E 0D01E9            JSR     <CLOCK                            ; Go clock out the CCD charge
653       P:037F P:037F 0AA4AB            JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER     ; Is Trigger High?
                        00037A
654       P:0381 P:0381 000000            NOP                                       ; Pause
655       P:0382 P:0382 0AA4AB            JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER     ; Is Trigger still High?
                        00037A
656       P:0384 P:0384 000000            NOP
657                             CLEAR_TRIG_RETURN
658       P:0385 P:0385 00000C            RTS
659    
660                             ; Subroutine to compute SROWS in unbinned pixels and store in UBSROWS
661    
662                             UB_CONV
663       P:0386 P:0386 4CB800            MOVE                          Y:<SROWS,X0
664       P:0387 P:0387 4D8600            MOVE                          Y:<NPBIN,X1 ; Adjust for for parallel binning factor
665       P:0388 P:0388 2000A0            MPY     X0,X1,A
666       P:0389 P:0389 200022            ASR     A
667       P:038A P:038A 583900            MOVE                          A0,Y:<UBSROWS ; Put unbinned number in UBSROWS
668       P:038B P:038B 00000C            RTS
669    
670                             ; Key code segments for the HIPO modes.
671                             ; Jump table to the various modes - see also timhdr.s
672                             START_FT_EXPOSURE
673       P:038C P:038C 0A30A1            JSET    #FIND,X:IMAGE_MODE,SINGLE_PROC
                        0003BD
674       P:038E P:038E 0A30A4            JSET    #SINGLE,X:IMAGE_MODE,SINGLE_PROC
                        0003BD
675                             ;       JSET    #SERIES,X:IMAGE_MODE,SERIES_PROC        ; defunct.  Use basic occ.
676       P:0390 P:0390 0A30A0            JSET    #FDOTS,X:IMAGE_MODE,FDOT_PROC
                        00039F
677       P:0392 P:0392 0A30A2            JSET    #SDOTS,X:IMAGE_MODE,SDOT_PROC     ; slow dots & strips use sdot_proc
                        0003E7
678       P:0394 P:0394 0A30A5            JSET    #STRIP,X:IMAGE_MODE,SDOT_PROC
                        0003E7
679       P:0396 P:0396 0A30A7            JSET    #B_OCC,X:IMAGE_MODE,SINGLE_PROC   ; basic occ uses single_proc
                        0003BD
680       P:0398 P:0398 0A30A6            JSET    #F_OCC,X:IMAGE_MODE,FPO_PROC      ; fast & pipelined occ use occ_proc
                        000411
681       P:039A P:039A 0A30A8            JSET    #P_OCC,X:IMAGE_MODE,FPO_PROC
                        000411
682       P:039C P:039C 44F400            MOVE              #'ERR',X0               ; error if not a valid mode
                        455252
683       P:039E P:039E 0C0000            JMP     <ERROR
684    
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 14



685                             FDOT_PROC                                           ; used by fdots only
686                             ; Start by replacing SROWS (binned rows) with unbinned rows.  Will get rewritten on next SEX command
687                             ; Leave the DO loop in here - no reason to change it - won't exceed 65535 dots, for sure!
688       P:039F P:039F 0D0386            JSR     UB_CONV                           ; Fill in unbinned SROWS
689       P:03A0 P:03A0 5E8200            MOVE                          Y:<NPR,A
690       P:03A1 P:03A1 5E1C00            MOVE                          A,Y:<NP_READ ; Make sure that NP_READ=NPR in case of subfram
e
691       P:03A2 P:03A2 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
692       P:03A3 P:03A3 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for FDOTS
693       P:03A4 P:03A4 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
694       P:03A5 P:03A5 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        000441
695       P:03A7 P:03A7 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
696       P:03A8 P:03A8 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
697                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
698       P:03A9 P:03A9 0D0481            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
699       P:03AA P:03AA 063A40            DO      Y:<IFRAMES,FDOT_LOOP              ; Loop over the number of FDOTS
                        0003B5
700       P:03AC P:03AC 0A00A8            JSET    #TRIGGER,X:STATUS,FDX_END         ; If no triggering jump to expose image function
                        0003B1
701       P:03AE P:03AE 67F400            MOVE              #FDX_END,R7             ; Store the Address into R7
                        0003B1
702       P:03B0 P:03B0 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
703       P:03B1 P:03B1 0D0366  FDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
704       P:03B2 P:03B2 4DB900            MOVE                          Y:<UBSROWS,X1 ; Number of unbinned rows per shift
705       P:03B3 P:03B3 0D0456            JSR     <ISHIFT                           ; Clock out the waveforms
706       P:03B4 P:03B4 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
707       P:03B5 P:03B5 000000            NOP
708                             FDOT_LOOP
709       P:03B6 P:03B6 0D0488            JSR     <C_CSHUT                          ; Conditionally close shutter
710       P:03B7 P:03B7 063A40            DO      Y:<IFRAMES,FDOT_LP1               ; Loop over the number of FDOTS during readout
                        0003BA
711       P:03B9 P:03B9 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD
712       P:03BA P:03BA 000000            NOP
713                             FDOT_LP1
714                             ;       JSR     <WAIT_UNTIL_TRIGGER             ; If taking more than one set of dots sync. trigger.
  Vestigial?
715       P:03BB P:03BB 0AF080            JMP     CLEANUP                           ; clean up after command.
                        00044E
716    
717                             SINGLE_PROC                                         ; Used by find, single, and basic occ
718       P:03BD P:03BD 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for find & basic occ
719       P:03BE P:03BE 0A3084            JCLR    #SINGLE,X:IMAGE_MODE,*+3          ; But if single mode,
                        0003C1
720       P:03C0 P:03C0 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
721       P:03C1 P:03C1 0A3102            BCLR    #STORAGE,X:<ISTATUS               ; Do the FT, no storage clocks only during reado
ut
722       P:03C2 P:03C2 0A3100            BCLR    #NO_SKIP,X:<ISTATUS               ; Do parallel skip up to the subframe boundary
723    
724                                       IF      @SCP("50","0")
725                                       ELSE
726       P:03C3 P:03C3 063280            DO      #SDELAY,SNGL_DELAY1
                        0003CA
727       P:03C5 P:03C5 44F400            MOVE              #25000,X0
                        0061A8
728       P:03C7 P:03C7 06C400            DO      X0,SNGL_DELAY0
                        0003C9
729       P:03C9 P:03C9 000000            NOP
730                              SNGL_DELAY0
731       P:03CA P:03CA 000000            NOP
732                              SNGL_DELAY1
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 15



733       P:03CB P:03CB 000000            NOP
734                                       ENDIF
735    
736    
737       P:03CC P:03CC 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        000441
738       P:03CE P:03CE 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
739       P:03CF P:03CF 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
740                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
741       P:03D0 P:03D0 58BA00            MOVE                          Y:<IFRAMES,A0
742       P:03D1 P:03D1 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
743       P:03D2 P:03D2 0D0481  SN_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
744       P:03D3 P:03D3 0A00A8            JSET    #TRIGGER,X:STATUS,SNX_END         ; If no triggering jump to expose image function
                        0003D8
745       P:03D5 P:03D5 67F400            MOVE              #SNX_END,R7             ; Store the Address into R7
                        0003D8
746       P:03D7 P:03D7 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
747       P:03D8 P:03D8 0D0366  SNX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
748       P:03D9 P:03D9 0D0488            JSR     <C_CSHUT                          ; Close shutter if open-close bit is set
749       P:03DA P:03DA 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD
750       P:03DB P:03DB 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
751       P:03DC P:03DC 200013            CLR     A
752       P:03DD P:03DD 58BE00            MOVE                          Y:<IFLPCNT,A0
753       P:03DE P:03DE 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
754       P:03DF P:03DF 583E00            MOVE                          A0,Y:<IFLPCNT
755       P:03E0 P:03E0 200003            TST     A
756       P:03E1 P:03E1 0E23D2            JNE     SN_LP                             ; End of IFRAMES loop
757       P:03E2 P:03E2 0A30A1            JSET    #FIND,X:IMAGE_MODE,*+3
                        0003E5
758       P:03E4 P:03E4 0D048A            JSR     <CSHUT                            ; Close the shutter unless in find mode
759       P:03E5 P:03E5 0AF080            JMP     CLEANUP                           ; clean up after command.
                        00044E
760    
761                             SDOT_PROC                                           ; Used by slow dots and strips
762       P:03E7 P:03E7 5EB800            MOVE                          Y:<SROWS,A
763       P:03E8 P:03E8 5E1C00            MOVE                          A,Y:<NP_READ ; Make sure that NP_READ=SROWS
764       P:03E9 P:03E9 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for strips
765       P:03EA P:03EA 0A3082            JCLR    #SDOTS,X:IMAGE_MODE,*+3           ; But if sdots mode,
                        0003ED
766       P:03EC P:03EC 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
767       P:03ED P:03ED 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for SDOTS and st
rips
768       P:03EE P:03EE 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
769                                       IF      @SCP("50","0")
770                                       ELSE
771       P:03EF P:03EF 063280            DO      #SDELAY,SDOT_DELAY1
                        0003F6
772       P:03F1 P:03F1 44F400            MOVE              #25000,X0
                        0061A8
773       P:03F3 P:03F3 06C400            DO      X0,SDOT_DELAY0
                        0003F5
774       P:03F5 P:03F5 000000            NOP
775                              SDOT_DELAY0
776       P:03F6 P:03F6 000000            NOP
777                              SDOT_DELAY1
778       P:03F7 P:03F7 000000            NOP
779                                       ENDIF
780    
781       P:03F8 P:03F8 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        000441
782       P:03FA P:03FA 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 16



783       P:03FB P:03FB 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
784                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
785       P:03FC P:03FC 58BA00            MOVE                          Y:<IFRAMES,A0
786       P:03FD P:03FD 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
787       P:03FE P:03FE 0D0481  SD_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
788       P:03FF P:03FF 0A00A8            JSET    #TRIGGER,X:STATUS,SDX_END         ; If no triggering jump to expose image function
                        000404
789       P:0401 P:0401 67F400            MOVE              #SDX_END,R7             ; Store the Address into R7
                        000404
790       P:0403 P:0403 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
791       P:0404 P:0404 0D0366  SDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
792       P:0405 P:0405 0D0488            JSR     <C_CSHUT                          ; Close shutter if open-close is set
793       P:0406 P:0406 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD.
794                                                                                 ; No FT or parallel skip since STORAGE=1
795       P:0407 P:0407 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
796       P:0408 P:0408 200013            CLR     A
797       P:0409 P:0409 58BE00            MOVE                          Y:<IFLPCNT,A0
798       P:040A P:040A 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
799       P:040B P:040B 583E00            MOVE                          A0,Y:<IFLPCNT
800       P:040C P:040C 200003            TST     A
801       P:040D P:040D 0E23FE            JNE     SD_LP                             ; End of IFRAMES loop
802       P:040E P:040E 0D048A            JSR     <CSHUT                            ; Unconditionally close shutter
803       P:040F P:040F 0AF080            JMP     CLEANUP                           ; clean up after command.
                        00044E
804    
805                             FPO_PROC                                            ; Used by fast and pipelined occultation modes
806       P:0411 P:0411 5E9C00            MOVE                          Y:<NP_READ,A
807       P:0412 P:0412 5E3800            MOVE                          A,Y:<SROWS  ; Make sure that SROWS=NP_READ
808       P:0413 P:0413 0D0386            JSR     UB_CONV                           ; Fill in unbinned SROWS in UBSROWS
809       P:0414 P:0414 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for both of these modes
810       P:0415 P:0415 0A3102            BCLR    #STORAGE,X:<ISTATUS               ; Storage clocks only during readout
811       P:0416 P:0416 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
812       P:0417 P:0417 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        000441
813       P:0419 P:0419 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
814       P:041A P:041A 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
815                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
816       P:041B P:041B 0D0481            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
817       P:041C P:041C 58BA00            MOVE                          Y:<IFRAMES,A0
818       P:041D P:041D 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
819       P:041E P:041E 0A00A8  FP_LP     JSET    #TRIGGER,X:STATUS,FPO_END         ; If no triggering jump to expose image function
                        000423
820       P:0420 P:0420 67F400            MOVE              #FPO_END,R7             ; Store the Address into R7
                        000423
821       P:0422 P:0422 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
822       P:0423 P:0423 0D0366  FPO_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
823       P:0424 P:0424 4DB900            MOVE                          Y:<UBSROWS,X1 ; Shift down UBSROWS unbinned rows
824       P:0425 P:0425 0BF080            JSR     ISHIFT                            ; Clock down subframe height
                        000456
825       P:0427 P:0427 0A30A8            JSET    #P_OCC,X:IMAGE_MODE,FPO_RD        ; Shift the rest of the way for F_OCC
                        000431
826                                                                                 ; Go straight to readout if P_OCC
827       P:0429 P:0429 4CF000            MOVE                          Y:S_SIZE,X0
                        00003B
828       P:042B P:042B 208E00            MOVE              X0,A                    ; Get only least significant 24 bits
829       P:042C P:042C 4CB900            MOVE                          Y:<UBSROWS,X0
830       P:042D P:042D 200044            SUB     X0,A                              ;
831       P:042E P:042E 21C500            MOVE              A,X1                    ; X1 = S_SIZE - UBSROWS
832       P:042F P:042F 0BF080            JSR     SSHIFT                            ; Clock storage the rest of the way
                        00045F
833       P:0431 P:0431 0D0134  FPO_RD    JSR     <RCCD1                            ; Finally, read out the CCD.  Skip the FT
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 17



834       P:0432 P:0432 0A30A6            JSET    #F_OCC,X:IMAGE_MODE,FPO_SK        ; Shift back up by UBSROWS if P_OCC
                        000437
835       P:0434 P:0434 4DB900            MOVE                          Y:<UBSROWS,X1 ; Shift UBSROWS unbinned rows back up
836       P:0435 P:0435 0BF080            JSR     RSHIFT                            ; Clock subframe height back up
                        000468
837       P:0437 P:0437 0D0370  FPO_SK    JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
838       P:0438 P:0438 200013            CLR     A
839       P:0439 P:0439 58BE00            MOVE                          Y:<IFLPCNT,A0
840       P:043A P:043A 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
841       P:043B P:043B 583E00            MOVE                          A0,Y:<IFLPCNT
842       P:043C P:043C 200003            TST     A
843       P:043D P:043D 0E241E            JNE     FP_LP                             ; End of IFRAMES loop
844       P:043E P:043E 0D048A            JSR     <CSHUT                            ; Unconditionally close shutter
845       P:043F P:043F 0AF080            JMP     CLEANUP                           ; clean up after command.
                        00044E
846    
847                             ; Support subroutines and code fragments used in the various mode code
848                             ; IMG_INI, CLEANUP, ISHIFT, SSHIFT, RSHIFT
849                             ;  Image initialization subroutine.  Sets up status bits & PCI card
850    
851       P:0441 P:0441 09F480  IMG_INI   MOVEP             #$020102,Y:WRFO         ; Transmit header word
                        020102
852       P:0443 P:0443 060FA0            REP     #15                               ; Delay for transmission
853       P:0444 P:0444 000000            NOP
854       P:0445 P:0445 09F480            MOVEP             #'IIA',Y:WRFO           ; Initialize Image Address
                        494941
855       P:0447 P:0447 060FA0            REP     #15
856       P:0448 P:0448 000000            NOP
857       P:0449 P:0449 0A0024            BSET    #ST_RDC,X:<STATUS                 ; Set status to reading out
858       P:044A P:044A 0D05F6            JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
859       P:044B P:044B 0AA421            BSET    #WW,X:PBD                         ; Set WW = 1 for 16-bit image data
860       P:044C P:044C 000000            NOP
861       P:044D P:044D 00000C            RTS
862    
863                             ; Cleanup code fragment (not a subroutine) for the end all modes.  JMP to it.
864    
865       P:044E P:044E 0AA401  CLEANUP   BCLR    #WW,X:PBD                         ; Clear WW to 0 for 32-bit commands
866       P:044F P:044F 0A0004            BCLR    #ST_RDC,X:<STATUS                 ; Clear status to NOT reading out
867                             ; Restore the controller to non-image data transfer and idling if necessary
868       P:0450 P:0450 0A0082            JCLR    #IDLMODE,X:<STATUS,START          ; Don't idle after readout
                        000008
869       P:0452 P:0452 44F400            MOVE              #IDLE,X0
                        00020F
870       P:0454 P:0454 440000            MOVE              X0,X:<IDL_ADR
871       P:0455 P:0455 0C0008            JMP     <START                            ; Wait for a new command
872    
873                             ; Shift image and storage areas down by the number of rows in X1
874                             ISHIFT
875       P:0456 P:0456 06C500            DO      X1,ISH_LOOP                       ; Number of rows to shift is in X1
                        00045A
876       P:0458 P:0458 306000            MOVE              #<IS_CLEAR,R0           ; Ganged clocks with DG running
877       P:0459 P:0459 0D01E9            JSR     <CLOCK                            ; Parallel clocking
878       P:045A P:045A 000000            NOP
879                             ISH_LOOP
880       P:045B P:045B 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                        000068
881       P:045D P:045D 0D01E9            JSR     <CLOCK
882       P:045E P:045E 00000C            RTS                                       ; End of ISHIFT
883    
884                             ; Shift storage area only down by the number of rows in X1
885                             SSHIFT
886       P:045F P:045F 06C500            DO      X1,SSH_LOOP                       ; Number of rows to shift is in X1
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timmisc.s  Page 18



                        000463
887       P:0461 P:0461 305000            MOVE              #<S_CLEAR,R0            ; Storage clocks only with DG running
888       P:0462 P:0462 0D01E9            JSR     <CLOCK                            ; Parallel clocking
889       P:0463 P:0463 000000            NOP
890                             SSH_LOOP
891       P:0464 P:0464 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                        000068
892       P:0466 P:0466 0D01E9            JSR     <CLOCK
893       P:0467 P:0467 00000C            RTS                                       ; End of SSHIFT
894    
895                             ; Used by pipelined occultation mode to move the storage area back up to
896                             ; the seam following read of a subframe
897                             RSHIFT
898       P:0468 P:0468 06C500            DO      X1,RVS_SHIFT                      ; Number of rows to read out
                        00046C
899       P:046A P:046A 304800            MOVE              #<R_S_PARALLEL,R0       ; Reverse parallel waveform
900       P:046B P:046B 0D01E9            JSR     <CLOCK                            ; Parallel clocking
901       P:046C P:046C 000000            NOP
902                             RVS_SHIFT
903       P:046D P:046D 00000C            RTS                                       ; End of RSHIFT
904                                       INCLUDE "timCCDmisc.s"                    ; Generic
905                             ; This file is for utilities that are in common to all the timing board
906                             ;   programs, located starting at P:$200 in external SRAM
907    
908                                     COMMENT *
909    
910                             The following commands are supported in this "timmisc.s" file
911                             PAL_DLY                 Subroutine to delay by about 8 microseconds
912                             SET_DAC                 Transfer DAC values in (R0) table to the DACs
913                             FASTSKP                 Compute number of waveform table entries in a readout
914                                                             for fast clocking
915                             SYNTHETIC_IMAGE         Generate a synthetic image for system testing
916                             OSHUT                   Subroutine call for opening the shutter
917                             CSHUT                   Subroutine call for closing the shutter
918                             OPEN_SHUTTER            Command for opening the shutter
919                             CLOSE_SHUTTER           Command for closing the shutter
920                             SET_EXP_TIME            Write desired exposure time to timing board variable
921                             RD_EXP_TIME             Read elapsed exposure time
922                             START_EXPOSURE          Start an exposure - 'DON' reply, clear FPA, open
923                                                     shutter, expose, close shutter, delay Y:SH_DLY, readout
924                             PAUSE_EXPOSURE          Close shutter, stop exposure timer
925                             RESUME_EXPOSURE         Open shutter if necessary, resume exposure timer
926                             ABORT_EXPOSURE          Close shutter, stop exposure timer
927                             INF                     Return version and timing information
928                             IDL                     Put FPA to clocking when not processing commands or
929                                                     reading out
930                             STP                     Put FPA to not clocking when not processing commands or
931                                                     reading out
932                             READ_CONTROLLER_CONFIGURATION
933    
934                             PWR_OFF                 Turn off ananlog power supply voltages to backplane
935                             PWR_ON                  Turn on analog power supply voltages to backplane
936                             SETBIAS                 Command to call SET_BIASES and reply 'DON'
937                             SET_BIASES              Subroutine to turn on all bias and clock voltages
938                                                     by reading them from the waveform tables and writing
939                                                     them to the DACs
940                             SER_ANA                 Direct the timing board DSP's synchronous serial
941                                                     transmitter to the analog boards (clock driver, video)
942                             SER_UTL                 Direct the timing board DSP's synchronous serial
943                                                     transmitter to the utility board
944                             CLR_SWS                 Clear the analog switches in the clock driver and
945                                                     video boards to lower their power consumption, as a
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timCCDmisc.s  Page 19



946                                                     command with a 'DON' reply
947                             CLEAR_SWITCHES          A subroutine call for CLR_WSW
948                             ST_GAIN                 Set the video processor gain to one of four values
949                             WR_CNTRL
950                             SET_DC
951                             SET_BIAS_NUMBER
952                             SET_MUX
953    
954                                     *
955    
956                             ;  ** Place this file after the custom timmisc.s file so it continues
957                             ;       to be written in the P:$200 address space  ****
958    
959                             ; Hardware control bit definitions
960       000004                SHUTTER   EQU     4                                 ; Shutter control bit = TIM-LATCH0, A30
961    
962    
963                             ; Delay for serial writes to the PALs and DACs by 8 microsec
964       P:046E P:046E 06FA80  PAL_DLY   DO      #250,DLY                          ; Wait 8 usec for serial data transmission
                        000470
965       P:0470 P:0470 000000            NOP
966       P:0471 P:0471 000000  DLY       NOP
967       P:0472 P:0472 00000C            RTS
968    
969                             ;  Update the DACs
970       P:0473 P:0473 4CD800  SET_DAC   MOVE                          Y:(R0)+,X0  ; Get the number of table entries
971       P:0474 P:0474 06C400            DO      X0,SET_L0                         ; Repeat X0 times
                        000478
972       P:0476 P:0476 08D8EF            MOVEP             Y:(R0)+,X:SSITX         ; Send out the waveform
973       P:0477 P:0477 0D046E            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
974       P:0478 P:0478 000000            NOP                                       ; Do loop restriction
975                             SET_L0
976       P:0479 P:0479 00000C            RTS                                       ; Return from subroutine
977    
978                             ; Subroutine for computing number of fast clocks needed
979       P:047A P:047A 2000A8  FASTSKP   MPY     X0,X1,B                           ; X1 = number of pixels to skip,
980                                                                                 ; X0 = number of waveform table entries
981       P:047B P:047B 20002A            ASR     B                                 ; Correct for multiplication left shift
982       P:047C P:047C 212E00            MOVE              B0,A                    ; Get only least significant 24 bits
983       P:047D P:047D 458000            MOVE              X:<ONE,X1
984       P:047E P:047E 200064            SUB     X1,A                              ; Subtract 1
985       P:047F P:047F 21C500            MOVE              A,X1                    ; X1 = X0 * X1 - 1
986       P:0480 P:0480 00000C            RTS
987    
988                             ; Subroutine with two entry points.  C_OSHUT is conditional on SHUT
989                             ; Open the shutter conditionally based on the shutter status bit
990                             ; Open the shutter by setting the backplane bit TIM-LATCH0
991       P:0481 P:0481 0A008B  C_OSHUT   JCLR    #SHUT,X:STATUS,OSH_RTN
                        000487
992       P:0483 P:0483 0A0023  OSHUT     BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
993       P:0484 P:0484 0A0004            BCLR    #SHUTTER,X:<LATCH                 ; Clear hardware shutter bit to open
994       P:0485 P:0485 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                        000000
995       P:0487 P:0487 00000C  OSH_RTN   RTS
996    
997                             ; Subroutine with two entry points.  C_CSHUT is conditional on OPEN_CLOSE
998                             ; Close the shutter conditionally based on the open-close ISTATUS bit
999                             ; Close the shutter by clearing the backplane bit TIM-LATCH0
1000      P:0488 P:0488 0A3181  C_CSHUT   JCLR    #OPEN_CLOSE,X:ISTATUS,CSH_RTN     ; Don't close if always open
                        00049A
1001      P:048A P:048A 0A0003  CSHUT     BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
1002      P:048B P:048B 0A0024            BSET    #SHUTTER,X:<LATCH                 ; Set hardware shutter bit to close
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timCCDmisc.s  Page 20



1003      P:048C P:048C 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                        000000
1004      P:048E P:048E 5E8900            MOVE                          Y:<SH_DEL,A
1005      P:048F P:048F 200003            TST     A
1006      P:0490 P:0490 0EF499            JLE     <S_DEL0
1007      P:0491 P:0491 44F400            MOVE              #25000,X0
                        0061A8
1008      P:0493 P:0493 06CE00            DO      A,S_DEL0                          ; Delay by Y:SH_DEL milliseconds
                        000498
1009      P:0495 P:0495 06C400            DO      X0,S_DEL1
                        000497
1010      P:0497 P:0497 000000            NOP
1011      P:0498 P:0498 000000  S_DEL1    NOP
1012      P:0499 P:0499 000000  S_DEL0    NOP
1013      P:049A P:049A 00000C  CSH_RTN   RTS
1014   
1015                            ; Open the shutter from the timing board, executed as a command
1016                            OPEN_SHUTTER
1017      P:049B P:049B 0D0483            JSR     <OSHUT
1018      P:049C P:049C 0C0000            JMP     <FINISH
1019   
1020                            ; Close the shutter from the timing board, executed as a command
1021                            CLOSE_SHUTTER
1022      P:049D P:049D 0D048A            JSR     <CSHUT
1023      P:049E P:049E 0C0000            JMP     <FINISH
1024   
1025                            ; Set the desired exposure time
1026                            SET_EXP_TIME
1027      P:049F P:049F 44DC00            MOVE              X:(R4)+,X0
1028      P:04A0 P:04A0 440000            MOVE              X0,X:<EXP_TIM           ; Write to magic address
1029      P:04A1 P:04A1 440000            MOVE              X0,X:<TGT_TIM
1030      P:04A2 P:04A2 0C0000            JMP     <FINISH
1031   
1032   
1033                            ; Abort exposure - close the shutter, stop the timer and resume idle mode
1034                            ABORT_EXPOSURE
1035      P:04A3 P:04A3 0A9E00            BCLR    #TIM_BIT,X:TCSR                   ; Disable the DSP exposure timer
1036      P:04A4 P:04A4 0D048A            JSR     <CSHUT                            ; Close the shutter
1037      P:04A5 P:04A5 0A0082            JCLR    #IDLMODE,X:<STATUS,FINISH         ; Check whether to idle after readout
                        000000
1038      P:04A7 P:04A7 44F400            MOVE              #IDLE,X0                ; Idle after readout
                        00020F
1039      P:04A9 P:04A9 440000            MOVE              X0,X:<IDL_ADR
1040      P:04AA P:04AA 0C0000            JMP     <FINISH
1041   
1042                            ;       Process INF according to the single addressing parameter
1043                            GET_INFO
1044      P:04AB P:04AB 56DC00            MOVE              X:(R4)+,A               ; 0-4 is generic, >= 0x100 tim specific
1045      P:04AC P:04AC 44F400            MOVE              #IVERSION,X0
                        04407F
1046      P:04AE P:04AE 46F400            MOVE              #>GET_VERSION,Y0
                        000000
1047      P:04B0 P:04B0 200055            CMP     Y0,A
1048      P:04B1 P:04B1 0EA000            JEQ     <FINISH1
1049      P:04B2 P:04B2 44F400            MOVE              #IFLAVOR,X0
                        612020
1050      P:04B4 P:04B4 46F400            MOVE              #>GET_FLAVOR,Y0
                        000001
1051      P:04B6 P:04B6 200055            CMP     Y0,A
1052      P:04B7 P:04B7 0EA000            JEQ     <FINISH1
1053      P:04B8 P:04B8 44F400            MOVE              #ITIME0,X0
                        00CBC8
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timCCDmisc.s  Page 21



1054      P:04BA P:04BA 46F400            MOVE              #>GET_TIME0,Y0
                        000002
1055      P:04BC P:04BC 200055            CMP     Y0,A
1056      P:04BD P:04BD 0EA000            JEQ     <FINISH1                          ; Is it Time0?
1057      P:04BE P:04BE 44F400            MOVE              #ITIME1,X0
                        004CC0
1058      P:04C0 P:04C0 46F400            MOVE              #>GET_TIME1,Y0
                        000003
1059      P:04C2 P:04C2 200055            CMP     Y0,A
1060      P:04C3 P:04C3 0EA000            JEQ     <FINISH1                          ; Is it Time1?
1061      P:04C4 P:04C4 240000            MOVE              #ISVNREV,X0
1062      P:04C5 P:04C5 46F400            MOVE              #>GET_SVNREV,Y0
                        000004
1063      P:04C7 P:04C7 200055            CMP     Y0,A
1064      P:04C8 P:04C8 0EA000            JEQ     <FINISH1                          ; Is it Svn rev?
1065      P:04C9 P:04C9 44F400            MOVE              #TIMCAPABLE,X0
                        0001FB
1066      P:04CB P:04CB 46F400            MOVE              #>GET_CAPABLE,Y0
                        000100
1067      P:04CD P:04CD 200055            CMP     Y0,A
1068      P:04CE P:04CE 0EA000            JEQ     <FINISH1                          ; Is it Tim Capabilities?
1069      P:04CF P:04CF 44F400            MOVE              #INT_TIM,X0
                        080000
1070      P:04D1 P:04D1 46F400            MOVE              #>GET_INT_TIM,Y0
                        000101
1071      P:04D3 P:04D3 200055            CMP     Y0,A
1072      P:04D4 P:04D4 0EA000            JEQ     <FINISH1                          ; Is it Integration time?
1073      P:04D5 P:04D5 44F400            MOVE              #R_DELAY,X0
                        000000
1074      P:04D7 P:04D7 46F400            MOVE              #>GET_R_DELAY,Y0
                        000102
1075      P:04D9 P:04D9 200055            CMP     Y0,A
1076      P:04DA P:04DA 0EA000            JEQ     <FINISH1                          ; Is it Serial time?
1077      P:04DB P:04DB 44F400            MOVE              #SI_DELAY,X0
                        860000
1078      P:04DD P:04DD 46F400            MOVE              #>GET_SI_DELAY,Y0
                        000103
1079      P:04DF P:04DF 200055            CMP     Y0,A
1080      P:04E0 P:04E0 0EA000            JEQ     <FINISH1                          ; Is it Parallel time?
1081      P:04E1 P:04E1 0C0000            JMP     <ERROR
1082   
1083   
1084                            ; Set software to IDLE mode
1085      P:04E2 P:04E2 44F400  IDL       MOVE              #IDLE,X0                ; Exercise clocks when idling
                        00020F
1086      P:04E4 P:04E4 440000            MOVE              X0,X:<IDL_ADR
1087      P:04E5 P:04E5 0A0022            BSET    #IDLMODE,X:<STATUS                ; Idle after readout
1088      P:04E6 P:04E6 0C0000            JMP     <FINISH                           ; Need to send header and 'DON'
1089   
1090                            ; Come to here on a 'STP' command so 'DON' can be sent
1091      P:04E7 P:04E7 44F400  STP       MOVE              #TST_RCV,X0             ; Wait for commands during exposure
                        000000
1092      P:04E9 P:04E9 440000            MOVE              X0,X:<IDL_ADR           ;  instead of exercising clocks
1093      P:04EA P:04EA 0A0002            BCLR    #IDLMODE,X:<STATUS                ; Don't idle after readout
1094      P:04EB P:04EB 0C0000            JMP     <FINISH
1095   
1096                            ; Let the host computer read the controller configuration
1097                            READ_CONTROLLER_CONFIGURATION
1098      P:04EC P:04EC 4C8A00            MOVE                          Y:<CONFIG,X0 ; Just transmit the configuration
1099      P:04ED P:04ED 0C0000            JMP     <FINISH1
1100   
1101                            ; Power off
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timCCDmisc.s  Page 22



1102      P:04EE P:04EE 0D053D  PWR_OFF   JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1103      P:04EF P:04EF 0AA202            BCLR    #LVEN,X:PBDDR                     ; Set these signals to DSP inputs
1104      P:04F0 P:04F0 0AA20D            BCLR    #PWRST,X:PBDDR
1105      P:04F1 P:04F1 0AA203            BCLR    #HVEN,X:PBDDR
1106      P:04F2 P:04F2 0AA422            BSET    #LVEN,X:PBD                       ; LVEN = HVEN = 1 => Power reset
1107      P:04F3 P:04F3 0AA42D            BSET    #PWRST,X:PBD
1108      P:04F4 P:04F4 0AA423            BSET    #HVEN,X:PBD
1109      P:04F5 P:04F5 0C0000            JMP     <FINISH
1110   
1111                            ; Start power-on cycle
1112      P:04F6 P:04F6 0AA222  PWR_ON    BSET    #LVEN,X:PBDDR                     ; Set these signals to DSP outputs
1113      P:04F7 P:04F7 0AA22D            BSET    #PWRST,X:PBDDR
1114      P:04F8 P:04F8 0AA223            BSET    #HVEN,X:PBDDR
1115      P:04F9 P:04F9 0D053D            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1116   
1117                            ; Ramp up the low voltages (+/- 6.5V, 16.5V) and then delay
1118      P:04FA P:04FA 0AA402            BCLR    #LVEN,X:PBD                       ; LVEN = Low => Turn on +/- 6.5V,
1119      P:04FB P:04FB 0AA40D            BCLR    #PWRST,X:PBD
1120      P:04FC P:04FC 44F400            MOVE              #60000,X0
                        00EA60
1121      P:04FE P:04FE 06C400            DO      X0,WT_PON1                        ; Wait 10 millisec or so for settling
                        000503
1122      P:0500 P:0500 07708E            MOVE              A,P:RSTWDT              ; Reset watchdog timer
                        006000
1123      P:0502 P:0502 07708E            MOVE              A,P:RSTWDT
                        006000
1124                            WT_PON1
1125   
1126                            ; Ramp up the high +36 volt power line and then delay
1127      P:0504 P:0504 0AA403            BCLR    #HVEN,X:PBD                       ; HVEN = Low => Turn on +36V
1128      P:0505 P:0505 44F400            MOVE              #60000,X0
                        00EA60
1129      P:0507 P:0507 06C400            DO      X0,WT_PON2                        ; Wait 10 millisec or so for settling
                        00050C
1130      P:0509 P:0509 07708E            MOVE              A,P:RSTWDT              ; Reset watchdog timer
                        006000
1131      P:050B P:050B 07708E            MOVE              A,P:RSTWDT
                        006000
1132                            WT_PON2
1133      P:050D P:050D 0D0514            JSR     <SET_BIASES                       ; Turn on the DC bias supplies
1134      P:050E P:050E 44F400            MOVE              #IDLE,X0
                        00020F
1135      P:0510 P:0510 440000            MOVE              X0,X:<IDL_ADR
1136      P:0511 P:0511 0C0000            JMP     <FINISH                           ; All done with 'DON'
1137   
1138      P:0512 P:0512 0D0514  SETBIAS   JSR     <SET_BIASES
1139      P:0513 P:0513 0C0000            JMP     <FINISH
1140   
1141                            ; Set all the DC bias voltages and video processor offset values, reading
1142                            ;   them from the table labeled DACS in this file
1143                            SET_BIASES
1144      P:0514 P:0514 0D052D            JSR     <SER_ANA
1145      P:0515 P:0515 0A0020            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
1146      P:0516 P:0516 0A0022            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
1147      P:0517 P:0517 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Disable clear of DAC and enable clocks
                        000000
1148      P:0519 P:0519 0D046E            JSR     <PAL_DLY                          ; Delay for all this to happen
1149      P:051A P:051A 0D046E            JSR     <PAL_DLY                          ; Delay for all this to happen
1150   
1151                            ; Disable simultaneous update of clock driver boards
1152      P:051B P:051B 0A0001            BCLR    #1,X:<LATCH
1153      P:051C P:051C 09F081            MOVEP             X:LATCH,Y:WRLATCH
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timCCDmisc.s  Page 23



                        000000
1154   
1155                            ; Read DAC values from a table, and set DACs
1156      P:051E P:051E 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                        000100
1157      P:0520 P:0520 0D0473            JSR     <SET_DAC
1158   
1159                            ; Set all video processor analog switches to open to disable them (1 => OFF)
1160      P:0521 P:0521 56F400            MOVE              #$000FFF,A
                        000FFF
1161      P:0523 P:0523 566600            MOVE              A,X:(R6)                ; Send out the waveform
1162      P:0524 P:0524 000000            NOP
1163   
1164                            ; Let the DAC voltages all ramp up before exiting
1165      P:0525 P:0525 56F400            MOVE              #400,A                  ; Delay 4 millisec
                        000190
1166      P:0527 P:0527 06CE00            DO      A,L_SBI1
                        00052A
1167      P:0529 P:0529 0D046E            JSR     <PAL_DLY                          ; Delay for all this to happen
1168      P:052A P:052A 000000            NOP
1169                            L_SBI1
1170      P:052B P:052B 0D0534            JSR     <SER_UTL                          ; SSI -> utility board communication
1171      P:052C P:052C 00000C            RTS
1172   
1173                            ; Enable serial communication to the analog boards
1174      P:052D P:052D 0AA420  SER_ANA   BSET    #0,X:PBD                          ; Set H0 for analog boards SSI
1175      P:052E P:052E 08F4A1            MOVEP             #$0000,X:PCC            ; Software reset of SSI
                        000000
1176      P:0530 P:0530 0AAD0A            BCLR    #10,X:CRB                         ; SSI -> continuous clock for analog
1177      P:0531 P:0531 08F4A1            MOVEP             #$0160,X:PCC            ; Re-enable the SSI
                        000160
1178      P:0533 P:0533 00000C            RTS
1179   
1180                            ; Enable serial communication to the utility board
1181      P:0534 P:0534 08F4A1  SER_UTL   MOVEP             #$0000,X:PCC            ; Software reset of SSI
                        000000
1182      P:0536 P:0536 0AAD2A            BSET    #10,X:CRB                         ; SSI -> gated clock for util board
1183      P:0537 P:0537 08F4A1            MOVEP             #$0160,X:PCC            ; Enable the SSI
                        000160
1184      P:0539 P:0539 0AA400            BCLR    #0,X:PBD                          ; Clear H0 for utility board SSI
1185      P:053A P:053A 00000C            RTS
1186   
1187      P:053B P:053B 0D053D  CLR_SWS   JSR     <CLEAR_SWITCHES
1188      P:053C P:053C 0C0000            JMP     <FINISH
1189   
1190                            ; Clear all video processor analog switches to lower their power dissipation
1191                            CLEAR_SWITCHES
1192      P:053D P:053D 0D052D            JSR     <SER_ANA                          ; Set SSI to analog board communication
1193      P:053E P:053E 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                        0C3000
1194      P:0540 P:0540 20001B            CLR     B
1195      P:0541 P:0541 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC writes
1196      P:0542 P:0542 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writes
                        001000
1197      P:0544 P:0544 060F80            DO      #15,L_VIDEO                       ; Fifteen video processor boards maximum
                        00054B
1198      P:0546 P:0546 08CE2F            MOVEP             A,X:SSITX               ; Gain, integrate speed
1199      P:0547 P:0547 200040            ADD     X0,A
1200      P:0548 P:0548 577000            MOVE              B,X:WRSS
                        00FF80
1201      P:054A P:054A 0D046E            JSR     <PAL_DLY                          ; Delay for the serial data transmission
1202      P:054B P:054B 200068            ADD     X1,B
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timCCDmisc.s  Page 24



1203                            L_VIDEO
1204      P:054C P:054C 0A0000            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
1205      P:054D P:054D 0A0002            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
1206      P:054E P:054E 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                        000000
1207      P:0550 P:0550 44F400            MOVE              #IDLE,X0
                        00020F
1208      P:0552 P:0552 440000            MOVE              X0,X:<IDL_ADR
1209      P:0553 P:0553 0D0534            JSR     <SER_UTL                          ; Return SSI to utility board
1210      P:0554 P:0554 00000C            RTS
1211   
1212                            ; Set the clock multiplexers
1213      P:0555 P:0555 0D052D  SET_MUX   JSR     <SER_ANA                          ; Set SSI to analog board communication
1214      P:0556 P:0556 56DC00            MOVE              X:(R4)+,A               ; Clock driver board number
1215      P:0557 P:0557 0614A0            REP     #20
1216      P:0558 P:0558 200033            LSL     A
1217      P:0559 P:0559 44F400            MOVE              #$003000,X0
                        003000
1218      P:055B P:055B 200042            OR      X0,A
1219      P:055C P:055C 21C500            MOVE              A,X1                    ; Move here for storage
1220   
1221                            ; Get the first MUX number
1222      P:055D P:055D 56DC00            MOVE              X:(R4)+,A               ; Get the first MUX number
1223      P:055E P:055E 0AF0A9            JLT     ERR_SM1
                        0005A0
1224      P:0560 P:0560 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                        000018
1225      P:0562 P:0562 200045            CMP     X0,A
1226      P:0563 P:0563 0AF0A1            JGE     ERR_SM1
                        0005A0
1227      P:0565 P:0565 21CF00            MOVE              A,B
1228      P:0566 P:0566 44F400            MOVE              #>7,X0
                        000007
1229      P:0568 P:0568 20004E            AND     X0,B
1230      P:0569 P:0569 44F400            MOVE              #>$18,X0
                        000018
1231      P:056B P:056B 200046            AND     X0,A
1232      P:056C P:056C 0E256F            JNE     <SMX_1                            ; Test for 0 <= MUX number <= 7
1233      P:056D P:056D 0ACD63            BSET    #3,B1
1234      P:056E P:056E 0C057A            JMP     <SMX_A
1235      P:056F P:056F 44F400  SMX_1     MOVE              #>$08,X0
                        000008
1236      P:0571 P:0571 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1237      P:0572 P:0572 0E2575            JNE     <SMX_2
1238      P:0573 P:0573 0ACD64            BSET    #4,B1
1239      P:0574 P:0574 0C057A            JMP     <SMX_A
1240      P:0575 P:0575 44F400  SMX_2     MOVE              #>$10,X0
                        000010
1241      P:0577 P:0577 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1242      P:0578 P:0578 0E25A0            JNE     <ERR_SM1
1243      P:0579 P:0579 0ACD65            BSET    #5,B1
1244      P:057A P:057A 20006A  SMX_A     OR      X1,B1                             ; Add prefix to MUX numbers
1245      P:057B P:057B 21A700            MOVE              B1,Y1
1246   
1247                            ; Add on the second MUX number
1248      P:057C P:057C 56DC00            MOVE              X:(R4)+,A               ; Get the next MUX number
1249      P:057D P:057D 0AF0A9            JLT     ERR_SM2
                        0005A1
1250      P:057F P:057F 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                        000018
1251      P:0581 P:0581 200045            CMP     X0,A
1252      P:0582 P:0582 0AF0A1            JGE     ERR_SM2
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timCCDmisc.s  Page 25



                        0005A1
1253      P:0584 P:0584 0606A0            REP     #6
1254      P:0585 P:0585 200033            LSL     A
1255      P:0586 P:0586 21CF00            MOVE              A,B
1256      P:0587 P:0587 44F400            MOVE              #$1C0,X0
                        0001C0
1257      P:0589 P:0589 20004E            AND     X0,B
1258      P:058A P:058A 44F400            MOVE              #>$600,X0
                        000600
1259      P:058C P:058C 200046            AND     X0,A
1260      P:058D P:058D 0E2590            JNE     <SMX_3                            ; Test for 0 <= MUX number <= 7
1261      P:058E P:058E 0ACD69            BSET    #9,B1
1262      P:058F P:058F 0C059B            JMP     <SMX_B
1263      P:0590 P:0590 44F400  SMX_3     MOVE              #>$200,X0
                        000200
1264      P:0592 P:0592 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1265      P:0593 P:0593 0E2596            JNE     <SMX_4
1266      P:0594 P:0594 0ACD6A            BSET    #10,B1
1267      P:0595 P:0595 0C059B            JMP     <SMX_B
1268      P:0596 P:0596 44F400  SMX_4     MOVE              #>$400,X0
                        000400
1269      P:0598 P:0598 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1270      P:0599 P:0599 0E25A1            JNE     <ERR_SM2
1271      P:059A P:059A 0ACD6B            BSET    #11,B1
1272      P:059B P:059B 200078  SMX_B     ADD     Y1,B                              ; Add prefix to MUX numbers
1273   
1274      P:059C P:059C 08CD2F            MOVEP             B1,X:SSITX
1275      P:059D P:059D 0D046E            JSR     <PAL_DLY                          ; Delay for all this to happen
1276      P:059E P:059E 0D0534            JSR     <SER_UTL                          ; Return SSI to utility board communication
1277      P:059F P:059F 0C0000            JMP     <FINISH
1278      P:05A0 P:05A0 56DC00  ERR_SM1   MOVE              X:(R4)+,A
1279      P:05A1 P:05A1 0D0534  ERR_SM2   JSR     <SER_UTL                          ; Return SSI to utility board communication
1280      P:05A2 P:05A2 0C0000            JMP     <ERROR
1281   
1282   
1283                            ; Set the video processor gain and integrator speed for all video boards
1284                            ;  Command syntax is  SGN  #GAIN  #SPEED, #GAIN = 1, 2, 5 or 10
1285                            ;                                         #SPEED = 0 for slow, 1 for fast
1286      P:05A3 P:05A3 0D052D  ST_GAIN   JSR     <SER_ANA                          ; Set SSI to analog board communication
1287      P:05A4 P:05A4 56DC00            MOVE              X:(R4)+,A               ; Gain value (1,2,5 or 10)
1288      P:05A5 P:05A5 44F400            MOVE              #>1,X0
                        000001
1289      P:05A7 P:05A7 200045            CMP     X0,A                              ; Check for gain = x1
1290      P:05A8 P:05A8 0E25AC            JNE     <STG2
1291      P:05A9 P:05A9 57F400            MOVE              #>$77,B
                        000077
1292      P:05AB P:05AB 0C05C0            JMP     <STG_A
1293      P:05AC P:05AC 44F400  STG2      MOVE              #>2,X0                  ; Check for gain = x2
                        000002
1294      P:05AE P:05AE 200045            CMP     X0,A
1295      P:05AF P:05AF 0E25B3            JNE     <STG5
1296      P:05B0 P:05B0 57F400            MOVE              #>$BB,B
                        0000BB
1297      P:05B2 P:05B2 0C05C0            JMP     <STG_A
1298      P:05B3 P:05B3 44F400  STG5      MOVE              #>5,X0                  ; Check for gain = x5
                        000005
1299      P:05B5 P:05B5 200045            CMP     X0,A
1300      P:05B6 P:05B6 0E25BA            JNE     <STG10
1301      P:05B7 P:05B7 57F400            MOVE              #>$DD,B
                        0000DD
1302      P:05B9 P:05B9 0C05C0            JMP     <STG_A
1303      P:05BA P:05BA 44F400  STG10     MOVE              #>10,X0                 ; Check for gain = x10
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timCCDmisc.s  Page 26



                        00000A
1304      P:05BC P:05BC 200045            CMP     X0,A
1305      P:05BD P:05BD 0E2000            JNE     <ERROR
1306      P:05BE P:05BE 57F400            MOVE              #>$EE,B
                        0000EE
1307   
1308      P:05C0 P:05C0 56DC00  STG_A     MOVE              X:(R4)+,A               ; Integrator Speed (0 for slow, 1 for fast)
1309      P:05C1 P:05C1 0ACC00            JCLR    #0,A1,STG_B
                        0005C5
1310      P:05C3 P:05C3 0ACD68            BSET    #8,B1
1311      P:05C4 P:05C4 0ACD69            BSET    #9,B1
1312      P:05C5 P:05C5 44F400  STG_B     MOVE              #$0C3C00,X0
                        0C3C00
1313      P:05C7 P:05C7 20004A            OR      X0,B
1314      P:05C8 P:05C8 5F0000            MOVE                          B,Y:<GAIN   ; Store the GAIN value for later us
1315   
1316                            ; Send this same value to 15 video processor boards whether they exist or not
1317      P:05C9 P:05C9 241000            MOVE              #$100000,X0             ; Increment value
1318      P:05CA P:05CA 060F80            DO      #15,STG_LOOP
                        0005CF
1319      P:05CC P:05CC 577000            MOVE              B,X:SSITX               ; Transmit the SSI word
                        00FFEF
1320      P:05CE P:05CE 0D046E            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
1321      P:05CF P:05CF 200048            ADD     X0,B                              ; Increment the video processor board number
1322                            STG_LOOP
1323   
1324      P:05D0 P:05D0 0D0534            JSR     <SER_UTL                          ; Return SSI to utility board communication
1325      P:05D1 P:05D1 0C0000            JMP     <FINISH
1326      P:05D2 P:05D2 56DC00  ERR_SGN   MOVE              X:(R4)+,A
1327      P:05D3 P:05D3 0D0534            JSR     <SER_UTL                          ; Return SSI to utility board communication
1328      P:05D4 P:05D4 0C0000            JMP     <ERROR
1329   
1330                            ; Write an arbitraty control word over the SSI link to any register, any board
1331                            ; Command syntax is  WRC number, number is 24-bit number to be sent to any board
1332                            ;WR_CNTRL
1333                            ;       JSR     <SER_ANA        ; Set SSI to analog board communication
1334                            ;       JSR     <PAL_DLY        ; Wait for the number to be sent
1335                            ;        MOVEP  X:(R4)+,X:SSITX ; Send out the waveform
1336                            ;       JSR     <PAL_DLY        ; Wait for SSI and PAL to be empty
1337                            ;       JSR     <SER_UTL        ; Return SSI to utility board communication
1338                            ;       JMP     <FINISH
1339   
1340   
1341   
1342                            ; Specify subarray readout coordinates, one rectangle only
1343                            ; Call this subroutine BEFORE SET_SUBARRAY_POSITIONS since it
1344                            ; initializes NBOXES
1345                            SET_SUBARRAY_SIZES
1346      P:05D5 P:05D5 200013            CLR     A
1347      P:05D6 P:05D6 5E1900            MOVE                          A,Y:<NBOXES ; Number of subimage boxes = 0 to start
1348      P:05D7 P:05D7 44DC00            MOVE              X:(R4)+,X0
1349      P:05D8 P:05D8 4C1A00            MOVE                          X0,Y:<NR_BIAS ; Number of bias pixels to read
1350      P:05D9 P:05D9 44DC00            MOVE              X:(R4)+,X0
1351      P:05DA P:05DA 4C1B00            MOVE                          X0,Y:<NS_READ ; Number of columns in subimage read
1352      P:05DB P:05DB 44DC00            MOVE              X:(R4)+,X0
1353      P:05DC P:05DC 4C1C00            MOVE                          X0,Y:<NP_READ ; Number of rows in subimage read
1354      P:05DD P:05DD 0C0000            JMP     <FINISH
1355   
1356                            ; Call this routine once for every subarray to be added to the table
1357                            ; Note that the way the variables are arranged the subframes all are the
1358                            ; same dimensions.  They also cannot overlap in the row direction.
1359                            ; SET_SUBARRAY_SIZES must be called first to initialize NBOXES
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timCCDmisc.s  Page 27



1360                            SET_SUBARRAY_POSITIONS
1361      P:05DE P:05DE 4C9900            MOVE                          Y:<NBOXES,X0 ; Next available slot
1362      P:05DF P:05DF 458000            MOVE              X:<THREE,X1
1363      P:05E0 P:05E0 2000A0            MPY     X0,X1,A
1364      P:05E1 P:05E1 200022            ASR     A
1365      P:05E2 P:05E2 210C00            MOVE              A0,A1
1366      P:05E3 P:05E3 44F400            MOVE              #>24,X0
                        000018
1367      P:05E5 P:05E5 200045            CMP     X0,A
1368      P:05E6 P:05E6 0E7000            JGT     <ERROR                            ; Error if number of boxes > 9
1369      P:05E7 P:05E7 44F400            MOVE              #READ_TABLE,X0
                        00001D
1370      P:05E9 P:05E9 200040            ADD     X0,A
1371      P:05EA P:05EA 219700            MOVE              A1,R7
1372      P:05EB P:05EB 44DC00            MOVE              X:(R4)+,X0
1373      P:05EC P:05EC 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of rows (parallels) to clear
1374      P:05ED P:05ED 44DC00            MOVE              X:(R4)+,X0
1375      P:05EE P:05EE 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears before
1376      P:05EF P:05EF 44DC00            MOVE              X:(R4)+,X0              ;  the box readout
1377      P:05F0 P:05F0 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears after
1378      P:05F1 P:05F1 5E9900            MOVE                          Y:<NBOXES,A ;  the box readout
1379      P:05F2 P:05F2 448000            MOVE              X:<ONE,X0
1380      P:05F3 P:05F3 200040            ADD     X0,A                              ; Update the next available slot position
1381      P:05F4 P:05F4 5E1900            MOVE                          A,Y:<NBOXES
1382      P:05F5 P:05F5 0C0000            JMP     <FINISH
1383   
1384                            ; Alert the PCI interface board that images are coming soon
1385                            ; This tells the PCI card how many pixels to expect for each SEX command
1386                            ; This is fairly complex.  The first value sent is NSR*NPR (NAXIS1*NAXIS2).
1387                            ; The second value is IFRAMES, but if NBOXES > 0, it is IFRAMES*NBOXES
1388                            PCI_READ_IMAGE
1389      P:05F6 P:05F6 44F400            MOVE              #$020104,X0             ; Send header word to the FO transmitter
                        020104
1390      P:05F8 P:05F8 0D0611            JSR     <XMT_FO
1391      P:05F9 P:05F9 44F400            MOVE              #'RDA',X0
                        524441
1392      P:05FB P:05FB 0D0611            JSR     <XMT_FO
1393      P:05FC P:05FC 4CF000            MOVE                          Y:NSR,X0    ; NSR = NAXIS1
                        000001
1394      P:05FE P:05FE 4DF000            MOVE                          Y:NPR,X1    ; NPR = NAXIS2
                        000002
1395      P:0600 P:0600 2000A8            MPY     X0,X1,B
1396      P:0601 P:0601 20002A            ASR     B                                 ; Correct for multiplication left shift
1397      P:0602 P:0602 212400            MOVE              B0,X0
1398      P:0603 P:0603 0D0611            JSR     <XMT_FO                           ; Send NSR*NPR to PCI card
1399      P:0604 P:0604 4CF000            MOVE                          Y:IFRAMES,X0 ; IFRAMES = NAXIS3
                        00003A
1400      P:0606 P:0606 5E9900            MOVE                          Y:<NBOXES,A ; If NBOXES = 0, transmit that to PCI
1401      P:0607 P:0607 200003            TST     A
1402      P:0608 P:0608 0AF0AA            JEQ     XMT
                        00060E
1403      P:060A P:060A 4D9900            MOVE                          Y:<NBOXES,X1 ; If NBOXES = 0, transmit that to PCI
1404      P:060B P:060B 2000A8            MPY     X0,X1,B                           ; If not, multiply by NBOXES, then send
1405      P:060C P:060C 20002A            ASR     B                                 ; Correct for multiplication left shift
1406      P:060D P:060D 212400            MOVE              B0,X0                   ; Get only least significant 24 bits
1407      P:060E P:060E 000000  XMT       NOP
1408      P:060F P:060F 0D0611            JSR     <XMT_FO
1409      P:0610 P:0610 00000C            RTS
1410   
1411      P:0611 P:0611 09C400  XMT_FO    MOVEP             X0,Y:WRFO
1412      P:0612 P:0612 060FA0            REP     #15
1413      P:0613 P:0613 000000            NOP
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  timCCDmisc.s  Page 28



1414      P:0614 P:0614 00000C            RTS
1415   
1416                            ; Check for program overflow
1417                                      IF      @CVS(N,*)-$200>MISC_LEN
1419                                      ENDIF                                     ;  will not overflow
1420   
1421   
1422                            ;**************************************************************************
1423                            ;                                                                         *
1424                            ;    Permanent address register assignments                               *
1425                            ;        R1 - Address of SSI receiver contents                            *
1426                            ;        R2 - Address of SCI receiver contents                            *
1427                            ;        R3 - Pointer to current top of command buffer                    *
1428                            ;        R4 - Pointer to processed contents of command buffer             *
1429                            ;        R5 - Temporary register for processing SSI and SCI contents      *
1430                            ;        R6 - CCD clock driver address for CCD #0 = $FF80                 *
1431                            ;                It is also the A/D address of analog board #0            *
1432                            ;                                                                         *
1433                            ;    Other registers                                                      *
1434                            ;        R0, R7 - Temporary registers used all over the place.            *
1435                            ;        R5 - Can be used as a temporary register but is circular,        *
1436                            ;               modulo 32.                                                *
1437                            ;**************************************************************************
1438   
1439                            ;  Specify execution and load addresses
1440                                      IF      @SCP("HOST","HOST")
1441      P:0130 P:0130                   ORG     P:APL_ADR,P:APL_ADR               ; Download address
1442                                      ELSE
1444                                      ENDIF
1445   
1446                            ;  ***********************   CCD  READOUT   ***********************
1447                            ; RDCCD is now a subroutine
1448   
1449                            RDCCD
1450      P:0130 P:0130 0A31A2            JSET    #STORAGE,X:ISTATUS,RCCD1
                        000134
1451                            ; Do the frame transfer if STORAGE==0, else skip it.
1452      P:0132 P:0132 4DBB00            MOVE                          Y:<S_SIZE,X1
1453      P:0133 P:0133 0D0456            JSR     ISHIFT                            ; Do the frame transfer
1454   
1455                            ; Calculate some readout parameters.
1456                            ; This is also an alternative entry point for skipping the frame transfer
1457                            ; STORAGE also selects ganged or storage only parallels during readout
1458                            ; NO_SKIP skips over the section that parallel skips to the subframe start
1459   
1460      P:0134 P:0134 5E9900  RCCD1     MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1461      P:0135 P:0135 200003            TST     A
1462      P:0136 P:0136 0E2140            JNE     <SUB_IMG
1463      P:0137 P:0137 5C1600            MOVE                          A1,Y:<NP_SKIP ; Zero these all out.  Full frame
1464      P:0138 P:0138 5C1700            MOVE                          A1,Y:<NS_SKP1
1465      P:0139 P:0139 5C1800            MOVE                          A1,Y:<NS_SKP2
1466      P:013A P:013A 5E8100            MOVE                          Y:<NSR,A    ; NSERIALS_READ = NSR
1467      P:013B P:013B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                        00013E
1468      P:013D P:013D 200022            ASR     A                                 ; Split serials require / 2
1469      P:013E P:013E 5E1000            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1470      P:013F P:013F 0C014F            JMP     <SETUP
1471   
1472                            ; Loop over the required number of subimage boxes if NBOXES > 0
1473      P:0140 P:0140 67F400  SUB_IMG   MOVE              #READ_TABLE,R7          ; Parameter table for subimage readout
                        00001D
1474      P:0142 P:0142 061940            DO      Y:<NBOXES,L_NBOXES                ; Loop over number of boxes
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  tim.s  Page 29



                        0001E5
1475      P:0144 P:0144 4CDF00            MOVE                          Y:(R7)+,X0
1476      P:0145 P:0145 4C1600            MOVE                          X0,Y:<NP_SKIP
1477      P:0146 P:0146 4CDF00            MOVE                          Y:(R7)+,X0
1478      P:0147 P:0147 4C1700            MOVE                          X0,Y:<NS_SKP1
1479      P:0148 P:0148 4CDF00            MOVE                          Y:(R7)+,X0
1480      P:0149 P:0149 4C1800            MOVE                          X0,Y:<NS_SKP2
1481      P:014A P:014A 5E9B00            MOVE                          Y:<NS_READ,A
1482      P:014B P:014B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                        00014E
1483      P:014D P:014D 200022            ASR     A
1484      P:014E P:014E 5E1000            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1485   
1486                            ; Calculate the fast readout parameters
1487      P:014F P:014F 0D0342  SETUP     JSR     <SETUP_SUBROUTINE
1488   
1489                            ; Skip over the required number of rows for subimage readout
1490                            ; If #NO_SKIP == 0 skip rows up to first subframe, storage clocks only
1491      P:0150 P:0150 0A31A0            JSET    #NO_SKIP,X:ISTATUS,CLR_SR
                        00015A
1492      P:0152 P:0152 5E9600            MOVE                          Y:<NP_SKIP,A ; Number of rows NP_SKIP to skip
1493      P:0153 P:0153 200003            TST     A
1494      P:0154 P:0154 0EA15A            JEQ     <CLR_SR                           ; If zero, skip this shift
1495      P:0155 P:0155 061640            DO      Y:<NP_SKIP,L_SKIP1                ; Clock number of rows to skip
                        000159
1496      P:0157 P:0157 305000            MOVE              #<S_CLEAR,R0            ; SR kept clear with DG
1497      P:0158 P:0158 0D01E9            JSR     <CLOCK
1498      P:0159 P:0159 000000            NOP
1499                            L_SKIP1
1500   
1501                            ; Clear out the accumulated charge from the serial shift register
1502                            ; Leave this commented-out code in until we can test it with a subframe
1503                            ; CLR_SR MOVE   #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1504                            ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1505                            ;       NOP
1506                            ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1507                            ;       DO      Y:<NSCLR,*+3            ; Number of waveform entries total
1508                            ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1509                            ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1510   
1511      P:015A P:015A 60F400  CLR_SR    MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel skip
                        000068
1512      P:015C P:015C 0D01E9            JSR     <CLOCK
1513   
1514                            ; Parallel shift the image into the serial shift register
1515      P:015D P:015D 4C8200            MOVE                          Y:<NPR,X0   ; Number of rows set by host computer
1516      P:015E P:015E 5E9900            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1517      P:015F P:015F 200003            TST     A
1518      P:0160 P:0160 0EA162            JEQ     *+2
1519      P:0161 P:0161 4C9C00            MOVE                          Y:<NP_READ,X0 ; If NBOXES .NE. 0 use subimage table
1520   
1521                            ; Main loop over each line to be read out
1522                            ; If split parallels have to divide NPR by two to be loop counter
1523                            ; Subimages implicitly assumes that parallels are not split
1524      P:0162 P:0162 0A0086            JCLR    #SPLIT_P,X:STATUS,PLOOP           ; skip this if not split parallels
                        000168
1525      P:0164 P:0164 5EF000            MOVE                          Y:NPR,A     ; Get NPR
                        000002
1526      P:0166 P:0166 200022            ASR     A                                 ; Divide by 2
1527      P:0167 P:0167 21C400            MOVE              A,X0                    ; Overwrite loop counter in X0
1528   
1529                            ; Finally start the row loop
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  tim.s  Page 30



1530      P:0168 P:0168 06C400  PLOOP     DO      X0,LPR                            ; Number of rows to read out
                        0001E4
1531   
1532                            ; Check for a command once per line. Only the ABORT command is allowed
1533      P:016A P:016A 0D0000            JSR     <GET_RCV                          ; Was a command received?
1534      P:016B P:016B 0E0175            JCC     <CONT_RD                          ; If no, continue reading out
1535      P:016C P:016C 0C0000            JMP     <CHK_SSI                          ; If yes, go process it
1536   
1537                            ; Abort the readout currently underway
1538      P:016D P:016D 0A0084  ABR_RDC   JCLR    #ST_RDC,X:<STATUS,ABORT_EXPOSURE
                        0004A3
1539      P:016F P:016F 00008C            ENDDO                                     ; Properly terminate row loop
1540      P:0170 P:0170 5E9900            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1541      P:0171 P:0171 200003            TST     A
1542      P:0172 P:0172 0EA174            JEQ     *+2
1543      P:0173 P:0173 00008C            ENDDO                                     ; Properly terminate box loop
1544      P:0174 P:0174 00000C            RTS                                       ; Return early from subroutine
1545   
1546                            ; Move the row into the serial register.
1547      P:0175 P:0175 060640  CONT_RD   DO      Y:<NPBIN,LPR_I                    ; Transfer # of rows, with binning
                        00017C
1548      P:0177 P:0177 305800            MOVE              #<IS_PARALLEL,R0
1549      P:0178 P:0178 0A31A2            JSET    #STORAGE,X:ISTATUS,GANGED         ; if STORAGE == 1 ganged parallels
                        00017B
1550      P:017A P:017A 304000            MOVE              #<S_PARALLEL,R0         ; if STORAGE == 0 store clocks only
1551      P:017B P:017B 0D01E9  GANGED    JSR     <CLOCK                            ; Parallel clocking
1552      P:017C P:017C 000000            NOP
1553                            LPR_I
1554   
1555                            ; Skip over NS_SKP1 columns for subimage readout
1556      P:017D P:017D 5E9700            MOVE                          Y:<NS_SKP1,A ; Number of columns to skip
1557      P:017E P:017E 200003            TST     A
1558      P:017F P:017F 0EA188            JEQ     <L_READ
1559      P:0180 P:0180 0505A1            MOVE              #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1560      P:0181 P:0181 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1561      P:0182 P:0182 000000            NOP
1562      P:0183 P:0183 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1563      P:0184 P:0184 061240            DO      Y:<NSKIP1,LS_SKIP1                ; Number of waveform entries total
                        000186
1564      P:0186 P:0186 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1565                            LS_SKIP1
1566      P:0187 P:0187 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1567   
1568                            ; Finally read some real pixels - this is the serial binning routine
1569      P:0188 P:0188 200013  L_READ    CLR     A
1570      P:0189 P:0189 20001B            CLR     B
1571      P:018A P:018A 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1572      P:018B P:018B 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                        000006
1573      P:018D P:018D 200005            CMP     B,A                               ; else do special waveforms via NO_BIN
1574      P:018E P:018E 0E719F            JGT     <NO_BIN                           ; Skip over general serial binning software
1575      P:018F P:018F 00000B            DEC     B                                 ; serial binning factor minus 1
1576      P:0190 P:0190 212700            MOVE              B0,Y1
1577      P:0191 P:0191 061040            DO      Y:<NSERIALS_READ,LSR_BIN          ; Number of pixels to read out
                        00019D
1578      P:0193 P:0193 688E00            MOVE                          Y:<INITIAL_CLOCK,R0 ; (already /2 if split serials)
1579      P:0194 P:0194 0D01E9            JSR     <CLOCK
1580                            ;       DO      Y:<NSBIN,LSR_I          ; Bin serially NSBIN times
1581      P:0195 P:0195 06C700            DO      Y1,LSR_I                          ; Bin serially NSBIN times
                        000199
1582      P:0197 P:0197 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1583      P:0198 P:0198 0D01E9            JSR     <CLOCK                            ;   shift register
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  tim.s  Page 31



1584      P:0199 P:0199 000000            NOP
1585                            LSR_I
1586      P:019A P:019A 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                        0000B4
1587      P:019C P:019C 0D01E9            JSR     <CLOCK
1588                            ;       MOVE    Y1,Y:<INTERVAL          ; HACK.  Use for debugging
1589      P:019D P:019D 000000            NOP
1590                            LSR_BIN
1591      P:019E P:019E 0C01A9            JMP     <OVER_RD                          ; All done binning
1592   
1593                            ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1594      P:019F P:019F 588C00  NO_BIN    MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1595      P:01A0 P:01A0 00000A            DEC     A                                 ; waveform - 1 into M1
1596      P:01A1 P:01A1 04C8A1            MOVE              A0,M1                   ; Modularity
1597      P:01A2 P:01A2 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1598      P:01A3 P:01A3 000000            NOP
1599      P:01A4 P:01A4 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1600      P:01A5 P:01A5 061340            DO      Y:<NREAD,LSR                      ; Number of waveform entries total
                        0001A7
1601      P:01A7 P:01A7 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1602                            LSR
1603      P:01A8 P:01A8 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1604   
1605                            ; If NR_BIAS=0 clobber SR with DG and skip to end of row loop
1606      P:01A9 P:01A9 5E9A00  OVER_RD   MOVE                          Y:<NR_BIAS,A ; Is NR_BIAS zero?
1607      P:01AA P:01AA 200003            TST     A
1608      P:01AB P:01AB 0E21B1            JNE     <OVR_RD1                          ; no, go to the NS_SKP2 section
1609      P:01AC P:01AC 60F400            MOVE              #DUMP_SERIAL,R0         ; yes, clobber SR with DG
                        000068
1610      P:01AE P:01AE 0D01E9            JSR     <CLOCK
1611      P:01AF P:01AF 0AF080            JMP     END_ROW                           ; and go to the end of the row loop
                        0001E4
1612                            ; Skip over NS_SKP2 columns for subimage readout to get to overscan region
1613      P:01B1 P:01B1 5E9800  OVR_RD1   MOVE                          Y:<NS_SKP2,A ; Number of columns to skip
1614      P:01B2 P:01B2 200003            TST     A
1615      P:01B3 P:01B3 0EA1BC            JEQ     <L_BIAS
1616      P:01B4 P:01B4 0505A1            MOVE              #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1617      P:01B5 P:01B5 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1618      P:01B6 P:01B6 000000            NOP
1619      P:01B7 P:01B7 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1620      P:01B8 P:01B8 061440            DO      Y:<NSKIP2,LS_SKIP2                ; Number of waveform entries total
                        0001BA
1621      P:01BA P:01BA FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1622                            LS_SKIP2
1623      P:01BB P:01BB 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1624   
1625                            ; And read the bias pixels if in subimage readout mode
1626                            ; I think this means that if NBOXES==0 you have to have NSR include bias px.
1627      P:01BC P:01BC 5E9900  L_BIAS    MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1628      P:01BD P:01BD 200003            TST     A
1629      P:01BE P:01BE 0EA1E4            JEQ     <END_ROW
1630   
1631                            ; Finally read some real bias pixels
1632      P:01BF P:01BF 200013            CLR     A
1633      P:01C0 P:01C0 20001B            CLR     B
1634      P:01C1 P:01C1 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1635      P:01C2 P:01C2 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                        000006
1636      P:01C4 P:01C4 200005            CMP     B,A                               ; else do special waveforms via NO_BIN_BIAS
1637      P:01C5 P:01C5 0E71DA            JGT     <NO_BIN_BIAS                      ; Skip over general serial binning software
1638      P:01C6 P:01C6 00000B            DEC     B                                 ; serial binning factor minus 1
1639      P:01C7 P:01C7 212700            MOVE              B0,Y1
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  tim.s  Page 32



1640      P:01C8 P:01C8 5E9A00            MOVE                          Y:<NR_BIAS,A
1641      P:01C9 P:01C9 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                        0001CC
1642      P:01CB P:01CB 200022            ASR     A                                 ; Split serials require / 2
1643      P:01CC P:01CC 06CE00            DO      A,LBIAS_BIN                       ; Number of pixels to read out
                        0001D8
1644      P:01CE P:01CE 688E00            MOVE                          Y:<INITIAL_CLOCK,R0
1645      P:01CF P:01CF 0D01E9            JSR     <CLOCK
1646      P:01D0 P:01D0 06C700            DO      Y1,LBIAS_I                        ; Bin serially NSBIN times
                        0001D4
1647                            ;       DO      Y:<NSBIN,LBIAS_I        ; Bin serially NSBIN times
1648      P:01D2 P:01D2 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1649      P:01D3 P:01D3 0D01E9            JSR     <CLOCK                            ;   shift register
1650      P:01D4 P:01D4 000000            NOP
1651                            LBIAS_I
1652      P:01D5 P:01D5 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                        0000B4
1653      P:01D7 P:01D7 0D01E9            JSR     <CLOCK
1654      P:01D8 P:01D8 000000            NOP
1655                            LBIAS_BIN
1656      P:01D9 P:01D9 0C01E4            JMP     <END_ROW                          ; All done binning
1657   
1658                            ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1659                            ; NBIAS is already divided by 2 in SETUP_SUBROUTINE if split serials.
1660                            NO_BIN_BIAS
1661      P:01DA P:01DA 588C00            MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1662      P:01DB P:01DB 00000A            DEC     A                                 ; waveform - 1 into M1
1663      P:01DC P:01DC 04C8A1            MOVE              A0,M1                   ; Modularity
1664      P:01DD P:01DD 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1665      P:01DE P:01DE 000000            NOP
1666      P:01DF P:01DF 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1667      P:01E0 P:01E0 061540            DO      Y:<NBIAS,*+3                      ; Number of waveform entries total
                        0001E2
1668      P:01E2 P:01E2 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1669      P:01E3 P:01E3 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1670      P:01E4 P:01E4 000000  END_ROW   NOP
1671      P:01E5 P:01E5 000000  LPR       NOP                                       ; End of parallel loop
1672      P:01E6 P:01E6 000000  L_NBOXES  NOP                                       ; End of subimage boxes loop
1673      P:01E7 P:01E7 000000            NOP
1674      P:01E8 P:01E8 00000C            RTS
1675   
1676                            ; ***************** END OF CCD READOUT SUBROUTINE  ************
1677   
1678                            ; Core subroutine for clocking out CCD charge
1679                            ; Must keep in tim.s to insure that it is in fast P memory
1680   
1681      P:01E9 P:01E9 4CD800  CLOCK     MOVE                          Y:(R0)+,X0  ; # of waveform entries
1682      P:01EA P:01EA 5ED800            MOVE                          Y:(R0)+,A   ; Start the pipeline
1683      P:01EB P:01EB 06C400            DO      X0,CLK1                           ; Repeat X0 times
                        0001ED
1684      P:01ED P:01ED FA0600            MOVE              A,X:(R6)    Y:(R0)+,A   ; Send out the waveform
1685                            CLK1
1686      P:01EE P:01EE 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1687      P:01EF P:01EF 00000C            RTS                                       ; Return from subroutine
1688   
1689                            ; Check for program overflow
1690                                      IF      @CVS(N,*)>$200
1692                                      ENDIF                                     ;  will not overflow
1693   
1694                            ; ***********  DATA AREAS - READOUT PARAMETERS AND WAVEFORMS  ************
1695                                      IF      @SCP("HOST","HOST")
1696      X:0030 X:0030                   ORG     X:IMGVAR_ADR,X:IMGVAR_ADR
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  tim.s  Page 33



1697      X:0030 X:0030         IMAGE_MODE DC     0
1698      X:0031 X:0031         ISTATUS   DC      0
1699      X:0032 X:0032         DSP_VERS  DC      VERSION                           ; code version must stay in loc,n 32!!
1700      X:0033 X:0033         DSP_FLAV  DC      FLAVOR                            ;  type of dsp support must stay in loc,n 33!!
1701                            ; The next three locations are for tracking the readout timing for gain
1702                            ; calculation, exp-int calculation, and greed factor calculation
1703                            ; They are locations 0x34, 35, and 36
1704      X:0034 X:0034         INTTIM    DC      INT_TIM                           ; per-pixel integration in Leach units
1705      X:0035 X:0035         RDELAY    DC      R_DELAY                           ; serial overlap in Leach units
1706      X:0036 X:0036         SIDELAY   DC      SI_DELAY                          ; parallel overlap in Leach units
1707      X:0037 X:0037         BINBIT    DC      2                                 ; Bit representation of bin factor, bits 1-5
1708                                                                                ; 2 = bit 1 set. Bit zero not used.
1709                                      ENDIF
1710   
1711                            ; Command table - make sure there are exactly 32 entries in it
1712                                      IF      @SCP("HOST","HOST")
1713      X:0080 X:0080                   ORG     X:COM_TBL,X:COM_TBL               ; Download address
1714                                      ELSE
1716                                      ENDIF
1717      X:0080 X:0080                   DC      'IDL',IDL                         ; Put CCD in IDLE mode
1718      X:0082 X:0082                   DC      'STP',STP                         ; Exit IDLE mode
1719      X:0084 X:0084                   DC      'SBV',SETBIAS                     ; Set DC bias supply voltages
1720      X:0086 X:0086                   DC      'RDC',RDCCD                       ; Begin CCD readout
1721      X:0088 X:0088                   DC      'CLR',CLEAR                       ; Fast clear the CCD
1722      X:008A X:008A                   DC      'SGN',ST_GAIN                     ; Set video processor gain
1723      X:008C X:008C                   DC      'SMX',SET_MUX                     ; Set clock driver MUX output
1724   
1725      X:008E X:008E                   DC      'ABR',ABR_RDC                     ; Abort readout
1726      X:0090 X:0090                   DC      'CRD',CONT_RD                     ; Continue reading out
1727      X:0092 X:0092                   DC      'CSW',CLR_SWS                     ; Clear analog switches to lower power
1728      X:0094 X:0094                   DC      'SOS',SEL_OS                      ; Select output source
1729      X:0096 X:0096                   DC      'RCC',READ_CONTROLLER_CONFIGURATION
1730      X:0098 X:0098                   DC      'SSS',SET_SUBARRAY_SIZES
1731      X:009A X:009A                   DC      'SSP',SET_SUBARRAY_POSITIONS
1732      X:009C X:009C                   DC      'DON',START                       ; Nothing special
1733      X:009E X:009E                   DC      'OSH',OPEN_SHUTTER
1734      X:00A0 X:00A0                   DC      'CSH',CLOSE_SHUTTER
1735      X:00A2 X:00A2                   DC      'PON',PWR_ON                      ; Turn on all camera biases and clocks
1736      X:00A4 X:00A4                   DC      'POF',PWR_OFF                     ; Turn +/- 15V power supplies off
1737      X:00A6 X:00A6                   DC      'SET',SET_EXP_TIME                ; Set exposure time
1738      X:00A8 X:00A8                   DC      'SEX',START_FT_EXPOSURE           ; Goes to mode-dependent jump table
1739      X:00AA X:00AA                   DC      'AEX',ABORT_EXPOSURE
1740      X:00AC X:00AC                   DC      'STG',SET_TRIGGER                 ;  Set Trigger Mode on or off
1741      X:00AE X:00AE                   DC      'SIP',SET_IMAGE_PARAM
1742      X:00B0 X:00B0                   DC      'SRC',SET_ROWS_COLUMNS            ; Set NSR, NPR, and binning
1743      X:00B2 X:00B2                   DC      'INF',GET_INFO                    ; info command for versioning and more
1744      X:00B4 X:00B4                   DC      ,0,START,0,START,0,START,0,START
1745   
1746                                      IF      @SCP("HOST","HOST")
1747      Y:0000 Y:0000                   ORG     Y:0,Y:0                           ; Download address
1748                                      ELSE
1750                                      ENDIF
1751   
1752                            ; NSR, NPR, NSBIN, and NPBIN are set by SET_ROWS_COLUMNS
1753      Y:0000 Y:0000         GAIN      DC      0                                 ; Video processor gain and integrator speed
1754      Y:0001 Y:0001         NSR       DC      1072                              ; Number Serial Read, prescan + image + bias
1755      Y:0002 Y:0002         NPR       DC      1030                              ; Number Parallel Read
1756      Y:0003 Y:0003         NS_CLR    DC      1070                              ; To clear serial register, twice
1757      Y:0004 Y:0004         NPCLR     DC      2057                              ; To clear parallel register, twice
1758      Y:0005 Y:0005         NSBIN     DC      1                                 ; Serial binning parameter
1759      Y:0006 Y:0006         NPBIN     DC      1                                 ; Parallel binning parameter
1760      Y:0007 Y:0007         NROWS     DC      1030                              ; Number of physical rows in CCD
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  tim.s  Page 34



1761      Y:0008 Y:0008         NCOLS     DC      1072                              ; Number of physical columns in CCD
1762   
1763                            ; Miscellaneous definitions
1764                            ; Delete TST_DAT since it isn't used.  Need the space so S_SIZE doesn't barf.
1765                            ; TST_DAT       DC      0               ; Temporary definition for test images
1766      Y:0009 Y:0009         SH_DEL    DC      3                                 ; Delay in milliseconds between shutter closing
1767                                                                                ;   and image readout.  Actual delay is 1.5x
1768                                                                                ;   as long as advertised, e.g. 4.5 ms for 3.
1769      Y:000A Y:000A         CONFIG    DC      CC                                ; Controller configuration
1770                            ; Readout peculiarity parameters
1771                             SERIAL_SKIP
1772      Y:000B Y:000B                   DC      SERIAL_SKIP_LEFT                  ; Serial skipping waveforms
1773      Y:000C Y:000C         SERWAVLEN DC      5                                 ; Serial read waveform table length
1774                             SERIAL_CLOCK
1775      Y:000D Y:000D                   DC      SERIAL_CLOCK_LEFT                 ; Serial waveform table
1776                             INITIAL_CLOCK
1777      Y:000E Y:000E                   DC      INITIAL_CLOCK_LEFT                ; Serial waveform table
1778                             PARALLEL_CLOCK
1779      Y:000F Y:000F                   DC      IS_PARALLEL                       ; Addr. of parallel clocking
1780   
1781                             NSERIALS_READ
1782      Y:0010 Y:0010                   DC      0                                 ; Number of serials to read
1783      Y:0011 Y:0011         NSCLR     DC      0                                 ; Number of waveforms in fast mode
1784      Y:0012 Y:0012         NSKIP1    DC      0                                 ; Number of waveforms in fast mode
1785      Y:0013 Y:0013         NREAD     DC      0                                 ; Number of waveforms in fast mode
1786      Y:0014 Y:0014         NSKIP2    DC      0                                 ; Number of waveforms in fast mode
1787      Y:0015 Y:0015         NBIAS     DC      0                                 ; Number of waveforms in fast mode
1788   
1789                            ; These three parameters are read from the READ_TABLE when needed by the
1790                            ;   RDCCD routine as it loops through the required number of boxes
1791      Y:0016 Y:0016         NP_SKIP   DC      0                                 ; Number of rows to skip
1792      Y:0017 Y:0017         NS_SKP1   DC      0                                 ; Number of serials to clear before read
1793      Y:0018 Y:0018         NS_SKP2   DC      0                                 ; Number of serials to clear after read
1794   
1795                            ; Subimage readout parameters. Ten subimage boxes maximum.
1796                            ; All subimage boxes are the same size, NS_READ x NP_READ
1797                            ; NR_BIAS, NS_READ, and NP_READ are set by SET_SUBARRAY_SIZES
1798                            ; The READ_TABLE entries and implicitly NBOXES are set by SET_SUBARRAY_POSITIONS
1799      Y:0019 Y:0019         NBOXES    DC      0                                 ; Number of boxes to read
1800      Y:001A Y:001A         NR_BIAS   DC      0                                 ; Number of bias pixels to read
1801      Y:001B Y:001B         NS_READ   DC      0                                 ; Number of columns per box
1802      Y:001C Y:001C         NP_READ   DC      0                                 ; Number of rows per box
1803      Y:001D Y:001D         READ_TABLE DC     0,0,0                             ; #1 = Number of rows to clear,
1804      Y:0020 Y:0020                   DC      0,0,0                             ; #2 = Number of columns to skip before
1805      Y:0023 Y:0023                   DC      0,0,0                             ;   subimage read
1806      Y:0026 Y:0026                   DC      0,0,0                             ; #3 = Number of columns to clear after
1807      Y:0029 Y:0029                   DC      0,0,0                             ;   subimage read to get to overscan area
1808      Y:002C Y:002C                   DC      0,0,0
1809      Y:002F Y:002F                   DC      0,0,0
1810      Y:0032 Y:0032                   DC      0,0,0
1811      Y:0035 Y:0035                   DC      0,0,0
1812   
1813                            ; IMAGE_MODE, SROWS, IFRAMES, and INTERVAL are set by SET_IMAGE_PARAM
1814                            ; UBSROWS is set later on by UB_CONV.  S_SIZE is hardwired.
1815      Y:0038 Y:0038         SROWS     DC      1                                 ; Number of Storage image rows to Loop over
1816      Y:0039 Y:0039         UBSROWS   DC      1                                 ; SROWS in unbinned pixels.  Set by UB_CONV
1817      Y:003A Y:003A         IFRAMES   DC      1                                 ; Number of Series frames to Loop over
1818      Y:003B Y:003B         S_SIZE    DC      1033                              ; Number of rows in the Storage Array
1819                                                                                ; NOTE: Not equal to # rows in image area!
1820      Y:003C Y:003C         INTERVAL  DC      7                                 ; Interval to pause for soft trigger
1821      Y:003D Y:003D         AMPVAL    DC      0                                 ; Amplifier selected
1822      Y:003E Y:003E         IFLPCNT   DC      0                                 ; 24-bit IFRAMES loop counter for timmisc.s
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  tim.s  Page 35



1823      Y:003F Y:003F         TESTLOC1  DC      0                                 ; Test location
1824                            ; NOTE:  TESTLOC1 is address 63 in the Y memory.  There are addressing problems
1825                            ; starting at the next address (64).
1826   
1827                            ; Include the waveform table
1828                                      INCLUDE "HIPO_Red.waveforms.s"            ; Readout and clocking waveforms
1829                            ; Waveform tables and definitions for the e2v CCD47 1K sq. frame
1830                            ; transfer CCD for HIPO.
1831                            ;
1832   
1833                            ; CCD clock voltage definitions
1834      000000                VIDEO     EQU     $000000                           ; Video processor board select = 0
1835      002000                CLK2      EQU     $002000                           ; Clock driver board select = 2
1836      003000                CLK3      EQU     $003000                           ; Clock driver board select = 3
1837      000800                CLK_ZERO  EQU     $000800                           ; Zero volts on clock driver line
1838      000800                BIAS_ZERO EQU     $000800                           ;
1839   
1840                            ; Select INT_TIM by value of 08 macro defined in Makefile or
1841                            ; environment. If one of the values indicated is not set, INT_TIM will be
1842                            ; undefined and the assemble will fail.
1843                            ; see the Confluence page for gwaves timing board port,
1844                            ; at the end of dated entry for July 1 2010
1845                            ; http://jumar.lowell.edu/confluence/display/GWAVES/Notes+On+Port+of++Timing+Board+DSP+to+Gen-iii+GW
AVES+CCD
1846                            ;
1847                            ; Please keep the tooltip commentn remarks as and where they are,
1848                            ; right before the EQU
1849   
1850                                      IF      @SCP("08","04")
1854                                      ENDIF
1855                                      IF      @SCP("08","08")
1856                            ; 1.0 us/px - use gain 4.75, doesn't clip - use gain 9.5, clips @ PRAM
1857                            ; <tooltip comment1> Fast, full well OK
1858      080000                INT_TIM   EQU     $080000
1859                                      ENDIF
1860                                      IF      @SCP("08","15")
1864                                      ENDIF
1865                                      IF      @SCP("08","1D")
1869                                      ENDIF
1870                                      IF      @SCP("08","47")
1874                                      ENDIF
1875                                      IF      @SCP("08","6D")
1879                                      ENDIF
1880                                      IF      @SCP("08","92")
1884                                      ENDIF
1885                            ;ADC_TIM                EQU     $0C0000 ; Slow ADC TIME
1886                            ; <tooltip comment1> Not a standard DSP
1887      000000                ADC_TIM   EQU     $000000                           ; Fast ADC TIME
1888   
1889                            ; Delay numbers in clocking
1890                            ; Select SI_DELAY by value of 86 macro defined in Makefile or
1891                            ; environment. If one of the values indicated is not set, SI_DELAY will be
1892                            ; undefined and the assemble will fail.
1893                            ; see the Confluence page for gwaves timing board port,
1894                            ; at the end of dated entry for July 1 2010
1895                            ; http://jumar.lowell.edu/confluence/display/GWAVES/Notes+On+Port+of++Timing+Board+DSP+to+Gen-iii+GW
AVES+CCD
1896                            ; Please keep the tooltip commentn remarks as and where they are,
1897                            ; right before the EQU
1898   
1899                                      IF      @SCP("86","86")
1900                            ; Fast Storage/Image Delay
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 36



1901                            ; <tooltip comment2> Very low light and moderately unflattenable
1902      860000                SI_DELAY  EQU     $860000
1903                                      ENDIF
1904                                      IF      @SCP("86","89")
1908                                      ENDIF
1909                                      IF      @SCP("86","8B")
1913                                      ENDIF
1914                                      IF      @SCP("86","8C")
1918                                      ENDIF
1919                                      IF      @SCP("86","C0")
1923                                      ENDIF
1924   
1925                            ; Select R_DELAY by value of 00 macro defined in Makefile or
1926                            ; environment. If one of the values indicated is not set, R_DELAY will be
1927                            ; undefined and the assemble will fail.
1928                            ; see the Confluence page for gwaves timing board port,
1929                            ; at the end of dated entry for July 1 2010
1930                            ; http://jumar.lowell.edu/confluence/display/GWAVES/Notes+On+Port+of++Timing+Board+DSP+to+Gen-iii+GW
AVES+CCD
1931   
1932                                      IF      @SCP("00","00")
1933                            ; Fast serial register transfer delay
1934      000000                R_DELAY   EQU     $000000
1935                                      ENDIF
1936                                      IF      @SCP("00","08")
1939                                      ENDIF
1940   
1941      000000                SKIP_DELAY EQU    $000000                           ; Serial register skipping delay
1942   
1943                            ; Clock voltages in volts                       Old     New     Data Sheet
1944      2.500000E+000         RG_HI     EQU     +2.5                              ; Reset                  1.5     3.0     4
1945      -9.500000E+000        RG_LO     EQU     -9.5                              ;                       -3.0    -9.0    -8
1946      1.500000E+000         R_HI      EQU     +1.5                              ; Serials                4.65    4.5     2
1947      -8.500000E+000        R_LO      EQU     -8.5                              ;                       -6.6    -6.5    -8
1948      2.500000E+000         SI_HI     EQU     +2.5                              ; Parallels              3.7     4.0     4
1949      -9.500000E+000        SI_LO     EQU     -9.5                              ;                       -6.9    -7.0    -8
1950      2.500000E+000         DG_HI     EQU     +2.5                              ; Dump Gate
1951      -9.500000E+000        DG_LO     EQU     -9.5                              ;                                       -8
1952   
1953                            ; DC Bias voltages in volts                     Old     New     Data Sheet
1954      2.050000E+001         VODL      EQU     20.5                              ; Output Drain Left     25.1    24      21
1955      2.050000E+001         VODR      EQU     20.5                              ; Output Drain Right    25.1    24
1956      9.000000E+000         VRDL      EQU     9.00                              ; Reset Drain Left      12.2    11      10
1957      9.000000E+000         VRDR      EQU     9.00                              ; Reset Drain Right
1958      -6.500000E+000        VOG       EQU     -6.5                              ; Output Gate           -1.2    -3      -5
1959      -9.500000E+000        VABG      EQU     -9.5                              ; Anti-blooming gate    -5.0    -5      -8
1960      000700                OFFSET    EQU     $700
1961      000700                OFFSET0   EQU     $700                              ; Left Side Of Frame
1962      0006EF                OFFSET1   EQU     $6EF                              ; Right Side Of Frame
1963   
1964                            ; Define switch state bits for the lower CCD clock driver bank CLK2
1965      000001                H1L       EQU     1                                 ; Serial #1 Left, Pin 1 - clock 0
1966      000002                H2L       EQU     2                                 ; Serial #2 Left, Pin 2 - clock 1
1967      000004                H3L       EQU     4                                 ; Serial #3 Left, Pin 3 - clock 2
1968      000008                H1R       EQU     8                                 ; Serial #1 Right, Pin 4 - clock 3
1969      000010                H2R       EQU     $10                               ; Serial #2 Right, Pin 5 - clock 4
1970      000020                H3R       EQU     $20                               ; Serial #2 Right, Pin 6 - clock 5
1971      000100                RGL       EQU     $100                              ; Reset Gate Left, Pin 9 - clock 8
1972      000200                RGR       EQU     $200                              ; Reset Gate Right, Pin 10 - clock 9
1973   
1974                            ; Pins 9-12 are not used
1975   
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 37



1976                            ; Define switch state bits for the upper CCD clock driver bank CLK3
1977      000001                I1        EQU     1                                 ; Image, phase #1, Pin 13 - clock 12
1978      000002                I2        EQU     2                                 ; Image, phase #2, Pin 14 - clock 13
1979      000004                I3        EQU     4                                 ; Image, phase #3, Pin 15 - clock 14
1980      000008                S1        EQU     8                                 ; Storage, phase #1, Pin 16 - clock 15
1981      000010                S2        EQU     $10                               ; Storage, phase #2, Pin 17 - clock 16
1982      000020                S3        EQU     $20                               ; Storage, phase #3, Pin 18 - clock 17
1983      000100                DG        EQU     $100                              ; Dump Gate, Pin 34 - clock 20
1984   
1985                            ;  ***  Definitions for Y: memory waveform tables  *****
1986                            ; Clock only the Storage clocks : S1->S2->S3
1987                            S_PARALLEL
1988      Y:0040 Y:0040                   DC      END_S_PARALLEL-S_PARALLEL-2
1989      Y:0041 Y:0041                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1990                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
1991      Y:0042 Y:0042                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00
1992      Y:0043 Y:0043                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00
1993      Y:0044 Y:0044                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3
1994      Y:0045 Y:0045                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3
1995      Y:0046 Y:0046                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3
1996      Y:0047 Y:0047                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
1997                            END_S_PARALLEL
1998   
1999                            ; Reverse clock only the Storage clocks : S1->S3->S2->S1
2000                            ; Use in pipelined occultation mode
2001                            R_S_PARALLEL
2002      Y:0048 Y:0048                   DC      END_R_S_PARALLEL-R_S_PARALLEL-2
2003      Y:0049 Y:0049                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2004      Y:004A Y:004A                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3
2005      Y:004B Y:004B                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3
2006      Y:004C Y:004C                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3
2007      Y:004D Y:004D                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00
2008      Y:004E Y:004E                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00
2009      Y:004F Y:004F                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
2010                            END_R_S_PARALLEL
2011   
2012                            ; Clock only the Storage clocks : S1->S2->S3 with DG
2013                            S_CLEAR
2014      Y:0050 Y:0050                   DC      END_S_CLEAR-S_CLEAR-2
2015      Y:0051 Y:0051                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2016                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
2017      Y:0052 Y:0052                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00+DG
2018      Y:0053 Y:0053                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00+DG
2019      Y:0054 Y:0054                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3+DG
2020      Y:0055 Y:0055                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3+DG
2021      Y:0056 Y:0056                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3+DG
2022      Y:0057 Y:0057                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
2023                            END_S_CLEAR
2024                            ; 2 microsecond delay before readout starts may be needed here
2025                            ;       DC      CLK3+$600000+I1+00+00+S1+00+0000
2026   
2027                            ; Clock both the Storage and Image clocks : I1->I2->I3 and S1->S2->S3
2028                            IS_PARALLEL
2029      Y:0058 Y:0058                   DC      END_IS_PARALLEL-IS_PARALLEL-2
2030      Y:0059 Y:0059                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2031                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
2032      Y:005A Y:005A                   DC      CLK3+SI_DELAY+I1+I2+00+S1+S2+00
2033      Y:005B Y:005B                   DC      CLK3+SI_DELAY+00+I2+00+00+S2+00
2034      Y:005C Y:005C                   DC      CLK3+SI_DELAY+00+I2+I3+00+S2+S3
2035      Y:005D Y:005D                   DC      CLK3+SI_DELAY+00+00+I3+00+00+S3
2036      Y:005E Y:005E                   DC      CLK3+SI_DELAY+I1+00+I3+S1+00+S3
2037      Y:005F Y:005F                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 38



2038                            END_IS_PARALLEL
2039   
2040                            ; Clock both the Storage and Image clocks : I1->I2->I3 and S1->S2->S3
2041                            IS_CLEAR
2042      Y:0060 Y:0060                   DC      IS_CLEAR_END-IS_CLEAR-2
2043      Y:0061 Y:0061                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2044                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+00 ; Probably not needed
2045      Y:0062 Y:0062                   DC      CLK3+SI_DELAY+I1+I2+00+S1+S2+00+DG
2046      Y:0063 Y:0063                   DC      CLK3+SI_DELAY+00+I2+00+00+S2+00+DG
2047      Y:0064 Y:0064                   DC      CLK3+SI_DELAY+00+I2+I3+00+S2+S3+DG
2048      Y:0065 Y:0065                   DC      CLK3+SI_DELAY+00+00+I3+00+00+S3+DG
2049      Y:0066 Y:0066                   DC      CLK3+SI_DELAY+I1+00+I3+S1+00+S3+DG
2050      Y:0067 Y:0067                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
2051                            IS_CLEAR_END
2052   
2053                            DUMP_SERIAL
2054      Y:0068 Y:0068                   DC      END_DUMP_SERIAL-DUMP_SERIAL-2
2055      Y:0069 Y:0069                   DC      CLK2+SI_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2056      Y:006A Y:006A                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
2057      Y:006B Y:006B                   DC      CLK2+SI_DELAY+RGL+RGR+000+000+000+000+000+000
2058      Y:006C Y:006C                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+00
2059      Y:006D Y:006D                   DC      CLK2+SI_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2060                            END_DUMP_SERIAL
2061                                    COMMENT *
2062                            ; Michigan AIMO clocking - this is vestigial and commented out
2063                            PARALLEL DC     PARALLEL_CLEAR-PARALLEL-2
2064                                    DC      CLK2+$000000+RGL+RGR+H1L+H1R+H2L+H2R+00+000+000+00
2065                                    DC      CLK3+P_DELAY+00+00+I3
2066                                    DC      CLK3+P_DELAY+00+00+I3
2067                                    DC      CLK3+P_DELAY+I1+00+I3
2068                                    DC      CLK3+P_DELAY+I1+00+00
2069                                    DC      CLK3+P_DELAY+I1+I2+00
2070                                    DC      CLK3+P_DELAY+00+I2+00
2071                                    DC      CLK3+P_DELAY+00+I2+I3
2072                                    DC      CLK3+P_DELAY+00+00+I3
2073                                    DC      CLK3+P_DELAY+00+00+I3
2074                                    DC      CLK3+P_DELAY+00+00+00
2075                                    *
2076   
2077                            ; For serial clocking we know that the serial registers are laid out as
2078                            ; follows for a backside part per communication with Paul Jorden:
2079   
2080                            ;          Right Side               Left Side
2081                            ;       OG  3  2  1  3 .........  3  2  1  3  OG
2082   
2083                            ; Left amp is   2 -> 1 -> 3
2084                            ; Right amp is  1 -> 2 -> 3
2085   
2086                            ; For a frontside part the left and right are reversed.
2087                            ; Parallel phase 3 dumps into serial 1 and 2.
2088   
2089                            ; Between serial clock code lumps the serials are left as follows:
2090                            ; LEFT  Phase 2 L and R both high
2091                            ; RIGHT Phase 1 L and R both high
2092                            ; SPLIT H1R and H2L are high
2093   
2094                            ; Video processor bit definition
2095                            ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2096   
2097                            SERIAL_IDLE                                         ; Split serial
2098      Y:006E Y:006E                   DC      END_SERIAL_IDLE-SERIAL_IDLE-2
2099      Y:006F Y:006F                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 39



2100      Y:0070 Y:0070                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2101      Y:0071 Y:0071                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2102      Y:0072 Y:0072                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2103      Y:0073 Y:0073                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2104      Y:0074 Y:0074                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2105      Y:0075 Y:0075                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2106      Y:0076 Y:0076                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2107      Y:0077 Y:0077                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2108      Y:0078 Y:0078                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2109      Y:0079 Y:0079                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2110      Y:007A Y:007A                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2111                            ; Not needed, so comment out
2112                            ;       DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2113                            END_SERIAL_IDLE
2114   
2115                            ; The following waveforms are for binned operation.  This is tricky with the
2116                            ; CCD47 because it doesn't have a summing well.  The reset level integration
2117                            ; has to happen before serial 3 drops for the first time and the data level
2118                            ; integration has to happen after it drops for the last time.  The initial
2119                            ; clocks go through the reset integration, the serial clocks are the
2120                            ; intervening clocks for additional pixels binned with the first one, and
2121                            ; the video process is left to do the last clock and data integration.
2122   
2123                            INITIAL_CLOCK_SPLIT                                 ; Both amplifiers
2124      Y:007B Y:007B                   DC      END_INITIAL_CLOCK_SPLIT-INITIAL_CLOCK_SPLIT-2
2125      Y:007C Y:007C                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2126      Y:007D Y:007D                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2127      Y:007E Y:007E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2128      Y:007F Y:007F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2129      Y:0080 Y:0080                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2130      Y:0081 Y:0081                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2131      Y:0082 Y:0082                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2132      Y:0083 Y:0083                   DC      $00F020                           ; Transmit A/D data to host
2133      Y:0084 Y:0084                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2134      Y:0085 Y:0085                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2135      Y:0086 Y:0086                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2136                            END_INITIAL_CLOCK_SPLIT
2137   
2138                            INITIAL_CLOCK_RIGHT                                 ; Serial right, Swap S1L and S2L
2139      Y:0087 Y:0087                   DC      END_INITIAL_CLOCK_RIGHT-INITIAL_CLOCK_RIGHT-2
2140      Y:0088 Y:0088                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2141      Y:0089 Y:0089                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2142      Y:008A Y:008A                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2143      Y:008B Y:008B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2144      Y:008C Y:008C                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2145      Y:008D Y:008D                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2146      Y:008E Y:008E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2147      Y:008F Y:008F                   DC      $00F021                           ; Transmit A/D data to host
2148      Y:0090 Y:0090                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2149      Y:0091 Y:0091                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2150      Y:0092 Y:0092                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2151                            END_INITIAL_CLOCK_RIGHT
2152   
2153                            INITIAL_CLOCK_LEFT                                  ; Serial left, Swap S1R and S2R
2154      Y:0093 Y:0093                   DC      END_INITIAL_CLOCK_LEFT-INITIAL_CLOCK_LEFT-2
2155      Y:0094 Y:0094                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2156      Y:0095 Y:0095                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2157      Y:0096 Y:0096                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2158      Y:0097 Y:0097                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2159      Y:0098 Y:0098                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2160      Y:0099 Y:0099                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2161      Y:009A Y:009A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 40



2162      Y:009B Y:009B                   DC      $00F000                           ; Transmit A/D data to host
2163      Y:009C Y:009C                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2164      Y:009D Y:009D                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2165      Y:009E Y:009E                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2166                            END_INITIAL_CLOCK_LEFT
2167   
2168                            SERIAL_CLOCK_SPLIT                                  ; Both amplifiers
2169      Y:009F Y:009F                   DC      END_SERIAL_CLOCK_SPLIT-SERIAL_CLOCK_SPLIT-2
2170      Y:00A0 Y:00A0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2171      Y:00A1 Y:00A1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2172      Y:00A2 Y:00A2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2173      Y:00A3 Y:00A3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2174      Y:00A4 Y:00A4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2175      Y:00A5 Y:00A5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2176                            END_SERIAL_CLOCK_SPLIT
2177   
2178                            SERIAL_CLOCK_RIGHT                                  ; Serial right, Swap S1L and S2L
2179      Y:00A6 Y:00A6                   DC      END_SERIAL_CLOCK_RIGHT-SERIAL_CLOCK_RIGHT-2
2180      Y:00A7 Y:00A7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2181      Y:00A8 Y:00A8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2182      Y:00A9 Y:00A9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2183      Y:00AA Y:00AA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2184      Y:00AB Y:00AB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2185      Y:00AC Y:00AC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2186                            END_SERIAL_CLOCK_RIGHT
2187   
2188                            SERIAL_CLOCK_LEFT                                   ; Serial left, Swap S1R and S2R
2189      Y:00AD Y:00AD                   DC      END_SERIAL_CLOCK_LEFT-SERIAL_CLOCK_LEFT-2
2190      Y:00AE Y:00AE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2191      Y:00AF Y:00AF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2192      Y:00B0 Y:00B0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2193      Y:00B1 Y:00B1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2194      Y:00B2 Y:00B2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2195      Y:00B3 Y:00B3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2196                            END_SERIAL_CLOCK_LEFT
2197   
2198                            VIDEO_PROCESS
2199      Y:00B4 Y:00B4                   DC      END_VIDEO_PROCESS-VIDEO_PROCESS-2
2200                            CCLK_1                                              ; The following line is overwritten by timmisc.s
2201      Y:00B5 Y:00B5                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2202      Y:00B6 Y:00B6                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2203      Y:00B7 Y:00B7                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2204                            CCLK_2                                              ; The following line is overwritten by timmisc.s
, but is correct as is.
2205                            ; Actually it shouldn't be needed so comment it out.
2206                            ;       DC      CLK2+S_DLY+S1R+S2R+000+S1L+S2L+000+000+000+000+000
2207                            END_VIDEO_PROCESS
2208   
2209                            ; Starting Y: address of circular waveforms for no-overhead access
2210      0000C0                STRT_CIR  EQU     $C0
2211      000620                ROM_DISP  EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+STRT_CIR
2212      000660                DAC_DISP  EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+$100
2213   
2214                            ; Check for Y: data memory overflow
2215                                      IF      @CVS(N,*)>STRT_CIR
2217                                      ENDIF                                     ;  will not overflow
2218   
2219                            ; The fast serial code with the circulating address register must start
2220                            ;   on a boundary that is a multiple of the address register modulus.
2221   
2222                                      IF      @SCP("HOST","HOST")
2223      Y:00C0 Y:00C0                   ORG     Y:STRT_CIR,Y:STRT_CIR             ; Download address
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 41



2224                                      ELSE
2226                                      ENDIF
2227   
2228                            ; This is an area to copy in the serial fast binned waveforms from high Y memory
2229                            ; It is 0x28 = 40 locations long, enough to put in a binned-by-five waveform
2230                            ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2231                            SERIAL_READ
2232      Y:00C0 Y:00C0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2233      Y:00C1 Y:00C1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2234      Y:00C2 Y:00C2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2235      Y:00C3 Y:00C3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2236      Y:00C4 Y:00C4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2237      Y:00C5 Y:00C5                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2238                            SXMIT
2239      Y:00C6 Y:00C6                   DC      $00F000                           ; Transmit A/D data to host
2240      Y:00C7 Y:00C7                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2241      Y:00C8 Y:00C8                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2242      Y:00C9 Y:00C9                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2243      Y:00CA Y:00CA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2244      Y:00CB Y:00CB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2245      Y:00CC Y:00CC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2246      Y:00CD Y:00CD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2247      Y:00CE Y:00CE                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2248      Y:00CF Y:00CF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2249      Y:00D0 Y:00D0                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2250      Y:00D1 Y:00D1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2251      Y:00D2 Y:00D2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2252      Y:00D3 Y:00D3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2253      Y:00D4 Y:00D4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2254      Y:00D5 Y:00D5                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2255      Y:00D6 Y:00D6                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2256      Y:00D7 Y:00D7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2257      Y:00D8 Y:00D8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2258      Y:00D9 Y:00D9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2259      Y:00DA Y:00DA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2260      Y:00DB Y:00DB                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2261      Y:00DC Y:00DC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2262      Y:00DD Y:00DD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2263      Y:00DE Y:00DE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2264      Y:00DF Y:00DF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2265      Y:00E0 Y:00E0                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2266      Y:00E1 Y:00E1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2267      Y:00E2 Y:00E2                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2268      Y:00E3 Y:00E3                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2269      Y:00E4 Y:00E4                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2270                            END_SERIAL
2271   
2272                            ; Serial clocking waveform for skipping
2273                                      IF      @SCP("HOST","HOST")
2274      Y:00E8 Y:00E8                   ORG     Y:STRT_CIR+$28,Y:STRT_CIR+$28     ; Download address
2275                                      ELSE
2277                                      ENDIF
2278   
2279                            ; There are three serial skip waveforms that must all be the same length
2280                            SERIAL_SKIP_LEFT
2281                            ;       DC      END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-2
2282      Y:00E8 Y:00E8                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2283      Y:00E9 Y:00E9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2284      Y:00EA Y:00EA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2285      Y:00EB Y:00EB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2286      Y:00EC Y:00EC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2287      Y:00ED Y:00ED                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 42



2288                            END_SERIAL_SKIP_LEFT
2289   
2290                                      IF      @SCP("HOST","HOST")
2291      Y:00F0 Y:00F0                   ORG     Y:STRT_CIR+$30,Y:STRT_CIR+$30     ; Download address
2292                                      ELSE
2294                                      ENDIF
2295   
2296                            SERIAL_SKIP_RIGHT
2297                            ;       DC      END_SERIAL_SKIP_RIGHT-SERIAL_SKIP_RIGHT-2
2298      Y:00F0 Y:00F0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2299      Y:00F1 Y:00F1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2300      Y:00F2 Y:00F2                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2301      Y:00F3 Y:00F3                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2302      Y:00F4 Y:00F4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2303      Y:00F5 Y:00F5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2304                            END_SERIAL_SKIP_RIGHT
2305   
2306                                      IF      @SCP("HOST","HOST")
2307      Y:00F8 Y:00F8                   ORG     Y:STRT_CIR+$38,Y:STRT_CIR+$38     ; Download address
2308                                      ELSE
2310                                      ENDIF
2311   
2312                            SERIAL_SKIP_SPLIT
2313                            ;       DC      END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-2
2314      Y:00F8 Y:00F8                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2315      Y:00F9 Y:00F9                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2316      Y:00FA Y:00FA                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2317      Y:00FB Y:00FB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2318      Y:00FC Y:00FC                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2319      Y:00FD Y:00FD                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2320                            END_SERIAL_SKIP_SPLIT
2321   
2322                            ; Put all the following code in SRAM.
2323                                      IF      @SCP("HOST","HOST")
2324      Y:0100 Y:0100                   ORG     Y:$100,Y:$100                     ; Download address
2325                                      ELSE
2327                                      ENDIF
2328   
2329                            ; Initialization of clock driver and video processor DACs and switches
2330      Y:0100 Y:0100         DACS      DC      END_DACS-DACS-1
2331      Y:0101 Y:0101                   DC      (CLK2<<8)+(0<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S1 Left High, pin 1
2332      Y:0102 Y:0102                   DC      (CLK2<<8)+(1<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S1 Left Low
2333      Y:0103 Y:0103                   DC      (CLK2<<8)+(2<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S2 Left Right High, pin 2
2334      Y:0104 Y:0104                   DC      (CLK2<<8)+(3<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S2 Left Low
2335      Y:0105 Y:0105                   DC      (CLK2<<8)+(4<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S3 Left High, pin 3
2336      Y:0106 Y:0106                   DC      (CLK2<<8)+(5<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S3 Left Low
2337      Y:0107 Y:0107                   DC      (CLK2<<8)+(6<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S1 Right High, pin 4
2338      Y:0108 Y:0108                   DC      (CLK2<<8)+(7<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S1 Right Low
2339      Y:0109 Y:0109                   DC      (CLK2<<8)+(8<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S2 Right High, pin 5
2340      Y:010A Y:010A                   DC      (CLK2<<8)+(9<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S2 Right Low
2341      Y:010B Y:010B                   DC      (CLK2<<8)+(10<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S3 Right High, pin 6
2342      Y:010C Y:010C                   DC      (CLK2<<8)+(11<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S3 Right Low
2343      Y:010D Y:010D                   DC      (CLK2<<8)+(12<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 7
2344      Y:010E Y:010E                   DC      (CLK2<<8)+(13<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2345      Y:010F Y:010F                   DC      (CLK2<<8)+(14<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 8
2346      Y:0110 Y:0110                   DC      (CLK2<<8)+(15<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2347      Y:0111 Y:0111                   DC      (CLK2<<8)+(16<<14)+@CVI((RG_HI+10.0)/20.0*4095) ; RG Left High, pin 9
2348      Y:0112 Y:0112                   DC      (CLK2<<8)+(17<<14)+@CVI((RG_LO+10.0)/20.0*4095) ; RG Left Low
2349      Y:0113 Y:0113                   DC      (CLK2<<8)+(18<<14)+@CVI((RG_HI+10.0)/20.0*4095) ; RG Right High, pin 10
2350      Y:0114 Y:0114                   DC      (CLK2<<8)+(19<<14)+@CVI((RG_LO+10.0)/20.0*4095) ; RG Rightd Low
2351      Y:0115 Y:0115                   DC      (CLK2<<8)+(20<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 11
2352      Y:0116 Y:0116                   DC      (CLK2<<8)+(21<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 43



2353      Y:0117 Y:0117                   DC      (CLK2<<8)+(22<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 12
2354      Y:0118 Y:0118                   DC      (CLK2<<8)+(23<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2355      Y:0119 Y:0119                   DC      (CLK2<<8)+(24<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; I1 High, pin 13
2356      Y:011A Y:011A                   DC      (CLK2<<8)+(25<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; I1 Low
2357      Y:011B Y:011B                   DC      (CLK2<<8)+(26<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; I2 High, pin 14
2358      Y:011C Y:011C                   DC      (CLK2<<8)+(27<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; I2 Low
2359      Y:011D Y:011D                   DC      (CLK2<<8)+(28<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; I3 High, pin 15
2360      Y:011E Y:011E                   DC      (CLK2<<8)+(29<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; I3 Low
2361      Y:011F Y:011F                   DC      (CLK2<<8)+(30<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; S1 High, pin 16
2362      Y:0120 Y:0120                   DC      (CLK2<<8)+(31<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; S1 Low
2363      Y:0121 Y:0121                   DC      (CLK2<<8)+(32<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; S2 High, pin 17
2364      Y:0122 Y:0122                   DC      (CLK2<<8)+(33<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; S2 Low
2365      Y:0123 Y:0123                   DC      (CLK2<<8)+(34<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; S3 High, pin 18
2366      Y:0124 Y:0124                   DC      (CLK2<<8)+(35<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; S3 Low
2367      Y:0125 Y:0125                   DC      (CLK2<<8)+(36<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 19
2368      Y:0126 Y:0126                   DC      (CLK2<<8)+(37<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2369      Y:0127 Y:0127                   DC      (CLK2<<8)+(38<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 33
2370      Y:0128 Y:0128                   DC      (CLK2<<8)+(39<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2371      Y:0129 Y:0129                   DC      (CLK2<<8)+(40<<14)+@CVI((DG_HI+10.0)/20.0*4095) ; DG High, pin 34
2372      Y:012A Y:012A                   DC      (CLK2<<8)+(41<<14)+@CVI((DG_LO+10.0)/20.0*4095) ; DG Low
2373      Y:012B Y:012B                   DC      (CLK2<<8)+(42<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 35
2374      Y:012C Y:012C                   DC      (CLK2<<8)+(43<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2375      Y:012D Y:012D                   DC      (CLK2<<8)+(44<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 36
2376      Y:012E Y:012E                   DC      (CLK2<<8)+(45<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2377      Y:012F Y:012F                   DC      (CLK2<<8)+(46<<14)+@CVI((VABG+10.0)/20.0*4095) ; Anti-Blooming Gate High, pin 37
2378      Y:0130 Y:0130                   DC      (CLK2<<8)+(47<<14)+@CVI((VABG+10.0)/20.0*4095) ; Anti-Blooming Gate Low
2379   
2380                            ; Set gain and integrator speed
2381      Y:0131 Y:0131                   DC      $0c3fdd                           ; Gain, speed
2382   
2383                            ;       DC      $0c3f77                 ; Gain x1, fast integ speed, board #0
2384                            ;       DC      $0c3fbb                 ; Gain x2, fast integ speed, board #0
2385                            ;       DC      $0c3fdd                 ; Gain x4.75, fast integ speed, board #0
2386                            ;       DC      $0c3fee                 ; Gain x9.50, fast integ speed, board #0
2387                            ;       DC      $0c3cee                 ; Gain x9.50, slow integ speed, board #0
2388   
2389                            ; Input offset voltages for DC coupling. Target is U4#6 = 24 volts
2390      Y:0132 Y:0132                   DC      $0c0800                           ; Input offset, ch. A
2391      Y:0133 Y:0133                   DC      $0c8800                           ; Input offset, ch. B
2392   
2393                            ; Output offset voltages
2394      Y:0134 Y:0134                   DC      $0c4000+OFFSET0                   ; Output video offset, ch. A
2395      Y:0135 Y:0135                   DC      $0cc000+OFFSET1                   ; Output video offset, ch. B
2396   
2397                            ; Output and reset drain DC bias voltages
2398      Y:0136 Y:0136                   DC      $0d0000+@CVI((VODL-7.50)/22.5*4095) ; VODL pin #1
2399      Y:0137 Y:0137                   DC      $0d4000+@CVI((VODR-7.50)/22.5*4095) ; VODR pin #2
2400      Y:0138 Y:0138                   DC      $0d8000+@CVI((VRDL-5.00)/15.0*4095) ; VRDL pin #3
2401      Y:0139 Y:0139                   DC      $0dc000+@CVI((VRDR-5.00)/15.0*4095) ; VRDR pin #4
2402   
2403   
2404                            ; Output and anti-blooming gates
2405      Y:013A Y:013A                   DC      $0f0000+BIAS_ZERO                 ; Unused pin #9
2406      Y:013B Y:013B                   DC      $0f4000+BIAS_ZERO                 ; Unused pin #10
2407      Y:013C Y:013C                   DC      $0f8000+@CVI((VOG+10.0)/20.0*4095) ; Unused pin #11
2408      Y:013D Y:013D                   DC      $0fc000+@CVI((VABG+10.0)/20.0*4095) ; Unused pin #12
2409                            END_DACS
2410   
2411   
2412                            ;       These are the 15 fast serial read waveforms for left, right,
2413                            ;       and split reads for serial binning factors from 1 to 5.
2414   
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 44



2415                            ;       Unbinned waveforms
2416                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2417                            SERIAL_READ_LEFT_1
2418      Y:013E Y:013E                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2419      Y:013F Y:013F                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2420      Y:0140 Y:0140                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2421      Y:0141 Y:0141                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2422      Y:0142 Y:0142                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2423      Y:0143 Y:0143                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2424                            SXMIT_LEFT_1
2425      Y:0144 Y:0144                   DC      $00F000                           ; Transmit A/D data to host
2426      Y:0145 Y:0145                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2427      Y:0146 Y:0146                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2428      Y:0147 Y:0147                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2429      Y:0148 Y:0148                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2430      Y:0149 Y:0149                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2431      Y:014A Y:014A                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2432                            END_SERIAL_READ_LEFT_1
2433   
2434                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2435                            SERIAL_READ_RIGHT_1
2436      Y:014B Y:014B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2437      Y:014C Y:014C                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2438      Y:014D Y:014D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2439      Y:014E Y:014E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2440      Y:014F Y:014F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2441      Y:0150 Y:0150                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2442                            SXMIT_RIGHT_1
2443      Y:0151 Y:0151                   DC      $00F021                           ; Transmit A/D data to host
2444      Y:0152 Y:0152                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2445      Y:0153 Y:0153                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2446      Y:0154 Y:0154                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2447      Y:0155 Y:0155                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2448      Y:0156 Y:0156                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2449      Y:0157 Y:0157                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2450                            END_SERIAL_READ_RIGHT_1
2451   
2452                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2453                            SERIAL_READ_SPLIT_1
2454      Y:0158 Y:0158                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2455      Y:0159 Y:0159                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2456      Y:015A Y:015A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2457      Y:015B Y:015B                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2458      Y:015C Y:015C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2459      Y:015D Y:015D                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2460                            SXMIT_SPLIT_1
2461      Y:015E Y:015E                   DC      $00F020                           ; Transmit A/D data to host
2462      Y:015F Y:015F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2463      Y:0160 Y:0160                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2464      Y:0161 Y:0161                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2465      Y:0162 Y:0162                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2466      Y:0163 Y:0163                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2467      Y:0164 Y:0164                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2468                            END_SERIAL_READ_SPLIT_1
2469   
2470                            ; Bin by 2 waveforms
2471                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2472                            SERIAL_READ_LEFT_2
2473      Y:0165 Y:0165                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2474      Y:0166 Y:0166                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2475      Y:0167 Y:0167                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2476      Y:0168 Y:0168                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 45



2477      Y:0169 Y:0169                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2478      Y:016A Y:016A                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2479                            SXMIT_LEFT_2
2480      Y:016B Y:016B                   DC      $00F000                           ; Transmit A/D data to host
2481      Y:016C Y:016C                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2482      Y:016D Y:016D                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2483      Y:016E Y:016E                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2484      Y:016F Y:016F                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2485      Y:0170 Y:0170                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2486      Y:0171 Y:0171                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2487      Y:0172 Y:0172                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2488      Y:0173 Y:0173                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2489      Y:0174 Y:0174                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2490      Y:0175 Y:0175                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2491      Y:0176 Y:0176                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2492      Y:0177 Y:0177                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2493                            END_SERIAL_READ_LEFT_2
2494   
2495                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2496                            SERIAL_READ_RIGHT_2
2497      Y:0178 Y:0178                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2498      Y:0179 Y:0179                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2499      Y:017A Y:017A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2500      Y:017B Y:017B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2501      Y:017C Y:017C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2502      Y:017D Y:017D                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2503                            SXMIT_RIGHT_2
2504      Y:017E Y:017E                   DC      $00F021                           ; Transmit A/D data to host
2505      Y:017F Y:017F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2506      Y:0180 Y:0180                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2507      Y:0181 Y:0181                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2508      Y:0182 Y:0182                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2509      Y:0183 Y:0183                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2510      Y:0184 Y:0184                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2511      Y:0185 Y:0185                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2512      Y:0186 Y:0186                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2513      Y:0187 Y:0187                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2514      Y:0188 Y:0188                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2515      Y:0189 Y:0189                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2516      Y:018A Y:018A                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2517                            END_SERIAL_READ_RIGHT_2
2518   
2519                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2520                            SERIAL_READ_SPLIT_2
2521      Y:018B Y:018B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2522      Y:018C Y:018C                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2523      Y:018D Y:018D                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2524      Y:018E Y:018E                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2525      Y:018F Y:018F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2526      Y:0190 Y:0190                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2527                            SXMIT_SPLIT_2
2528      Y:0191 Y:0191                   DC      $00F020                           ; Transmit A/D data to host
2529      Y:0192 Y:0192                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2530      Y:0193 Y:0193                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2531      Y:0194 Y:0194                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2532      Y:0195 Y:0195                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2533      Y:0196 Y:0196                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2534      Y:0197 Y:0197                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2535      Y:0198 Y:0198                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2536      Y:0199 Y:0199                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2537      Y:019A Y:019A                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2538      Y:019B Y:019B                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 46



2539      Y:019C Y:019C                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2540      Y:019D Y:019D                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2541                            END_SERIAL_READ_SPLIT_2
2542   
2543   
2544                            ;       Binned by 3 waveforms
2545                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2546                            SERIAL_READ_LEFT_3
2547      Y:019E Y:019E                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2548      Y:019F Y:019F                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2549      Y:01A0 Y:01A0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2550      Y:01A1 Y:01A1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2551      Y:01A2 Y:01A2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2552      Y:01A3 Y:01A3                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2553                            SXMIT_LEFT_3
2554      Y:01A4 Y:01A4                   DC      $00F000                           ; Transmit A/D data to host
2555      Y:01A5 Y:01A5                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2556      Y:01A6 Y:01A6                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2557      Y:01A7 Y:01A7                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2558      Y:01A8 Y:01A8                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2559      Y:01A9 Y:01A9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2560      Y:01AA Y:01AA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2561      Y:01AB Y:01AB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2562      Y:01AC Y:01AC                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2563      Y:01AD Y:01AD                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2564      Y:01AE Y:01AE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2565      Y:01AF Y:01AF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2566      Y:01B0 Y:01B0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2567      Y:01B1 Y:01B1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2568      Y:01B2 Y:01B2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2569      Y:01B3 Y:01B3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2570      Y:01B4 Y:01B4                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2571      Y:01B5 Y:01B5                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2572      Y:01B6 Y:01B6                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2573                            END_SERIAL_READ_LEFT_3
2574   
2575                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2576                            SERIAL_READ_RIGHT_3
2577      Y:01B7 Y:01B7                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2578      Y:01B8 Y:01B8                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2579      Y:01B9 Y:01B9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2580      Y:01BA Y:01BA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2581      Y:01BB Y:01BB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2582      Y:01BC Y:01BC                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2583                            SXMIT_RIGHT_3
2584      Y:01BD Y:01BD                   DC      $00F021                           ; Transmit A/D data to host
2585      Y:01BE Y:01BE                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2586      Y:01BF Y:01BF                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2587      Y:01C0 Y:01C0                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2588      Y:01C1 Y:01C1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2589      Y:01C2 Y:01C2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2590      Y:01C3 Y:01C3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2591      Y:01C4 Y:01C4                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2592      Y:01C5 Y:01C5                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2593      Y:01C6 Y:01C6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2594      Y:01C7 Y:01C7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2595      Y:01C8 Y:01C8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2596      Y:01C9 Y:01C9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2597      Y:01CA Y:01CA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2598      Y:01CB Y:01CB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2599      Y:01CC Y:01CC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2600      Y:01CD Y:01CD                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 47



2601      Y:01CE Y:01CE                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2602      Y:01CF Y:01CF                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2603                            END_SERIAL_READ_RIGHT_3
2604   
2605                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2606                            SERIAL_READ_SPLIT_3
2607      Y:01D0 Y:01D0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2608      Y:01D1 Y:01D1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2609      Y:01D2 Y:01D2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2610      Y:01D3 Y:01D3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2611      Y:01D4 Y:01D4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2612      Y:01D5 Y:01D5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2613                            SXMIT_SPLIT_3
2614      Y:01D6 Y:01D6                   DC      $00F020                           ; Transmit A/D data to host
2615      Y:01D7 Y:01D7                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2616      Y:01D8 Y:01D8                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2617      Y:01D9 Y:01D9                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2618      Y:01DA Y:01DA                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2619      Y:01DB Y:01DB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2620      Y:01DC Y:01DC                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2621      Y:01DD Y:01DD                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2622      Y:01DE Y:01DE                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2623      Y:01DF Y:01DF                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2624      Y:01E0 Y:01E0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2625      Y:01E1 Y:01E1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2626      Y:01E2 Y:01E2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2627      Y:01E3 Y:01E3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2628      Y:01E4 Y:01E4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2629      Y:01E5 Y:01E5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2630      Y:01E6 Y:01E6                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2631      Y:01E7 Y:01E7                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2632      Y:01E8 Y:01E8                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2633                            END_SERIAL_READ_SPLIT_3
2634   
2635                            ;       Binned by 4 waveforms
2636                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2637                            SERIAL_READ_LEFT_4
2638      Y:01E9 Y:01E9                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2639      Y:01EA Y:01EA                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2640      Y:01EB Y:01EB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2641      Y:01EC Y:01EC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2642      Y:01ED Y:01ED                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2643      Y:01EE Y:01EE                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2644                            SXMIT_LEFT_4
2645      Y:01EF Y:01EF                   DC      $00F000                           ; Transmit A/D data to host
2646      Y:01F0 Y:01F0                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2647      Y:01F1 Y:01F1                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2648      Y:01F2 Y:01F2                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2649      Y:01F3 Y:01F3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2650      Y:01F4 Y:01F4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2651      Y:01F5 Y:01F5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2652      Y:01F6 Y:01F6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2653      Y:01F7 Y:01F7                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2654      Y:01F8 Y:01F8                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2655      Y:01F9 Y:01F9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2656      Y:01FA Y:01FA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2657      Y:01FB Y:01FB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2658      Y:01FC Y:01FC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2659      Y:01FD Y:01FD                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2660      Y:01FE Y:01FE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2661      Y:01FF Y:01FF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2662      Y:0200 Y:0200                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 48



2663      Y:0201 Y:0201                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2664      Y:0202 Y:0202                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2665      Y:0203 Y:0203                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2666      Y:0204 Y:0204                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2667      Y:0205 Y:0205                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2668      Y:0206 Y:0206                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2669      Y:0207 Y:0207                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2670                            END_SERIAL_READ_LEFT_4
2671   
2672                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2673                            SERIAL_READ_RIGHT_4
2674      Y:0208 Y:0208                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2675      Y:0209 Y:0209                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2676      Y:020A Y:020A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2677      Y:020B Y:020B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2678      Y:020C Y:020C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2679      Y:020D Y:020D                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2680                            SXMIT_RIGHT_4
2681      Y:020E Y:020E                   DC      $00F021                           ; Transmit A/D data to host
2682      Y:020F Y:020F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2683      Y:0210 Y:0210                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2684      Y:0211 Y:0211                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2685      Y:0212 Y:0212                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2686      Y:0213 Y:0213                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2687      Y:0214 Y:0214                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2688      Y:0215 Y:0215                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2689      Y:0216 Y:0216                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2690      Y:0217 Y:0217                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2691      Y:0218 Y:0218                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2692      Y:0219 Y:0219                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2693      Y:021A Y:021A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2694      Y:021B Y:021B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2695      Y:021C Y:021C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2696      Y:021D Y:021D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2697      Y:021E Y:021E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2698      Y:021F Y:021F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2699      Y:0220 Y:0220                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2700      Y:0221 Y:0221                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2701      Y:0222 Y:0222                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2702      Y:0223 Y:0223                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2703      Y:0224 Y:0224                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2704      Y:0225 Y:0225                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2705      Y:0226 Y:0226                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2706                            END_SERIAL_READ_RIGHT_4
2707   
2708                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2709                            SERIAL_READ_SPLIT_4
2710      Y:0227 Y:0227                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2711      Y:0228 Y:0228                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2712      Y:0229 Y:0229                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2713      Y:022A Y:022A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2714      Y:022B Y:022B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2715      Y:022C Y:022C                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2716                            SXMIT_SPLIT_4
2717      Y:022D Y:022D                   DC      $00F020                           ; Transmit A/D data to host
2718      Y:022E Y:022E                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2719      Y:022F Y:022F                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2720      Y:0230 Y:0230                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2721      Y:0231 Y:0231                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2722      Y:0232 Y:0232                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2723      Y:0233 Y:0233                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2724      Y:0234 Y:0234                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 49



2725      Y:0235 Y:0235                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2726      Y:0236 Y:0236                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2727      Y:0237 Y:0237                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2728      Y:0238 Y:0238                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2729      Y:0239 Y:0239                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2730      Y:023A Y:023A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2731      Y:023B Y:023B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2732      Y:023C Y:023C                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2733      Y:023D Y:023D                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2734      Y:023E Y:023E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2735      Y:023F Y:023F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2736      Y:0240 Y:0240                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2737      Y:0241 Y:0241                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2738      Y:0242 Y:0242                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2739      Y:0243 Y:0243                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2740      Y:0244 Y:0244                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2741      Y:0245 Y:0245                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2742                            END_SERIAL_READ_SPLIT_4
2743   
2744                            ;       Binned by 5 waveforms
2745                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2746                            SERIAL_READ_LEFT_5
2747      Y:0246 Y:0246                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2748      Y:0247 Y:0247                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2749      Y:0248 Y:0248                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2750      Y:0249 Y:0249                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2751      Y:024A Y:024A                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2752      Y:024B Y:024B                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2753                            SXMIT_LEFT_5
2754      Y:024C Y:024C                   DC      $00F000                           ; Transmit A/D data to host
2755      Y:024D Y:024D                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2756      Y:024E Y:024E                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2757      Y:024F Y:024F                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2758      Y:0250 Y:0250                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2759      Y:0251 Y:0251                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2760      Y:0252 Y:0252                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2761      Y:0253 Y:0253                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2762      Y:0254 Y:0254                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2763      Y:0255 Y:0255                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2764      Y:0256 Y:0256                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2765      Y:0257 Y:0257                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2766      Y:0258 Y:0258                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2767      Y:0259 Y:0259                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2768      Y:025A Y:025A                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2769      Y:025B Y:025B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2770      Y:025C Y:025C                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2771      Y:025D Y:025D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2772      Y:025E Y:025E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2773      Y:025F Y:025F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2774      Y:0260 Y:0260                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2775      Y:0261 Y:0261                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2776      Y:0262 Y:0262                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2777      Y:0263 Y:0263                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2778      Y:0264 Y:0264                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2779      Y:0265 Y:0265                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2780      Y:0266 Y:0266                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2781      Y:0267 Y:0267                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2782      Y:0268 Y:0268                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2783      Y:0269 Y:0269                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2784      Y:026A Y:026A                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2785                            END_SERIAL_READ_LEFT_5
2786   
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 50



2787                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2788                            SERIAL_READ_RIGHT_5
2789      Y:026B Y:026B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2790      Y:026C Y:026C                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2791      Y:026D Y:026D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2792      Y:026E Y:026E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2793      Y:026F Y:026F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2794      Y:0270 Y:0270                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2795                            SXMIT_RIGHT_5
2796      Y:0271 Y:0271                   DC      $00F021                           ; Transmit A/D data to host
2797      Y:0272 Y:0272                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2798      Y:0273 Y:0273                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2799      Y:0274 Y:0274                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2800      Y:0275 Y:0275                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2801      Y:0276 Y:0276                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2802      Y:0277 Y:0277                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2803      Y:0278 Y:0278                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2804      Y:0279 Y:0279                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2805      Y:027A Y:027A                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2806      Y:027B Y:027B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2807      Y:027C Y:027C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2808      Y:027D Y:027D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2809      Y:027E Y:027E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2810      Y:027F Y:027F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2811      Y:0280 Y:0280                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2812      Y:0281 Y:0281                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2813      Y:0282 Y:0282                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2814      Y:0283 Y:0283                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2815      Y:0284 Y:0284                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2816      Y:0285 Y:0285                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2817      Y:0286 Y:0286                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2818      Y:0287 Y:0287                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2819      Y:0288 Y:0288                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2820      Y:0289 Y:0289                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2821      Y:028A Y:028A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2822      Y:028B Y:028B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2823      Y:028C Y:028C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2824      Y:028D Y:028D                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2825      Y:028E Y:028E                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2826      Y:028F Y:028F                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2827                            END_SERIAL_READ_RIGHT_5
2828   
2829                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2830                            SERIAL_READ_SPLIT_5
2831      Y:0290 Y:0290                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2832      Y:0291 Y:0291                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2833      Y:0292 Y:0292                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2834      Y:0293 Y:0293                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2835      Y:0294 Y:0294                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2836      Y:0295 Y:0295                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2837                            SXMIT_SPLIT_5
2838      Y:0296 Y:0296                   DC      $00F020                           ; Transmit A/D data to host
2839      Y:0297 Y:0297                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2840      Y:0298 Y:0298                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2841      Y:0299 Y:0299                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2842      Y:029A Y:029A                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2843      Y:029B Y:029B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2844      Y:029C Y:029C                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2845      Y:029D Y:029D                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2846      Y:029E Y:029E                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2847      Y:029F Y:029F                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2848      Y:02A0 Y:02A0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
Motorola DSP56000 Assembler  Version 6.2.0   110-10-21  16:24:59  HIPO_Red.waveforms.s  Page 51



2849      Y:02A1 Y:02A1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2850      Y:02A2 Y:02A2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2851      Y:02A3 Y:02A3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2852      Y:02A4 Y:02A4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2853      Y:02A5 Y:02A5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2854      Y:02A6 Y:02A6                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2855      Y:02A7 Y:02A7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2856      Y:02A8 Y:02A8                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2857      Y:02A9 Y:02A9                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2858      Y:02AA Y:02AA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2859      Y:02AB Y:02AB                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2860      Y:02AC Y:02AC                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2861      Y:02AD Y:02AD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2862      Y:02AE Y:02AE                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2863      Y:02AF Y:02AF                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2864      Y:02B0 Y:02B0                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2865      Y:02B1 Y:02B1                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2866      Y:02B2 Y:02B2                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2867      Y:02B3 Y:02B3                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2868      Y:02B4 Y:02B4                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2869                            END_SERIAL_READ_SPLIT_5
2870   
2871   
2872                                      IF      @SCP("HOST","EEPROM")
2876                                      ENDIF
2877   
2878                               ENDSEC                                    ; End of section TIMEEV57
2879   
2880                     ;  End of program
2881                               END

0    Errors
0    Warnings


