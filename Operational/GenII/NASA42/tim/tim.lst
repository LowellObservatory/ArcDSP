Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  tim.s  Page 1



1                        ; This file is used to generate DSP code for the TimII second generation
2                        ;   timing board. This is Rev. 3.00 software.
3                        ;
4                        ; This file contains two subroutines and X and Y data areas.  The two
5                        ; subroutines are RDCCD (with secondary entry point RCCD1) and CLOCK.
6                        ; These need to be in fast P memory.  The boot code and tim.s are there.
7                        ; tim.s includes timmisc.s and timCCDmisc.s at the
8                        ; beginning and the waveforms file at the end in Y memory.
9      
10                                 PAGE    132                               ; Printronix page width - 132 columns
11     
12                       ; Define a section name so it doesn't conflict with other application programs
13                                 SECTION TIMEEV57
14     
15                       ; Include a header file that defines global parameters
16                                 INCLUDE "timhdr.s"
17                              COMMENT *
18     
19                       This is a header file that is shared between the fiber optic timing board
20                       boot and application code files
21                               *
22     
23                                 PAGE    132                               ; Printronix page width - 132 columns
24     
25                       ; Some basic structural definitions
26        000130         APL_ADR   EQU     $130                              ; P: memory location where application code begins
27        0000D0         APL_LEN   EQU     $200-APL_ADR                      ; Maximum length of application program
28        000030         IMGVAR_ADR EQU    $30                               ;  Special Image Mode variables Starting Address in X:
29     
30                       ; CHANGING MISC_LEN FROM 0X280 TO A LARGER NUMBER BREAKS THE ROM COPY APPROACH!
31                       ; However if all you do is download there is a lot more memory available.
32        000620         MISC_LEN  EQU     $620                              ; Maximum length of "miscellanous" code
33                       ;MISC_LEN EQU   $600    ; Maximum length of "miscellanous" code
34                       ; MISC_LEN EQU  $280    ; Maximum length of "miscellanous" code
35     
36        000040         COM_LEN   EQU     $40                               ; Length of memory for application commands
37        00003C         TIM_ISR   EQU     $3C                               ; DSP timer interrupt service routine address
38        00003E         PGM_CON   EQU     $3E                               ; Program continues on here
39        000080         COM_TBL   EQU     $80                               ; Starting address of command table in X: memory
40        000500         N_W_APL   EQU     $500                              ; Number of words in each application
41        000028         NUM_COM   EQU     40                                ; Number of entries in command table
42     
43        000000         RST_ISR   EQU     $00                               ; Hardware reset interrupt
44        000006         ROM_ID    EQU     $06                               ; Location of program Identification = SWI interrupt
45        000008         START     EQU     $08                               ; Starting address of program
46        000060         RCV_BUF   EQU     $60                               ; Starting address of receiver buffer in X:
47        00000F         TBL_ADR   EQU     $0F                               ; (IR) Waveform tables starting address
48     
49        004000         ROM_OFF   EQU     $4000                             ; Boot program offset address in EEPROM
50        004200         LD_X      EQU     $4200                             ; Assembler loads X: starting at this EEPROM address
51        00C600         RD_X      EQU     $C600                             ; DSP reads X: from this EEPROM address
52     
53                       ; Define DSP port addresses
54        00FF80         WRSS      EQU     $FF80                             ; Write clock driver and VP switch states
55        00FFC0         RDFO      EQU     $FFC0                             ; Read serial receiver fiber optic contents
56        00FFC0         WRFO      EQU     $FFC0                             ; Write to fiber optic serial transmitter
57        00FFA0         RDAD      EQU     $FFA0                             ; Read A/D datum into DSP
58        00FFA0         RDAD0     EQU     $FFA0                             ; Address for reading A/D #0
59        00FFA1         RDAD1     EQU     $FFA1                             ; Address for reading A/D #1
60        00FFC1         WRLATCH   EQU     $FFC1                             ; Write to timing board latch
61        006000         RSTWDT    EQU     $6000                             ; Address to reset the timing board watchdog timer
62        00FFFE         BCR       EQU     $FFFE                             ; Bus (=Port A) Control Register -> Wait States
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timhdr.s  Page 2



63        00FFE0         PBC       EQU     $FFE0                             ; Port B Control Register
64        00FFE2         PBDDR     EQU     $FFE2                             ; Port B Data Direction Register
65        00FFE4         PBD       EQU     $FFE4                             ; Port B Data Register
66        00FFE1         PCC       EQU     $FFE1                             ; Port C Control Register
67        00FFE3         PCDDR     EQU     $FFE3                             ; PortC Data Direction Register
68        00FFE5         PCD       EQU     $FFE5                             ; Port C Data Register
69        00FFFF         IPR       EQU     $FFFF                             ; Interrupt Priority Register
70        00FFEF         SSITX     EQU     $FFEF                             ; SSI Transmit and Receive data register
71        00FFEF         SSIRX     EQU     $FFEF                             ; SSI Transmit and Receive data register
72        00FFEE         SSISR     EQU     $FFEE                             ; SSI Status Register
73        00FFEC         CRA       EQU     $FFEC                             ; SSI Control Register A
74        00FFED         CRB       EQU     $FFED                             ; SSI Control Regsiter B
75        00FFDE         TCSR      EQU     $FFDE                             ; Timer control and status register
76        00FFDF         TCR       EQU     $FFDF                             ; Timer count register
77     
78                       ; Hardware bit definitions all over the place
79        000006         SSI_TDE   EQU     6                                 ; SSI Transmitter data register empty
80        000007         SSI_RDF   EQU     7                                 ; SSI Receiver data register full
81        000002         LVEN      EQU     2                                 ; Low voltage enable (+/-15 volt nominal)
82        000003         HVEN      EQU     3                                 ; Enable high voltage (+32V nominal)
83        000005         TIM_U_RST EQU     5                                 ; Timing to utility board reset bit number in U25
84        00000D         PWRST     EQU     13                                ; Power control board reset
85        000007         RST_FIFO  EQU     7                                 ; Reset FIFO bit number in control latch U25
86        000009         EF        EQU     9                                 ; FIFO empty flag, low true
87        000000         TIM_BIT   EQU     0                                 ; Timer status bit
88        000001         WW        EQU     1                                 ; Word width = 1 for 16-bit image data, 0 for 24-bit
89        000000         CDAC      EQU     0                                 ; Bit number in U25 for clearing DACs
90        000002         ENCK      EQU     2                                 ; Bit number in U25 for enabling analog switches
91        000001         DUALCLK   EQU     1                                 ; Set to clock two halves of clock driver board togethe
r
92     
93                       ; Software status bits, defined at X:<STATUS = X:0
94        000000         ST_RCV    EQU     0                                 ; Set if FO, cleared if SSI
95        00000A         TST_IMG   EQU     10                                ; Set if controller is to generate a test image
96        00000B         SHUT      EQU     11                                ; Set if opening shutter at beginning of exposure
97     
98                       ; Software status bits, defined at X:<STATUS = X:0
99        000002         IDLMODE   EQU     2                                 ; Set if need to idle after readout
100       000003         ST_SHUT   EQU     3                                 ; Set to indicate shutter is closed, clear for open
101       000004         ST_RDC    EQU     4                                 ; Set if executing 'RDC' command - reading out
102       000005         SPLIT_S   EQU     5                                 ; Set if split serial
103       000006         SPLIT_P   EQU     6                                 ; Set if split parallel
104       000007         MPP       EQU     7                                 ; Set if parallels are in MPP mode
105       000008         TRIGGER   EQU     8                                 ; Set if a Hardware triggered exposure
106    
107    
108                      ; Image mode bits, defined at X:<IMAGE_MODE
109    
110       000000         FDOTS     EQU     0                                 ; Fast Dots
111       000001         FIND      EQU     1                                 ; Find
112       000002         SDOTS     EQU     2                                 ; Slow Dots
113       000003         SERIES    EQU     3                                 ; Series
114       000004         SINGLE    EQU     4                                 ; Single
115       000005         STRIP     EQU     5                                 ; Stripscan
116       000006         F_OCC     EQU     6                                 ; Fast occultation, keep as 6 for compatibility
117       000007         B_OCC     EQU     7                                 ; Basic occultation
118       000008         P_OCC     EQU     8                                 ; Pipelined occultation
119    
120                      ; Image Status, define at X:<ISTATUS
121       000000         NO_SKIP   EQU     0                                 ; Set for slow dots, fast and pipelined occultation mod
e
122                                                                          ; to avoid parallel skipping to the subframe boundary.
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timhdr.s  Page 3



123       000001         OPEN_CLOSE EQU    1                                 ; Set if shutter opens/closes each image
124                                                                          ; Clear if shutter stays open for many images
125       000002         STORAGE   EQU     2                                 ; Set if storage area is to be clocked
126    
127    
128                      ; Specify controller configuration bits of the X:STATUS word
129                      ;   to describe the software capabilities of this application file
130                      ; The bit is set (=1) if the capability is supported by the controller
131    
132    
133                              COMMENT *
134    
135                      BIT #'s         FUNCTION
136                      2,1,0           Video Processor
137                                              000     CCD Rev. 3
138                                              001     CCD Gen I
139                                              010     IR Rev. 4
140                                              011     IR Coadder
141    
142                      4,3             Timing Board
143                                              00      Rev. 4, Gen II
144                                              01      Gen I
145    
146                      6,5             Utility Board
147                                              00      No utility board
148                                              01      Utility Rev. 3
149    
150                      7               Shutter
151                                              0       No shutter support
152                                              1       Yes shutter support
153    
154                      9,8             Temperature readout
155                                              00      No temperature readout
156                                              01      Polynomial Diode calibration
157                                              10      Linear temperature sensor calibration
158    
159                      10              Subarray readout
160                                              0       Not supported
161                                              1       Yes supported
162    
163                      11              Binning
164                                              0       Not supported
165                                              1       Yes supported
166    
167                      12              Split-Serial readout
168                                              0       Not supported
169                                              1       Yes supported
170    
171                      13              Split-Parallel readout
172                                              0       Not supported
173                                              1       Yes supported
174    
175                      14              MPP = Inverted parallel clocks
176                                              0       Not supported
177                                              1       Yes supported
178    
179                      16,15           Clock Driver Board
180                                              00      Rev. 3
181                                              11      No clock driver board (Gen I)
182    
183                      19,18,17                Special implementations
184                                              000     Somewhere else
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timhdr.s  Page 4



185                                              001     Mount Laguna Observatory
186                                              010     NGST Aladdin
187                                              xxx     Other
188                              *
189    
190                      CCDVIDREV3B
191       000000                   EQU     $000000                           ; CCD Video Processor Rev. 3
192       000001         VIDGENI   EQU     $000001                           ; CCD Video Processor Gen I
193       000002         IRREV4    EQU     $000002                           ; IR Video Processor Rev. 4
194       000003         COADDER   EQU     $000003                           ; IR Coadder
195       000000         TIMREV4   EQU     $000000                           ; Timing Rev. 4
196       000008         TIMGENI   EQU     $000008                           ; Timing Gen I
197       000020         UTILREV3  EQU     $000020                           ; Utility Rev. 3 supported
198       000080         SHUTTER_CC EQU    $000080                           ; Shutter supported
199       000100         TEMP_POLY EQU     $000100                           ; Polynomial calibration
200                      TEMP_LINEAR
201       000200                   EQU     $000200                           ; Linear calibration
202       000400         SUBARRAY  EQU     $000400                           ; Subarray readout supported
203       000800         BINNING   EQU     $000800                           ; Binning supported
204                      SPLIT_SERIAL
205       001000                   EQU     $001000                           ; Split serial supported
206                      SPLIT_PARALLEL
207       002000                   EQU     $002000                           ; Split parallel supported
208       004000         MPP_CC    EQU     $004000                           ; Inverted clocks supported
209       018000         CLKDRVGENI EQU    $018000                           ; No clock driver board - Gen I
210       020000         MLO       EQU     $020000                           ; Set if Mount Laguna Observatory
211       040000         NGST      EQU     $040000                           ; NGST Aladdin implementation
212                                INCLUDE "infospec.s"
213                      ; General DSP info field specifications.
214                      ; These values are 'addresses' and used as the argument for the INF command.
215    
216                      GET_VERSION
217       000000                   EQU     0                                 ; IVERSION field
218       000001         GET_FLAVOR EQU    1                                 ; IFLAVOR field
219       000002         GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
220       000003         GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
221       000004         GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if available)
222    
223                                INCLUDE "timinfospec.s"
224                      ; TIM DSP info field specifications.
225                      ; These values are 'addresses' and used as the argument for the INF command.
226    
227                      GET_CAPABLE
228       000100                   EQU     $100                              ; ICAPABLE field (what dsp supports).
229                      GET_INT_TIM
230       000101                   EQU     $101                              ; Integration time per pixel in leach units
231                      GET_R_DELAY
232       000102                   EQU     $102                              ; Serial overlap in leach units
233                      GET_SI_DELAY
234       000103                   EQU     $103                              ; Parallel overlap in leach units
235    
236                                INCLUDE "timinfo.s"
237                      ; DSP Version
238       04407F         IVERSION  EQU     278655                            ; 1.4/1
239    
240       612020         IFLAVOR   EQU     'a  '                             ; a
241    
242       00ED19         ITIME0    EQU     60697                             ; lo order time: 2010 5 11  5:37:29 GMT
243    
244       004BE8         ITIME1    EQU     19432                             ; hi order time: 2010 5 11  5:37:29 GMT
245    
246       000000         ISVNREV   EQU     0                                 ; most recent code svn rev
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timinfo.s  Page 5



247    
248    
249                      ; tim capability definitions
250                      FINDCAPABLE
251       000001                   EQU     1                                 ; Find exposure mode
252                      SNGLCAPABLE
253       000002                   EQU     2                                 ; Single exposure mode
254                      SERICAPABLE
255       000004                   EQU     4                                 ; Series exposure mode
256                      BASCCAPABLE
257       000008                   EQU     8                                 ; Basic occ exposure mode
258                      FASTCAPABLE
259       000010                   EQU     16                                ; Fast occ exposure mode
260                      PIPECAPABLE
261       000020                   EQU     32                                ; Pipeline occ exposure mode
262                      FDOTCAPABLE
263       000040                   EQU     64                                ; Fast dots exposure mode
264                      SDOTCAPABLE
265       000080                   EQU     128                               ; Slow dots exposure mode
266                      STRPCAPABLE
267       000100                   EQU     256                               ; Slow dots exposure mode
268       0001CB         TIMCAPABLE EQU    FINDCAPABLE+SNGLCAPABLE+STRPCAPABLE+BASCCAPABLE+FDOTCAPABLE+SDOTCAPABLE
269    
270       000000         APL_NUM   EQU     0                                 ; Application number from 0 to 3
271    
272       001420         CC        EQU     CCDVIDREV3B+TIMREV4+UTILREV3+SUBARRAY+SPLIT_SERIAL
273    
274                      ; Include miscellaneous timing commands
275                                INCLUDE "timmisc.s"                       ; Custom
276                      ; This file is for utilities that are in common to all the timing board
277                      ;   programs, located starting at P:$200 in external SRAM
278    
279    
280                      ;  ****************  PROGRAM CODE IN SRAM PROGRAM SPACE    *******************
281                      ; Put all the following code in SRAM, starting at P:$200.
282                                IF      @SCP("HOST","HOST")
283       P:0200 P:0200                   ORG     P:$200,P:$200                     ; Download address
284                                       ELSE
286                                       ENDIF
287    
288                             ; Fast clear of CCD, executed as a command
289       P:0200 P:0200 0D0202  CLEAR     JSR     <CLR_CCD
290       P:0201 P:0201 0C0000            JMP     <FINISH
291    
292                             ; Fast clear image before each exposure, executed as a subroutine.  Uses DG
293       P:0202 P:0202 060440  CLR_CCD   DO      Y:<NPCLR,LPCLR                    ; Loop over number of lines in image
                        000207
294       P:0204 P:0204 60F400            MOVE              #ABCD_CLEAR_SPLIT,R0    ; Address of parallel transfer waveform
                        00018B
295       P:0206 P:0206 0D01EC            JSR     <CLOCK                            ; Go clock out the CCD charge
296       P:0207 P:0207 000000            NOP                                       ; Do loop restriction
297                             LPCLR
298       P:0208 P:0208 60F400            MOVE              #DUMP_SERIAL,R0
                        0001C6
299       P:020A P:020A 0D01EC            JSR     <CLOCK                            ; and wipe out the dregs in the SR
300       P:020B P:020B 44F400            MOVE              #TST_RCV,X0             ; Wait for commands during exposure
                        000000
301       P:020D P:020D 440000            MOVE              X0,X:<IDL_ADR           ;  instead of idling
302       P:020E P:020E 00000C            RTS
303    
304                             ; Keep the CCD idling when not reading out
305       P:020F P:020F 060340  IDLE      DO      Y:<NS_CLR,IDL1                    ; Loop over number of pixels per line
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 6



                        000217
306       P:0211 P:0211 304000            MOVE              #<SERIAL_IDLE,R0        ; Serial transfer on pixel
307       P:0212 P:0212 0D01EC            JSR     <CLOCK                            ; Go to it
308       P:0213 P:0213 0D0000            JSR     <GET_RCV                          ; Check for FO or SSI commands
309       P:0214 P:0214 0E0217            JCC     <NO_COM                           ; Continue IDLE if no commands received
310       P:0215 P:0215 00008C            ENDDO                                     ; Cancel the DO loop
311       P:0216 P:0216 0C0000            JMP     <CHK_SSI                          ; Go process header and command
312       P:0217 P:0217 000000  NO_COM    NOP
313                             IDL1
314       P:0218 P:0218 60F400            MOVE              #ABCD_CLEAR_SPLIT,R0    ; Address of parallel clocking waveform
                        00018B
315       P:021A P:021A 683F00            MOVE                          R0,Y:<TESTLOC1 ; HACK
316       P:021B P:021B 0D01EC            JSR     <CLOCK                            ; Go clock out the CCD charge
317       P:021C P:021C 0C020F            JMP     <IDLE
318    
319    
320                             ; Select which readouts to process
321                             ;   'SOS'  Amplifier_name
322                             ;       Amplifier_names = '__A', '__B', '__C', '__D', '_AB', '_CD', '_BD', 'ALL'
323    
324       P:021D P:021D 44DC00  SEL_OS    MOVE              X:(R4)+,X0              ; Get amplifier(s) name
325       P:021E P:021E 0D0220            JSR     <SELECT_OUTPUT_SOURCE
326       P:021F P:021F 0C0000            JMP     <FINISH1
327    
328                             ; A massive subroutine for setting all the addresses depending on the
329                             ; output source(s) selection and binning parameter.  Most of the
330                             ; waveforms are in fast Y memory (< 0xFF) but there isn't enough
331                             ; space for the fast serial binning waveforms for binning factors
332                             ; 1 through 4.  These are in high Y memory and have to be copied in.
333    
334                             SELECT_OUTPUT_SOURCE
335                             ; Set all the waveform addresses depending on which readout/binning mode
336       P:0220 P:0220 56F400  CMP_A     MOVE              #'__A',A                ; A Amplifier = e2v H amp = Leach channel #3
                        5F5F41
337       P:0222 P:0222 200045            CMP     X0,A
338       P:0223 P:0223 0E2283            JNE     <CMP_B
339       P:0224 P:0224 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
340       P:0225 P:0225 56F400            MOVE              #ABCD_UP,A
                        000153
341       P:0227 P:0227 5E7000            MOVE                          A,Y:IS_PAR_CLK ; ganged parallels
                        00000F
342       P:0229 P:0229 56F400            MOVE              #CD_UP,A
                        000198
343       P:022B P:022B 5E7000            MOVE                          A,Y:S_PAR_CLK ; storage area parallels
                        000010
344       P:022D P:022D 56F400            MOVE              #ABCD_CLEAR_UP,A
                        000171
345       P:022F P:022F 5E7000            MOVE                          A,Y:IS_PAR_CLR ; Clear full CCD
                        000011
346       P:0231 P:0231 56F400            MOVE              #CD_CLEAR_UP,A
                        0001AC
347       P:0233 P:0233 5E7000            MOVE                          A,Y:S_PAR_CLR ; Clear storage area only
                        000012
348       P:0235 P:0235 56F400            MOVE              #SERIAL_SKIP_EH,A
                        0000E8
349       P:0237 P:0237 5E7000            MOVE                          A,Y:SERIAL_SKIP ; Now do the serials for general binning
                        00000B
350       P:0239 P:0239 56F400            MOVE              #INITIAL_CLOCK_EH,A
                        000055
351       P:023B P:023B 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
352       P:023D P:023D 56F400            MOVE              #SERIAL_CLOCK_EH,A
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 7



                        00006A
353       P:023F P:023F 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
354       P:0241 P:0241 56F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000),A
                        03200A
355       P:0243 P:0243 5E7000            MOVE                          A,Y:CCLK_1
                        00007D
356       P:0245 P:0245 44F400            MOVE              #$00F063,X0             ; Channel 3 only
                        00F063
357       P:0247 P:0247 4C7000            MOVE                          X0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary binning
                        000079
358       P:0249 P:0249 4C7000            MOVE                          X0,Y:SXMIT_EH_1 ; and into all the hard-coded binned cases i
n high Y
                        0001D2
359       P:024B P:024B 4C7000            MOVE                          X0,Y:SXMIT_EH_2
                        000202
360       P:024D P:024D 4C7000            MOVE                          X0,Y:SXMIT_EH_3
                        000244
361       P:024F P:024F 4C7000            MOVE                          X0,Y:SXMIT_EH_4
                        000298
362       P:0251 P:0251 0A7005            BCLR    #SPLIT_S,X:STATUS                 ; Serials not split
                        000000
363       P:0253 P:0253 0A7006            BCLR    #SPLIT_P,X:STATUS                 ; Parallels not split
                        000000
364                             ; Now go through copying in the serial read waveform if binning more than 4.
365       P:0255 P:0255 200013            CLR     A
366       P:0256 P:0256 20001B            CLR     B
367       P:0257 P:0257 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 5 or greater
368       P:0258 P:0258 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
369       P:0259 P:0259 50F400            MOVE              #>4,A0
                        000004
370       P:025B P:025B 200005            CMP     B,A
371       P:025C P:025C 0E9537            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
372       P:025D P:025D 0D0544            JSR     <SET_BINBIT                       ; else set BINBIT
373       P:025E P:025E 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
374       P:025F P:025F 0A3781  TRY_1_A   JCLR    #1,X:<BINBIT,TRY_2_A
                        000268
375                             ;       MOVE    #1,A0                   ; HACK
376                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
377       P:0261 P:0261 60F400            MOVE              #SERIAL_READ_EH_1,R0    ; Here if H amp, bin by 1
                        0001CC
378       P:0263 P:0263 51F400            MOVE              #(END_SERIAL_READ_EH_1-SERIAL_READ_EH_1),B0
                        00000E
379       P:0265 P:0265 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
380       P:0266 P:0266 0D053D            JSR     <WAVECPY                          ; Copy the waveform
381       P:0267 P:0267 0C0537            JMP     <CMP_END
382       P:0268 P:0268 0A3782  TRY_2_A   JCLR    #2,X:<BINBIT,TRY_3_A
                        000271
383       P:026A P:026A 60F400            MOVE              #SERIAL_READ_EH_2,R0    ; Here if H amp, bin by 2
                        0001F6
384       P:026C P:026C 51F400            MOVE              #(END_SERIAL_READ_EH_2-SERIAL_READ_EH_2),B0
                        000014
385       P:026E P:026E 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
386       P:026F P:026F 0D053D            JSR     <WAVECPY                          ; Copy the waveform
387       P:0270 P:0270 0C0537            JMP     <CMP_END
388       P:0271 P:0271 0A3783  TRY_3_A   JCLR    #3,X:<BINBIT,TRY_4_A
                        00027A
389       P:0273 P:0273 60F400            MOVE              #SERIAL_READ_EH_3,R0    ; Here if H amp, bin by 3
                        000232
390       P:0275 P:0275 51F400            MOVE              #(END_SERIAL_READ_EH_3-SERIAL_READ_EH_3),B0
                        00001A
391       P:0277 P:0277 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 8



392       P:0278 P:0278 0D053D            JSR     <WAVECPY                          ; Copy the waveform
393       P:0279 P:0279 0C0537            JMP     <CMP_END
394       P:027A P:027A 0A3784  TRY_4_A   JCLR    #4,X:<BINBIT,CMP_ERROR
                        00053A
395       P:027C P:027C 60F400            MOVE              #SERIAL_READ_EH_4,R0    ; Here if H amp, bin by 4
                        000280
396       P:027E P:027E 51F400            MOVE              #(END_SERIAL_READ_EH_4-SERIAL_READ_EH_4),B0
                        000020
397       P:0280 P:0280 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
398       P:0281 P:0281 0D053D            JSR     <WAVECPY                          ; Copy the waveform
399       P:0282 P:0282 0C0537            JMP     <CMP_END
400    
401       P:0283 P:0283 56F400  CMP_B     MOVE              #'__B',A                ; B Amplifier = e2v G amp = Leach channel #2
                        5F5F42
402       P:0285 P:0285 200045            CMP     X0,A
403       P:0286 P:0286 0E22E6            JNE     <CMP_C
404       P:0287 P:0287 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
405       P:0288 P:0288 56F400            MOVE              #ABCD_UP,A
                        000153
406       P:028A P:028A 5E7000            MOVE                          A,Y:IS_PAR_CLK ; ganged parallels
                        00000F
407       P:028C P:028C 56F400            MOVE              #CD_UP,A
                        000198
408       P:028E P:028E 5E7000            MOVE                          A,Y:S_PAR_CLK ; storage area parallels
                        000010
409       P:0290 P:0290 56F400            MOVE              #ABCD_CLEAR_UP,A
                        000171
410       P:0292 P:0292 5E7000            MOVE                          A,Y:IS_PAR_CLR ; Clear full CCD
                        000011
411       P:0294 P:0294 56F400            MOVE              #CD_CLEAR_UP,A
                        0001AC
412       P:0296 P:0296 5E7000            MOVE                          A,Y:S_PAR_CLR ; Clear storage area only
                        000012
413       P:0298 P:0298 56F400            MOVE              #SERIAL_SKIP_FG,A
                        0000F0
414       P:029A P:029A 5E7000            MOVE                          A,Y:SERIAL_SKIP ; Now do the serials for general binning
                        00000B
415       P:029C P:029C 56F400            MOVE              #INITIAL_CLOCK_FG,A
                        00005C
416       P:029E P:029E 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
417       P:02A0 P:02A0 56F400            MOVE              #SERIAL_CLOCK_FG,A
                        000071
418       P:02A2 P:02A2 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
419       P:02A4 P:02A4 56F400            MOVE              #(CLK2+$030000+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000),A
                        032011
420       P:02A6 P:02A6 5E7000            MOVE                          A,Y:CCLK_1
                        00007D
421       P:02A8 P:02A8 44F400            MOVE              #$00F042,X0             ; Channel 2 only
                        00F042
422       P:02AA P:02AA 4C7000            MOVE                          X0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary binning
                        000079
423       P:02AC P:02AC 4C7000            MOVE                          X0,Y:SXMIT_FG_1 ; and into all the hard-coded binned cases i
n high Y
                        0001E0
424       P:02AE P:02AE 4C7000            MOVE                          X0,Y:SXMIT_FG_2
                        000216
425       P:02B0 P:02B0 4C7000            MOVE                          X0,Y:SXMIT_FG_3
                        00025E
426       P:02B2 P:02B2 4C7000            MOVE                          X0,Y:SXMIT_FG_4
                        0002B8
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 9



427       P:02B4 P:02B4 0A7005            BCLR    #SPLIT_S,X:STATUS                 ; Serials not split
                        000000
428       P:02B6 P:02B6 0A7006            BCLR    #SPLIT_P,X:STATUS                 ; Parallels not split
                        000000
429                             ; Now go through copying in the serial read waveform if binning more than 4.
430       P:02B8 P:02B8 200013            CLR     A
431       P:02B9 P:02B9 20001B            CLR     B
432       P:02BA P:02BA 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 5 or greater
433       P:02BB P:02BB 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
434       P:02BC P:02BC 50F400            MOVE              #>4,A0
                        000004
435       P:02BE P:02BE 200005            CMP     B,A
436       P:02BF P:02BF 0E9537            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
437       P:02C0 P:02C0 0D0544            JSR     <SET_BINBIT                       ; else set BINBIT
438       P:02C1 P:02C1 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
439       P:02C2 P:02C2 0A3781  TRY_1_B   JCLR    #1,X:<BINBIT,TRY_2_B
                        0002CB
440                             ;       MOVE    #1,A0                   ; HACK
441                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
442       P:02C4 P:02C4 60F400            MOVE              #SERIAL_READ_FG_1,R0    ; Here if G amp, bin by 1
                        0001DA
443       P:02C6 P:02C6 51F400            MOVE              #(END_SERIAL_READ_FG_1-SERIAL_READ_FG_1),B0
                        00000E
444       P:02C8 P:02C8 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
445       P:02C9 P:02C9 0D053D            JSR     <WAVECPY                          ; Copy the waveform
446       P:02CA P:02CA 0C0537            JMP     <CMP_END
447       P:02CB P:02CB 0A3782  TRY_2_B   JCLR    #2,X:<BINBIT,TRY_3_B
                        0002D4
448       P:02CD P:02CD 60F400            MOVE              #SERIAL_READ_FG_2,R0    ; Here if G amp, bin by 2
                        00020A
449       P:02CF P:02CF 51F400            MOVE              #(END_SERIAL_READ_FG_2-SERIAL_READ_FG_2),B0
                        000014
450       P:02D1 P:02D1 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
451       P:02D2 P:02D2 0D053D            JSR     <WAVECPY                          ; Copy the waveform
452       P:02D3 P:02D3 0C0537            JMP     <CMP_END
453       P:02D4 P:02D4 0A3783  TRY_3_B   JCLR    #3,X:<BINBIT,TRY_4_B
                        0002DD
454       P:02D6 P:02D6 60F400            MOVE              #SERIAL_READ_FG_3,R0    ; Here if G amp, bin by 3
                        00024C
455       P:02D8 P:02D8 51F400            MOVE              #(END_SERIAL_READ_FG_3-SERIAL_READ_FG_3),B0
                        00001A
456       P:02DA P:02DA 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
457       P:02DB P:02DB 0D053D            JSR     <WAVECPY                          ; Copy the waveform
458       P:02DC P:02DC 0C0537            JMP     <CMP_END
459       P:02DD P:02DD 0A3784  TRY_4_B   JCLR    #4,X:<BINBIT,CMP_ERROR
                        00053A
460       P:02DF P:02DF 60F400            MOVE              #SERIAL_READ_FG_4,R0    ; Here if G amp, bin by 4
                        0002A0
461       P:02E1 P:02E1 51F400            MOVE              #(END_SERIAL_READ_FG_4-SERIAL_READ_FG_4),B0
                        000020
462       P:02E3 P:02E3 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
463       P:02E4 P:02E4 0D053D            JSR     <WAVECPY                          ; Copy the waveform
464       P:02E5 P:02E5 0C0537            JMP     <CMP_END
465    
466       P:02E6 P:02E6 56F400  CMP_C     MOVE              #'__C',A                ; C Amplifier = e2v E amp = Leach channel #0
                        5F5F43
467       P:02E8 P:02E8 200045            CMP     X0,A
468       P:02E9 P:02E9 0E2349            JNE     <CMP_D
469       P:02EA P:02EA 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
470       P:02EB P:02EB 56F400            MOVE              #ABCD_DOWN,A
                        00015D
471       P:02ED P:02ED 5E7000            MOVE                          A,Y:IS_PAR_CLK ; ganged parallels
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 10



                        00000F
472       P:02EF P:02EF 56F400            MOVE              #AB_DOWN,A
                        0001A2
473       P:02F1 P:02F1 5E7000            MOVE                          A,Y:S_PAR_CLK ; storage area parallels
                        000010
474       P:02F3 P:02F3 56F400            MOVE              #ABCD_CLEAR_DOWN,A
                        00017E
475       P:02F5 P:02F5 5E7000            MOVE                          A,Y:IS_PAR_CLR ; Clear full CCD
                        000011
476       P:02F7 P:02F7 56F400            MOVE              #AB_CLEAR_DOWN,A
                        0001B9
477       P:02F9 P:02F9 5E7000            MOVE                          A,Y:S_PAR_CLR ; Clear storage area only
                        000012
478       P:02FB P:02FB 56F400            MOVE              #SERIAL_SKIP_EH,A
                        0000E8
479       P:02FD P:02FD 5E7000            MOVE                          A,Y:SERIAL_SKIP ; Now do the serials for general binning
                        00000B
480       P:02FF P:02FF 56F400            MOVE              #INITIAL_CLOCK_EH,A
                        000055
481       P:0301 P:0301 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
482       P:0303 P:0303 56F400            MOVE              #SERIAL_CLOCK_EH,A
                        00006A
483       P:0305 P:0305 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
484       P:0307 P:0307 56F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000),A
                        03200A
485       P:0309 P:0309 5E7000            MOVE                          A,Y:CCLK_1
                        00007D
486       P:030B P:030B 44F400            MOVE              #$00F000,X0             ; Channel 0 only
                        00F000
487       P:030D P:030D 4C7000            MOVE                          X0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary binning
                        000079
488       P:030F P:030F 4C7000            MOVE                          X0,Y:SXMIT_EH_1 ; and into all the hard-coded binned cases i
n high Y
                        0001D2
489       P:0311 P:0311 4C7000            MOVE                          X0,Y:SXMIT_EH_2
                        000202
490       P:0313 P:0313 4C7000            MOVE                          X0,Y:SXMIT_EH_3
                        000244
491       P:0315 P:0315 4C7000            MOVE                          X0,Y:SXMIT_EH_4
                        000298
492       P:0317 P:0317 0A7005            BCLR    #SPLIT_S,X:STATUS                 ; Serials not split
                        000000
493       P:0319 P:0319 0A7006            BCLR    #SPLIT_P,X:STATUS                 ; Parallels not split
                        000000
494                             ; Now go through copying in the serial read waveform if binning more than 4.
495       P:031B P:031B 200013            CLR     A
496       P:031C P:031C 20001B            CLR     B
497       P:031D P:031D 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 5 or greater
498       P:031E P:031E 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
499       P:031F P:031F 50F400            MOVE              #>4,A0
                        000004
500       P:0321 P:0321 200005            CMP     B,A
501       P:0322 P:0322 0E9537            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
502       P:0323 P:0323 0D0544            JSR     <SET_BINBIT                       ; else set BINBIT
503       P:0324 P:0324 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
504       P:0325 P:0325 0A3781  TRY_1_C   JCLR    #1,X:<BINBIT,TRY_2_C
                        00032E
505                             ;       MOVE    #1,A0                   ; HACK
506                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
507       P:0327 P:0327 60F400            MOVE              #SERIAL_READ_EH_1,R0    ; Here if E amp, bin by 1
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 11



                        0001CC
508       P:0329 P:0329 51F400            MOVE              #(END_SERIAL_READ_EH_1-SERIAL_READ_EH_1),B0
                        00000E
509       P:032B P:032B 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
510       P:032C P:032C 0D053D            JSR     <WAVECPY                          ; Copy the waveform
511       P:032D P:032D 0C0537            JMP     <CMP_END
512       P:032E P:032E 0A3782  TRY_2_C   JCLR    #2,X:<BINBIT,TRY_3_C
                        000337
513       P:0330 P:0330 60F400            MOVE              #SERIAL_READ_EH_2,R0    ; Here if E amp, bin by 2
                        0001F6
514       P:0332 P:0332 51F400            MOVE              #(END_SERIAL_READ_EH_2-SERIAL_READ_EH_2),B0
                        000014
515       P:0334 P:0334 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
516       P:0335 P:0335 0D053D            JSR     <WAVECPY                          ; Copy the waveform
517       P:0336 P:0336 0C0537            JMP     <CMP_END
518       P:0337 P:0337 0A3783  TRY_3_C   JCLR    #3,X:<BINBIT,TRY_4_C
                        000340
519       P:0339 P:0339 60F400            MOVE              #SERIAL_READ_EH_3,R0    ; Here if E amp, bin by 3
                        000232
520       P:033B P:033B 51F400            MOVE              #(END_SERIAL_READ_EH_3-SERIAL_READ_EH_3),B0
                        00001A
521       P:033D P:033D 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
522       P:033E P:033E 0D053D            JSR     <WAVECPY                          ; Copy the waveform
523       P:033F P:033F 0C0537            JMP     <CMP_END
524       P:0340 P:0340 0A3784  TRY_4_C   JCLR    #4,X:<BINBIT,CMP_ERROR
                        00053A
525       P:0342 P:0342 60F400            MOVE              #SERIAL_READ_EH_4,R0    ; Here if E amp, bin by 4
                        000280
526       P:0344 P:0344 51F400            MOVE              #(END_SERIAL_READ_EH_4-SERIAL_READ_EH_4),B0
                        000020
527       P:0346 P:0346 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
528       P:0347 P:0347 0D053D            JSR     <WAVECPY                          ; Copy the waveform
529       P:0348 P:0348 0C0537            JMP     <CMP_END
530    
531       P:0349 P:0349 56F400  CMP_D     MOVE              #'__D',A                ; D Amplifier = e2v F amp = Leach channel #1
                        5F5F44
532       P:034B P:034B 200045            CMP     X0,A
533       P:034C P:034C 0E23AC            JNE     <CMP_AB
534       P:034D P:034D 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
535       P:034E P:034E 56F400            MOVE              #ABCD_DOWN,A
                        00015D
536       P:0350 P:0350 5E7000            MOVE                          A,Y:IS_PAR_CLK ; ganged parallels
                        00000F
537       P:0352 P:0352 56F400            MOVE              #AB_DOWN,A
                        0001A2
538       P:0354 P:0354 5E7000            MOVE                          A,Y:S_PAR_CLK ; storage area parallels
                        000010
539       P:0356 P:0356 56F400            MOVE              #ABCD_CLEAR_DOWN,A
                        00017E
540       P:0358 P:0358 5E7000            MOVE                          A,Y:IS_PAR_CLR ; Clear full CCD
                        000011
541       P:035A P:035A 56F400            MOVE              #AB_CLEAR_DOWN,A
                        0001B9
542       P:035C P:035C 5E7000            MOVE                          A,Y:S_PAR_CLR ; Clear storage area only
                        000012
543       P:035E P:035E 56F400            MOVE              #SERIAL_SKIP_FG,A
                        0000F0
544       P:0360 P:0360 5E7000            MOVE                          A,Y:SERIAL_SKIP ; Now do the serials for general binning
                        00000B
545       P:0362 P:0362 56F400            MOVE              #INITIAL_CLOCK_FG,A
                        00005C
546       P:0364 P:0364 5E7000            MOVE                          A,Y:INITIAL_CLOCK
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 12



                        00000E
547       P:0366 P:0366 56F400            MOVE              #SERIAL_CLOCK_FG,A
                        000071
548       P:0368 P:0368 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
549       P:036A P:036A 56F400            MOVE              #(CLK2+$030000+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000),A
                        032011
550       P:036C P:036C 5E7000            MOVE                          A,Y:CCLK_1
                        00007D
551       P:036E P:036E 44F400            MOVE              #$00F021,X0             ; Channel 1 only
                        00F021
552       P:0370 P:0370 4C7000            MOVE                          X0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary binning
                        000079
553       P:0372 P:0372 4C7000            MOVE                          X0,Y:SXMIT_FG_1 ; and into all the hard-coded binned cases i
n high Y
                        0001E0
554       P:0374 P:0374 4C7000            MOVE                          X0,Y:SXMIT_FG_2
                        000216
555       P:0376 P:0376 4C7000            MOVE                          X0,Y:SXMIT_FG_3
                        00025E
556       P:0378 P:0378 4C7000            MOVE                          X0,Y:SXMIT_FG_4
                        0002B8
557       P:037A P:037A 0A7005            BCLR    #SPLIT_S,X:STATUS                 ; Serials not split
                        000000
558       P:037C P:037C 0A7006            BCLR    #SPLIT_P,X:STATUS                 ; Parallels not split
                        000000
559                             ; Now go through copying in the serial read waveform if binning more than 4.
560       P:037E P:037E 200013            CLR     A
561       P:037F P:037F 20001B            CLR     B
562       P:0380 P:0380 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 5 or greater
563       P:0381 P:0381 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
564       P:0382 P:0382 50F400            MOVE              #>4,A0
                        000004
565       P:0384 P:0384 200005            CMP     B,A
566       P:0385 P:0385 0E9537            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
567       P:0386 P:0386 0D0544            JSR     <SET_BINBIT                       ; else set BINBIT
568       P:0387 P:0387 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
569       P:0388 P:0388 0A3781  TRY_1_D   JCLR    #1,X:<BINBIT,TRY_2_D
                        000391
570                             ;       MOVE    #1,A0                   ; HACK
571                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
572       P:038A P:038A 60F400            MOVE              #SERIAL_READ_FG_1,R0    ; Here if F amp, bin by 1
                        0001DA
573       P:038C P:038C 51F400            MOVE              #(END_SERIAL_READ_FG_1-SERIAL_READ_FG_1),B0
                        00000E
574       P:038E P:038E 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
575       P:038F P:038F 0D053D            JSR     <WAVECPY                          ; Copy the waveform
576       P:0390 P:0390 0C0537            JMP     <CMP_END
577       P:0391 P:0391 0A3782  TRY_2_D   JCLR    #2,X:<BINBIT,TRY_3_D
                        00039A
578       P:0393 P:0393 60F400            MOVE              #SERIAL_READ_FG_2,R0    ; Here if F amp, bin by 2
                        00020A
579       P:0395 P:0395 51F400            MOVE              #(END_SERIAL_READ_FG_2-SERIAL_READ_FG_2),B0
                        000014
580       P:0397 P:0397 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
581       P:0398 P:0398 0D053D            JSR     <WAVECPY                          ; Copy the waveform
582       P:0399 P:0399 0C0537            JMP     <CMP_END
583       P:039A P:039A 0A3783  TRY_3_D   JCLR    #3,X:<BINBIT,TRY_4_D
                        0003A3
584       P:039C P:039C 60F400            MOVE              #SERIAL_READ_FG_3,R0    ; Here if F amp, bin by 3
                        00024C
585       P:039E P:039E 51F400            MOVE              #(END_SERIAL_READ_FG_3-SERIAL_READ_FG_3),B0
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 13



                        00001A
586       P:03A0 P:03A0 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
587       P:03A1 P:03A1 0D053D            JSR     <WAVECPY                          ; Copy the waveform
588       P:03A2 P:03A2 0C0537            JMP     <CMP_END
589       P:03A3 P:03A3 0A3784  TRY_4_D   JCLR    #4,X:<BINBIT,CMP_ERROR
                        00053A
590       P:03A5 P:03A5 60F400            MOVE              #SERIAL_READ_FG_4,R0    ; Here if F amp, bin by 4
                        0002A0
591       P:03A7 P:03A7 51F400            MOVE              #(END_SERIAL_READ_FG_4-SERIAL_READ_FG_4),B0
                        000020
592       P:03A9 P:03A9 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
593       P:03AA P:03AA 0D053D            JSR     <WAVECPY                          ; Copy the waveform
594       P:03AB P:03AB 0C0537            JMP     <CMP_END
595    
596       P:03AC P:03AC 56F400  CMP_AB    MOVE              #'_AB',A                ; AB Amplifier = e2v HG amp = Leach channels 2-3
                        5F4142
597       P:03AE P:03AE 200045            CMP     X0,A
598       P:03AF P:03AF 0E240F            JNE     <CMP_CD
599       P:03B0 P:03B0 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
600       P:03B1 P:03B1 56F400            MOVE              #ABCD_UP,A
                        000153
601       P:03B3 P:03B3 5E7000            MOVE                          A,Y:IS_PAR_CLK ; ganged parallels
                        00000F
602       P:03B5 P:03B5 56F400            MOVE              #CD_UP,A
                        000198
603       P:03B7 P:03B7 5E7000            MOVE                          A,Y:S_PAR_CLK ; storage area parallels
                        000010
604       P:03B9 P:03B9 56F400            MOVE              #ABCD_CLEAR_UP,A
                        000171
605       P:03BB P:03BB 5E7000            MOVE                          A,Y:IS_PAR_CLR ; Clear full CCD
                        000011
606       P:03BD P:03BD 56F400            MOVE              #CD_CLEAR_UP,A
                        0001AC
607       P:03BF P:03BF 5E7000            MOVE                          A,Y:S_PAR_CLR ; Clear storage area only
                        000012
608       P:03C1 P:03C1 56F400            MOVE              #SERIAL_SKIP_SPLIT,A
                        0000F8
609       P:03C3 P:03C3 5E7000            MOVE                          A,Y:SERIAL_SKIP ; Now do the serials for general binning
                        00000B
610       P:03C5 P:03C5 56F400            MOVE              #INITIAL_CLOCK_SPLIT,A
                        00004E
611       P:03C7 P:03C7 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
612       P:03C9 P:03C9 56F400            MOVE              #SERIAL_CLOCK_SPLIT,A
                        000063
613       P:03CB P:03CB 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
614       P:03CD P:03CD 56F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000),A
                        032012
615       P:03CF P:03CF 5E7000            MOVE                          A,Y:CCLK_1
                        00007D
616       P:03D1 P:03D1 44F400            MOVE              #$00F062,X0             ; Channels 2-3
                        00F062
617       P:03D3 P:03D3 4C7000            MOVE                          X0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary binning
                        000079
618       P:03D5 P:03D5 4C7000            MOVE                          X0,Y:SXMIT_SPLIT_1 ; and into all the hard-coded binned case
s in high Y
                        0001EE
619       P:03D7 P:03D7 4C7000            MOVE                          X0,Y:SXMIT_SPLIT_2
                        00022A
620       P:03D9 P:03D9 4C7000            MOVE                          X0,Y:SXMIT_SPLIT_3
                        000278
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 14



621       P:03DB P:03DB 4C7000            MOVE                          X0,Y:SXMIT_SPLIT_4
                        0002D8
622       P:03DD P:03DD 0A7025            BSET    #SPLIT_S,X:STATUS                 ; Serials split
                        000000
623       P:03DF P:03DF 0A7006            BCLR    #SPLIT_P,X:STATUS                 ; Parallels not split
                        000000
624                             ; Now go through copying in the serial read waveform if binning more than 4.
625       P:03E1 P:03E1 200013            CLR     A
626       P:03E2 P:03E2 20001B            CLR     B
627       P:03E3 P:03E3 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 5 or greater
628       P:03E4 P:03E4 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
629       P:03E5 P:03E5 50F400            MOVE              #>4,A0
                        000004
630       P:03E7 P:03E7 200005            CMP     B,A
631       P:03E8 P:03E8 0E9537            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
632       P:03E9 P:03E9 0D0544            JSR     <SET_BINBIT                       ; else set BINBIT
633       P:03EA P:03EA 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
634       P:03EB P:03EB 0A3781  TRY_1_AB  JCLR    #1,X:<BINBIT,TRY_2_AB
                        0003F4
635                             ;       MOVE    #1,A0                   ; HACK
636                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
637       P:03ED P:03ED 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if HG amp, bin by 1
                        0001E8
638       P:03EF P:03EF 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                        00000E
639       P:03F1 P:03F1 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
640       P:03F2 P:03F2 0D053D            JSR     <WAVECPY                          ; Copy the waveform
641       P:03F3 P:03F3 0C0537            JMP     <CMP_END
642       P:03F4 P:03F4 0A3782  TRY_2_AB  JCLR    #2,X:<BINBIT,TRY_3_AB
                        0003FD
643       P:03F6 P:03F6 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if HG amp, bin by 2
                        00021E
644       P:03F8 P:03F8 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                        000014
645       P:03FA P:03FA 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
646       P:03FB P:03FB 0D053D            JSR     <WAVECPY                          ; Copy the waveform
647       P:03FC P:03FC 0C0537            JMP     <CMP_END
648       P:03FD P:03FD 0A3783  TRY_3_AB  JCLR    #3,X:<BINBIT,TRY_4_AB
                        000406
649       P:03FF P:03FF 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if HG amp, bin by 3
                        000266
650       P:0401 P:0401 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                        00001A
651       P:0403 P:0403 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
652       P:0404 P:0404 0D053D            JSR     <WAVECPY                          ; Copy the waveform
653       P:0405 P:0405 0C0537            JMP     <CMP_END
654       P:0406 P:0406 0A3784  TRY_4_AB  JCLR    #4,X:<BINBIT,CMP_ERROR
                        00053A
655       P:0408 P:0408 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if HG amp, bin by 4
                        0002C0
656       P:040A P:040A 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                        000020
657       P:040C P:040C 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
658       P:040D P:040D 0D053D            JSR     <WAVECPY                          ; Copy the waveform
659       P:040E P:040E 0C0537            JMP     <CMP_END
660    
661       P:040F P:040F 56F400  CMP_CD    MOVE              #'_CD',A                ; CD Amplifier = e2v EF amp = Leach channels 0-1
                        5F4344
662       P:0411 P:0411 200045            CMP     X0,A
663       P:0412 P:0412 0E2472            JNE     <CMP_BD
664       P:0413 P:0413 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
665       P:0414 P:0414 56F400            MOVE              #ABCD_DOWN,A
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 15



                        00015D
666       P:0416 P:0416 5E7000            MOVE                          A,Y:IS_PAR_CLK ; ganged parallels
                        00000F
667       P:0418 P:0418 56F400            MOVE              #AB_DOWN,A
                        0001A2
668       P:041A P:041A 5E7000            MOVE                          A,Y:S_PAR_CLK ; storage area parallels
                        000010
669       P:041C P:041C 56F400            MOVE              #ABCD_CLEAR_DOWN,A
                        00017E
670       P:041E P:041E 5E7000            MOVE                          A,Y:IS_PAR_CLR ; Clear full CCD
                        000011
671       P:0420 P:0420 56F400            MOVE              #AB_CLEAR_DOWN,A
                        0001B9
672       P:0422 P:0422 5E7000            MOVE                          A,Y:S_PAR_CLR ; Clear storage area only
                        000012
673       P:0424 P:0424 56F400            MOVE              #SERIAL_SKIP_SPLIT,A
                        0000F8
674       P:0426 P:0426 5E7000            MOVE                          A,Y:SERIAL_SKIP ; Now do the serials for general binning
                        00000B
675       P:0428 P:0428 56F400            MOVE              #INITIAL_CLOCK_SPLIT,A
                        00004E
676       P:042A P:042A 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
677       P:042C P:042C 56F400            MOVE              #SERIAL_CLOCK_SPLIT,A
                        000063
678       P:042E P:042E 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
679       P:0430 P:0430 56F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000),A
                        032012
680       P:0432 P:0432 5E7000            MOVE                          A,Y:CCLK_1
                        00007D
681       P:0434 P:0434 44F400            MOVE              #$00F020,X0             ; Channels 0-1
                        00F020
682       P:0436 P:0436 4C7000            MOVE                          X0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary binning
                        000079
683       P:0438 P:0438 4C7000            MOVE                          X0,Y:SXMIT_SPLIT_1 ; and into all the hard-coded binned case
s in high Y
                        0001EE
684       P:043A P:043A 4C7000            MOVE                          X0,Y:SXMIT_SPLIT_2
                        00022A
685       P:043C P:043C 4C7000            MOVE                          X0,Y:SXMIT_SPLIT_3
                        000278
686       P:043E P:043E 4C7000            MOVE                          X0,Y:SXMIT_SPLIT_4
                        0002D8
687       P:0440 P:0440 0A7025            BSET    #SPLIT_S,X:STATUS                 ; Serials split
                        000000
688       P:0442 P:0442 0A7006            BCLR    #SPLIT_P,X:STATUS                 ; Parallels not split
                        000000
689                             ; Now go through copying in the serial read waveform if binning more than 4.
690       P:0444 P:0444 200013            CLR     A
691       P:0445 P:0445 20001B            CLR     B
692       P:0446 P:0446 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 5 or greater
693       P:0447 P:0447 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
694       P:0448 P:0448 50F400            MOVE              #>4,A0
                        000004
695       P:044A P:044A 200005            CMP     B,A
696       P:044B P:044B 0E9537            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
697       P:044C P:044C 0D0544            JSR     <SET_BINBIT                       ; else set BINBIT
698       P:044D P:044D 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
699       P:044E P:044E 0A3781  TRY_1_CD  JCLR    #1,X:<BINBIT,TRY_2_CD
                        000457
700                             ;       MOVE    #1,A0                   ; HACK
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 16



701                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
702       P:0450 P:0450 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if EF amp, bin by 1
                        0001E8
703       P:0452 P:0452 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                        00000E
704       P:0454 P:0454 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
705       P:0455 P:0455 0D053D            JSR     <WAVECPY                          ; Copy the waveform
706       P:0456 P:0456 0C0537            JMP     <CMP_END
707       P:0457 P:0457 0A3782  TRY_2_CD  JCLR    #2,X:<BINBIT,TRY_3_CD
                        000460
708       P:0459 P:0459 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if EF amp, bin by 2
                        00021E
709       P:045B P:045B 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                        000014
710       P:045D P:045D 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
711       P:045E P:045E 0D053D            JSR     <WAVECPY                          ; Copy the waveform
712       P:045F P:045F 0C0537            JMP     <CMP_END
713       P:0460 P:0460 0A3783  TRY_3_CD  JCLR    #3,X:<BINBIT,TRY_4_CD
                        000469
714       P:0462 P:0462 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if EF amp, bin by 3
                        000266
715       P:0464 P:0464 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                        00001A
716       P:0466 P:0466 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
717       P:0467 P:0467 0D053D            JSR     <WAVECPY                          ; Copy the waveform
718       P:0468 P:0468 0C0537            JMP     <CMP_END
719       P:0469 P:0469 0A3784  TRY_4_CD  JCLR    #4,X:<BINBIT,CMP_ERROR
                        00053A
720       P:046B P:046B 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if EF amp, bin by 4
                        0002C0
721       P:046D P:046D 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                        000020
722       P:046F P:046F 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
723       P:0470 P:0470 0D053D            JSR     <WAVECPY                          ; Copy the waveform
724       P:0471 P:0471 0C0537            JMP     <CMP_END
725    
726       P:0472 P:0472 56F400  CMP_BD    MOVE              #'_BD',A                ; BD Amplifier = e2v FG amp = Leach channels 1-2
                        5F4244
727       P:0474 P:0474 200045            CMP     X0,A                              ; Note that EH amplifier isn't possible - Leach 
channels 0 & 3
728       P:0475 P:0475 0E24D5            JNE     <CMP_ALL                          ; are not adjacent so SXMIT doesn't work.
729       P:0476 P:0476 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
730       P:0477 P:0477 56F400            MOVE              #ABCD_SPLIT,A
                        000167
731       P:0479 P:0479 5E7000            MOVE                          A,Y:IS_PAR_CLK ; ganged parallels
                        00000F
732       P:047B P:047B 56F400            MOVE              #CD_UP,A
                        000198
733       P:047D P:047D 5E7000            MOVE                          A,Y:S_PAR_CLK ; storage area parallels; NA for split paralle
ls
                        000010
734       P:047F P:047F 56F400            MOVE              #ABCD_CLEAR_SPLIT,A
                        00018B
735       P:0481 P:0481 5E7000            MOVE                          A,Y:IS_PAR_CLR ; Clear full CCD
                        000011
736       P:0483 P:0483 56F400            MOVE              #CD_CLEAR_UP,A
                        0001AC
737       P:0485 P:0485 5E7000            MOVE                          A,Y:S_PAR_CLR ; Clear storage area only; NA for split parall
els
                        000012
738       P:0487 P:0487 56F400            MOVE              #SERIAL_SKIP_FG,A
                        0000F0
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 17



739       P:0489 P:0489 5E7000            MOVE                          A,Y:SERIAL_SKIP ; Now do the serials for general binning
                        00000B
740       P:048B P:048B 56F400            MOVE              #INITIAL_CLOCK_FG,A
                        00005C
741       P:048D P:048D 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
742       P:048F P:048F 56F400            MOVE              #SERIAL_CLOCK_FG,A
                        000071
743       P:0491 P:0491 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
744       P:0493 P:0493 56F400            MOVE              #(CLK2+$030000+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000),A
                        032011
745       P:0495 P:0495 5E7000            MOVE                          A,Y:CCLK_1
                        00007D
746       P:0497 P:0497 44F400            MOVE              #$00F041,X0             ; Channels 1-2
                        00F041
747       P:0499 P:0499 4C7000            MOVE                          X0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary binning
                        000079
748       P:049B P:049B 4C7000            MOVE                          X0,Y:SXMIT_FG_1 ; and into all the hard-coded binned cases i
n high Y
                        0001E0
749       P:049D P:049D 4C7000            MOVE                          X0,Y:SXMIT_FG_2
                        000216
750       P:049F P:049F 4C7000            MOVE                          X0,Y:SXMIT_FG_3
                        00025E
751       P:04A1 P:04A1 4C7000            MOVE                          X0,Y:SXMIT_FG_4
                        0002B8
752       P:04A3 P:04A3 0A7005            BCLR    #SPLIT_S,X:STATUS                 ; Serials not split
                        000000
753       P:04A5 P:04A5 0A7026            BSET    #SPLIT_P,X:STATUS                 ; Parallels split
                        000000
754                             ; Now go through copying in the serial read waveform if binning more than 4.
755       P:04A7 P:04A7 200013            CLR     A
756       P:04A8 P:04A8 20001B            CLR     B
757       P:04A9 P:04A9 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 5 or greater
758       P:04AA P:04AA 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
759       P:04AB P:04AB 50F400            MOVE              #>4,A0
                        000004
760       P:04AD P:04AD 200005            CMP     B,A
761       P:04AE P:04AE 0E9537            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
762       P:04AF P:04AF 0D0544            JSR     <SET_BINBIT                       ; else set BINBIT
763       P:04B0 P:04B0 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
764       P:04B1 P:04B1 0A3781  TRY_1_BD  JCLR    #1,X:<BINBIT,TRY_2_BD
                        0004BA
765                             ;       MOVE    #1,A0                   ; HACK
766                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
767       P:04B3 P:04B3 60F400            MOVE              #SERIAL_READ_FG_1,R0    ; Here if FG amp, bin by 1
                        0001DA
768       P:04B5 P:04B5 51F400            MOVE              #(END_SERIAL_READ_FG_1-SERIAL_READ_FG_1),B0
                        00000E
769       P:04B7 P:04B7 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
770       P:04B8 P:04B8 0D053D            JSR     <WAVECPY                          ; Copy the waveform
771       P:04B9 P:04B9 0C0537            JMP     <CMP_END
772       P:04BA P:04BA 0A3782  TRY_2_BD  JCLR    #2,X:<BINBIT,TRY_3_BD
                        0004C3
773       P:04BC P:04BC 60F400            MOVE              #SERIAL_READ_FG_2,R0    ; Here if FG amp, bin by 2
                        00020A
774       P:04BE P:04BE 51F400            MOVE              #(END_SERIAL_READ_FG_2-SERIAL_READ_FG_2),B0
                        000014
775       P:04C0 P:04C0 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
776       P:04C1 P:04C1 0D053D            JSR     <WAVECPY                          ; Copy the waveform
777       P:04C2 P:04C2 0C0537            JMP     <CMP_END
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 18



778       P:04C3 P:04C3 0A3783  TRY_3_BD  JCLR    #3,X:<BINBIT,TRY_4_BD
                        0004CC
779       P:04C5 P:04C5 60F400            MOVE              #SERIAL_READ_FG_3,R0    ; Here if FG amp, bin by 3
                        00024C
780       P:04C7 P:04C7 51F400            MOVE              #(END_SERIAL_READ_FG_3-SERIAL_READ_FG_3),B0
                        00001A
781       P:04C9 P:04C9 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
782       P:04CA P:04CA 0D053D            JSR     <WAVECPY                          ; Copy the waveform
783       P:04CB P:04CB 0C0537            JMP     <CMP_END
784       P:04CC P:04CC 0A3784  TRY_4_BD  JCLR    #4,X:<BINBIT,CMP_ERROR
                        00053A
785       P:04CE P:04CE 60F400            MOVE              #SERIAL_READ_FG_4,R0    ; Here if FG amp, bin by 4
                        0002A0
786       P:04D0 P:04D0 51F400            MOVE              #(END_SERIAL_READ_FG_4-SERIAL_READ_FG_4),B0
                        000020
787       P:04D2 P:04D2 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
788       P:04D3 P:04D3 0D053D            JSR     <WAVECPY                          ; Copy the waveform
789       P:04D4 P:04D4 0C0537            JMP     <CMP_END
790    
791       P:04D5 P:04D5 56F400  CMP_ALL   MOVE              #'ALL',A                ; ABCD Amplifier = e2v EFGH amp = Leach channels
 0-3
                        414C4C
792       P:04D7 P:04D7 200045            CMP     X0,A
793       P:04D8 P:04D8 0E253A            JNE     <CMP_ERROR
794       P:04D9 P:04D9 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
795       P:04DA P:04DA 56F400            MOVE              #ABCD_SPLIT,A
                        000167
796       P:04DC P:04DC 5E7000            MOVE                          A,Y:IS_PAR_CLK ; ganged parallels
                        00000F
797       P:04DE P:04DE 56F400            MOVE              #CD_UP,A
                        000198
798       P:04E0 P:04E0 5E7000            MOVE                          A,Y:S_PAR_CLK ; storage area parallels; NA for split paralle
ls
                        000010
799       P:04E2 P:04E2 56F400            MOVE              #ABCD_CLEAR_SPLIT,A
                        00018B
800       P:04E4 P:04E4 5E7000            MOVE                          A,Y:IS_PAR_CLR ; Clear full CCD
                        000011
801       P:04E6 P:04E6 56F400            MOVE              #CD_CLEAR_UP,A
                        0001AC
802       P:04E8 P:04E8 5E7000            MOVE                          A,Y:S_PAR_CLR ; Clear storage area only; NA for split parall
els
                        000012
803       P:04EA P:04EA 56F400            MOVE              #SERIAL_SKIP_SPLIT,A
                        0000F8
804       P:04EC P:04EC 5E7000            MOVE                          A,Y:SERIAL_SKIP ; Now do the serials for general binning
                        00000B
805       P:04EE P:04EE 56F400            MOVE              #INITIAL_CLOCK_SPLIT,A
                        00004E
806       P:04F0 P:04F0 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
807       P:04F2 P:04F2 56F400            MOVE              #SERIAL_CLOCK_SPLIT,A
                        000063
808       P:04F4 P:04F4 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
809       P:04F6 P:04F6 56F400            MOVE              #(CLK2+$030000+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000),A
                        032012
810       P:04F8 P:04F8 5E7000            MOVE                          A,Y:CCLK_1
                        00007D
811       P:04FA P:04FA 44F400            MOVE              #$00F060,X0             ; All four channels
                        00F060
812       P:04FC P:04FC 4C7000            MOVE                          X0,Y:SXMIT_VP ; Put into VIDEO_PROCESS for arbitrary binning
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 19



                        000079
813       P:04FE P:04FE 4C7000            MOVE                          X0,Y:SXMIT_SPLIT_1 ; and into all the hard-coded binned case
s in high Y
                        0001EE
814       P:0500 P:0500 4C7000            MOVE                          X0,Y:SXMIT_SPLIT_2
                        00022A
815       P:0502 P:0502 4C7000            MOVE                          X0,Y:SXMIT_SPLIT_3
                        000278
816       P:0504 P:0504 4C7000            MOVE                          X0,Y:SXMIT_SPLIT_4
                        0002D8
817       P:0506 P:0506 0A7025            BSET    #SPLIT_S,X:STATUS                 ; Serials split
                        000000
818       P:0508 P:0508 0A7026            BSET    #SPLIT_P,X:STATUS                 ; Parallels split
                        000000
819                             ; Now go through copying in the serial read waveform if binning more than 4.
820       P:050A P:050A 200013            CLR     A
821       P:050B P:050B 20001B            CLR     B
822       P:050C P:050C 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 5 or greater
823       P:050D P:050D 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 4?
824       P:050E P:050E 50F400            MOVE              #>4,A0
                        000004
825       P:0510 P:0510 200005            CMP     B,A
826       P:0511 P:0511 0E9537            JLT     <CMP_END                          ; If binning 5 or more, don't copy.
827       P:0512 P:0512 0D0544            JSR     <SET_BINBIT                       ; else set BINBIT
828       P:0513 P:0513 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
829       P:0514 P:0514 0A3781  TRY_1_ALL JCLR    #1,X:<BINBIT,TRY_2_ALL
                        00051D
830                             ;       MOVE    #1,A0                   ; HACK
831                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
832       P:0516 P:0516 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if ALL amp, bin by 1
                        0001E8
833       P:0518 P:0518 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                        00000E
834       P:051A P:051A 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
835       P:051B P:051B 0D053D            JSR     <WAVECPY                          ; Copy the waveform
836       P:051C P:051C 0C0537            JMP     <CMP_END
837       P:051D P:051D 0A3782  TRY_2_ALL JCLR    #2,X:<BINBIT,TRY_3_ALL
                        000526
838       P:051F P:051F 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if ALL amp, bin by 2
                        00021E
839       P:0521 P:0521 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                        000014
840       P:0523 P:0523 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
841       P:0524 P:0524 0D053D            JSR     <WAVECPY                          ; Copy the waveform
842       P:0525 P:0525 0C0537            JMP     <CMP_END
843       P:0526 P:0526 0A3783  TRY_3_ALL JCLR    #3,X:<BINBIT,TRY_4_ALL
                        00052F
844       P:0528 P:0528 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if ALL amp, bin by 3
                        000266
845       P:052A P:052A 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                        00001A
846       P:052C P:052C 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
847       P:052D P:052D 0D053D            JSR     <WAVECPY                          ; Copy the waveform
848       P:052E P:052E 0C0537            JMP     <CMP_END
849       P:052F P:052F 0A3784  TRY_4_ALL JCLR    #4,X:<BINBIT,CMP_ERROR
                        00053A
850       P:0531 P:0531 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if ALL amp, bin by 4
                        0002C0
851       P:0533 P:0533 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                        000020
852       P:0535 P:0535 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
853       P:0536 P:0536 0D053D            JSR     <WAVECPY                          ; Copy the waveform
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 20



854    
855       P:0537 P:0537 44F400  CMP_END   MOVE              #'DON',X0
                        444F4E
856       P:0539 P:0539 00000C            RTS
857                             CMP_ERROR                                           ; Here if illegal amplifier or binning
858       P:053A P:053A 44F400            MOVE              #'ERR',X0
                        455252
859       P:053C P:053C 00000C            RTS
860    
861                             ; Short function to copy in waveforms from high Y to fast Y memory.
862                             ; R0 is the source address, R7 the destination, and X0 is intermediary reg.
863                             WAVECPY
864       P:053D P:053D 06C900            DO      B0,WAVELP                         ; Copy the waveform; B0 is SERWAVLEN already
                        000541
865       P:053F P:053F 4CD800            MOVE                          Y:(R0)+,X0
866       P:0540 P:0540 4C5F00            MOVE                          X0,Y:(R7)+
867       P:0541 P:0541 000000            NOP
868                             WAVELP
869       P:0542 P:0542 000000            NOP
870       P:0543 P:0543 00000C            RTS
871    
872                             ; Short function to set the correct bit in BINBIT based on NSBIN
873                             ; Called only if NSBIN is less than 6.
874    
875                             SET_BINBIT
876                             ;       MOVE    Y:<TESTLOC1,A0                  ; HACK - test if this code is executed
877                             ;       INC     A                               ; HACK
878                             ;       MOVE    A0,Y:<TESTLOC1                  ; HACK
879       P:0544 P:0544 50F400            MOVE              #>1,A0                  ; Put a bit in A and shift to right spot
                        000001
880       P:0546 P:0546 060540            DO      Y:<NSBIN,BINLOOP                  ; Bit zero position not used, 1-4 used
                        000548
881       P:0548 P:0548 200032            ASL     A
882                             BINLOOP
883       P:0549 P:0549 503700            MOVE              A0,X:<BINBIT            ; set bit 1-4 for SELECT_OUTPUT_SOURCE jump tabl
e
884       P:054A P:054A 00000C            RTS
885    
886    
887                             ; Set the number of rows and columns and binning factors
888                             SET_ROWS_COLUMNS
889       P:054B P:054B 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NSR = NAXIS1
890       P:054C P:054C 4C7000            MOVE                          X0,Y:NSR
                        000001
891       P:054E P:054E 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NPR = NAXIS2
892       P:054F P:054F 4C7000            MOVE                          X0,Y:NPR
                        000002
893       P:0551 P:0551 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NSBIN
894       P:0552 P:0552 4C7000            MOVE                          X0,Y:NSBIN
                        000005
895       P:0554 P:0554 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NPBIN
896       P:0555 P:0555 4C7000            MOVE                          X0,Y:NPBIN
                        000006
897       P:0557 P:0557 4CBD00            MOVE                          Y:<AMPVAL,X0 ; Get ampval in X0 for SOS call
898       P:0558 P:0558 0D0220            JSR     <SELECT_OUTPUT_SOURCE             ; Update serial read waveform in case binning ch
anged
899       P:0559 P:0559 0C0000            JMP     <FINISH
900    
901                             ; Set the variables for the time-resolved modes
902                             SET_IMAGE_PARAM
903       P:055A P:055A 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Image mode
904       P:055B P:055B 447000            MOVE              X0,X:IMAGE_MODE
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 21



                        000030
905       P:055D P:055D 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Iframes = NAXIS3
906       P:055E P:055E 4C7000            MOVE                          X0,Y:IFRAMES
                        00003A
907       P:0560 P:0560 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Srows
908       P:0561 P:0561 4C7000            MOVE                          X0,Y:SROWS
                        000038
909       P:0563 P:0563 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Interval
910                             ;       MOVE    X0,Y:INTERVAL           ; HACK - Using Interval as a test location
911       P:0564 P:0564 0C0000            JMP     <FINISH
912    
913    
914                             ; Set the hardware trigger bit, executed as a command
915                             SET_TRIGGER
916       P:0565 P:0565 44DC00            MOVE              X:(R4)+,X0              ; Get the trigger value
917       P:0566 P:0566 56F400            MOVE              #'_ON',A
                        5F4F4E
918       P:0568 P:0568 200045            CMP     X0,A
919       P:0569 P:0569 0AF0A2            JNE     NO_TRIGGER
                        000570
920       P:056B P:056B 0AA4AB            JSET    #11,X:PBD,TRIG_CLR                ; Is Trigger running?
                        00056E
921       P:056D P:056D 0C0000            JMP     <ERROR                            ; Yes! report Error!  Why do this?
922                             TRIG_CLR
923       P:056E P:056E 0A0028            BSET    #TRIGGER,X:<STATUS                ; Set status bit, hardware trigger
924       P:056F P:056F 0C0000            JMP     <FINISH
925                             NO_TRIGGER
926       P:0570 P:0570 0A0008            BCLR    #TRIGGER,X:<STATUS                ; Clear Status bit, software timing
927       P:0571 P:0571 0C0000            JMP     <FINISH
928    
929                             ; Calculate the fast read parameters for each readout box
930                             SETUP_SUBROUTINE
931       P:0572 P:0572 4C8C00            MOVE                          Y:<SERWAVLEN,X0 ; # of waveforms
932       P:0573 P:0573 4D9300            MOVE                          Y:<NSERIALS_READ,X1 ; Number of pixels to read
933       P:0574 P:0574 0D0669            JSR     <FASTSKP                          ; Compute number of clocks required
934       P:0575 P:0575 4D1600            MOVE                          X1,Y:<NREAD ; Number of waveforms per line
935       P:0576 P:0576 5E9D00            MOVE                          Y:<NR_BIAS,A ; Number of pixels to read
936       P:0577 P:0577 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                        00057A
937       P:0579 P:0579 200022            ASR     A
938       P:057A P:057A 21C500            MOVE              A,X1                    ; Number of waveforms per line
939       P:057B P:057B 0D0669            JSR     <FASTSKP                          ; Compute number of clocks required
940       P:057C P:057C 4D1800            MOVE                          X1,Y:<NBIAS ; Number of waveforms per line
941       P:057D P:057D 44F400            MOVE              #(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT),X0 ; # of waveforms
                        000007
942       P:057F P:057F 4D8300            MOVE                          Y:<NS_CLR,X1 ; Number of pixels to skip
943       P:0580 P:0580 0D0669            JSR     <FASTSKP                          ; Compute number of clocks required
944       P:0581 P:0581 4D1400            MOVE                          X1,Y:<NSCLR ; Number of waveforms per line
945       P:0582 P:0582 4D9A00            MOVE                          Y:<NS_SKP1,X1 ; Number of pixels to skip
946       P:0583 P:0583 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
947       P:0584 P:0584 2000F0            MPY     Y1,X1,A
948       P:0585 P:0585 200022            ASR     A
949       P:0586 P:0586 210500            MOVE              A0,X1
950       P:0587 P:0587 0D0669            JSR     <FASTSKP                          ; Compute number of clocks required
951       P:0588 P:0588 4D1500            MOVE                          X1,Y:<NSKIP1 ; Number of waveforms per line
952       P:0589 P:0589 4D9B00            MOVE                          Y:<NS_SKP2,X1 ; Number of pixels to skip
953       P:058A P:058A 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
954       P:058B P:058B 2000F0            MPY     Y1,X1,A
955       P:058C P:058C 200022            ASR     A
956       P:058D P:058D 210500            MOVE              A0,X1
957       P:058E P:058E 0D0669            JSR     <FASTSKP                          ; Compute number of clocks required
958       P:058F P:058F 4D1700            MOVE                          X1,Y:<NSKIP2 ; Number of waveforms per line
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 22



959       P:0590 P:0590 4D9900            MOVE                          Y:<NP_SKIP,X1
960       P:0591 P:0591 4F8600            MOVE                          Y:<NPBIN,Y1
961       P:0592 P:0592 2000F0            MPY     X1,Y1,A
962       P:0593 P:0593 200022            ASR     A
963       P:0594 P:0594 581900            MOVE                          A0,Y:<NP_SKIP
964       P:0595 P:0595 00000C            RTS
965    
966                             ; Returns immediately if hardware triggering is not being used
967                             ; Blocks until the trigger is found to be high twice in a row.
968                             ; Waits until the trigger goes high
969                             WAIT_UNTIL_TRIGGER
970       P:0596 P:0596 0A0088            JCLR    #TRIGGER,X:STATUS,UNTIL_TRIGGER_RETURN
                        00059F
971       P:0598 P:0598 000000            NOP
972       P:0599 P:0599 0AA48B            JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER      ; Is Trigger Low?
                        000596
973       P:059B P:059B 000000            NOP                                       ; Pause
974       P:059C P:059C 0AA48B            JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER      ; Is Trigger still Low?
                        000596
975       P:059E P:059E 000000            NOP
976                             UNTIL_TRIGGER_RETURN
977       P:059F P:059F 00000C            RTS
978    
979                             ; Returns immediately if hardware triggering is not being used
980                             ; Blocks until the trigger is found to be low twice in a row.
981                             ; Waits while the trigger is high
982                             WAIT_WHILE_TRIGGER
983       P:05A0 P:05A0 0A0088            JCLR    #TRIGGER,X:STATUS,WHILE_TRIGGER_RETURN
                        0005A9
984       P:05A2 P:05A2 000000            NOP
985       P:05A3 P:05A3 0AA4AB            JSET    #11,X:PBD,WAIT_WHILE_TRIGGER      ; Is Trigger High?
                        0005A0
986       P:05A5 P:05A5 000000            NOP                                       ; Pause
987       P:05A6 P:05A6 0AA4AB            JSET    #11,X:PBD,WAIT_WHILE_TRIGGER      ; Is Trigger still High?
                        0005A0
988       P:05A8 P:05A8 000000            NOP
989                             WHILE_TRIGGER_RETURN
990       P:05A9 P:05A9 00000C            RTS
991    
992                             ; Like WAIT_WHILE_TRIGGER but clears the CCD while waiting
993                             ; Pro:  Clears CCD while waiting.  Con: timing rattiness of 1 parallel time
994                             ; Returns immediately if hardware triggering is not being used
995                             ; Blocks until the trigger is found to be low twice in a row.
996                             ; Waits while the trigger is high
997                             CLEAR_WHILE_TRIGGER
998       P:05AA P:05AA 0A0088            JCLR    #TRIGGER,X:STATUS,CLEAR_TRIG_RETURN
                        0005B4
999       P:05AC P:05AC 689100            MOVE                          Y:<IS_PAR_CLR,R0 ; Address of parallel transfer waveform
1000      P:05AD P:05AD 0D01EC            JSR     <CLOCK                            ; Go clock out the CCD charge
1001      P:05AE P:05AE 0AA4AB            JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER     ; Is Trigger High?
                        0005AA
1002      P:05B0 P:05B0 000000            NOP                                       ; Pause
1003      P:05B1 P:05B1 0AA4AB            JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER     ; Is Trigger still High?
                        0005AA
1004      P:05B3 P:05B3 000000            NOP
1005                            CLEAR_TRIG_RETURN
1006      P:05B4 P:05B4 00000C            RTS
1007   
1008                            ; Subroutine to compute SROWS in unbinned pixels and store in UBSROWS
1009   
1010                            UB_CONV
1011      P:05B5 P:05B5 4CB800            MOVE                          Y:<SROWS,X0
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 23



1012      P:05B6 P:05B6 4D8600            MOVE                          Y:<NPBIN,X1 ; Adjust for for parallel binning factor
1013      P:05B7 P:05B7 2000A0            MPY     X0,X1,A
1014      P:05B8 P:05B8 200022            ASR     A
1015      P:05B9 P:05B9 583900            MOVE                          A0,Y:<UBSROWS ; Put unbinned number in UBSROWS
1016      P:05BA P:05BA 00000C            RTS
1017   
1018                            ; Key code segments for the HIPO modes.
1019                            ; Jump table to the various modes - see also timhdr.s
1020                            START_FT_EXPOSURE
1021      P:05BB P:05BB 0A30A1            JSET    #FIND,X:IMAGE_MODE,SINGLE_PROC
                        0005E8
1022      P:05BD P:05BD 0A30A4            JSET    #SINGLE,X:IMAGE_MODE,SINGLE_PROC
                        0005E8
1023                            ;       JSET    #SERIES,X:IMAGE_MODE,SERIES_PROC        ; defunct.  Use basic occ.
1024      P:05BF P:05BF 0A30A0            JSET    #FDOTS,X:IMAGE_MODE,FDOT_PROC
                        0005CA
1025      P:05C1 P:05C1 0A30A2            JSET    #SDOTS,X:IMAGE_MODE,SDOT_PROC     ; slow dots & strips use sdot_proc
                        000615
1026      P:05C3 P:05C3 0A30A5            JSET    #STRIP,X:IMAGE_MODE,SDOT_PROC
                        000615
1027      P:05C5 P:05C5 0A30A7            JSET    #B_OCC,X:IMAGE_MODE,SINGLE_PROC   ; basic occ uses single_proc
                        0005E8
1028                            ;       JSET    #F_OCC,X:IMAGE_MODE,FPO_PROC            ; fast & pipelined occ use occ_proc
1029                            ;       JSET    #P_OCC,X:IMAGE_MODE,FPO_PROC
1030      P:05C7 P:05C7 44F400            MOVE              #'ERR',X0               ; error if not a valid mode
                        455252
1031      P:05C9 P:05C9 0C0000            JMP     <ERROR
1032   
1033                            FDOT_PROC                                           ; used by fdots only
1034                            ; Start by replacing SROWS (binned rows) with unbinned rows.  Will get rewritten on next SEX command
1035                            ; Leave the DO loop in here - no reason to change it - won't exceed 65535 dots, for sure!
1036      P:05CA P:05CA 0D05B5            JSR     UB_CONV                           ; Fill in unbinned SROWS
1037      P:05CB P:05CB 5E8200            MOVE                          Y:<NPR,A
1038      P:05CC P:05CC 5E1F00            MOVE                          A,Y:<NP_READ ; Make sure that NP_READ=NPR in case of subfram
e
1039      P:05CD P:05CD 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
1040      P:05CE P:05CE 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for FDOTS
1041      P:05CF P:05CF 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
1042      P:05D0 P:05D0 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        000636
1043      P:05D2 P:05D2 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
1044      P:05D3 P:05D3 0D05A0            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
1045                            ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
1046      P:05D4 P:05D4 0D0670            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
1047      P:05D5 P:05D5 063A40            DO      Y:<IFRAMES,FDOT_LOOP              ; Loop over the number of FDOTS
                        0005E0
1048      P:05D7 P:05D7 0A00A8            JSET    #TRIGGER,X:STATUS,FDX_END         ; If no triggering jump to expose image function
                        0005DC
1049      P:05D9 P:05D9 67F400            MOVE              #FDX_END,R7             ; Store the Address into R7
                        0005DC
1050      P:05DB P:05DB 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
1051      P:05DC P:05DC 0D0596  FDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
1052      P:05DD P:05DD 4DB900            MOVE                          Y:<UBSROWS,X1 ; Number of unbinned rows per shift
1053      P:05DE P:05DE 0D064B            JSR     <ISHIFT                           ; Clock out the waveforms
1054      P:05DF P:05DF 0D05A0            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
1055      P:05E0 P:05E0 000000            NOP
1056                            FDOT_LOOP
1057      P:05E1 P:05E1 0D0677            JSR     <C_CSHUT                          ; Conditionally close shutter
1058      P:05E2 P:05E2 063A40            DO      Y:<IFRAMES,FDOT_LP1               ; Loop over the number of FDOTS during readout
                        0005E5
1059      P:05E4 P:05E4 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 24



1060      P:05E5 P:05E5 000000            NOP
1061                            FDOT_LP1
1062                            ;       JSR     <WAIT_UNTIL_TRIGGER             ; If taking more than one set of dots sync. trigger.
  Vestigial?
1063      P:05E6 P:05E6 0AF080            JMP     CLEANUP                           ; clean up after command.
                        000643
1064   
1065                            SINGLE_PROC                                         ; Used by find, single, and basic occ
1066      P:05E8 P:05E8 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for find & basic occ
1067      P:05E9 P:05E9 0A3084            JCLR    #SINGLE,X:IMAGE_MODE,*+3          ; But if single mode,
                        0005EC
1068      P:05EB P:05EB 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
1069      P:05EC P:05EC 0A3102            BCLR    #STORAGE,X:<ISTATUS               ; Do the FT, storage clocks only during readout
1070      P:05ED P:05ED 0A30A7            JSET    #B_OCC,X:IMAGE_MODE,NO_CHG        ; STORAGE=0 for basic, 1 otherwise
                        0005F0
1071      P:05EF P:05EF 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't do the FT, ganged clocks only during rea
dout
1072      P:05F0 P:05F0 0A3100  NO_CHG    BCLR    #NO_SKIP,X:<ISTATUS               ; Do parallel skip up to the subframe boundary
1073      P:05F1 P:05F1 063280            DO      #50,TST_DELAY1
                        0005F8
1074      P:05F3 P:05F3 44F400            MOVE              #25000,X0
                        0061A8
1075      P:05F5 P:05F5 06C400            DO      X0,TST_DELAY0
                        0005F7
1076      P:05F7 P:05F7 000000            NOP
1077      P:05F8 P:05F8 000000  TST_DELAY0 NOP
1078      P:05F9 P:05F9 000000  TST_DELAY1 NOP
1079   
1080      P:05FA P:05FA 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        000636
1081      P:05FC P:05FC 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
1082      P:05FD P:05FD 0D05A0            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
1083                            ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
1084      P:05FE P:05FE 58BA00            MOVE                          Y:<IFRAMES,A0
1085      P:05FF P:05FF 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
1086      P:0600 P:0600 0D0670  SN_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
1087      P:0601 P:0601 0A00A8            JSET    #TRIGGER,X:STATUS,SNX_END         ; If no triggering jump to expose image function
                        000606
1088      P:0603 P:0603 67F400            MOVE              #SNX_END,R7             ; Store the Address into R7
                        000606
1089      P:0605 P:0605 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
1090      P:0606 P:0606 0D0596  SNX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
1091      P:0607 P:0607 0D0677            JSR     <C_CSHUT                          ; Close shutter if open-close bit is set
1092      P:0608 P:0608 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD
1093      P:0609 P:0609 0D05A0            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
1094      P:060A P:060A 200013            CLR     A
1095      P:060B P:060B 58BE00            MOVE                          Y:<IFLPCNT,A0
1096      P:060C P:060C 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
1097      P:060D P:060D 583E00            MOVE                          A0,Y:<IFLPCNT
1098      P:060E P:060E 200003            TST     A
1099      P:060F P:060F 0E2600            JNE     SN_LP                             ; End of IFRAMES loop
1100      P:0610 P:0610 0A30A1            JSET    #FIND,X:IMAGE_MODE,*+3
                        000613
1101      P:0612 P:0612 0D0679            JSR     <CSHUT                            ; Close the shutter unless in find mode
1102      P:0613 P:0613 0AF080            JMP     CLEANUP                           ; clean up after command.
                        000643
1103   
1104                            SDOT_PROC                                           ; Used by slow dots and strips
1105      P:0615 P:0615 5EB800            MOVE                          Y:<SROWS,A
1106      P:0616 P:0616 5E1F00            MOVE                          A,Y:<NP_READ ; Make sure that NP_READ=SROWS
1107      P:0617 P:0617 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for strips
1108      P:0618 P:0618 0A3082            JCLR    #SDOTS,X:IMAGE_MODE,*+3           ; But if sdots mode,
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 25



                        00061B
1109      P:061A P:061A 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
1110      P:061B P:061B 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for SDOTS and st
rips
1111      P:061C P:061C 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
1112      P:061D P:061D 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        000636
1113      P:061F P:061F 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
1114      P:0620 P:0620 0D05A0            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
1115                            ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
1116      P:0621 P:0621 58BA00            MOVE                          Y:<IFRAMES,A0
1117      P:0622 P:0622 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
1118      P:0623 P:0623 0D0670  SD_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
1119      P:0624 P:0624 0A00A8            JSET    #TRIGGER,X:STATUS,SDX_END         ; If no triggering jump to expose image function
                        000629
1120      P:0626 P:0626 67F400            MOVE              #SDX_END,R7             ; Store the Address into R7
                        000629
1121      P:0628 P:0628 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
1122      P:0629 P:0629 0D0596  SDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
1123      P:062A P:062A 0D0677            JSR     <C_CSHUT                          ; Close shutter if open-close is set
1124      P:062B P:062B 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD.
1125                                                                                ; No FT or parallel skip since STORAGE=1
1126      P:062C P:062C 0D05A0            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
1127      P:062D P:062D 200013            CLR     A
1128      P:062E P:062E 58BE00            MOVE                          Y:<IFLPCNT,A0
1129      P:062F P:062F 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
1130      P:0630 P:0630 583E00            MOVE                          A0,Y:<IFLPCNT
1131      P:0631 P:0631 200003            TST     A
1132      P:0632 P:0632 0E2623            JNE     SD_LP                             ; End of IFRAMES loop
1133      P:0633 P:0633 0D0679            JSR     <CSHUT                            ; Unconditionally close shutter
1134      P:0634 P:0634 0AF080            JMP     CLEANUP                           ; clean up after command.
                        000643
1135   
1136                            ; Support subroutines and code fragments used in the various mode code
1137                            ; IMG_INI, CLEANUP, ISHIFT, SSHIFT, RSHIFT
1138                            ;  Image initialization subroutine.  Sets up status bits & PCI card
1139   
1140      P:0636 P:0636 09F480  IMG_INI   MOVEP             #$020102,Y:WRFO         ; Transmit header word
                        020102
1141      P:0638 P:0638 060FA0            REP     #15                               ; Delay for transmission
1142      P:0639 P:0639 000000            NOP
1143      P:063A P:063A 09F480            MOVEP             #'IIA',Y:WRFO           ; Initialize Image Address
                        494941
1144      P:063C P:063C 060FA0            REP     #15
1145      P:063D P:063D 000000            NOP
1146      P:063E P:063E 0A0024            BSET    #ST_RDC,X:<STATUS                 ; Set status to reading out
1147      P:063F P:063F 0D07E5            JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
1148      P:0640 P:0640 0AA421            BSET    #WW,X:PBD                         ; Set WW = 1 for 16-bit image data
1149      P:0641 P:0641 000000            NOP
1150      P:0642 P:0642 00000C            RTS
1151   
1152                            ; Cleanup code fragment (not a subroutine) for the end all modes.  JMP to it.
1153   
1154      P:0643 P:0643 0AA401  CLEANUP   BCLR    #WW,X:PBD                         ; Clear WW to 0 for 32-bit commands
1155      P:0644 P:0644 0A0004            BCLR    #ST_RDC,X:<STATUS                 ; Clear status to NOT reading out
1156                            ; Restore the controller to non-image data transfer and idling if necessary
1157      P:0645 P:0645 0A0082            JCLR    #IDLMODE,X:<STATUS,START          ; Don't idle after readout
                        000008
1158      P:0647 P:0647 44F400            MOVE              #IDLE,X0
                        00020F
1159      P:0649 P:0649 440000            MOVE              X0,X:<IDL_ADR
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timmisc.s  Page 26



1160      P:064A P:064A 0C0008            JMP     <START                            ; Wait for a new command
1161   
1162                            ; Shift image and storage areas down by the number of rows in X1
1163                            ISHIFT
1164      P:064B P:064B 06C500            DO      X1,ISH_LOOP                       ; Number of rows to shift is in X1
                        00064F
1165      P:064D P:064D 689100            MOVE                          Y:<IS_PAR_CLR,R0 ; Ganged clocks with DG running
1166      P:064E P:064E 0D01EC            JSR     <CLOCK                            ; Parallel clocking
1167      P:064F P:064F 000000            NOP
1168                            ISH_LOOP
1169      P:0650 P:0650 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                        0001C6
1170      P:0652 P:0652 0D01EC            JSR     <CLOCK
1171      P:0653 P:0653 00000C            RTS                                       ; End of ISHIFT
1172   
1173                            ; Shift storage area only down by the number of rows in X1
1174                            SSHIFT
1175      P:0654 P:0654 06C500            DO      X1,SSH_LOOP                       ; Number of rows to shift is in X1
                        000658
1176      P:0656 P:0656 689200            MOVE                          Y:<S_PAR_CLR,R0 ; Storage clocks only with DG running
1177      P:0657 P:0657 0D01EC            JSR     <CLOCK                            ; Parallel clocking
1178      P:0658 P:0658 000000            NOP
1179                            SSH_LOOP
1180      P:0659 P:0659 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                        0001C6
1181      P:065B P:065B 0D01EC            JSR     <CLOCK
1182      P:065C P:065C 00000C            RTS                                       ; End of SSHIFT
1183                                      INCLUDE "timCCDmisc.s"                    ; Generic
1184                            ; This file is for utilities that are in common to all the timing board
1185                            ;   programs, located starting at P:$200 in external SRAM
1186   
1187                                    COMMENT *
1188   
1189                            The following commands are supported in this "timmisc.s" file
1190                            PAL_DLY                 Subroutine to delay by about 8 microseconds
1191                            SET_DAC                 Transfer DAC values in (R0) table to the DACs
1192                            FASTSKP                 Compute number of waveform table entries in a readout
1193                                                            for fast clocking
1194                            SYNTHETIC_IMAGE         Generate a synthetic image for system testing
1195                            OSHUT                   Subroutine call for opening the shutter
1196                            CSHUT                   Subroutine call for closing the shutter
1197                            OPEN_SHUTTER            Command for opening the shutter
1198                            CLOSE_SHUTTER           Command for closing the shutter
1199                            SET_EXP_TIME            Write desired exposure time to timing board variable
1200                            RD_EXP_TIME             Read elapsed exposure time
1201                            START_EXPOSURE          Start an exposure - 'DON' reply, clear FPA, open
1202                                                    shutter, expose, close shutter, delay Y:SH_DLY, readout
1203                            PAUSE_EXPOSURE          Close shutter, stop exposure timer
1204                            RESUME_EXPOSURE         Open shutter if necessary, resume exposure timer
1205                            ABORT_EXPOSURE          Close shutter, stop exposure timer
1206                            INF                     Return version and timing information
1207                            IDL                     Put FPA to clocking when not processing commands or
1208                                                    reading out
1209                            STP                     Put FPA to not clocking when not processing commands or
1210                                                    reading out
1211                            READ_CONTROLLER_CONFIGURATION
1212   
1213                            PWR_OFF                 Turn off ananlog power supply voltages to backplane
1214                            PWR_ON                  Turn on analog power supply voltages to backplane
1215                            SETBIAS                 Command to call SET_BIASES and reply 'DON'
1216                            SET_BIASES              Subroutine to turn on all bias and clock voltages
1217                                                    by reading them from the waveform tables and writing
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timCCDmisc.s  Page 27



1218                                                    them to the DACs
1219                            SER_ANA                 Direct the timing board DSP's synchronous serial
1220                                                    transmitter to the analog boards (clock driver, video)
1221                            SER_UTL                 Direct the timing board DSP's synchronous serial
1222                                                    transmitter to the utility board
1223                            CLR_SWS                 Clear the analog switches in the clock driver and
1224                                                    video boards to lower their power consumption, as a
1225                                                    command with a 'DON' reply
1226                            CLEAR_SWITCHES          A subroutine call for CLR_WSW
1227                            ST_GAIN                 Set the video processor gain to one of four values
1228                            WR_CNTRL
1229                            SET_DC
1230                            SET_BIAS_NUMBER
1231                            SET_MUX
1232   
1233                                    *
1234   
1235                            ;  ** Place this file after the custom timmisc.s file so it continues
1236                            ;       to be written in the P:$200 address space  ****
1237   
1238                            ; Hardware control bit definitions
1239      000004                SHUTTER   EQU     4                                 ; Shutter control bit = TIM-LATCH0, A30
1240   
1241   
1242                            ; Delay for serial writes to the PALs and DACs by 8 microsec
1243      P:065D P:065D 06FA80  PAL_DLY   DO      #250,DLY                          ; Wait 8 usec for serial data transmission
                        00065F
1244      P:065F P:065F 000000            NOP
1245      P:0660 P:0660 000000  DLY       NOP
1246      P:0661 P:0661 00000C            RTS
1247   
1248                            ;  Update the DACs
1249      P:0662 P:0662 4CD800  SET_DAC   MOVE                          Y:(R0)+,X0  ; Get the number of table entries
1250      P:0663 P:0663 06C400            DO      X0,SET_L0                         ; Repeat X0 times
                        000667
1251      P:0665 P:0665 08D8EF            MOVEP             Y:(R0)+,X:SSITX         ; Send out the waveform
1252      P:0666 P:0666 0D065D            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
1253      P:0667 P:0667 000000            NOP                                       ; Do loop restriction
1254                            SET_L0
1255      P:0668 P:0668 00000C            RTS                                       ; Return from subroutine
1256   
1257                            ; Subroutine for computing number of fast clocks needed
1258      P:0669 P:0669 2000A8  FASTSKP   MPY     X0,X1,B                           ; X1 = number of pixels to skip,
1259                                                                                ; X0 = number of waveform table entries
1260      P:066A P:066A 20002A            ASR     B                                 ; Correct for multiplication left shift
1261      P:066B P:066B 212E00            MOVE              B0,A                    ; Get only least significant 24 bits
1262      P:066C P:066C 458000            MOVE              X:<ONE,X1
1263      P:066D P:066D 200064            SUB     X1,A                              ; Subtract 1
1264      P:066E P:066E 21C500            MOVE              A,X1                    ; X1 = X0 * X1 - 1
1265      P:066F P:066F 00000C            RTS
1266   
1267                            ; Subroutine with two entry points.  C_OSHUT is conditional on SHUT
1268                            ; Open the shutter conditionally based on the shutter status bit
1269                            ; Open the shutter by setting the backplane bit TIM-LATCH0
1270      P:0670 P:0670 0A008B  C_OSHUT   JCLR    #SHUT,X:STATUS,OSH_RTN
                        000676
1271      P:0672 P:0672 0A0023  OSHUT     BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
1272      P:0673 P:0673 0A0024            BSET    #SHUTTER,X:<LATCH                 ; Set hardware shutter bit to open
1273      P:0674 P:0674 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                        000000
1274      P:0676 P:0676 00000C  OSH_RTN   RTS
1275   
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timCCDmisc.s  Page 28



1276                            ; Subroutine with two entry points.  C_CSHUT is conditional on OPEN_CLOSE
1277                            ; Close the shutter conditionally based on the open-close ISTATUS bit
1278                            ; Close the shutter by clearing the backplane bit TIM-LATCH0
1279      P:0677 P:0677 0A3181  C_CSHUT   JCLR    #OPEN_CLOSE,X:ISTATUS,CSH_RTN     ; Don't close if always open
                        000689
1280      P:0679 P:0679 0A0003  CSHUT     BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
1281      P:067A P:067A 0A0004            BCLR    #SHUTTER,X:<LATCH                 ; Clear hardware shutter bit to close
1282      P:067B P:067B 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                        000000
1283      P:067D P:067D 5E8900            MOVE                          Y:<SH_DEL,A
1284      P:067E P:067E 200003            TST     A
1285      P:067F P:067F 0EF688            JLE     <S_DEL0
1286      P:0680 P:0680 44F400            MOVE              #25000,X0
                        0061A8
1287      P:0682 P:0682 06CE00            DO      A,S_DEL0                          ; Delay by Y:SH_DEL milliseconds
                        000687
1288      P:0684 P:0684 06C400            DO      X0,S_DEL1
                        000686
1289      P:0686 P:0686 000000            NOP
1290      P:0687 P:0687 000000  S_DEL1    NOP
1291      P:0688 P:0688 000000  S_DEL0    NOP
1292      P:0689 P:0689 00000C  CSH_RTN   RTS
1293   
1294                            ; Open the shutter from the timing board, executed as a command
1295                            OPEN_SHUTTER
1296      P:068A P:068A 0D0672            JSR     <OSHUT
1297      P:068B P:068B 0C0000            JMP     <FINISH
1298   
1299                            ; Close the shutter from the timing board, executed as a command
1300                            CLOSE_SHUTTER
1301      P:068C P:068C 0D0679            JSR     <CSHUT
1302      P:068D P:068D 0C0000            JMP     <FINISH
1303   
1304                            ; Set the desired exposure time
1305                            SET_EXP_TIME
1306      P:068E P:068E 44DC00            MOVE              X:(R4)+,X0
1307      P:068F P:068F 440000            MOVE              X0,X:<EXP_TIM           ; Write to magic address
1308      P:0690 P:0690 440000            MOVE              X0,X:<TGT_TIM
1309      P:0691 P:0691 0C0000            JMP     <FINISH
1310   
1311   
1312                            ; Abort exposure - close the shutter, stop the timer and resume idle mode
1313                            ABORT_EXPOSURE
1314      P:0692 P:0692 0A9E00            BCLR    #TIM_BIT,X:TCSR                   ; Disable the DSP exposure timer
1315      P:0693 P:0693 0D0679            JSR     <CSHUT                            ; Close the shutter
1316      P:0694 P:0694 0A0082            JCLR    #IDLMODE,X:<STATUS,FINISH         ; Check whether to idle after readout
                        000000
1317      P:0696 P:0696 44F400            MOVE              #IDLE,X0                ; Idle after readout
                        00020F
1318      P:0698 P:0698 440000            MOVE              X0,X:<IDL_ADR
1319      P:0699 P:0699 0C0000            JMP     <FINISH
1320   
1321                            ;       Process INF according to the single addressing parameter
1322                            GET_INFO
1323      P:069A P:069A 56DC00            MOVE              X:(R4)+,A               ; 0-4 is generic, >= 0x100 tim specific
1324      P:069B P:069B 44F400            MOVE              #IVERSION,X0
                        04407F
1325      P:069D P:069D 46F400            MOVE              #>GET_VERSION,Y0
                        000000
1326      P:069F P:069F 200055            CMP     Y0,A
1327      P:06A0 P:06A0 0EA000            JEQ     <FINISH1
1328      P:06A1 P:06A1 44F400            MOVE              #IFLAVOR,X0
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timCCDmisc.s  Page 29



                        612020
1329      P:06A3 P:06A3 46F400            MOVE              #>GET_FLAVOR,Y0
                        000001
1330      P:06A5 P:06A5 200055            CMP     Y0,A
1331      P:06A6 P:06A6 0EA000            JEQ     <FINISH1
1332      P:06A7 P:06A7 44F400            MOVE              #ITIME0,X0
                        00ED19
1333      P:06A9 P:06A9 46F400            MOVE              #>GET_TIME0,Y0
                        000002
1334      P:06AB P:06AB 200055            CMP     Y0,A
1335      P:06AC P:06AC 0EA000            JEQ     <FINISH1                          ; Is it Time0?
1336      P:06AD P:06AD 44F400            MOVE              #ITIME1,X0
                        004BE8
1337      P:06AF P:06AF 46F400            MOVE              #>GET_TIME1,Y0
                        000003
1338      P:06B1 P:06B1 200055            CMP     Y0,A
1339      P:06B2 P:06B2 0EA000            JEQ     <FINISH1                          ; Is it Time1?
1340      P:06B3 P:06B3 240000            MOVE              #ISVNREV,X0
1341      P:06B4 P:06B4 46F400            MOVE              #>GET_SVNREV,Y0
                        000004
1342      P:06B6 P:06B6 200055            CMP     Y0,A
1343      P:06B7 P:06B7 0EA000            JEQ     <FINISH1                          ; Is it Svn rev?
1344      P:06B8 P:06B8 44F400            MOVE              #TIMCAPABLE,X0
                        0001CB
1345      P:06BA P:06BA 46F400            MOVE              #>GET_CAPABLE,Y0
                        000100
1346      P:06BC P:06BC 200055            CMP     Y0,A
1347      P:06BD P:06BD 0EA000            JEQ     <FINISH1                          ; Is it Tim Capabilities?
1348      P:06BE P:06BE 44F400            MOVE              #INT_TIM,X0
                        1D0000
1349      P:06C0 P:06C0 46F400            MOVE              #>GET_INT_TIM,Y0
                        000101
1350      P:06C2 P:06C2 200055            CMP     Y0,A
1351      P:06C3 P:06C3 0EA000            JEQ     <FINISH1                          ; Is it Integration time?
1352      P:06C4 P:06C4 44F400            MOVE              #R_DELAY,X0
                        000000
1353      P:06C6 P:06C6 46F400            MOVE              #>GET_R_DELAY,Y0
                        000102
1354      P:06C8 P:06C8 200055            CMP     Y0,A
1355      P:06C9 P:06C9 0EA000            JEQ     <FINISH1                          ; Is it Serial time?
1356      P:06CA P:06CA 44F400            MOVE              #SI_DELAY,X0
                        BF0000
1357      P:06CC P:06CC 46F400            MOVE              #>GET_SI_DELAY,Y0
                        000103
1358      P:06CE P:06CE 200055            CMP     Y0,A
1359      P:06CF P:06CF 0EA000            JEQ     <FINISH1                          ; Is it Parallel time?
1360      P:06D0 P:06D0 0C0000            JMP     <ERROR
1361   
1362                            ; Set software to IDLE mode
1363      P:06D1 P:06D1 44F400  IDL       MOVE              #IDLE,X0                ; Exercise clocks when idling
                        00020F
1364      P:06D3 P:06D3 440000            MOVE              X0,X:<IDL_ADR
1365      P:06D4 P:06D4 0A0022            BSET    #IDLMODE,X:<STATUS                ; Idle after readout
1366      P:06D5 P:06D5 0C0000            JMP     <FINISH                           ; Need to send header and 'DON'
1367   
1368                            ; Come to here on a 'STP' command so 'DON' can be sent
1369      P:06D6 P:06D6 44F400  STP       MOVE              #TST_RCV,X0             ; Wait for commands during exposure
                        000000
1370      P:06D8 P:06D8 440000            MOVE              X0,X:<IDL_ADR           ;  instead of exercising clocks
1371      P:06D9 P:06D9 0A0002            BCLR    #IDLMODE,X:<STATUS                ; Don't idle after readout
1372      P:06DA P:06DA 0C0000            JMP     <FINISH
1373   
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timCCDmisc.s  Page 30



1374                            ; Let the host computer read the controller configuration
1375                            READ_CONTROLLER_CONFIGURATION
1376      P:06DB P:06DB 4C8A00            MOVE                          Y:<CONFIG,X0 ; Just transmit the configuration
1377      P:06DC P:06DC 0C0000            JMP     <FINISH1
1378   
1379                            ; Power off
1380      P:06DD P:06DD 0D072C  PWR_OFF   JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1381      P:06DE P:06DE 0AA202            BCLR    #LVEN,X:PBDDR                     ; Set these signals to DSP inputs
1382      P:06DF P:06DF 0AA20D            BCLR    #PWRST,X:PBDDR
1383      P:06E0 P:06E0 0AA203            BCLR    #HVEN,X:PBDDR
1384      P:06E1 P:06E1 0AA422            BSET    #LVEN,X:PBD                       ; LVEN = HVEN = 1 => Power reset
1385      P:06E2 P:06E2 0AA42D            BSET    #PWRST,X:PBD
1386      P:06E3 P:06E3 0AA423            BSET    #HVEN,X:PBD
1387      P:06E4 P:06E4 0C0000            JMP     <FINISH
1388   
1389                            ; Start power-on cycle
1390      P:06E5 P:06E5 0AA222  PWR_ON    BSET    #LVEN,X:PBDDR                     ; Set these signals to DSP outputs
1391      P:06E6 P:06E6 0AA22D            BSET    #PWRST,X:PBDDR
1392      P:06E7 P:06E7 0AA223            BSET    #HVEN,X:PBDDR
1393      P:06E8 P:06E8 0D072C            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1394   
1395                            ; Ramp up the low voltages (+/- 6.5V, 16.5V) and then delay
1396      P:06E9 P:06E9 0AA402            BCLR    #LVEN,X:PBD                       ; LVEN = Low => Turn on +/- 6.5V,
1397      P:06EA P:06EA 0AA40D            BCLR    #PWRST,X:PBD
1398      P:06EB P:06EB 44F400            MOVE              #60000,X0
                        00EA60
1399      P:06ED P:06ED 06C400            DO      X0,WT_PON1                        ; Wait 10 millisec or so for settling
                        0006F2
1400      P:06EF P:06EF 07708E            MOVE              A,P:RSTWDT              ; Reset watchdog timer
                        006000
1401      P:06F1 P:06F1 07708E            MOVE              A,P:RSTWDT
                        006000
1402                            WT_PON1
1403   
1404                            ; Ramp up the high +36 volt power line and then delay
1405      P:06F3 P:06F3 0AA403            BCLR    #HVEN,X:PBD                       ; HVEN = Low => Turn on +36V
1406      P:06F4 P:06F4 44F400            MOVE              #60000,X0
                        00EA60
1407      P:06F6 P:06F6 06C400            DO      X0,WT_PON2                        ; Wait 10 millisec or so for settling
                        0006FB
1408      P:06F8 P:06F8 07708E            MOVE              A,P:RSTWDT              ; Reset watchdog timer
                        006000
1409      P:06FA P:06FA 07708E            MOVE              A,P:RSTWDT
                        006000
1410                            WT_PON2
1411      P:06FC P:06FC 0D0703            JSR     <SET_BIASES                       ; Turn on the DC bias supplies
1412      P:06FD P:06FD 44F400            MOVE              #IDLE,X0
                        00020F
1413      P:06FF P:06FF 440000            MOVE              X0,X:<IDL_ADR
1414      P:0700 P:0700 0C0000            JMP     <FINISH                           ; All done with 'DON'
1415   
1416      P:0701 P:0701 0D0703  SETBIAS   JSR     <SET_BIASES
1417      P:0702 P:0702 0C0000            JMP     <FINISH
1418   
1419                            ; Set all the DC bias voltages and video processor offset values, reading
1420                            ;   them from the table labeled DACS in this file
1421                            SET_BIASES
1422      P:0703 P:0703 0D071C            JSR     <SER_ANA
1423      P:0704 P:0704 0A0020            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
1424      P:0705 P:0705 0A0022            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
1425      P:0706 P:0706 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Disable clear of DAC and enable clocks
                        000000
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timCCDmisc.s  Page 31



1426      P:0708 P:0708 0D065D            JSR     <PAL_DLY                          ; Delay for all this to happen
1427      P:0709 P:0709 0D065D            JSR     <PAL_DLY                          ; Delay for all this to happen
1428   
1429                            ; Disable simultaneous update of clock driver boards
1430      P:070A P:070A 0A0001            BCLR    #1,X:<LATCH
1431      P:070B P:070B 09F081            MOVEP             X:LATCH,Y:WRLATCH
                        000000
1432   
1433                            ; Read DAC values from a table, and set DACs
1434      P:070D P:070D 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                        000100
1435      P:070F P:070F 0D0662            JSR     <SET_DAC
1436   
1437                            ; Set all video processor analog switches to open to disable them (1 => OFF)
1438      P:0710 P:0710 56F400            MOVE              #$000FFF,A
                        000FFF
1439      P:0712 P:0712 566600            MOVE              A,X:(R6)                ; Send out the waveform
1440      P:0713 P:0713 000000            NOP
1441   
1442                            ; Let the DAC voltages all ramp up before exiting
1443      P:0714 P:0714 56F400            MOVE              #400,A                  ; Delay 4 millisec
                        000190
1444      P:0716 P:0716 06CE00            DO      A,L_SBI1
                        000719
1445      P:0718 P:0718 0D065D            JSR     <PAL_DLY                          ; Delay for all this to happen
1446      P:0719 P:0719 000000            NOP
1447                            L_SBI1
1448      P:071A P:071A 0D0723            JSR     <SER_UTL                          ; SSI -> utility board communication
1449      P:071B P:071B 00000C            RTS
1450   
1451                            ; Enable serial communication to the analog boards
1452      P:071C P:071C 0AA420  SER_ANA   BSET    #0,X:PBD                          ; Set H0 for analog boards SSI
1453      P:071D P:071D 08F4A1            MOVEP             #$0000,X:PCC            ; Software reset of SSI
                        000000
1454      P:071F P:071F 0AAD0A            BCLR    #10,X:CRB                         ; SSI -> continuous clock for analog
1455      P:0720 P:0720 08F4A1            MOVEP             #$0160,X:PCC            ; Re-enable the SSI
                        000160
1456      P:0722 P:0722 00000C            RTS
1457   
1458                            ; Enable serial communication to the utility board
1459      P:0723 P:0723 08F4A1  SER_UTL   MOVEP             #$0000,X:PCC            ; Software reset of SSI
                        000000
1460      P:0725 P:0725 0AAD2A            BSET    #10,X:CRB                         ; SSI -> gated clock for util board
1461      P:0726 P:0726 08F4A1            MOVEP             #$0160,X:PCC            ; Enable the SSI
                        000160
1462      P:0728 P:0728 0AA400            BCLR    #0,X:PBD                          ; Clear H0 for utility board SSI
1463      P:0729 P:0729 00000C            RTS
1464   
1465      P:072A P:072A 0D072C  CLR_SWS   JSR     <CLEAR_SWITCHES
1466      P:072B P:072B 0C0000            JMP     <FINISH
1467   
1468                            ; Clear all video processor analog switches to lower their power dissipation
1469                            CLEAR_SWITCHES
1470      P:072C P:072C 0D071C            JSR     <SER_ANA                          ; Set SSI to analog board communication
1471      P:072D P:072D 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                        0C3000
1472      P:072F P:072F 20001B            CLR     B
1473      P:0730 P:0730 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC writes
1474      P:0731 P:0731 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writes
                        001000
1475      P:0733 P:0733 060F80            DO      #15,L_VIDEO                       ; Fifteen video processor boards maximum
                        00073A
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timCCDmisc.s  Page 32



1476      P:0735 P:0735 08CE2F            MOVEP             A,X:SSITX               ; Gain, integrate speed
1477      P:0736 P:0736 200040            ADD     X0,A
1478      P:0737 P:0737 577000            MOVE              B,X:WRSS
                        00FF80
1479      P:0739 P:0739 0D065D            JSR     <PAL_DLY                          ; Delay for the serial data transmission
1480      P:073A P:073A 200068            ADD     X1,B
1481                            L_VIDEO
1482      P:073B P:073B 0A0000            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
1483      P:073C P:073C 0A0002            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
1484      P:073D P:073D 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                        000000
1485      P:073F P:073F 44F400            MOVE              #IDLE,X0
                        00020F
1486      P:0741 P:0741 440000            MOVE              X0,X:<IDL_ADR
1487      P:0742 P:0742 0D0723            JSR     <SER_UTL                          ; Return SSI to utility board
1488      P:0743 P:0743 00000C            RTS
1489   
1490                            ; Set the clock multiplexers
1491      P:0744 P:0744 0D071C  SET_MUX   JSR     <SER_ANA                          ; Set SSI to analog board communication
1492      P:0745 P:0745 56DC00            MOVE              X:(R4)+,A               ; Clock driver board number
1493      P:0746 P:0746 0614A0            REP     #20
1494      P:0747 P:0747 200033            LSL     A
1495      P:0748 P:0748 44F400            MOVE              #$003000,X0
                        003000
1496      P:074A P:074A 200042            OR      X0,A
1497      P:074B P:074B 21C500            MOVE              A,X1                    ; Move here for storage
1498   
1499                            ; Get the first MUX number
1500      P:074C P:074C 56DC00            MOVE              X:(R4)+,A               ; Get the first MUX number
1501      P:074D P:074D 0AF0A9            JLT     ERR_SM1
                        00078F
1502      P:074F P:074F 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                        000018
1503      P:0751 P:0751 200045            CMP     X0,A
1504      P:0752 P:0752 0AF0A1            JGE     ERR_SM1
                        00078F
1505      P:0754 P:0754 21CF00            MOVE              A,B
1506      P:0755 P:0755 44F400            MOVE              #>7,X0
                        000007
1507      P:0757 P:0757 20004E            AND     X0,B
1508      P:0758 P:0758 44F400            MOVE              #>$18,X0
                        000018
1509      P:075A P:075A 200046            AND     X0,A
1510      P:075B P:075B 0E275E            JNE     <SMX_1                            ; Test for 0 <= MUX number <= 7
1511      P:075C P:075C 0ACD63            BSET    #3,B1
1512      P:075D P:075D 0C0769            JMP     <SMX_A
1513      P:075E P:075E 44F400  SMX_1     MOVE              #>$08,X0
                        000008
1514      P:0760 P:0760 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1515      P:0761 P:0761 0E2764            JNE     <SMX_2
1516      P:0762 P:0762 0ACD64            BSET    #4,B1
1517      P:0763 P:0763 0C0769            JMP     <SMX_A
1518      P:0764 P:0764 44F400  SMX_2     MOVE              #>$10,X0
                        000010
1519      P:0766 P:0766 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1520      P:0767 P:0767 0E278F            JNE     <ERR_SM1
1521      P:0768 P:0768 0ACD65            BSET    #5,B1
1522      P:0769 P:0769 20006A  SMX_A     OR      X1,B1                             ; Add prefix to MUX numbers
1523      P:076A P:076A 21A700            MOVE              B1,Y1
1524   
1525                            ; Add on the second MUX number
1526      P:076B P:076B 56DC00            MOVE              X:(R4)+,A               ; Get the next MUX number
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timCCDmisc.s  Page 33



1527      P:076C P:076C 0AF0A9            JLT     ERR_SM2
                        000790
1528      P:076E P:076E 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                        000018
1529      P:0770 P:0770 200045            CMP     X0,A
1530      P:0771 P:0771 0AF0A1            JGE     ERR_SM2
                        000790
1531      P:0773 P:0773 0606A0            REP     #6
1532      P:0774 P:0774 200033            LSL     A
1533      P:0775 P:0775 21CF00            MOVE              A,B
1534      P:0776 P:0776 44F400            MOVE              #$1C0,X0
                        0001C0
1535      P:0778 P:0778 20004E            AND     X0,B
1536      P:0779 P:0779 44F400            MOVE              #>$600,X0
                        000600
1537      P:077B P:077B 200046            AND     X0,A
1538      P:077C P:077C 0E277F            JNE     <SMX_3                            ; Test for 0 <= MUX number <= 7
1539      P:077D P:077D 0ACD69            BSET    #9,B1
1540      P:077E P:077E 0C078A            JMP     <SMX_B
1541      P:077F P:077F 44F400  SMX_3     MOVE              #>$200,X0
                        000200
1542      P:0781 P:0781 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1543      P:0782 P:0782 0E2785            JNE     <SMX_4
1544      P:0783 P:0783 0ACD6A            BSET    #10,B1
1545      P:0784 P:0784 0C078A            JMP     <SMX_B
1546      P:0785 P:0785 44F400  SMX_4     MOVE              #>$400,X0
                        000400
1547      P:0787 P:0787 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1548      P:0788 P:0788 0E2790            JNE     <ERR_SM2
1549      P:0789 P:0789 0ACD6B            BSET    #11,B1
1550      P:078A P:078A 200078  SMX_B     ADD     Y1,B                              ; Add prefix to MUX numbers
1551   
1552      P:078B P:078B 08CD2F            MOVEP             B1,X:SSITX
1553      P:078C P:078C 0D065D            JSR     <PAL_DLY                          ; Delay for all this to happen
1554      P:078D P:078D 0D0723            JSR     <SER_UTL                          ; Return SSI to utility board communication
1555      P:078E P:078E 0C0000            JMP     <FINISH
1556      P:078F P:078F 56DC00  ERR_SM1   MOVE              X:(R4)+,A
1557      P:0790 P:0790 0D0723  ERR_SM2   JSR     <SER_UTL                          ; Return SSI to utility board communication
1558      P:0791 P:0791 0C0000            JMP     <ERROR
1559   
1560   
1561                            ; Set the video processor gain and integrator speed for all video boards
1562                            ;  Command syntax is  SGN  #GAIN  #SPEED, #GAIN = 1, 2, 5 or 10
1563                            ;                                         #SPEED = 0 for slow, 1 for fast
1564      P:0792 P:0792 0D071C  ST_GAIN   JSR     <SER_ANA                          ; Set SSI to analog board communication
1565      P:0793 P:0793 56DC00            MOVE              X:(R4)+,A               ; Gain value (1,2,5 or 10)
1566      P:0794 P:0794 44F400            MOVE              #>1,X0
                        000001
1567      P:0796 P:0796 200045            CMP     X0,A                              ; Check for gain = x1
1568      P:0797 P:0797 0E279B            JNE     <STG2
1569      P:0798 P:0798 57F400            MOVE              #>$77,B
                        000077
1570      P:079A P:079A 0C07AF            JMP     <STG_A
1571      P:079B P:079B 44F400  STG2      MOVE              #>2,X0                  ; Check for gain = x2
                        000002
1572      P:079D P:079D 200045            CMP     X0,A
1573      P:079E P:079E 0E27A2            JNE     <STG5
1574      P:079F P:079F 57F400            MOVE              #>$BB,B
                        0000BB
1575      P:07A1 P:07A1 0C07AF            JMP     <STG_A
1576      P:07A2 P:07A2 44F400  STG5      MOVE              #>5,X0                  ; Check for gain = x5
                        000005
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timCCDmisc.s  Page 34



1577      P:07A4 P:07A4 200045            CMP     X0,A
1578      P:07A5 P:07A5 0E27A9            JNE     <STG10
1579      P:07A6 P:07A6 57F400            MOVE              #>$DD,B
                        0000DD
1580      P:07A8 P:07A8 0C07AF            JMP     <STG_A
1581      P:07A9 P:07A9 44F400  STG10     MOVE              #>10,X0                 ; Check for gain = x10
                        00000A
1582      P:07AB P:07AB 200045            CMP     X0,A
1583      P:07AC P:07AC 0E2000            JNE     <ERROR
1584      P:07AD P:07AD 57F400            MOVE              #>$EE,B
                        0000EE
1585   
1586      P:07AF P:07AF 56DC00  STG_A     MOVE              X:(R4)+,A               ; Integrator Speed (0 for slow, 1 for fast)
1587      P:07B0 P:07B0 0ACC00            JCLR    #0,A1,STG_B
                        0007B4
1588      P:07B2 P:07B2 0ACD68            BSET    #8,B1
1589      P:07B3 P:07B3 0ACD69            BSET    #9,B1
1590      P:07B4 P:07B4 44F400  STG_B     MOVE              #$0C3C00,X0
                        0C3C00
1591      P:07B6 P:07B6 20004A            OR      X0,B
1592      P:07B7 P:07B7 5F0000            MOVE                          B,Y:<GAIN   ; Store the GAIN value for later us
1593   
1594                            ; Send this same value to 15 video processor boards whether they exist or not
1595      P:07B8 P:07B8 241000            MOVE              #$100000,X0             ; Increment value
1596      P:07B9 P:07B9 060F80            DO      #15,STG_LOOP
                        0007BE
1597      P:07BB P:07BB 577000            MOVE              B,X:SSITX               ; Transmit the SSI word
                        00FFEF
1598      P:07BD P:07BD 0D065D            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
1599      P:07BE P:07BE 200048            ADD     X0,B                              ; Increment the video processor board number
1600                            STG_LOOP
1601   
1602      P:07BF P:07BF 0D0723            JSR     <SER_UTL                          ; Return SSI to utility board communication
1603      P:07C0 P:07C0 0C0000            JMP     <FINISH
1604      P:07C1 P:07C1 56DC00  ERR_SGN   MOVE              X:(R4)+,A
1605      P:07C2 P:07C2 0D0723            JSR     <SER_UTL                          ; Return SSI to utility board communication
1606      P:07C3 P:07C3 0C0000            JMP     <ERROR
1607   
1608                            ; Write an arbitraty control word over the SSI link to any register, any board
1609                            ; Command syntax is  WRC number, number is 24-bit number to be sent to any board
1610                            ;WR_CNTRL
1611                            ;       JSR     <SER_ANA        ; Set SSI to analog board communication
1612                            ;       JSR     <PAL_DLY        ; Wait for the number to be sent
1613                            ;        MOVEP  X:(R4)+,X:SSITX ; Send out the waveform
1614                            ;       JSR     <PAL_DLY        ; Wait for SSI and PAL to be empty
1615                            ;       JSR     <SER_UTL        ; Return SSI to utility board communication
1616                            ;       JMP     <FINISH
1617   
1618   
1619   
1620                            ; Specify subarray readout coordinates, one rectangle only
1621                            ; Call this subroutine BEFORE SET_SUBARRAY_POSITIONS since it
1622                            ; initializes NBOXES
1623                            SET_SUBARRAY_SIZES
1624      P:07C4 P:07C4 200013            CLR     A
1625      P:07C5 P:07C5 5E1C00            MOVE                          A,Y:<NBOXES ; Number of subimage boxes = 0 to start
1626      P:07C6 P:07C6 44DC00            MOVE              X:(R4)+,X0
1627      P:07C7 P:07C7 4C1D00            MOVE                          X0,Y:<NR_BIAS ; Number of bias pixels to read
1628      P:07C8 P:07C8 44DC00            MOVE              X:(R4)+,X0
1629      P:07C9 P:07C9 4C1E00            MOVE                          X0,Y:<NS_READ ; Number of columns in subimage read
1630      P:07CA P:07CA 44DC00            MOVE              X:(R4)+,X0
1631      P:07CB P:07CB 4C1F00            MOVE                          X0,Y:<NP_READ ; Number of rows in subimage read
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timCCDmisc.s  Page 35



1632      P:07CC P:07CC 0C0000            JMP     <FINISH
1633   
1634                            ; Call this routine once for every subarray to be added to the table
1635                            ; Note that the way the variables are arranged the subframes all are the
1636                            ; same dimensions.  They also cannot overlap in the row direction.
1637                            ; SET_SUBARRAY_SIZES must be called first to initialize NBOXES
1638                            SET_SUBARRAY_POSITIONS
1639      P:07CD P:07CD 4C9C00            MOVE                          Y:<NBOXES,X0 ; Next available slot
1640      P:07CE P:07CE 458000            MOVE              X:<THREE,X1
1641      P:07CF P:07CF 2000A0            MPY     X0,X1,A
1642      P:07D0 P:07D0 200022            ASR     A
1643      P:07D1 P:07D1 210C00            MOVE              A0,A1
1644      P:07D2 P:07D2 44F400            MOVE              #>21,X0
                        000015
1645      P:07D4 P:07D4 200045            CMP     X0,A
1646      P:07D5 P:07D5 0E7000            JGT     <ERROR                            ; Error if number of boxes > 8
1647      P:07D6 P:07D6 44F400            MOVE              #READ_TABLE,X0
                        000020
1648      P:07D8 P:07D8 200040            ADD     X0,A
1649      P:07D9 P:07D9 219700            MOVE              A1,R7
1650      P:07DA P:07DA 44DC00            MOVE              X:(R4)+,X0
1651      P:07DB P:07DB 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of rows (parallels) to clear
1652      P:07DC P:07DC 44DC00            MOVE              X:(R4)+,X0
1653      P:07DD P:07DD 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears before
1654      P:07DE P:07DE 44DC00            MOVE              X:(R4)+,X0              ;  the box readout
1655      P:07DF P:07DF 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears after
1656      P:07E0 P:07E0 5E9C00            MOVE                          Y:<NBOXES,A ;  the box readout
1657      P:07E1 P:07E1 448000            MOVE              X:<ONE,X0
1658      P:07E2 P:07E2 200040            ADD     X0,A                              ; Update the next available slot position
1659      P:07E3 P:07E3 5E1C00            MOVE                          A,Y:<NBOXES
1660      P:07E4 P:07E4 0C0000            JMP     <FINISH
1661   
1662                            ; Alert the PCI interface board that images are coming soon
1663                            ; This tells the PCI card how many pixels to expect for each SEX command
1664                            ; This is fairly complex.  The first value sent is NSR*IFRAMES (NAXIS1*NAXIS3).
1665                            ; The second value is NPR (NAXIS2), but if NBOXES > 0, it is NPR*NBOXES
1666                            ; The catch is that for a 4K CCD we use a little over 12 bits just in the
1667                            ; basic full frame dimension so we can't use NSR*NPR like we did with HIPO.
1668                            ; I think we really only have 23 bits per number sent to the PCI card, so we
1669                            ; can only go up to a little less than 11 bits (2048) IFRAMES.  There is probably a better way
1670                            ; to factor this out, but we'll do this for now.
1671                            ; modified to use  NAXIS2*NAXIS3 ,  NBOXES*NAXIS1 to fix strips problem,
1672                            ; ed and pc, 11 Sep 2009
1673                            PCI_READ_IMAGE
1674      P:07E5 P:07E5 44F400            MOVE              #$020104,X0             ; Send header word to the FO transmitter
                        020104
1675      P:07E7 P:07E7 0D0800            JSR     <XMT_FO
1676      P:07E8 P:07E8 44F400            MOVE              #'RDA',X0
                        524441
1677      P:07EA P:07EA 0D0800            JSR     <XMT_FO
1678      P:07EB P:07EB 4CF000            MOVE                          Y:NPR,X0    ; NPR = NAXIS2
                        000002
1679      P:07ED P:07ED 4DF000            MOVE                          Y:IFRAMES,X1 ; IFRAMES = NAXIS3
                        00003A
1680      P:07EF P:07EF 2000A8            MPY     X0,X1,B
1681      P:07F0 P:07F0 20002A            ASR     B                                 ; Correct for multiplication left shift
1682      P:07F1 P:07F1 212400            MOVE              B0,X0
1683      P:07F2 P:07F2 0D0800            JSR     <XMT_FO                           ; Send NSR*IFRAMES to PCI card
1684      P:07F3 P:07F3 4CF000            MOVE                          Y:NSR,X0    ; NSR = NAXIS1
                        000001
1685      P:07F5 P:07F5 5E9C00            MOVE                          Y:<NBOXES,A ; If NBOXES = 0, transmit that to PCI
1686      P:07F6 P:07F6 200003            TST     A
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  timCCDmisc.s  Page 36



1687      P:07F7 P:07F7 0AF0AA            JEQ     XMT
                        0007FD
1688      P:07F9 P:07F9 4D9C00            MOVE                          Y:<NBOXES,X1 ; If NBOXES = 0, transmit that to PCI
1689      P:07FA P:07FA 2000A8            MPY     X0,X1,B                           ; If not, multiply by NBOXES, then send
1690      P:07FB P:07FB 20002A            ASR     B                                 ; Correct for multiplication left shift
1691      P:07FC P:07FC 212400            MOVE              B0,X0                   ; Get only least significant 24 bits
1692      P:07FD P:07FD 000000  XMT       NOP
1693      P:07FE P:07FE 0D0800            JSR     <XMT_FO
1694      P:07FF P:07FF 00000C            RTS
1695   
1696      P:0800 P:0800 09C400  XMT_FO    MOVEP             X0,Y:WRFO
1697      P:0801 P:0801 060FA0            REP     #15
1698      P:0802 P:0802 000000            NOP
1699      P:0803 P:0803 00000C            RTS
1700   
1701                            ; Check for program overflow
1702                                      IF      @CVS(N,*)-$200>MISC_LEN
1704                                      ENDIF                                     ;  will not overflow
1705   
1706   
1707                            ;**************************************************************************
1708                            ;                                                                         *
1709                            ;    Permanent address register assignments                               *
1710                            ;        R1 - Address of SSI receiver contents                            *
1711                            ;        R2 - Address of SCI receiver contents                            *
1712                            ;        R3 - Pointer to current top of command buffer                    *
1713                            ;        R4 - Pointer to processed contents of command buffer             *
1714                            ;        R5 - Temporary register for processing SSI and SCI contents      *
1715                            ;        R6 - CCD clock driver address for CCD #0 = $FF80                 *
1716                            ;                It is also the A/D address of analog board #0            *
1717                            ;                                                                         *
1718                            ;    Other registers                                                      *
1719                            ;        R0, R7 - Temporary registers used all over the place.            *
1720                            ;        R5 - Can be used as a temporary register but is circular,        *
1721                            ;               modulo 32.                                                *
1722                            ;**************************************************************************
1723   
1724                            ;  Specify execution and load addresses
1725                                      IF      @SCP("HOST","HOST")
1726      P:0130 P:0130                   ORG     P:APL_ADR,P:APL_ADR               ; Download address
1727                                      ELSE
1729                                      ENDIF
1730   
1731                            ;  ***********************   CCD  READOUT   ***********************
1732                            ; RDCCD is now a subroutine
1733   
1734                            RDCCD
1735      P:0130 P:0130 0A31A2            JSET    #STORAGE,X:ISTATUS,RCCD1
                        000134
1736                            ; Do the frame transfer if STORAGE==0, else skip it.
1737      P:0132 P:0132 4DBB00            MOVE                          Y:<S_SIZE,X1
1738      P:0133 P:0133 0D064B            JSR     ISHIFT                            ; Do the frame transfer; only Basic Occ does thi
s
1739   
1740                            ; Calculate some readout parameters.
1741                            ; This is also an alternative entry point for skipping the frame transfer
1742                            ; STORAGE also selects ganged or storage only parallels during readout
1743                            ; NO_SKIP skips over the section that parallel skips to the subframe start
1744   
1745      P:0134 P:0134 5E9C00  RCCD1     MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1746      P:0135 P:0135 200003            TST     A
1747      P:0136 P:0136 0E2140            JNE     <SUB_IMG
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  tim.s  Page 37



1748      P:0137 P:0137 5C1900            MOVE                          A1,Y:<NP_SKIP ; Zero these all out.  Full frame
1749      P:0138 P:0138 5C1A00            MOVE                          A1,Y:<NS_SKP1
1750      P:0139 P:0139 5C1B00            MOVE                          A1,Y:<NS_SKP2
1751      P:013A P:013A 5E8100            MOVE                          Y:<NSR,A    ; NSERIALS_READ = NSR
1752      P:013B P:013B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                        00013E
1753      P:013D P:013D 200022            ASR     A                                 ; Split serials require / 2
1754      P:013E P:013E 5E1300            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1755      P:013F P:013F 0C014F            JMP     <SETUP
1756   
1757                            ; Loop over the required number of subimage boxes if NBOXES > 0
1758      P:0140 P:0140 67F400  SUB_IMG   MOVE              #READ_TABLE,R7          ; Parameter table for subimage readout
                        000020
1759      P:0142 P:0142 061C40            DO      Y:<NBOXES,L_NBOXES                ; Loop over number of boxes
                        0001E8
1760      P:0144 P:0144 4CDF00            MOVE                          Y:(R7)+,X0
1761      P:0145 P:0145 4C1900            MOVE                          X0,Y:<NP_SKIP
1762      P:0146 P:0146 4CDF00            MOVE                          Y:(R7)+,X0
1763      P:0147 P:0147 4C1A00            MOVE                          X0,Y:<NS_SKP1
1764      P:0148 P:0148 4CDF00            MOVE                          Y:(R7)+,X0
1765      P:0149 P:0149 4C1B00            MOVE                          X0,Y:<NS_SKP2
1766      P:014A P:014A 5E9E00            MOVE                          Y:<NS_READ,A
1767      P:014B P:014B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                        00014E
1768      P:014D P:014D 200022            ASR     A
1769      P:014E P:014E 5E1300            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1770   
1771                            ; Calculate the fast readout parameters
1772      P:014F P:014F 0D0572  SETUP     JSR     <SETUP_SUBROUTINE
1773   
1774                            ; Skip over the required number of rows for subimage readout
1775                            ; If #NO_SKIP == 0 skip rows up to first subframe, storage clocks only
1776      P:0150 P:0150 0A31A0            JSET    #NO_SKIP,X:ISTATUS,CLR_SR
                        00015D
1777      P:0152 P:0152 5E9900            MOVE                          Y:<NP_SKIP,A ; Number of rows NP_SKIP to skip
1778      P:0153 P:0153 200003            TST     A
1779      P:0154 P:0154 0EA15D            JEQ     <CLR_SR                           ; If zero, skip this shift
1780      P:0155 P:0155 061940            DO      Y:<NP_SKIP,L_SKIP1                ; Clock number of rows to skip
                        00015C
1781      P:0157 P:0157 689100            MOVE                          Y:<IS_PAR_CLR,R0 ; SR kept clear with DG
1782      P:0158 P:0158 0A31A2            JSET    #STORAGE,X:ISTATUS,GANG_SK        ; if STORAGE == 0 store clocks only
                        00015B
1783      P:015A P:015A 689200            MOVE                          Y:<S_PAR_CLR,R0 ; SR kept clear with DG
1784      P:015B P:015B 0D01EC  GANG_SK   JSR     <CLOCK
1785      P:015C P:015C 000000            NOP
1786                            L_SKIP1
1787   
1788                            ; Clear out the accumulated charge from the serial shift register
1789                            ; Leave this commented-out code in until we can test it with a subframe
1790                            ; CLR_SR MOVE   #(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-1),M1 ; Modularity
1791                            ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1792                            ;       NOP
1793                            ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1794                            ;       DO      Y:<NSCLR,*+3            ; Number of waveform entries total
1795                            ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1796                            ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1797   
1798      P:015D P:015D 60F400  CLR_SR    MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel skip
                        0001C6
1799      P:015F P:015F 0D01EC            JSR     <CLOCK
1800   
1801                            ; Parallel shift the image into the serial shift register
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  tim.s  Page 38



1802      P:0160 P:0160 4C8200            MOVE                          Y:<NPR,X0   ; Number of rows set by host computer
1803      P:0161 P:0161 5E9C00            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1804      P:0162 P:0162 200003            TST     A
1805      P:0163 P:0163 0EA165            JEQ     *+2
1806      P:0164 P:0164 4C9F00            MOVE                          Y:<NP_READ,X0 ; If NBOXES .NE. 0 use subimage table
1807   
1808                            ; Main loop over each line to be read out
1809                            ; If split parallels have to divide NPR by two to be loop counter
1810                            ; Subimages implicitly assumes that parallels are not split
1811      P:0165 P:0165 0A0086            JCLR    #SPLIT_P,X:STATUS,PLOOP           ; skip this if not split parallels
                        00016B
1812      P:0167 P:0167 5EF000            MOVE                          Y:NPR,A     ; Get NPR
                        000002
1813      P:0169 P:0169 200022            ASR     A                                 ; Divide by 2
1814      P:016A P:016A 21C400            MOVE              A,X0                    ; Overwrite loop counter in X0
1815   
1816                            ; Finally start the row loop
1817      P:016B P:016B 06C400  PLOOP     DO      X0,LPR                            ; Number of rows to read out
                        0001E7
1818   
1819                            ; Check for a command once per line. Only the ABORT command is allowed
1820      P:016D P:016D 0D0000            JSR     <GET_RCV                          ; Was a command received?
1821      P:016E P:016E 0E0178            JCC     <CONT_RD                          ; If no, continue reading out
1822      P:016F P:016F 0C0000            JMP     <CHK_SSI                          ; If yes, go process it
1823   
1824                            ; Abort the readout currently underway
1825      P:0170 P:0170 0A0084  ABR_RDC   JCLR    #ST_RDC,X:<STATUS,ABORT_EXPOSURE
                        000692
1826      P:0172 P:0172 00008C            ENDDO                                     ; Properly terminate row loop
1827      P:0173 P:0173 5E9C00            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1828      P:0174 P:0174 200003            TST     A
1829      P:0175 P:0175 0EA177            JEQ     *+2
1830      P:0176 P:0176 00008C            ENDDO                                     ; Properly terminate box loop
1831      P:0177 P:0177 00000C            RTS                                       ; Return early from subroutine
1832   
1833                            ; Move the row into the serial register.
1834      P:0178 P:0178 060640  CONT_RD   DO      Y:<NPBIN,LPR_I                    ; Transfer # of rows, with binning
                        00017F
1835      P:017A P:017A 688F00            MOVE                          Y:<IS_PAR_CLK,R0
1836      P:017B P:017B 0A31A2            JSET    #STORAGE,X:ISTATUS,GANGED         ; if STORAGE == 1 ganged parallels
                        00017E
1837      P:017D P:017D 689000            MOVE                          Y:<S_PAR_CLK,R0 ; if STORAGE == 0 store clocks; Basic occ. o
nly
1838      P:017E P:017E 0D01EC  GANGED    JSR     <CLOCK                            ; Parallel clocking
1839      P:017F P:017F 000000            NOP
1840                            LPR_I
1841   
1842                            ; Skip over NS_SKP1 columns for subimage readout
1843      P:0180 P:0180 5E9A00            MOVE                          Y:<NS_SKP1,A ; Number of columns to skip
1844      P:0181 P:0181 200003            TST     A
1845      P:0182 P:0182 0EA18B            JEQ     <L_READ
1846      P:0183 P:0183 0506A1            MOVE              #<(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-1),M1 ; Modularity
1847      P:0184 P:0184 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1848      P:0185 P:0185 000000            NOP
1849      P:0186 P:0186 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1850      P:0187 P:0187 061540            DO      Y:<NSKIP1,LS_SKIP1                ; Number of waveform entries total
                        000189
1851      P:0189 P:0189 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1852                            LS_SKIP1
1853      P:018A P:018A 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1854   
1855                            ; Finally read some real pixels - this is the serial binning routine
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  tim.s  Page 39



1856      P:018B P:018B 200013  L_READ    CLR     A
1857      P:018C P:018C 20001B            CLR     B
1858      P:018D P:018D 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1859      P:018E P:018E 50F400            MOVE              #>5,A0                  ; If binning > 4, do general binning
                        000005
1860      P:0190 P:0190 200005            CMP     B,A                               ; else do special waveforms via NO_BIN
1861      P:0191 P:0191 0E71A2            JGT     <NO_BIN                           ; Skip over general serial binning software
1862      P:0192 P:0192 00000B            DEC     B                                 ; serial binning factor minus 1
1863      P:0193 P:0193 212700            MOVE              B0,Y1
1864      P:0194 P:0194 061340            DO      Y:<NSERIALS_READ,LSR_BIN          ; Number of pixels to read out
                        0001A0
1865      P:0196 P:0196 688E00            MOVE                          Y:<INITIAL_CLOCK,R0 ; (already /2 if split serials)
1866      P:0197 P:0197 0D01EC            JSR     <CLOCK
1867                            ;       DO      Y:<NSBIN,LSR_I          ; Bin serially NSBIN times
1868      P:0198 P:0198 06C700            DO      Y1,LSR_I                          ; Bin serially NSBIN times
                        00019C
1869      P:019A P:019A 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1870      P:019B P:019B 0D01EC            JSR     <CLOCK                            ;   shift register
1871      P:019C P:019C 000000            NOP
1872                            LSR_I
1873      P:019D P:019D 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                        000078
1874      P:019F P:019F 0D01EC            JSR     <CLOCK
1875                            ;       MOVE    Y1,Y:<INTERVAL          ; HACK.  Use for debugging
1876      P:01A0 P:01A0 000000            NOP
1877                            LSR_BIN
1878      P:01A1 P:01A1 0C01AC            JMP     <OVER_RD                          ; All done binning
1879   
1880                            ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1881      P:01A2 P:01A2 588C00  NO_BIN    MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1882      P:01A3 P:01A3 00000A            DEC     A                                 ; waveform - 1 into M1
1883      P:01A4 P:01A4 04C8A1            MOVE              A0,M1                   ; Modularity
1884      P:01A5 P:01A5 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1885      P:01A6 P:01A6 000000            NOP
1886      P:01A7 P:01A7 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1887      P:01A8 P:01A8 061640            DO      Y:<NREAD,LSR                      ; Number of waveform entries total
                        0001AA
1888      P:01AA P:01AA FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1889                            LSR
1890      P:01AB P:01AB 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1891   
1892                            ; If NR_BIAS=0 clobber SR with DG and skip to end of row loop
1893      P:01AC P:01AC 5E9D00  OVER_RD   MOVE                          Y:<NR_BIAS,A ; Is NR_BIAS zero?
1894      P:01AD P:01AD 200003            TST     A
1895      P:01AE P:01AE 0E21B4            JNE     <OVR_RD1                          ; no, go to the NS_SKP2 section
1896      P:01AF P:01AF 60F400            MOVE              #DUMP_SERIAL,R0         ; yes, clobber SR with DG
                        0001C6
1897      P:01B1 P:01B1 0D01EC            JSR     <CLOCK
1898      P:01B2 P:01B2 0AF080            JMP     END_ROW                           ; and go to the end of the row loop
                        0001E7
1899                            ; Skip over NS_SKP2 columns for subimage readout to get to overscan region
1900      P:01B4 P:01B4 5E9B00  OVR_RD1   MOVE                          Y:<NS_SKP2,A ; Number of columns to skip
1901      P:01B5 P:01B5 200003            TST     A
1902      P:01B6 P:01B6 0EA1BF            JEQ     <L_BIAS
1903      P:01B7 P:01B7 0506A1            MOVE              #<(END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-1),M1 ; Modularity
1904      P:01B8 P:01B8 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1905      P:01B9 P:01B9 000000            NOP
1906      P:01BA P:01BA 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1907      P:01BB P:01BB 061740            DO      Y:<NSKIP2,LS_SKIP2                ; Number of waveform entries total
                        0001BD
1908      P:01BD P:01BD FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1909                            LS_SKIP2
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  tim.s  Page 40



1910      P:01BE P:01BE 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1911   
1912                            ; And read the bias pixels if in subimage readout mode
1913                            ; I think this means that if NBOXES==0 you have to have NSR include bias px.
1914      P:01BF P:01BF 5E9C00  L_BIAS    MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1915      P:01C0 P:01C0 200003            TST     A
1916      P:01C1 P:01C1 0EA1E7            JEQ     <END_ROW
1917   
1918                            ; Finally read some real bias pixels
1919      P:01C2 P:01C2 200013            CLR     A
1920      P:01C3 P:01C3 20001B            CLR     B
1921      P:01C4 P:01C4 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1922      P:01C5 P:01C5 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                        000006
1923      P:01C7 P:01C7 200005            CMP     B,A                               ; else do special waveforms via NO_BIN_BIAS
1924      P:01C8 P:01C8 0E71DD            JGT     <NO_BIN_BIAS                      ; Skip over general serial binning software
1925      P:01C9 P:01C9 00000B            DEC     B                                 ; serial binning factor minus 1
1926      P:01CA P:01CA 212700            MOVE              B0,Y1
1927      P:01CB P:01CB 5E9D00            MOVE                          Y:<NR_BIAS,A
1928      P:01CC P:01CC 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                        0001CF
1929      P:01CE P:01CE 200022            ASR     A                                 ; Split serials require / 2
1930      P:01CF P:01CF 06CE00            DO      A,LBIAS_BIN                       ; Number of pixels to read out
                        0001DB
1931      P:01D1 P:01D1 688E00            MOVE                          Y:<INITIAL_CLOCK,R0
1932      P:01D2 P:01D2 0D01EC            JSR     <CLOCK
1933      P:01D3 P:01D3 06C700            DO      Y1,LBIAS_I                        ; Bin serially NSBIN times
                        0001D7
1934                            ;       DO      Y:<NSBIN,LBIAS_I        ; Bin serially NSBIN times
1935      P:01D5 P:01D5 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1936      P:01D6 P:01D6 0D01EC            JSR     <CLOCK                            ;   shift register
1937      P:01D7 P:01D7 000000            NOP
1938                            LBIAS_I
1939      P:01D8 P:01D8 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                        000078
1940      P:01DA P:01DA 0D01EC            JSR     <CLOCK
1941      P:01DB P:01DB 000000            NOP
1942                            LBIAS_BIN
1943      P:01DC P:01DC 0C01E7            JMP     <END_ROW                          ; All done binning
1944   
1945                            ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1946                            ; NBIAS is already divided by 2 in SETUP_SUBROUTINE if split serials.
1947                            NO_BIN_BIAS
1948      P:01DD P:01DD 588C00            MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1949      P:01DE P:01DE 00000A            DEC     A                                 ; waveform - 1 into M1
1950      P:01DF P:01DF 04C8A1            MOVE              A0,M1                   ; Modularity
1951      P:01E0 P:01E0 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1952      P:01E1 P:01E1 000000            NOP
1953      P:01E2 P:01E2 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1954      P:01E3 P:01E3 061840            DO      Y:<NBIAS,*+3                      ; Number of waveform entries total
                        0001E5
1955      P:01E5 P:01E5 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1956      P:01E6 P:01E6 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1957      P:01E7 P:01E7 000000  END_ROW   NOP
1958      P:01E8 P:01E8 000000  LPR       NOP                                       ; End of parallel loop
1959      P:01E9 P:01E9 000000  L_NBOXES  NOP                                       ; End of subimage boxes loop
1960      P:01EA P:01EA 000000            NOP
1961      P:01EB P:01EB 00000C            RTS
1962   
1963                            ; ***************** END OF CCD READOUT SUBROUTINE  ************
1964   
1965                            ; Core subroutine for clocking out CCD charge
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  tim.s  Page 41



1966                            ; Must keep in tim.s to insure that it is in fast P memory
1967   
1968      P:01EC P:01EC 4CD800  CLOCK     MOVE                          Y:(R0)+,X0  ; # of waveform entries
1969      P:01ED P:01ED 5ED800            MOVE                          Y:(R0)+,A   ; Start the pipeline
1970      P:01EE P:01EE 06C400            DO      X0,CLK1                           ; Repeat X0 times
                        0001F0
1971      P:01F0 P:01F0 FA0600            MOVE              A,X:(R6)    Y:(R0)+,A   ; Send out the waveform
1972                            CLK1
1973      P:01F1 P:01F1 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1974      P:01F2 P:01F2 00000C            RTS                                       ; Return from subroutine
1975   
1976                            ; Check for program overflow
1977                                      IF      @CVS(N,*)>$200
1979                                      ENDIF                                     ;  will not overflow
1980   
1981                            ; ***********  DATA AREAS - READOUT PARAMETERS AND WAVEFORMS  ************
1982                                      IF      @SCP("HOST","HOST")
1983      X:0030 X:0030                   ORG     X:IMGVAR_ADR,X:IMGVAR_ADR
1984      X:0030 X:0030         IMAGE_MODE DC     0
1985      X:0031 X:0031         ISTATUS   DC      0
1986      X:0032 X:0032         DSP_VERS  DC      VERSION                           ; code version must stay in loc,n 32!!
1987      X:0033 X:0033         DSP_FLAV  DC      FLAVOR                            ;  type of dsp support must stay in loc,n 33!!
1988                            ; The next three locations are for tracking the readout timing for gain
1989                            ; calculation, exp-int calculation, and greed factor calculation
1990                            ; They are locations 0x34, 35, and 36
1991      X:0034 X:0034         INTTIM    DC      INT_TIM                           ; per-pixel integration in Leach units
1992      X:0035 X:0035         RDELAY    DC      R_DELAY                           ; serial overlap in Leach units
1993      X:0036 X:0036         SIDELAY   DC      SI_DELAY                          ; parallel overlap in Leach units
1994      X:0037 X:0037         BINBIT    DC      2                                 ; Bit representation of bin factor, bits 1-5
1995                                                                                ; 2 = bit 1 set. Bit zero not used.
1996                                      ENDIF
1997   
1998                            ; Command table - make sure there are exactly 32 entries in it
1999                                      IF      @SCP("HOST","HOST")
2000      X:0080 X:0080                   ORG     X:COM_TBL,X:COM_TBL               ; Download address
2001                                      ELSE
2003                                      ENDIF
2004      X:0080 X:0080                   DC      'IDL',IDL                         ; Put CCD in IDLE mode
2005      X:0082 X:0082                   DC      'STP',STP                         ; Exit IDLE mode
2006      X:0084 X:0084                   DC      'SBV',SETBIAS                     ; Set DC bias supply voltages
2007      X:0086 X:0086                   DC      'RDC',RDCCD                       ; Begin CCD readout
2008      X:0088 X:0088                   DC      'CLR',CLEAR                       ; Fast clear the CCD
2009      X:008A X:008A                   DC      'SGN',ST_GAIN                     ; Set video processor gain
2010      X:008C X:008C                   DC      'SMX',SET_MUX                     ; Set clock driver MUX output
2011   
2012      X:008E X:008E                   DC      'ABR',ABR_RDC                     ; Abort readout
2013      X:0090 X:0090                   DC      'CRD',CONT_RD                     ; Continue reading out
2014      X:0092 X:0092                   DC      'CSW',CLR_SWS                     ; Clear analog switches to lower power
2015      X:0094 X:0094                   DC      'SOS',SEL_OS                      ; Select output source
2016      X:0096 X:0096                   DC      'RCC',READ_CONTROLLER_CONFIGURATION
2017      X:0098 X:0098                   DC      'SSS',SET_SUBARRAY_SIZES
2018      X:009A X:009A                   DC      'SSP',SET_SUBARRAY_POSITIONS
2019      X:009C X:009C                   DC      'DON',START                       ; Nothing special
2020      X:009E X:009E                   DC      'OSH',OPEN_SHUTTER
2021      X:00A0 X:00A0                   DC      'CSH',CLOSE_SHUTTER
2022      X:00A2 X:00A2                   DC      'PON',PWR_ON                      ; Turn on all camera biases and clocks
2023      X:00A4 X:00A4                   DC      'POF',PWR_OFF                     ; Turn +/- 15V power supplies off
2024      X:00A6 X:00A6                   DC      'SET',SET_EXP_TIME                ; Set exposure time
2025      X:00A8 X:00A8                   DC      'SEX',START_FT_EXPOSURE           ; Goes to mode-dependent jump table
2026      X:00AA X:00AA                   DC      'AEX',ABORT_EXPOSURE
2027      X:00AC X:00AC                   DC      'STG',SET_TRIGGER                 ;  Set Trigger Mode on or off
2028      X:00AE X:00AE                   DC      'SIP',SET_IMAGE_PARAM
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  tim.s  Page 42



2029      X:00B0 X:00B0                   DC      'SRC',SET_ROWS_COLUMNS            ; Set NSR, NPR, and binning
2030      X:00B2 X:00B2                   DC      'INF',GET_INFO                    ; info command for versioning and more
2031      X:00B4 X:00B4                   DC      ,0,START,0,START,0,START,0,START
2032   
2033                                      IF      @SCP("HOST","HOST")
2034      Y:0000 Y:0000                   ORG     Y:0,Y:0                           ; Download address
2035                                      ELSE
2037                                      ENDIF
2038   
2039                            ; NSR, NPR, NSBIN, and NPBIN are set by SET_ROWS_COLUMNS
2040      Y:0000 Y:0000         GAIN      DC      0                                 ; Video processor gain and integrator speed
2041      Y:0001 Y:0001         NSR       DC      1072                              ; Number Serial Read, prescan + image + bias
2042      Y:0002 Y:0002         NPR       DC      1030                              ; Number Parallel Read
2043      Y:0003 Y:0003         NS_CLR    DC      4146                              ; To clear serial register, twice, w/ split seri
als
2044      Y:0004 Y:0004         NPCLR     DC      4112                              ; To clear parallel register, twice, w/ split pa
rallels
2045      Y:0005 Y:0005         NSBIN     DC      1                                 ; Serial binning parameter
2046      Y:0006 Y:0006         NPBIN     DC      1                                 ; Parallel binning parameter
2047      Y:0007 Y:0007         NROWS     DC      4112                              ; Number of physical rows in CCD
2048      Y:0008 Y:0008         NCOLS     DC      4146                              ; Number of physical columns in CCD = 4096+50
2049   
2050                            ; Miscellaneous definitions
2051                            ; Delete TST_DAT since it isn't used.  Need the space so S_SIZE doesn't barf.
2052                            ; TST_DAT       DC      0               ; Temporary definition for test images
2053      Y:0009 Y:0009         SH_DEL    DC      500                               ; Delay in milliseconds between shutter closing
2054                                                                                ;   and image readout.  Actual delay is 1.5x
2055                                                                                ;   as long as advertised, e.g. 4.5 ms for 3.
2056      Y:000A Y:000A         CONFIG    DC      CC                                ; Controller configuration
2057                            ; Readout peculiarity parameters
2058                             SERIAL_SKIP
2059      Y:000B Y:000B                   DC      SERIAL_SKIP_SPLIT                 ; Serial skipping waveforms
2060      Y:000C Y:000C         SERWAVLEN DC      5                                 ; Serial read waveform table length
2061                             SERIAL_CLOCK
2062      Y:000D Y:000D                   DC      SERIAL_CLOCK_SPLIT                ; Serial waveform table
2063                             INITIAL_CLOCK
2064      Y:000E Y:000E                   DC      INITIAL_CLOCK_SPLIT               ; Serial waveform table
2065      Y:000F Y:000F         IS_PAR_CLK DC     ABCD_DOWN                         ; Addr. of ganged parallel clocking
2066      Y:0010 Y:0010         S_PAR_CLK DC      AB_DOWN                           ; Addr. of storage parallel clocking
2067      Y:0011 Y:0011         IS_PAR_CLR DC     ABCD_CLEAR_DOWN                   ; Addr. of ganged parallel clear
2068      Y:0012 Y:0012         S_PAR_CLR DC      AB_CLEAR_DOWN                     ; Addr. of storage parallel clear
2069   
2070                             NSERIALS_READ
2071      Y:0013 Y:0013                   DC      0                                 ; Number of serials to read
2072      Y:0014 Y:0014         NSCLR     DC      0                                 ; Number of waveforms in fast mode
2073      Y:0015 Y:0015         NSKIP1    DC      0                                 ; Number of waveforms in fast mode
2074      Y:0016 Y:0016         NREAD     DC      0                                 ; Number of waveforms in fast mode
2075      Y:0017 Y:0017         NSKIP2    DC      0                                 ; Number of waveforms in fast mode
2076      Y:0018 Y:0018         NBIAS     DC      0                                 ; Number of waveforms in fast mode
2077   
2078                            ; These three parameters are read from the READ_TABLE when needed by the
2079                            ;   RDCCD routine as it loops through the required number of boxes
2080      Y:0019 Y:0019         NP_SKIP   DC      0                                 ; Number of rows to skip
2081      Y:001A Y:001A         NS_SKP1   DC      0                                 ; Number of serials to clear before read
2082      Y:001B Y:001B         NS_SKP2   DC      0                                 ; Number of serials to clear after read
2083   
2084                            ; Subimage readout parameters. Ten subimage boxes maximum.
2085                            ; All subimage boxes are the same size, NS_READ x NP_READ
2086                            ; NR_BIAS, NS_READ, and NP_READ are set by SET_SUBARRAY_SIZES
2087                            ; The READ_TABLE entries and implicitly NBOXES are set by SET_SUBARRAY_POSITIONS
2088      Y:001C Y:001C         NBOXES    DC      0                                 ; Number of boxes to read
2089      Y:001D Y:001D         NR_BIAS   DC      0                                 ; Number of bias pixels to read
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  tim.s  Page 43



2090      Y:001E Y:001E         NS_READ   DC      0                                 ; Number of columns per box
2091      Y:001F Y:001F         NP_READ   DC      0                                 ; Number of rows per box
2092      Y:0020 Y:0020         READ_TABLE DC     0,0,0                             ; #1 = Number of rows to clear,
2093      Y:0023 Y:0023                   DC      0,0,0                             ; #2 = Number of columns to skip before
2094      Y:0026 Y:0026                   DC      0,0,0                             ;   subimage read
2095      Y:0029 Y:0029                   DC      0,0,0                             ; #3 = Number of columns to clear after
2096      Y:002C Y:002C                   DC      0,0,0                             ;   subimage read to get to overscan area
2097      Y:002F Y:002F                   DC      0,0,0
2098      Y:0032 Y:0032                   DC      0,0,0
2099      Y:0035 Y:0035                   DC      0,0,0
2100   
2101                            ; IMAGE_MODE, SROWS, IFRAMES, and INTERVAL are set by SET_IMAGE_PARAM
2102                            ; UBSROWS is set later on by UB_CONV.  S_SIZE is hardwired.
2103      Y:0038 Y:0038         SROWS     DC      1                                 ; Number of Storage image rows to Loop over
2104      Y:0039 Y:0039         UBSROWS   DC      1                                 ; SROWS in unbinned pixels.  Set by UB_CONV
2105      Y:003A Y:003A         IFRAMES   DC      1                                 ; Number of Series frames to Loop over
2106      Y:003B Y:003B         S_SIZE    DC      2056                              ; Number of rows in the Storage Array; A+B or C+
D
2107                                                                                ; NOTE: Not equal to # rows in image area!
2108      Y:003C Y:003C         INTERVAL  DC      7                                 ; Interval to pause for soft trigger
2109      Y:003D Y:003D         AMPVAL    DC      0                                 ; Amplifier selected
2110      Y:003E Y:003E         IFLPCNT   DC      0                                 ; 24-bit IFRAMES loop counter for timmisc.s
2111      Y:003F Y:003F         TESTLOC1  DC      0                                 ; Test location
2112                            ; NOTE:  TESTLOC1 is address 63 in the Y memory.  There are addressing problems
2113                            ; starting at the next address (64).
2114   
2115                            ; Include the waveform table
2116                                      INCLUDE "42cam.waveforms.s"               ; Readout and clocking waveforms
2117                            ; Waveform tables and definitions for the e2v CCD231 4K sq. frame
2118                            ; transfer CCD for the 42" camera.
2119   
2120                            ; CCD clock voltage definitions
2121      000000                VIDEO     EQU     $000000                           ; Video processor board select = 0
2122      002000                CLK2      EQU     $002000                           ; Clock driver board select = 2
2123      003000                CLK3      EQU     $003000                           ; Clock driver board select = 3
2124      000800                CLK_ZERO  EQU     $000800                           ; Zero volts on clock driver line
2125      000800                BIAS_ZERO EQU     $000800                           ; Zero volts on bias line
2126   
2127                            ; For NASA42 uncomment one of these lines at a time
2128                            ;INT_TIM        EQU     $080000 ; 1.0 us/px - use gain 9.5, clips at PRAM
2129                            ;INT_TIM        EQU     $130000 ; 1.4 us/px - use gain 4.75, clips at PRAM
2130      1D0000                INT_TIM   EQU     $1D0000                           ; 1.8 us/px - use gain 2
2131                            ;INT_TIM        EQU     $2D0000 ; 2.5 us/px - use gain 2, doesn't clip
2132                            ;INT_TIM        EQU     $600000 ; 4.7 us/px - use gain 1; Doesn't clip
2133   
2134                            ;ADC_TIM                EQU     $0C0000 ; Slow ADC TIME
2135      000000                ADC_TIM   EQU     $000000                           ; Fast ADC TIME
2136                            ; Delay numbers in clocking
2137      BF0000                SI_DELAY  EQU     $BF0000                           ; 10 microsecond parallel delay time
2138      FC0000                DG_DELAY  EQU     $FC0000                           ; 20 microsecond dump gate delay time
2139      000000                R_DELAY   EQU     $000000                           ; Fast serial regisiter transfer delay.  Set to 
$0x0000.
2140      030000                CDS_TIM   EQU     $030000                           ; Delay for single clock between reset & data
2141   
2142                            ; Clock voltages in volts
2143      3.000000E+000         RG_HI     EQU     +3.0                              ; Reset
2144      -8.000000E+000        RG_LO     EQU     -8.0                              ;
2145      1.000000E+000         R_HI      EQU     +1.0                              ; Serials
2146      -8.000000E+000        R_LO      EQU     -8.0                              ;
2147      1.000000E+000         SW_HI     EQU     +1.0                              ; Summing well, mode 1
2148      -8.000000E+000        SW_LO     EQU     -8.0                              ;
2149                            ; SW_HI EQU     -7.0    ; Summing well, mode 2
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 44



2150                            ; SW_LO EQU     -7.0    ;
2151      1.000000E+000         SI_HI     EQU     +1.0                              ; Parallels
2152      -9.000000E+000        SI_LO     EQU     -9.0                              ;
2153      1.000000E+000         TG_HI     EQU     +1.0                              ; Transfer Gate
2154      -9.000000E+000        TG_LO     EQU     -9.0                              ;
2155      3.000000E+000         DG_HI     EQU     +3.0                              ; Dump Gate
2156      -9.000000E+000        DG_LO     EQU     -9.0                              ;
2157   
2158                            ; DC Bias voltages in volts
2159      2.450000E+001         VOD       EQU     24.5                              ; Output Drain Left.  Best linearity at 24.5/14
2160      1.400000E+001         VRD       EQU     14.0                              ; Reset Drain Left      on OD/RD.  See 20100511 
notes
2161      -7.000000E+000        VOG       EQU     -7.0                              ; Output Gate, mode 1
2162                            ; VOG   EQU     +10.0   ; Output Gate, mode 2
2163      2.000000E+001         VDD       EQU     +20.0                             ; Dump Drain
2164      000700                OFFSET    EQU     $700
2165      000700                OFFSET0   EQU     $700                              ; e2v E, Peter's C, board 0, ch 0
2166      0006EF                OFFSET1   EQU     $6EF                              ; e2v F, Peter's D, board 0, ch 1
2167      000700                OFFSET2   EQU     $700                              ; e2v G, Peter's B, board 1, ch 0
2168      000700                OFFSET3   EQU     $700                              ; e2v H, Peter's A, board 1, ch 1
2169   
2170                            ; Define switch state bits for the lower CCD clock driver bank CLK2
2171                            ; Pins 11-12, clocks 10 & 11, are not used
2172      000001                SEH1      EQU     1                                 ; Serial #1 E & H registers, Pin 1 - clock 0
2173      000002                SEH2      EQU     2                                 ; Serial #2 E & H registers, Pin 2 - clock 1
2174      000004                SEH3      EQU     4                                 ; Serial #3 E & H registers, Pin 3 - clock 2
2175      000008                SFG1      EQU     8                                 ; Serial #1 F & G registers, Pin 4 - clock 3
2176      000010                SFG2      EQU     $10                               ; Serial #2 F & G registers, Pin 5 - clock 4
2177      000020                SFG3      EQU     $20                               ; Serial #3 F & G registers, Pin 6 - clock 5
2178      000040                SWEH      EQU     $40                               ; Summing well E & H registers, Pin 7 - clock 6
2179      000080                SWFG      EQU     $80                               ; Summing well F & G registers, Pin 8 - clock 7
2180      000100                REH       EQU     $100                              ; Reset Gate E & H registers, Pin 9 - clock 8
2181      000200                RFG       EQU     $200                              ; Reset Gate F & G registers, Pin 10 - clock 9
2182   
2183                            ; Define switch state bits for the upper CCD clock driver bank CLK3
2184                            ; All 12 of these are used
2185      000001                AB1       EQU     1                                 ; Parallel A & B, phase #1, Pin 13 - clock 12
2186      000002                AB2       EQU     2                                 ; Parallel A & B, phase #2, Pin 14 - clock 13
2187      000004                AB3       EQU     4                                 ; Parallel A & B, phase #3, Pin 15 - clock 14
2188      000008                AB4       EQU     8                                 ; Parallel A & B, phase #4, Pin 16 - clock 15
2189      000010                CD1       EQU     $10                               ; Parallel C & D, phase #1, Pin 17 - clock 16
2190      000020                CD2       EQU     $20                               ; Parallel C & D, phase #2, Pin 18 - clock 17
2191      000040                CD3       EQU     $40                               ; Parallel C & D, phase #3, Pin 19 - clock 18
2192      000080                CD4       EQU     $80                               ; Parallel C & D, phase #4, Pin 33 - clock 19
2193      000100                TGA       EQU     $100                              ; Transfer Gate A, Pin 34 - clock 20
2194      000200                TGD       EQU     $200                              ; Transfer Gate D, Pin 35 - clock 21
2195      000400                DGA       EQU     $400                              ; Dump Gate A, Pin 36 - clock 22
2196      000800                DGD       EQU     $800                              ; Dump Gate D, Pin 37 - clock 23
2197   
2198                            ;                  EH Side                                            FG Side
2199                            ;       OG  SW  1  2  3  1 .... EH1  EH2  EH3  FG2  FG1  .....  1  3  2  1  SW  OG
2200   
2201                            ; Transfer gate dumps into serial 1 and 2.
2202                            ; Serial 1 & 2 are high between serial clock code lumps.
2203   
2204                            ; Video processor bit definition
2205                            ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2206   
2207                            SERIAL_IDLE                                         ; Split serial during idle
2208      Y:0040 Y:0040                   DC      END_SERIAL_IDLE-SERIAL_IDLE-2
2209      Y:0041 Y:0041                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2210      Y:0042 Y:0042                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 45



2211      Y:0043 Y:0043                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
2212      Y:0044 Y:0044                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2213      Y:0045 Y:0045                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2214      Y:0046 Y:0046                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
2215      Y:0047 Y:0047                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2216      Y:0048 Y:0048                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2217      Y:0049 Y:0049                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2218      Y:004A Y:004A                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
2219      Y:004B Y:004B                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2220      Y:004C Y:004C                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2221      Y:004D Y:004D                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2222                            END_SERIAL_IDLE
2223   
2224                            ; The following waveforms are for binned operation.  This is for mode 1, i.e.
2225                            ; using a summing well.  Mode 2 uses SW as a second OG and binning has to be
2226                            ; done on the output node like in HIPO.
2227   
2228                            INITIAL_CLOCK_SPLIT                                 ; Both amplifiers
2229      Y:004E Y:004E                   DC      END_INITIAL_CLOCK_SPLIT-INITIAL_CLOCK_SPLIT-2
2230      Y:004F Y:004F                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2231      Y:0050 Y:0050                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2232      Y:0051 Y:0051                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
2233      Y:0052 Y:0052                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2234      Y:0053 Y:0053                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2235      Y:0054 Y:0054                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
2236                            END_INITIAL_CLOCK_SPLIT
2237   
2238                            INITIAL_CLOCK_EH                                    ; Shift to E and H amplifiers
2239      Y:0055 Y:0055                   DC      END_INITIAL_CLOCK_EH-INITIAL_CLOCK_EH-2
2240      Y:0056 Y:0056                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2241      Y:0057 Y:0057                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2242      Y:0058 Y:0058                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
2243      Y:0059 Y:0059                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
2244      Y:005A Y:005A                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
2245      Y:005B Y:005B                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
2246                            END_INITIAL_CLOCK_EH
2247   
2248                            INITIAL_CLOCK_FG                                    ; Shift to F and G amplifiers
2249      Y:005C Y:005C                   DC      END_INITIAL_CLOCK_FG-INITIAL_CLOCK_FG-2
2250      Y:005D Y:005D                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2251      Y:005E Y:005E                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2252      Y:005F Y:005F                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
2253      Y:0060 Y:0060                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
2254      Y:0061 Y:0061                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
2255      Y:0062 Y:0062                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
2256                            END_INITIAL_CLOCK_FG
2257   
2258                            SERIAL_CLOCK_SPLIT                                  ; Both amplifiers
2259      Y:0063 Y:0063                   DC      END_SERIAL_CLOCK_SPLIT-SERIAL_CLOCK_SPLIT-2
2260      Y:0064 Y:0064                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
2261      Y:0065 Y:0065                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
2262      Y:0066 Y:0066                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
2263      Y:0067 Y:0067                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2264      Y:0068 Y:0068                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2265      Y:0069 Y:0069                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
2266                            END_SERIAL_CLOCK_SPLIT
2267   
2268                            SERIAL_CLOCK_EH                                     ; Shift to E and H amplifiers
2269      Y:006A Y:006A                   DC      END_SERIAL_CLOCK_EH-SERIAL_CLOCK_EH-2
2270      Y:006B Y:006B                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
2271      Y:006C Y:006C                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
2272      Y:006D Y:006D                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 46



2273      Y:006E Y:006E                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
2274      Y:006F Y:006F                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
2275      Y:0070 Y:0070                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
2276                            END_SERIAL_CLOCK_EH
2277   
2278                            SERIAL_CLOCK_FG                                     ; Shift to F and G amplifiers
2279      Y:0071 Y:0071                   DC      END_SERIAL_CLOCK_FG-SERIAL_CLOCK_FG-2
2280      Y:0072 Y:0072                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
2281      Y:0073 Y:0073                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
2282      Y:0074 Y:0074                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
2283      Y:0075 Y:0075                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
2284      Y:0076 Y:0076                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
2285      Y:0077 Y:0077                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
2286                            END_SERIAL_CLOCK_FG
2287   
2288                            VIDEO_PROCESS
2289      Y:0078 Y:0078                   DC      END_VIDEO_PROCESS-VIDEO_PROCESS-2
2290                            SXMIT_VP
2291      Y:0079 Y:0079                   DC      $00F020                           ; Transmit A/D data to host; overwritten by SOS
2292      Y:007A Y:007A                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2293      Y:007B Y:007B                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2294      Y:007C Y:007C                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2295                            CCLK_1                                              ; The following line is overwritten by timmisc.s
2296      Y:007D Y:007D                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
2297      Y:007E Y:007E                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2298      Y:007F Y:007F                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2299      Y:0080 Y:0080                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2300                            END_VIDEO_PROCESS
2301   
2302                            ; Starting Y: address of circular waveforms for no-overhead access
2303      0000C0                STRT_CIR  EQU     $C0
2304      0007F0                ROM_DISP  EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+STRT_CIR
2305      000830                DAC_DISP  EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+$100
2306   
2307                            ; Check for Y: data memory overflow
2308                                      IF      @CVS(N,*)>STRT_CIR
2310                                      ENDIF                                     ;  will not overflow
2311   
2312                            ; The fast serial code with the circulating address register must start
2313                            ;   on a boundary that is a multiple of the address register modulus.
2314   
2315                                      IF      @SCP("HOST","HOST")
2316      Y:00C0 Y:00C0                   ORG     Y:STRT_CIR,Y:STRT_CIR             ; Download address
2317                                      ELSE
2319                                      ENDIF
2320   
2321                            ; This is an area to copy in the serial fast binned waveforms from high Y memory
2322                            ; It is 0x28 = 40 locations long, enough to put in a binned-by-four waveform
2323                            ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2324                            SERIAL_READ                                         ; Split serial during idle
2325      Y:00C0 Y:00C0                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2326      Y:00C1 Y:00C1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2327      Y:00C2 Y:00C2                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
2328      Y:00C3 Y:00C3                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2329      Y:00C4 Y:00C4                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2330      Y:00C5 Y:00C5                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
2331      Y:00C6 Y:00C6                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
2332      Y:00C7 Y:00C7                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
2333      Y:00C8 Y:00C8                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
2334      Y:00C9 Y:00C9                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2335      Y:00CA Y:00CA                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2336      Y:00CB Y:00CB                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 47



2337      Y:00CC Y:00CC                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
2338      Y:00CD Y:00CD                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
2339      Y:00CE Y:00CE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
2340      Y:00CF Y:00CF                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2341      Y:00D0 Y:00D0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2342      Y:00D1 Y:00D1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
2343      Y:00D2 Y:00D2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
2344      Y:00D3 Y:00D3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
2345      Y:00D4 Y:00D4                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
2346      Y:00D5 Y:00D5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2347      Y:00D6 Y:00D6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2348      Y:00D7 Y:00D7                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
2349                            SXMIT
2350      Y:00D8 Y:00D8                   DC      $00F000                           ; Transmit A/D data to host; overwritten by SOS
2351      Y:00D9 Y:00D9                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2352      Y:00DA Y:00DA                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2353      Y:00DB Y:00DB                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2354      Y:00DC Y:00DC                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
2355      Y:00DD Y:00DD                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2356      Y:00DE Y:00DE                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2357      Y:00DF Y:00DF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2358                            END_SERIAL_READ
2359   
2360   
2361                            ; Serial clocking waveform for skipping
2362                                      IF      @SCP("HOST","HOST")
2363      Y:00E8 Y:00E8                   ORG     Y:STRT_CIR+$28,Y:STRT_CIR+$28     ; Download address
2364                                      ELSE
2366                                      ENDIF
2367   
2368                            ; There are three serial skip waveforms that must all be the same length
2369                            SERIAL_SKIP_EH
2370      Y:00E8 Y:00E8                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2371      Y:00E9 Y:00E9                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
2372      Y:00EA Y:00EA                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+0000
2373      Y:00EB Y:00EB                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+0000
2374      Y:00EC Y:00EC                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+0000
2375      Y:00ED Y:00ED                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
2376      Y:00EE Y:00EE                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2377                            END_SERIAL_SKIP_EH
2378   
2379                                      IF      @SCP("HOST","HOST")
2380      Y:00F0 Y:00F0                   ORG     Y:STRT_CIR+$30,Y:STRT_CIR+$30     ; Download address
2381                                      ELSE
2383                                      ENDIF
2384   
2385                            SERIAL_SKIP_FG
2386      Y:00F0 Y:00F0                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2387      Y:00F1 Y:00F1                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
2388      Y:00F2 Y:00F2                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+0000
2389      Y:00F3 Y:00F3                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+0000
2390      Y:00F4 Y:00F4                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+0000
2391      Y:00F5 Y:00F5                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
2392      Y:00F6 Y:00F6                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2393                            END_SERIAL_SKIP_FG
2394   
2395                                      IF      @SCP("HOST","HOST")
2396      Y:00F8 Y:00F8                   ORG     Y:STRT_CIR+$38,Y:STRT_CIR+$38     ; Download address
2397                                      ELSE
2399                                      ENDIF
2400   
2401                            SERIAL_SKIP_SPLIT
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 48



2402      Y:00F8 Y:00F8                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2403      Y:00F9 Y:00F9                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
2404      Y:00FA Y:00FA                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+SFG1+0000+SFG3+0000
2405      Y:00FB Y:00FB                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+0000
2406      Y:00FC Y:00FC                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+0000+SFG2+SFG3+0000
2407      Y:00FD Y:00FD                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
2408      Y:00FE Y:00FE                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2409                            END_SERIAL_SKIP_SPLIT
2410   
2411                            ; Put all the following code in SRAM.
2412                                      IF      @SCP("HOST","HOST")
2413      Y:0100 Y:0100                   ORG     Y:$100,Y:$100                     ; Download address
2414                                      ELSE
2416                                      ENDIF
2417   
2418                            ; Initialization of clock driver and video processor DACs and switches
2419      Y:0100 Y:0100         DACS      DC      END_DACS-DACS-1
2420      Y:0101 Y:0101                   DC      (CLK2<<8)+(0<<14)+@CVI((R_HI+10.0)/20.0*4095) ; Serial EH1 High, pin 1
2421      Y:0102 Y:0102                   DC      (CLK2<<8)+(1<<14)+@CVI((R_LO+10.0)/20.0*4095) ; Serial EH1 Low
2422      Y:0103 Y:0103                   DC      (CLK2<<8)+(2<<14)+@CVI((R_HI+10.0)/20.0*4095) ; Serial EH2 High, pin 2
2423      Y:0104 Y:0104                   DC      (CLK2<<8)+(3<<14)+@CVI((R_LO+10.0)/20.0*4095) ; Serial EH2 Low
2424      Y:0105 Y:0105                   DC      (CLK2<<8)+(4<<14)+@CVI((R_HI+10.0)/20.0*4095) ; Serial EH3 High, pin 3
2425      Y:0106 Y:0106                   DC      (CLK2<<8)+(5<<14)+@CVI((R_LO+10.0)/20.0*4095) ; Serial EH3 Low
2426   
2427      Y:0107 Y:0107                   DC      (CLK2<<8)+(6<<14)+@CVI((R_HI+10.0)/20.0*4095) ; Serial FG1 High, pin 4
2428      Y:0108 Y:0108                   DC      (CLK2<<8)+(7<<14)+@CVI((R_LO+10.0)/20.0*4095) ; Serial FG1 Low
2429      Y:0109 Y:0109                   DC      (CLK2<<8)+(8<<14)+@CVI((R_HI+10.0)/20.0*4095) ; Serial FG2 High, pin 5
2430      Y:010A Y:010A                   DC      (CLK2<<8)+(9<<14)+@CVI((R_LO+10.0)/20.0*4095) ; Serial FG2 Low
2431      Y:010B Y:010B                   DC      (CLK2<<8)+(10<<14)+@CVI((R_HI+10.0)/20.0*4095) ; Serial FG3 High, pin 6
2432      Y:010C Y:010C                   DC      (CLK2<<8)+(11<<14)+@CVI((R_LO+10.0)/20.0*4095) ; Serial FG3 Low
2433   
2434      Y:010D Y:010D                   DC      (CLK2<<8)+(12<<14)+@CVI((SW_HI+10.0)/20.0*4095) ; Summing well EH High, pin 7
2435      Y:010E Y:010E                   DC      (CLK2<<8)+(13<<14)+@CVI((SW_LO+10.0)/20.0*4095) ; Summing well EH Low
2436      Y:010F Y:010F                   DC      (CLK2<<8)+(14<<14)+@CVI((SW_HI+10.0)/20.0*4095) ; Summing well FG High, pin 8
2437      Y:0110 Y:0110                   DC      (CLK2<<8)+(15<<14)+@CVI((SW_LO+10.0)/20.0*4095) ; Summing well FG Low
2438   
2439      Y:0111 Y:0111                   DC      (CLK2<<8)+(16<<14)+@CVI((RG_HI+10.0)/20.0*4095) ; Reset gate EH High, pin 9
2440      Y:0112 Y:0112                   DC      (CLK2<<8)+(17<<14)+@CVI((RG_LO+10.0)/20.0*4095) ; Reset gate EH Low
2441      Y:0113 Y:0113                   DC      (CLK2<<8)+(18<<14)+@CVI((RG_HI+10.0)/20.0*4095) ; Reset gate FG High, pin 10
2442      Y:0114 Y:0114                   DC      (CLK2<<8)+(19<<14)+@CVI((RG_LO+10.0)/20.0*4095) ; Reset gate FG Low
2443   
2444      Y:0115 Y:0115                   DC      (CLK2<<8)+(20<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 11
2445      Y:0116 Y:0116                   DC      (CLK2<<8)+(21<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2446      Y:0117 Y:0117                   DC      (CLK2<<8)+(22<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 12
2447      Y:0118 Y:0118                   DC      (CLK2<<8)+(23<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2448   
2449      Y:0119 Y:0119                   DC      (CLK2<<8)+(24<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; Parallel AB1 High, pin 13
2450      Y:011A Y:011A                   DC      (CLK2<<8)+(25<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; Parallel AB1 Low
2451      Y:011B Y:011B                   DC      (CLK2<<8)+(26<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; Parallel AB2 High, pin 14
2452      Y:011C Y:011C                   DC      (CLK2<<8)+(27<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; Parallel AB2 Low
2453      Y:011D Y:011D                   DC      (CLK2<<8)+(28<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; Parallel AB3 High, pin 15
2454      Y:011E Y:011E                   DC      (CLK2<<8)+(29<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; Parallel AB3 Low
2455      Y:011F Y:011F                   DC      (CLK2<<8)+(30<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; Parallel AB4 High, pin 16
2456      Y:0120 Y:0120                   DC      (CLK2<<8)+(31<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; Parallel AB4 Low
2457   
2458      Y:0121 Y:0121                   DC      (CLK2<<8)+(32<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; Parallel CD1 High, pin 17
2459      Y:0122 Y:0122                   DC      (CLK2<<8)+(33<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; Parallel CD1 Low
2460      Y:0123 Y:0123                   DC      (CLK2<<8)+(34<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; Parallel CD2 High, pin 18
2461      Y:0124 Y:0124                   DC      (CLK2<<8)+(35<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; Parallel CD2 Low
2462      Y:0125 Y:0125                   DC      (CLK2<<8)+(36<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; Parallel CD3 High, pin 19
2463      Y:0126 Y:0126                   DC      (CLK2<<8)+(37<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; Parallel CD3 Low
2464      Y:0127 Y:0127                   DC      (CLK2<<8)+(38<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; Parallel CD4 High, pin 33
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 49



2465      Y:0128 Y:0128                   DC      (CLK2<<8)+(39<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; Parallel CD4 Low
2466   
2467      Y:0129 Y:0129                   DC      (CLK2<<8)+(40<<14)+@CVI((TG_HI+10.0)/20.0*4095) ; Transfer gate A High, pin 34
2468      Y:012A Y:012A                   DC      (CLK2<<8)+(41<<14)+@CVI((TG_LO+10.0)/20.0*4095) ; Transfer gate A Low
2469      Y:012B Y:012B                   DC      (CLK2<<8)+(42<<14)+@CVI((TG_HI+10.0)/20.0*4095) ; Transfer gate D High, pin 35
2470      Y:012C Y:012C                   DC      (CLK2<<8)+(43<<14)+@CVI((TG_LO+10.0)/20.0*4095) ; Transfer gate D Low
2471   
2472      Y:012D Y:012D                   DC      (CLK2<<8)+(44<<14)+@CVI((DG_HI+10.0)/20.0*4095) ; Dump gate A High, pin 36
2473      Y:012E Y:012E                   DC      (CLK2<<8)+(45<<14)+@CVI((DG_LO+10.0)/20.0*4095) ; Dump gate A Low
2474      Y:012F Y:012F                   DC      (CLK2<<8)+(46<<14)+@CVI((DG_HI+10.0)/20.0*4095) ; Dump gate D High, pin 37
2475      Y:0130 Y:0130                   DC      (CLK2<<8)+(47<<14)+@CVI((DG_LO+10.0)/20.0*4095) ; Dump gate D Low
2476   
2477                            ; Set gain and integrator speed.  Uncomment the line pair you want
2478                            ;       DC      $0c3f77                 ; Gain x1, fast integ speed, board #0
2479                            ;       DC      $1c3f77                 ; Gain x1, fast integ speed, board #1
2480      Y:0131 Y:0131                   DC      $0c3fbb                           ; Gain x2, fast integ speed, board #0
2481      Y:0132 Y:0132                   DC      $1c3fbb                           ; Gain x2, fast integ speed, board #1
2482                            ;       DC      $0c3fdd                 ; Gain x4.75, fast integ speed, board #0
2483                            ;       DC      $1c3fdd                 ; Gain x4.75, fast integ speed, board #1
2484                            ;       DC      $0c3fee                 ; Gain x9.50, fast integ speed, board #0
2485                            ;       DC      $1c3fee                 ; Gain x9.50, fast integ speed, board #1
2486   
2487                            ;       DC      $0c3cee                 ; Gain x9.50, slow integ speed, board #0.  For reference onl
y
2488                            ;       DC      $1c3cee                 ; Gain x9.50, slow integ speed, board #1.  We don't use slow
 integ.
2489   
2490                            ; Input offset voltages for DC coupling. Target is U4#6 = 24 volts.  We don't use these.
2491      Y:0133 Y:0133                   DC      $0c0800                           ; Input offset, ch. 0, board 0
2492      Y:0134 Y:0134                   DC      $0c8800                           ; Input offset, ch. 1, board 0
2493      Y:0135 Y:0135                   DC      $1c0800                           ; Input offset, ch. 0, board 1
2494      Y:0136 Y:0136                   DC      $1c8800                           ; Input offset, ch. 1, board 1
2495   
2496                            ; Output offset voltages
2497      Y:0137 Y:0137                   DC      $0c4000+OFFSET0                   ; Output video offset, ch. 0, board 0, e2v E, Pe
ter's C
2498      Y:0138 Y:0138                   DC      $0cc000+OFFSET1                   ; Output video offset, ch. 1, board 0, e2v F, Pe
ter's D
2499      Y:0139 Y:0139                   DC      $1c4000+OFFSET2                   ; Output video offset, ch. 0, board 1, e2v G, Pe
ter's B
2500      Y:013A Y:013A                   DC      $1cc000+OFFSET3                   ; Output video offset, ch. 1, board 1, e2v H, Pe
ter's A
2501   
2502                            ; Output and reset drain DC bias voltages
2503      Y:013B Y:013B                   DC      $0d0000+@CVI((VOD-7.50)/22.5*4095) ; VOD E pin #1, Board 0
2504      Y:013C Y:013C                   DC      $0d4000+@CVI((VOD-7.50)/22.5*4095) ; VOD F pin #2
2505      Y:013D Y:013D                   DC      $0d8000+@CVI((VRD-5.00)/15.0*4095) ; VRD E pin #3
2506      Y:013E Y:013E                   DC      $0dc000+@CVI((VRD-5.00)/15.0*4095) ; VRD F pin #4
2507      Y:013F Y:013F                   DC      $1d0000+@CVI((VOD-7.50)/22.5*4095) ; VOD G pin #1, Board 1
2508      Y:0140 Y:0140                   DC      $1d4000+@CVI((VOD-7.50)/22.5*4095) ; VOD H pin #2
2509      Y:0141 Y:0141                   DC      $1d8000+@CVI((VRD-5.00)/15.0*4095) ; VRD G pin #3
2510      Y:0142 Y:0142                   DC      $1dc000+@CVI((VRD-5.00)/15.0*4095) ; VRD H pin #4
2511   
2512                            ; Dump gates and output gates
2513      Y:0143 Y:0143                   DC      $0e0000+@CVI((VDD-5.00)/15.0*4095) ; Dump drain A, pin #5, Board 0
2514      Y:0144 Y:0144                   DC      $0e4000+BIAS_ZERO                 ; Unused pin #6
2515      Y:0145 Y:0145                   DC      $0e8000+BIAS_ZERO                 ; Unused pin #7
2516      Y:0146 Y:0146                   DC      $0ec000+BIAS_ZERO                 ; Unused pin #8
2517      Y:0147 Y:0147                   DC      $0f0000+BIAS_ZERO                 ; Unused pin #9
2518      Y:0148 Y:0148                   DC      $0f4000+BIAS_ZERO                 ; Unused pin #10
2519      Y:0149 Y:0149                   DC      $0f8000+@CVI((VOG+10.0)/20.0*4095) ; Output Gate E pin #11
2520      Y:014A Y:014A                   DC      $0fc000+@CVI((VOG+10.0)/20.0*4095) ; Output Gate F pin #12
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 50



2521   
2522      Y:014B Y:014B                   DC      $1e0000+@CVI((VDD-5.00)/15.0*4095) ; Dump drain D, pin #5, Board 1
2523      Y:014C Y:014C                   DC      $1e4000+BIAS_ZERO                 ; Unused pin #6
2524      Y:014D Y:014D                   DC      $1e8000+BIAS_ZERO                 ; Unused pin #7
2525      Y:014E Y:014E                   DC      $1ec000+BIAS_ZERO                 ; Unused pin #8
2526      Y:014F Y:014F                   DC      $1f0000+BIAS_ZERO                 ; Unused pin #9
2527      Y:0150 Y:0150                   DC      $1f4000+BIAS_ZERO                 ; Unused pin #10
2528      Y:0151 Y:0151                   DC      $1f8000+@CVI((VOG+10.0)/20.0*4095) ; Output Gate G pin #11
2529      Y:0152 Y:0152                   DC      $1fc000+@CVI((VOG+10.0)/20.0*4095) ; Output Gate H pin #12
2530                            END_DACS
2531   
2532                            ;  ***  Definitions for Y: memory waveform tables  *****
2533                            ; Put the parallel clock waveforms in slow external Y memory since there isn't
2534                            ; enough room in the fast memory for everything we need.  The parallels are
2535                            ; way slow anyway so the slowness of the access can be tweaked with SI_DELAY.
2536                            ; Clock whole CCD up toward the GH serial register.  Serial phases 1 & 2 high.
2537                            ; CD goes 2-3-4-1, AB goes 3-2-1-4
2538                            ; Parallel phases 2 & 3 high during integration.
2539   
2540                            ; Serial clock convention:    REH SEH1 SEH2 SEH3 SWEH RFG SFG1 SFG2 SFG3 SWFG
2541                            ; Parallel clock convention:  AB1 AB2 AB3 AB4 TGA DGA CD1 CD2 CD3 CD4 TGD DGD
2542   
2543                            ABCD_UP
2544      Y:0153 Y:0153                   DC      END_ABCD_UP-ABCD_UP-2
2545      Y:0154 Y:0154                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2546      Y:0155 Y:0155                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+000
2547      Y:0156 Y:0156                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+000+CD3+CD4+000+000
2548      Y:0157 Y:0157                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+000+000+CD1+000+CD3+CD4+TGD+000
2549      Y:0158 Y:0158                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+000+000+CD1+000+000+CD4+TGD+000
2550      Y:0159 Y:0159                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+000+000+CD1+CD2+000+CD4+TGD+000
2551      Y:015A Y:015A                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+000+000+CD1+CD2+000+000+TGD+000
2552      Y:015B Y:015B                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+000+000+CD1+CD2+CD3+000+TGD+000
2553      Y:015C Y:015C                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
2554                            END_ABCD_UP
2555   
2556                            ; Clock whole CCD down toward the EF serial register.  Serial phases 1 & 2 high.
2557                            ; AB goes 2-3-4-1, CD goes 3-2-1-4
2558                            ; Parallel phases 2 & 3 high during integration.
2559                            ABCD_DOWN
2560      Y:015D Y:015D                   DC      END_ABCD_DOWN-ABCD_DOWN-2
2561      Y:015E Y:015E                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2562      Y:015F Y:015F                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+000+CD1+CD2+CD3+000+000+000
2563      Y:0160 Y:0160                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+000+CD1+CD2+000+000+000+000
2564      Y:0161 Y:0161                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+000+CD1+CD2+000+CD4+000+000
2565      Y:0162 Y:0162                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+000+CD1+000+000+CD4+000+000
2566      Y:0163 Y:0163                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+000+CD1+000+CD3+CD4+000+000
2567      Y:0164 Y:0164                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+000+CD3+CD4+000+000
2568      Y:0165 Y:0165                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+000
2569      Y:0166 Y:0166                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
2570                            END_ABCD_DOWN
2571   
2572                            ; Clock whole CCD split.  Serial phases 1 & 2 high.
2573                            ; ABCD all go 2-3-4-1
2574                            ; Parallel phases 2 & 3 high during integration.
2575                            ABCD_SPLIT
2576      Y:0167 Y:0167                   DC      END_ABCD_SPLIT-ABCD_SPLIT-2
2577      Y:0168 Y:0168                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2578      Y:0169 Y:0169                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+000+000+CD2+CD3+CD4+000+000
2579      Y:016A Y:016A                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+000+000+000+CD3+CD4+000+000
2580      Y:016B Y:016B                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+000+CD1+000+CD3+CD4+TGD+000
2581      Y:016C Y:016C                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+000+CD1+000+000+CD4+TGD+000
2582      Y:016D Y:016D                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+000+CD1+CD2+000+CD4+TGD+000
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 51



2583      Y:016E Y:016E                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+CD1+CD2+000+000+TGD+000
2584      Y:016F Y:016F                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+CD1+CD2+CD3+000+TGD+000
2585      Y:0170 Y:0170                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
2586                            END_ABCD_SPLIT
2587   
2588                            ; Clear whole CCD up toward the GH serial register.  Serial phases 1 & 2 high.
2589                            ; CD goes 2-3-4-1, AB goes 3-2-1-4
2590                            ; Parallel phases 2 & 3 high during integration.
2591                            ABCD_CLEAR_UP
2592      Y:0171 Y:0171                   DC      END_ABCD_CLEAR_UP-ABCD_CLEAR_UP-2
2593      Y:0172 Y:0172                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2594      Y:0173 Y:0173                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+DGD
2595      Y:0174 Y:0174                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+000+CD3+CD4+000+DGD
2596      Y:0175 Y:0175                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+000+000+CD1+000+CD3+CD4+TGD+DGD
2597      Y:0176 Y:0176                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+000+000+CD1+000+000+CD4+TGD+DGD
2598      Y:0177 Y:0177                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+000+000+CD1+CD2+000+CD4+TGD+DGD
2599      Y:0178 Y:0178                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+000+000+CD1+CD2+000+000+TGD+DGD
2600      Y:0179 Y:0179                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+000+000+CD1+CD2+CD3+000+TGD+DGD
2601      Y:017A Y:017A                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+DGD
2602      Y:017B Y:017B                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
2603      Y:017C Y:017C                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
2604      Y:017D Y:017D                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2605                            END_ABCD_CLEAR_UP
2606   
2607                            ; Clear whole CCD down toward the EF serial register.  Serial phases 1 & 2 high.
2608                            ; AB goes 2-3-4-1, CD goes 3-2-1-4
2609                            ; Parallel phases 2 & 3 high during integration.
2610                            ABCD_CLEAR_DOWN
2611      Y:017E Y:017E                   DC      END_ABCD_CLEAR_DOWN-ABCD_CLEAR_DOWN-2
2612      Y:017F Y:017F                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2613      Y:0180 Y:0180                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+DGA+CD1+CD2+CD3+000+000+000
2614      Y:0181 Y:0181                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+DGA+CD1+CD2+000+000+000+000
2615      Y:0182 Y:0182                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+DGA+CD1+CD2+000+CD4+000+000
2616      Y:0183 Y:0183                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+DGA+CD1+000+000+CD4+000+000
2617      Y:0184 Y:0184                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+DGA+CD1+000+CD3+CD4+000+000
2618      Y:0185 Y:0185                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+DGA+000+000+CD3+CD4+000+000
2619      Y:0186 Y:0186                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+DGA+000+CD2+CD3+CD4+000+000
2620      Y:0187 Y:0187                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+000
2621      Y:0188 Y:0188                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
2622      Y:0189 Y:0189                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
2623      Y:018A Y:018A                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2624                            END_ABCD_CLEAR_DOWN
2625   
2626                            ; Clear whole CCD split.  Serial phases 1 & 2 high.
2627                            ; ABCD all go 2-3-4-1
2628                            ; Parallel phases 2 & 3 high during integration.
2629                            ABCD_CLEAR_SPLIT
2630      Y:018B Y:018B                   DC      END_ABCD_CLEAR_SPLIT-ABCD_CLEAR_SPLIT-2
2631      Y:018C Y:018C                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2632      Y:018D Y:018D                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+DGA+000+CD2+CD3+CD4+000+DGD
2633      Y:018E Y:018E                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+DGA+000+000+CD3+CD4+000+DGD
2634      Y:018F Y:018F                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+DGA+CD1+000+CD3+CD4+TGD+DGD
2635      Y:0190 Y:0190                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+DGA+CD1+000+000+CD4+TGD+DGD
2636      Y:0191 Y:0191                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+DGA+CD1+CD2+000+CD4+TGD+DGD
2637      Y:0192 Y:0192                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+DGA+CD1+CD2+000+000+TGD+DGD
2638      Y:0193 Y:0193                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+DGA+CD1+CD2+CD3+000+TGD+DGD
2639      Y:0194 Y:0194                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+DGD
2640      Y:0195 Y:0195                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
2641      Y:0196 Y:0196                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
2642      Y:0197 Y:0197                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2643                            END_ABCD_CLEAR_SPLIT
2644   
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 52



2645                            ; Clock CD section up toward the GH serial register; AB static.  Serial phases 1 & 2 high.
2646                            ; CD goes 2-3-4-1
2647                            ; Parallel phases 2 & 3 high during integration.
2648                            CD_UP
2649      Y:0198 Y:0198                   DC      END_CD_UP-CD_UP-2
2650      Y:0199 Y:0199                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2651      Y:019A Y:019A                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+000
2652      Y:019B Y:019B                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+000+CD3+CD4+000+000
2653      Y:019C Y:019C                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+CD3+CD4+TGD+000
2654      Y:019D Y:019D                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+000+CD4+TGD+000
2655      Y:019E Y:019E                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+CD4+TGD+000
2656      Y:019F Y:019F                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+000+TGD+000
2657      Y:01A0 Y:01A0                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+CD3+000+TGD+000
2658      Y:01A1 Y:01A1                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
2659                            END_CD_UP
2660   
2661                            ; Clock AB section down toward the EF serial register; CD static.  Serial phases 1 & 2 high.
2662                            ; AB goes 2-3-4-1
2663                            ; Parallel phases 2 & 3 high during integration.
2664                            AB_DOWN
2665      Y:01A2 Y:01A2                   DC      END_AB_DOWN-AB_DOWN-2
2666      Y:01A3 Y:01A3                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2667      Y:01A4 Y:01A4                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+000+000+CD2+CD3+000+000+000
2668      Y:01A5 Y:01A5                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+000+000+CD2+CD3+000+000+000
2669      Y:01A6 Y:01A6                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+000+000+CD2+CD3+000+000+000
2670      Y:01A7 Y:01A7                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+000+000+CD2+CD3+000+000+000
2671      Y:01A8 Y:01A8                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+000+000+CD2+CD3+000+000+000
2672      Y:01A9 Y:01A9                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+000+000+CD2+CD3+000+000+000
2673      Y:01AA Y:01AA                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
2674      Y:01AB Y:01AB                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
2675                            END_AB_DOWN
2676   
2677                            ; Clear CD section up toward the GH serial register; AB static.  Serial phases 1 & 2 high.
2678                            ; CD goes 2-3-4-1
2679                            ; Parallel phases 2 & 3 high during integration.
2680                            CD_CLEAR_UP
2681      Y:01AC Y:01AC                   DC      END_CD_CLEAR_UP-CD_CLEAR_UP-2
2682      Y:01AD Y:01AD                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2683      Y:01AE Y:01AE                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+CD4+000+DGD
2684      Y:01AF Y:01AF                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+000+CD3+CD4+000+DGD
2685      Y:01B0 Y:01B0                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+CD3+CD4+TGD+DGD
2686      Y:01B1 Y:01B1                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+000+000+CD4+TGD+DGD
2687      Y:01B2 Y:01B2                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+CD4+TGD+DGD
2688      Y:01B3 Y:01B3                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+000+000+TGD+DGD
2689      Y:01B4 Y:01B4                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+CD1+CD2+CD3+000+TGD+DGD
2690      Y:01B5 Y:01B5                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+DGD
2691      Y:01B6 Y:01B6                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
2692      Y:01B7 Y:01B7                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
2693      Y:01B8 Y:01B8                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2694                            END_CD_CLEAR_UP
2695   
2696                            ; Clear AB section down toward the EF serial register; CD static.  Serial phases 1 & 2 high.
2697                            ; AB goes 2-3-4-1
2698                            ; Parallel phases 2 & 3 high during integration.
2699                            AB_CLEAR_DOWN
2700      Y:01B9 Y:01B9                   DC      END_AB_CLEAR_DOWN-AB_CLEAR_DOWN-2
2701      Y:01BA Y:01BA                   DC      CLK2+SI_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2702      Y:01BB Y:01BB                   DC      CLK3+SI_DELAY+000+AB2+AB3+AB4+TGA+DGA+000+CD2+CD3+000+000+000
2703      Y:01BC Y:01BC                   DC      CLK3+SI_DELAY+000+000+AB3+AB4+TGA+DGA+000+CD2+CD3+000+000+000
2704      Y:01BD Y:01BD                   DC      CLK3+SI_DELAY+AB1+000+AB3+AB4+TGA+DGA+000+CD2+CD3+000+000+000
2705      Y:01BE Y:01BE                   DC      CLK3+SI_DELAY+AB1+000+000+AB4+TGA+DGA+000+CD2+CD3+000+000+000
2706      Y:01BF Y:01BF                   DC      CLK3+SI_DELAY+AB1+AB2+000+AB4+TGA+DGA+000+CD2+CD3+000+000+000
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 53



2707      Y:01C0 Y:01C0                   DC      CLK3+SI_DELAY+AB1+AB2+000+000+000+DGA+000+CD2+CD3+000+000+000
2708      Y:01C1 Y:01C1                   DC      CLK3+SI_DELAY+AB1+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+000
2709      Y:01C2 Y:01C2                   DC      CLK3+SI_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+000
2710      Y:01C3 Y:01C3                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
2711      Y:01C4 Y:01C4                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
2712      Y:01C5 Y:01C5                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2713                            END_AB_CLEAR_DOWN
2714   
2715                            ; Dump both the EF and GH serial registers using DGA and DGD
2716                            DUMP_SERIAL
2717      Y:01C6 Y:01C6                   DC      END_DUMP_SERIAL-DUMP_SERIAL-2
2718      Y:01C7 Y:01C7                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2719      Y:01C8 Y:01C8                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+DGA+000+CD2+CD3+000+000+DGD
2720      Y:01C9 Y:01C9                   DC      CLK2+DG_DELAY+REH+0000+0000+0000+0000+RFG+0000+0000+0000+0000
2721      Y:01CA Y:01CA                   DC      CLK3+DG_DELAY+000+AB2+AB3+000+000+000+000+CD2+CD3+000+000+000
2722      Y:01CB Y:01CB                   DC      CLK2+DG_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2723                            END_DUMP_SERIAL
2724   
2725                            ; Parallel waveforms done.  Move on to the layered serial ones.
2726   
2727                            ;       These are the 12 fast serial read waveforms for left, right,
2728                            ;       and split reads for serial binning factors from 1 to 4.
2729   
2730                            ;       Unbinned waveforms
2731                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2732                            SERIAL_READ_EH_1
2733      Y:01CC Y:01CC                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2734      Y:01CD Y:01CD                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2735      Y:01CE Y:01CE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
2736      Y:01CF Y:01CF                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
2737      Y:01D0 Y:01D0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
2738      Y:01D1 Y:01D1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
2739                            SXMIT_EH_1
2740      Y:01D2 Y:01D2                   DC      $00F000                           ; Transmit A/D data to host
2741      Y:01D3 Y:01D3                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2742      Y:01D4 Y:01D4                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2743      Y:01D5 Y:01D5                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2744      Y:01D6 Y:01D6                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
2745      Y:01D7 Y:01D7                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2746      Y:01D8 Y:01D8                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2747      Y:01D9 Y:01D9                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2748                            END_SERIAL_READ_EH_1
2749   
2750                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2751                            SERIAL_READ_FG_1
2752      Y:01DA Y:01DA                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2753      Y:01DB Y:01DB                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2754      Y:01DC Y:01DC                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
2755      Y:01DD Y:01DD                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
2756      Y:01DE Y:01DE                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
2757      Y:01DF Y:01DF                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
2758                            SXMIT_FG_1
2759      Y:01E0 Y:01E0                   DC      $00F021                           ; Transmit A/D data to host
2760      Y:01E1 Y:01E1                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2761      Y:01E2 Y:01E2                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2762      Y:01E3 Y:01E3                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2763      Y:01E4 Y:01E4                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
2764      Y:01E5 Y:01E5                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2765      Y:01E6 Y:01E6                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2766      Y:01E7 Y:01E7                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2767                            END_SERIAL_READ_FG_1
2768   
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 54



2769                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2770                            SERIAL_READ_SPLIT_1
2771      Y:01E8 Y:01E8                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2772      Y:01E9 Y:01E9                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2773      Y:01EA Y:01EA                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
2774      Y:01EB Y:01EB                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2775      Y:01EC Y:01EC                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2776      Y:01ED Y:01ED                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
2777                            SXMIT_SPLIT_1
2778      Y:01EE Y:01EE                   DC      $00F020                           ; Transmit A/D data to host
2779      Y:01EF Y:01EF                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2780      Y:01F0 Y:01F0                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2781      Y:01F1 Y:01F1                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2782      Y:01F2 Y:01F2                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
2783      Y:01F3 Y:01F3                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2784      Y:01F4 Y:01F4                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2785      Y:01F5 Y:01F5                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2786                            END_SERIAL_READ_SPLIT_1
2787   
2788                            ;       Bin by 2 waveforms
2789                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2790                            SERIAL_READ_EH_2
2791      Y:01F6 Y:01F6                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2792      Y:01F7 Y:01F7                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2793      Y:01F8 Y:01F8                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
2794      Y:01F9 Y:01F9                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
2795      Y:01FA Y:01FA                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
2796      Y:01FB Y:01FB                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
2797      Y:01FC Y:01FC                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
2798      Y:01FD Y:01FD                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
2799      Y:01FE Y:01FE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
2800      Y:01FF Y:01FF                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
2801      Y:0200 Y:0200                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
2802      Y:0201 Y:0201                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
2803                            SXMIT_EH_2
2804      Y:0202 Y:0202                   DC      $00F000                           ; Transmit A/D data to host
2805      Y:0203 Y:0203                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2806      Y:0204 Y:0204                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2807      Y:0205 Y:0205                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2808      Y:0206 Y:0206                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
2809      Y:0207 Y:0207                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2810      Y:0208 Y:0208                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2811      Y:0209 Y:0209                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2812                            END_SERIAL_READ_EH_2
2813   
2814                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2815                            SERIAL_READ_FG_2
2816      Y:020A Y:020A                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2817      Y:020B Y:020B                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2818      Y:020C Y:020C                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
2819      Y:020D Y:020D                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
2820      Y:020E Y:020E                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
2821      Y:020F Y:020F                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
2822      Y:0210 Y:0210                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
2823      Y:0211 Y:0211                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
2824      Y:0212 Y:0212                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
2825      Y:0213 Y:0213                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
2826      Y:0214 Y:0214                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
2827      Y:0215 Y:0215                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
2828                            SXMIT_FG_2
2829      Y:0216 Y:0216                   DC      $00F021                           ; Transmit A/D data to host
2830      Y:0217 Y:0217                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 55



2831      Y:0218 Y:0218                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2832      Y:0219 Y:0219                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2833      Y:021A Y:021A                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
2834      Y:021B Y:021B                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2835      Y:021C Y:021C                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2836      Y:021D Y:021D                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2837                            END_SERIAL_READ_FG_2
2838   
2839                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2840                            SERIAL_READ_SPLIT_2
2841      Y:021E Y:021E                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2842      Y:021F Y:021F                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2843      Y:0220 Y:0220                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
2844      Y:0221 Y:0221                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2845      Y:0222 Y:0222                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2846      Y:0223 Y:0223                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
2847      Y:0224 Y:0224                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
2848      Y:0225 Y:0225                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
2849      Y:0226 Y:0226                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
2850      Y:0227 Y:0227                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2851      Y:0228 Y:0228                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2852      Y:0229 Y:0229                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
2853                            SXMIT_SPLIT_2
2854      Y:022A Y:022A                   DC      $00F020                           ; Transmit A/D data to host
2855      Y:022B Y:022B                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2856      Y:022C Y:022C                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2857      Y:022D Y:022D                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2858      Y:022E Y:022E                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
2859      Y:022F Y:022F                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2860      Y:0230 Y:0230                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2861      Y:0231 Y:0231                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2862                            END_SERIAL_READ_SPLIT_2
2863   
2864                            ;       Bin by 3 waveforms
2865                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2866                            SERIAL_READ_EH_3
2867      Y:0232 Y:0232                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2868      Y:0233 Y:0233                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2869      Y:0234 Y:0234                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
2870      Y:0235 Y:0235                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
2871      Y:0236 Y:0236                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
2872      Y:0237 Y:0237                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
2873      Y:0238 Y:0238                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
2874      Y:0239 Y:0239                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
2875      Y:023A Y:023A                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
2876      Y:023B Y:023B                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
2877      Y:023C Y:023C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
2878      Y:023D Y:023D                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
2879      Y:023E Y:023E                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
2880      Y:023F Y:023F                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
2881      Y:0240 Y:0240                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
2882      Y:0241 Y:0241                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
2883      Y:0242 Y:0242                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
2884      Y:0243 Y:0243                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
2885                            SXMIT_EH_3
2886      Y:0244 Y:0244                   DC      $00F000                           ; Transmit A/D data to host
2887      Y:0245 Y:0245                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2888      Y:0246 Y:0246                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2889      Y:0247 Y:0247                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2890      Y:0248 Y:0248                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
2891      Y:0249 Y:0249                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2892      Y:024A Y:024A                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 56



2893      Y:024B Y:024B                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2894                            END_SERIAL_READ_EH_3
2895   
2896                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2897                            SERIAL_READ_FG_3
2898      Y:024C Y:024C                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2899      Y:024D Y:024D                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2900      Y:024E Y:024E                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
2901      Y:024F Y:024F                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
2902      Y:0250 Y:0250                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
2903      Y:0251 Y:0251                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
2904      Y:0252 Y:0252                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
2905      Y:0253 Y:0253                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
2906      Y:0254 Y:0254                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
2907      Y:0255 Y:0255                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
2908      Y:0256 Y:0256                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
2909      Y:0257 Y:0257                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
2910      Y:0258 Y:0258                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
2911      Y:0259 Y:0259                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
2912      Y:025A Y:025A                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
2913      Y:025B Y:025B                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
2914      Y:025C Y:025C                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
2915      Y:025D Y:025D                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
2916                            SXMIT_FG_3
2917      Y:025E Y:025E                   DC      $00F021                           ; Transmit A/D data to host
2918      Y:025F Y:025F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2919      Y:0260 Y:0260                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2920      Y:0261 Y:0261                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2921      Y:0262 Y:0262                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
2922      Y:0263 Y:0263                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2923      Y:0264 Y:0264                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2924      Y:0265 Y:0265                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2925                            END_SERIAL_READ_FG_3
2926   
2927                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2928                            SERIAL_READ_SPLIT_3
2929      Y:0266 Y:0266                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2930      Y:0267 Y:0267                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2931      Y:0268 Y:0268                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
2932      Y:0269 Y:0269                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2933      Y:026A Y:026A                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2934      Y:026B Y:026B                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
2935      Y:026C Y:026C                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
2936      Y:026D Y:026D                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
2937      Y:026E Y:026E                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
2938      Y:026F Y:026F                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2939      Y:0270 Y:0270                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2940      Y:0271 Y:0271                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
2941      Y:0272 Y:0272                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
2942      Y:0273 Y:0273                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
2943      Y:0274 Y:0274                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
2944      Y:0275 Y:0275                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
2945      Y:0276 Y:0276                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
2946      Y:0277 Y:0277                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
2947                            SXMIT_SPLIT_3
2948      Y:0278 Y:0278                   DC      $00F020                           ; Transmit A/D data to host
2949      Y:0279 Y:0279                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2950      Y:027A Y:027A                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2951      Y:027B Y:027B                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2952      Y:027C Y:027C                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
2953      Y:027D Y:027D                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2954      Y:027E Y:027E                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 57



2955      Y:027F Y:027F                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2956                            END_SERIAL_READ_SPLIT_3
2957   
2958                            ;       Bin by 4 waveforms
2959                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2960                            SERIAL_READ_EH_4
2961      Y:0280 Y:0280                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2962      Y:0281 Y:0281                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2963      Y:0282 Y:0282                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
2964      Y:0283 Y:0283                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
2965      Y:0284 Y:0284                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
2966      Y:0285 Y:0285                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
2967      Y:0286 Y:0286                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
2968      Y:0287 Y:0287                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
2969      Y:0288 Y:0288                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
2970      Y:0289 Y:0289                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
2971      Y:028A Y:028A                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
2972      Y:028B Y:028B                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
2973      Y:028C Y:028C                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
2974      Y:028D Y:028D                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
2975      Y:028E Y:028E                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
2976      Y:028F Y:028F                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
2977      Y:0290 Y:0290                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
2978      Y:0291 Y:0291                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
2979      Y:0292 Y:0292                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+SFG1+0000+0000+0000
2980      Y:0293 Y:0293                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+0000
2981      Y:0294 Y:0294                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+0000+SFG2+0000+0000
2982      Y:0295 Y:0295                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+0000+SFG2+SFG3+0000
2983      Y:0296 Y:0296                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+0000
2984      Y:0297 Y:0297                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+SFG1+0000+SFG3+0000
2985                            SXMIT_EH_4
2986      Y:0298 Y:0298                   DC      $00F000                           ; Transmit A/D data to host
2987      Y:0299 Y:0299                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2988      Y:029A Y:029A                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2989      Y:029B Y:029B                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2990      Y:029C Y:029C                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
2991      Y:029D Y:029D                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2992      Y:029E Y:029E                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2993      Y:029F Y:029F                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
2994                            END_SERIAL_READ_EH_4
2995   
2996                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2997                            SERIAL_READ_FG_4
2998      Y:02A0 Y:02A0                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
2999      Y:02A1 Y:02A1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
3000      Y:02A2 Y:02A2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+0000
3001      Y:02A3 Y:02A3                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
3002      Y:02A4 Y:02A4                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
3003      Y:02A5 Y:02A5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
3004      Y:02A6 Y:02A6                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
3005      Y:02A7 Y:02A7                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
3006      Y:02A8 Y:02A8                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
3007      Y:02A9 Y:02A9                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
3008      Y:02AA Y:02AA                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
3009      Y:02AB Y:02AB                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
3010      Y:02AC Y:02AC                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
3011      Y:02AD Y:02AD                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
3012      Y:02AE Y:02AE                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
3013      Y:02AF Y:02AF                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
3014      Y:02B0 Y:02B0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
3015      Y:02B1 Y:02B1                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
3016      Y:02B2 Y:02B2                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+SWFG
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  42cam.waveforms.s  Page 58



3017      Y:02B3 Y:02B3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+SWFG
3018      Y:02B4 Y:02B4                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+0000+000+SFG1+0000+0000+SWFG
3019      Y:02B5 Y:02B5                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+0000+000+SFG1+0000+SFG3+SWFG
3020      Y:02B6 Y:02B6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+0000+000+0000+0000+SFG3+SWFG
3021      Y:02B7 Y:02B7                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+0000+000+0000+SFG2+SFG3+SWFG
3022                            SXMIT_FG_4
3023      Y:02B8 Y:02B8                   DC      $00F021                           ; Transmit A/D data to host
3024      Y:02B9 Y:02B9                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
3025      Y:02BA Y:02BA                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
3026      Y:02BB Y:02BB                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
3027      Y:02BC Y:02BC                   DC      CLK2+CDS_TIM+000+SEH1+0000+0000+0000+000+0000+SFG2+0000+0000
3028      Y:02BD Y:02BD                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
3029      Y:02BE Y:02BE                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
3030      Y:02BF Y:02BF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3031                            END_SERIAL_READ_FG_4
3032   
3033                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3034                            SERIAL_READ_SPLIT_4
3035      Y:02C0 Y:02C0                   DC      CLK2+R_DELAY+REH+SEH1+SEH2+0000+0000+RFG+SFG1+SFG2+0000+0000
3036      Y:02C1 Y:02C1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
3037      Y:02C2 Y:02C2                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+0000+000+SFG1+0000+0000+0000
3038      Y:02C3 Y:02C3                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3039      Y:02C4 Y:02C4                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3040      Y:02C5 Y:02C5                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3041      Y:02C6 Y:02C6                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
3042      Y:02C7 Y:02C7                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
3043      Y:02C8 Y:02C8                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
3044      Y:02C9 Y:02C9                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3045      Y:02CA Y:02CA                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3046      Y:02CB Y:02CB                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3047      Y:02CC Y:02CC                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
3048      Y:02CD Y:02CD                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
3049      Y:02CE Y:02CE                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
3050      Y:02CF Y:02CF                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3051      Y:02D0 Y:02D0                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3052      Y:02D1 Y:02D1                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3053      Y:02D2 Y:02D2                   DC      CLK2+R_DELAY+000+0000+SEH2+0000+SWEH+000+0000+SFG2+0000+SWFG
3054      Y:02D3 Y:02D3                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+SWEH+000+SFG1+SFG2+0000+SWFG
3055      Y:02D4 Y:02D4                   DC      CLK2+R_DELAY+000+SEH1+0000+0000+SWEH+000+SFG1+0000+0000+SWFG
3056      Y:02D5 Y:02D5                   DC      CLK2+R_DELAY+000+SEH1+0000+SEH3+SWEH+000+SFG1+0000+SFG3+SWFG
3057      Y:02D6 Y:02D6                   DC      CLK2+R_DELAY+000+0000+0000+SEH3+SWEH+000+0000+0000+SFG3+SWFG
3058      Y:02D7 Y:02D7                   DC      CLK2+R_DELAY+000+0000+SEH2+SEH3+SWEH+000+0000+SFG2+SFG3+SWFG
3059                            SXMIT_SPLIT_4
3060      Y:02D8 Y:02D8                   DC      $00F020                           ; Transmit A/D data to host
3061      Y:02D9 Y:02D9                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
3062      Y:02DA Y:02DA                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
3063      Y:02DB Y:02DB                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
3064      Y:02DC Y:02DC                   DC      CLK2+CDS_TIM+000+0000+SEH2+0000+0000+000+0000+SFG2+0000+0000
3065      Y:02DD Y:02DD                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
3066      Y:02DE Y:02DE                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
3067      Y:02DF Y:02DF                   DC      CLK2+R_DELAY+000+SEH1+SEH2+0000+0000+000+SFG1+SFG2+0000+0000
3068                            END_SERIAL_READ_SPLIT_4
3069   
3070                                      IF      @SCP("HOST","EEPROM")
3074                                      ENDIF
3075   
3076                               ENDSEC                                    ; End of section TIMEEV57
3077   
3078                     ;  End of program
3079                               END

0    Errors
Motorola DSP56000 Assembler  Version 6.2.0   110-05-10  22:37:30  tim.s  Page 59



0    Warnings


