Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 1



1                                  COMMENT *
2      
3                          This file is used to generate DSP code for the PCI interface
4                                  board using a DSP56301 as its main processor.
5      
6                          Version 1.7_3/2 Added conditional code for interaction history log.
7                          Version 1.7_3/1 Added conditional code for hardware timer, test point.
8                          Version 1.7_3   Revised PCI Error handling and versioning support.
9      
10                         Version 1.7_2 - PCI DMA writes like the gen-III code with fiber optic and DMA
11                                         transfer concurrency for still better performance.
12                                         Fill ptr and wrap counter for circular buffer support.
13     
14                         Version 1.7_1 - PCI DMA writes like the gen-III code for better performance.
15     
16                         Version 1.7 -   Replies to commands with polling only, no interrupts
17                                         Number of 16-bit pixels returned to host during image readout
18     
19                         Some Rules -
20                                 Commands executed only by the PCI board end with a jump to FINISH,
21                                         FINISH1 or ERROR, since these will assert the reply flags
22                                         and return from interrupt.
23                                 Commands passed along to the timing board end only with RTI since
24                                         the reply from the timing board will generate its own call
25                                         to FINISH1 or ERROR.
26                                 PCI -> commands are received as 24-bit words, with
27                                 Communication of commands and replies over the PCI bus is all at
28                                         24 bits per word. PCI address that need to be passed are
29                                         split into two 16-bit words.
30     
31                         CHANGES, Feb,March,2009 (Peter L. Collins, Lowell Observatory)
32                                  fixed race between READ_NUMBER_OF_PIXELS_READ (interrupt for pxl cntr)
33                                  and C_RPXLS- problem coming from non-atomic update of the two counter
34                                  locations, causing apparent pixel counter to occasionally 'back up'-
35                                  this was OK in earlier LOIS versions where the pixel counter was a
36                                  linear counter polled for completion- however, the circular buffering
37                                  mode used (now) on MAGIC and HIPO blows up. The fix involves several Y
38                                  locations to save an old copy of the pixel counter locations during
39                                  the critical section, and marking the critical state using bit 0 in
40                                  X:<R_PXLS_CRIT.
41     
42     
43                         March,2007 (Peter L. Collins, Lowell Observatory)
44                                 -The "long form" unused PCI retry/handler previously following WR_ERR
45                                  was slightly modified and made to work. The immediate effect was
46                                  to remove a large volume of secondary PCI retries (factor of 2).
47     
48                         February, 2007   (Peter L. Collins, Lowell Observatory)
49                                 -change pixel count returned in GET_PROGRESS ioctl to
50                                  6 bits bits of wrap and 26 bits of FILL.
51     
52                                 -Keep error counts regardless of error logging switch.
53     
54                                 -Prevent error logging in Y memory from overrunning Y memory- it
55                                  is bounded by PCIERRLOGSIZE.
56     
57                                 -Error buffer logging in Y memory controlled by X:PCIERRLOG switch.
58                                  Further modification to DMA to flush PCI transmit fifo before each
59                                  burst transfer. Error buffer added in Y memory following
60                                  the 512 pixel image buffer.
61     
62                                 -Interleave copy from RDFIFO to IMAGE_BUFER with pci transfer
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 2



63                                  using FILL and EMPTY. It is still tied to the 512 pixel block
64                                  concept (and use of the  half full flag on the fiber optic fifo.)
65     
66                         January, 2007   (Peter L. Collins, Lowell Observatory)
67                                 - put in geniii "DMA" to write to pci bus.
68                                 - add loop statistics and oscilloscope check points.
69                                 - fix to update DSR0 register for a pci retry. Prior
70                                   code seemed to be writing the next burst where the
71                                   last should have been- in the case of retry- ultimately
72                                   causing bad pixels off the end of the image bufer to appear
73                                   in the image in the case of retries (as engendered by heavy
74                                   concurrent host pci activity, such as an ftp).
75     
76                         February to March 2001
77                                 - Get rid of Number of Bytes per pixel in images. Assume 2.
78                                 - Get rid of $80A7 = read image command.
79                                 - Process 'RDA' timing board command to start the readout
80                                 - Jump to error if receiver FIFO is empty on vector commands
81                                 - Replace GET_FO mess with calls to RD_FO
82                                 - Implement a timeout on fiber optic words, called RD_FO_TIMEOUT
83                                 - Number of bytes per image replaces NCOLS x NROWS
84                                 - Interrupt levels set as folllows -
85                                         New vector command locations for more order
86                                         NMI for read PCI image address, reset PCI, abort readout
87                                         IPL = 2 for reset button, FIFO HF, enabled during readout
88                                         IPL = 1 for all host commands
89                                         Host commands disabled during image readout
90                                 - Host flags = 5 if reading out image
91                                 - Commands from the PCI host follow the fiber optic protocol,
92                                         header, command, arg1 - arg4
93                                     with command words written to $10020 and then vector $B1
94                                 - A BUSY host flag was introduced =6 for the case where a command
95                                         takes longer than the voodoo TIMEOUT to execute
96                                 - The non-maskable reboot from EEPROM command = $807B is implemented
97                                 - RDM and WRM were changed to abide by the timing board convention
98                                         of embedding the memory type in the address' most significant
99                                         nibble. This limits memory accesses to 64k on this board.
100                                - Eliminate Scatter/Gather image processing in favor of direct
101                                        FIFO to PCI bus transfers.
102                        April 25 - Change PCI write handshaking to MARQ and MDT, eliminating the
103                                        special writing of 8 pixels at the beginning of each image.
104    
105                        Version 1.7 as follows:
106                                - Slaved READ IMAGE to the controller for the number of pixels
107                                        to be read, not just the starting time.
108                                - Introduced the 'IIA' = Initialize Image Address command sent by
109                                        the timing board as a reply to the 'SEX' command to set
110                                        PCI_ADDR = BASE_ADDR at the start of an image instead of
111                                        having the host computer issue it.
112                                - Took out the WRITE_NUMBER_OF_BYTES_IN_IMAGE and
113                                        INITIALIZE_NUMBER_OF_PIXELS command because the
114                                        timing board now does this.
115                                - Introduced the local variable X:<HOST_FLAG that is set to
116                                        the value of the DCTR register bits 5,4,3 to inform
117                                        this program what state the controller is in.
118                                - Separately process commands from the controller to the PCI board,
119                                        distinguished by Destination = 1. Host commands or replies
120                                        have Destination = 0.
121                                - Introduced RDI = 'Reading Image ON' and RDO = 'Reading Image Off'
122                                        commands from the timing board to set host flags indicating
123                                        that the controller is readout out.
124                                *
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 3



125                                  PAGE    132                               ; Printronix page width - 132 columns
126    
127                        ; Equates to define the X: memory tables
128       000000           VAR_TBL   EQU     0                                 ; Variables and constants table
129       000030           ARG_TBL   EQU     $30                               ; Command arguments and addresses
130       000060           VAR2_TBL  EQU     $60                               ; Another variable and constants table
131    
132                        ; Various addressing control registers
133       FFFFFB           BCR       EQU     $FFFFFB                           ; Bus Control Register
134       FFFFFA           DCR       EQU     $FFFFFA                           ; DRAM Control Register
135       FFFFF9           AAR0      EQU     $FFFFF9                           ; Address Attribute Register, channel 0
136       FFFFF8           AAR1      EQU     $FFFFF8                           ; Address Attribute Register, channel 1
137       FFFFF7           AAR2      EQU     $FFFFF7                           ; Address Attribute Register, channel 2
138       FFFFF6           AAR3      EQU     $FFFFF6                           ; Address Attribute Register, channel 3
139       FFFFFD           PCTL      EQU     $FFFFFD                           ; PLL control register
140       FFFFFE           IPRP      EQU     $FFFFFE                           ; Interrupt Priority register - Peripheral
141       FFFFFF           IPRC      EQU     $FFFFFF                           ; Interrupt Priority register - Core
142    
143                        ; PCI control register
144       FFFFCD           DTXS      EQU     $FFFFCD                           ; DSP Slave transmit data FIFO
145       FFFFCC           DTXM      EQU     $FFFFCC                           ; DSP Master transmit data FIFO
146       FFFFCB           DRXR      EQU     $FFFFCB                           ; DSP Receive data FIFO
147       FFFFCA           DPSR      EQU     $FFFFCA                           ; DSP PCI Status Register
148       FFFFC9           DSR       EQU     $FFFFC9                           ; DSP Status Register
149       FFFFC8           DPAR      EQU     $FFFFC8                           ; DSP PCI Address Register
150       FFFFC7           DPMC      EQU     $FFFFC7                           ; DSP PCI Master Control Register
151       FFFFC6           DPCR      EQU     $FFFFC6                           ; DSP PCI Control Register
152       FFFFC5           DCTR      EQU     $FFFFC5                           ; DSP Control Register
153    
154                        ; Port E is the Synchronous Communications Interface (SCI) port
155       FFFF9F           PCRE      EQU     $FFFF9F                           ; Port Control Register
156       FFFF9E           PRRE      EQU     $FFFF9E                           ; Port Direction Register
157       FFFF9D           PDRE      EQU     $FFFF9D                           ; Port Data Register
158    
159                        ; Various PCI register bit equates
160       000001           STRQ      EQU     1                                 ; Slave transmit data request (DSR)
161       000002           SRRQ      EQU     2                                 ; Slave receive data request (DSR)
162       000017           HACT      EQU     23                                ; Host active, low true (DSR)
163       000001           MTRQ      EQU     1                                 ; Set whem master transmitter is not full (DPSR)
164       000004           MARQ      EQU     4                                 ; Master address request (DPSR)
165       00000A           TRTY      EQU     10                                ; PCI Target Retry (DPSR)
166       000000           HCIE      EQU     0                                 ; Host command interrupt enable (DCTR)
167       000006           INTA      EQU     6                                 ; Request PCI interrupt (DCTR)
168       000005           APER      EQU     5                                 ; Address parity error
169       000006           DPER      EQU     6                                 ; Data parity error
170       000007           MAB       EQU     7                                 ; Master Abort
171       000008           TAB       EQU     8                                 ; Target Abort
172       000009           TDIS      EQU     9                                 ; Target Disconnect
173       00000B           TO        EQU     11                                ; Timeout
174       00000E           MDT       EQU     14                                ; Master Data Transfer complete
175       00000F           RDCQ      EQU     15                                ; Remaining Data Count Qualifier
176       000002           SCLK      EQU     2                                 ; SCLK = transmitter special code
177    
178                        ; DPCR bit definitions
179       00000E           CLRT      EQU     14                                ; Clear the master transmitter DTXM
180       000012           MACE      EQU     18                                ; Master access counter enable
181       000015           IAE       EQU     21                                ; Insert Address Enable
182    
183                        ; DMA register definitions
184       FFFFEF           DSR0      EQU     $FFFFEF                           ; Source address register
185       FFFFEE           DDR0      EQU     $FFFFEE                           ; Destination address register
186       FFFFED           DCO0      EQU     $FFFFED                           ; Counter register
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 4



187       FFFFEC           DCR0      EQU     $FFFFEC                           ; Control register
188    
189                        ; Addresses of ESSI port
190       FFFFBC           TX00      EQU     $FFFFBC                           ; Transmit Data Register 0
191       FFFFB7           SSISR0    EQU     $FFFFB7                           ; Status Register
192       FFFFB6           CRB0      EQU     $FFFFB6                           ; Control Register B
193       FFFFB5           CRA0      EQU     $FFFFB5                           ; Control Register A
194    
195                        ; SSI Control Register A Bit Flags
196       000006           TDE       EQU     6                                 ; Set when transmitter data register is empty
197    
198                        ; Miscellaneous addresses
199       FFFFFF           RDFIFO    EQU     $FFFFFF                           ; Read the FIFO for incoming fiber optic data
200    
201                                  IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
202                        ; Timer Addresses
203       FFFF8F           TCSR0     EQU     $FFFF8F                           ; Triple timer control and status register 0
204       FFFF8E           TLR0      EQU     $FFFF8E                           ; Timer load register = 0
205       FFFF8D           TCPR0     EQU     $FFFF8D                           ; Timer compare register = exposure time
206       FFFF8C           TCR0      EQU     $FFFF8C                           ; Timer count register = elapsed time
207       FFFF8B           TCSR1     EQU     $FFFF8B                           ; Triple timer control and status register 1
208       FFFF8A           TLR1      EQU     $FFFF8A                           ; Timer load register = 0
209       FFFF89           TCPR1     EQU     $FFFF89                           ; Timer compare register = exposure time
210       FFFF88           TCR1      EQU     $FFFF88                           ; Timer count register = elapsed time
211       FFFF87           TCSR2     EQU     $FFFF87                           ; Triple timer control and status register 2
212       FFFF86           TLR2      EQU     $FFFF86                           ; Timer load register = 0
213       FFFF85           TCPR2     EQU     $FFFF85                           ; Timer compare register = exposure time
214       FFFF84           TCR2      EQU     $FFFF84                           ; Timer count register = elapsed time
215       FFFF83           TPLR      EQU     $FFFF83                           ; Timer prescaler load register => milliseconds
216       FFFF82           TPCR      EQU     $FFFF82                           ; Timer prescaler count register
217       000000           TIM_BIT   EQU     0                                 ; Set to enable the timer
218       000015           TCF       EQU     21                                ; Set when timer counter = compare register
219                                  ELSE
223                                  ENDIF
224    
225                        ; Phase Locked Loop initialization
226       750012           PLL_INIT  EQU     $750012                           ; PLL = 33 MHz x 19 / 8 = 78.4 MHz
227    
228                        ; Port C is Enhanced Synchronous Serial Port 0
229       FFFFBF           PCRC      EQU     $FFFFBF                           ; Port C Control Register
230       FFFFBE           PRRC      EQU     $FFFFBE                           ; Port C Data direction Register
231       FFFFBD           PDRC      EQU     $FFFFBD                           ; Port C GPIO Data Register
232    
233                        ; Port D is Enhanced Synchronous Serial Port 1
234       FFFFAF           PCRD      EQU     $FFFFAF                           ; Port D Control Register
235       FFFFAE           PRRD      EQU     $FFFFAE                           ; Port D Data direction Register
236       FFFFAD           PDRD      EQU     $FFFFAD                           ; Port D GPIO Data Register
237    
238                        ; Bit number definitions of GPIO pins on Port D
239       000000           EF        EQU     0                                 ; FIFO Empty flag, low true
240       000001           HF        EQU     1                                 ; FIFO Half Full flag, low true
241       000004           MODE      EQU     4                                 ; 1 for 32-bit reply data, 0 for 16-bit image
242    
243                        ; STATUS bit definition
244       000000           ODD       EQU     0                                 ; Set if odd number of pixels are in the image
245    
246                        ; PCI transfer constants
247       000200           FOBURST   EQU     512                               ; unit of pixels.
248       000080           PCIBURST  EQU     128                               ; unit of pixels.
249       000100           PCI2BURST EQU     256                               ; unit of pixels.
250                        PCI_ERRMAGIC
251       FEEDEE                     EQU     $FEEDEE                           ; set PCI_ERRLOG to this to enable retry log
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 5



252                        PCI_ERRLOGSIZE
253       000064                     EQU     100                               ; Maximum entries in Y memory pci error log
254                        PCI_ERRLOGFIRST
255       000400                     EQU     1024                              ; Start of Y memory pci error log
256                        PCI_ERRLOGLAST
257       000464                     EQU     1124                              ; End+1 of Y memory pci error log
258       0007D0           PCI_YCOMM EQU     2000                              ; small comm area up through 2047
259       0007E0           RPXLS_SAFE EQU    PCI_YCOMM+16                      ; alternate R_PXLS copy for race
260    
261                        ; History log
262                                  IF      @SCP("SUPPORTED","SUPPORTED")
263                        PCI_HISTFIRST
264       000800                     EQU     2048                              ; history log start in Y memory
265                        PCI_HISTEND
266       001000                     EQU     4096                              ; history log end + 1 in Y memory
267    
268                        ; PCI history tags
269       524E50           H_RDNUMPIX EQU    'RNP'                             ; READ_NUMBER_OF_PIXELS_READ
270                        H_RDREPLYVAL
271       525250                     EQU     'RRP'                             ; READ_REPLY_VALUE
272                        H_BASEPCIADDR
273       574250                     EQU     'WBP'                             ; WRITE_BASE_PCI_ADDRESS
274                        H_CLEARHOSTFLG
275       434846                     EQU     'CHF'                             ; CLEAR_HOST_FLAG
276                        F_READ_IMAGE
277       524441                     EQU     'RDA'                             ; READ_IMAGE
278                        F_READING_IMAGE
279       524449                     EQU     'RDI'                             ; READING_IMAGE
280                        F_INIT_NO_PIX
281       494941                     EQU     'IIA'                             ; INITIALIZE_NUMBER_OF_PIXELS
282       575331           F_WCMDSTG1 EQU    'WS1'                             ; WRITE-COMMAND error, stage 1, fifo empty
283       575332           F_WCMDSTG2 EQU    'WS2'                             ; WRITE-COMMAND error, stage 2, header bad
284       575333           F_WCMDSTG3 EQU    'WS3'                             ; WRITE-COMMAND error, stage 3, header bad
285       575334           F_WCMDSTG4 EQU    'WS4'                             ; WRITE-COMMAND error, stage 4, arg cnt <= 0
286       575335           F_WCMDSTG5 EQU    'WS5'                             ; WRITE-COMMAND error, stage 5, arg cnt too lrg
287       575336           F_WCMDSTG6 EQU    'WS6'                             ; WRITE-COMMAND error, stage 6, dest = 0
288                                  ENDIF
289    
290                        ;       Standard info fields specification
291                                  INCLUDE "infospec.s"
292                        ; General DSP info field specifications.
293                        ; These values are 'addresses' and used as the argument for the INF command.
294    
295                        GET_VERSION
296       000000                     EQU     0                                 ; IVERSION field
297       000001           GET_FLAVOR EQU    1                                 ; IFLAVOR field
298       000002           GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
299       000003           GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
300       000004           GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if available)
301    
302                        ;       PCI-specific info fields specification
303                                  INCLUDE "pciinfospec.s"
304                        ; PCI DSP info field specifications.
305                        ; These values are 'addresses' and used as the argument for the INF command.
306    
307                        GET_CAPABLE
308       000100                     EQU     $100                              ; ICAPABLE field (what dsp supports).
309    
310                        ;       File of info field values
311                                  INCLUDE "pciinfo.s"
312                        ; DSP Version
313       0471C5           IVERSION  EQU     291269                            ; 1.7/7/5
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciinfo.s  Page 6



314    
315       202020           IFLAVOR   EQU     '   '                             ; none
316    
317       00B444           ITIME0    EQU     46148                             ; lo order time: 2009 10 25  20:25:40 GMT
318    
319       004AE4           ITIME1    EQU     19172                             ; hi order time: 2009 10 25  20:25:40 GMT
320    
321       0F5217           ISVNREV   EQU     1004055                           ; most recent code svn rev
322    
323                                  INCLUDE "version.s"                       ; backward compatibility
324                        ; DSP Version
325       0471C1           VERSION   EQU     291265                            ; V1.7/7
326    
327    
328                        ; set up pci capabilities word
329                                  IF      @SCP("SUPPORTED","SUPPORTED")     ;bit 0 (1)
330       000001           RDACAPABLE EQU    1
331                                  ELSE
333                                  ENDIF
334                                  IF      @SCP("SUPPORTED","SUPPORTED")     ;bit 0 (1)
335                        HISTCAPABLE
336       000002                     EQU     2
337                                  ELSE
339                                  ENDIF
340                                  IF      @SCP("SUPPORTED","SUPPORTED")     ;bit 0 (1)
341       000004           TIMCAPABLE EQU    4
342                                  ELSE
344                                  ENDIF
345       000007           PCICAPABLE EQU    TIMCAPABLE+HISTCAPABLE+RDACAPABLE
346    
347    
348                        ; Special address for two words for the DSP to bootstrap code from the EEPROM
349                                  IF      @SCP("HOST","ROM")                ; Boot from ROM on power-on
356                                  ENDIF
357    
358                                  IF      @SCP("HOST","HOST")               ; Download via host computer
359       P:000000 P:000000                   ORG     P:0,P:0
360       P:000000 P:000000                   DC      END_ADR-INIT                      ; Number of boot words
361       P:000001 P:000001                   DC      INIT                              ; Starting address
362       P:000000 P:000000                   ORG     P:0,P:0
363       P:000000 P:000000 0C00B2  INIT      JMP     <START
364       P:000001 P:000001 000000            NOP
365                                           ENDIF
366    
367                                           IF      @SCP("HOST","ONCE")               ; Download via ONCE debugger
371                                           ENDIF
372    
373                                 ; Vectored interrupt table, addresses at the beginning are reserved
374       P:000002 P:000002                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0       ; $02-$0f Reserved
375       P:000010 P:000010                   DC      0,0                               ; $11 - IRQA* = FIFO EF*
376       P:000012 P:000012                   DC      0,0                               ; $13 - IRQB* = FIFO HF*
377       P:000014 P:000014 0BF080            JSR     CLEAN_UP_PCI                      ; $15 - Software reset switch
                            000342
378       P:000016 P:000016                   DC      0,0,0,0,0,0,0,0,0,0,0,0           ; Reserved for DMA and Timer
379       P:000022 P:000022                   DC      0,0,0,0,0,0,0,0,0,0,0,0           ;   interrupts
380       P:00002E P:00002E 0BF080            JSR     DOWNLOAD_PCI_DSP_CODE             ; $2F
                            000045
381    
382                                 ; Now we're at P:$30, where some unused vector addresses are located
383    
384                                 ; This is ROM only code that is only executed once on power-up when the
385                                 ;   ROM code is downloaded. It is skipped over on OnCE or PCI downloads.
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 7



386                                 ; Initialize the PLL - phase locked loop
387                                 INIT_PCI
388       P:000030 P:000030 08F4BD            MOVEP             #PLL_INIT,X:PCTL        ; Initialize PLL
                            750012
389       P:000032 P:000032 000000            NOP
390    
391                                 ; Program the PCI self-configuration registers
392       P:000033 P:000033 240000            MOVE              #0,X0
393       P:000034 P:000034 08F485            MOVEP             #$500000,X:DCTR         ; Set self-configuration mode
                            500000
394       P:000036 P:000036 0604A0            REP     #4
395       P:000037 P:000037 08C408            MOVEP             X0,X:DPAR               ; Dummy writes to configuration space
396       P:000038 P:000038 08F487            MOVEP             #>$0000,X:DPMC          ; Subsystem ID
                            000000
397       P:00003A P:00003A 08F488            MOVEP             #>$0000,X:DPAR          ; Subsystem Vendor ID
                            000000
398    
399                                 ; PCI Personal reset
400       P:00003C P:00003C 08C405            MOVEP             X0,X:DCTR               ; Personal software reset
401       P:00003D P:00003D 000000            NOP
402       P:00003E P:00003E 000000            NOP
403       P:00003F P:00003F 0A89B7            JSET    #HACT,X:DSR,*                     ; Test for personal reset completion
                            00003F
404       P:000041 P:000041 07F084            MOVE              P:(*+3),X0              ; Trick to write "JMP <START" to P:0
                            000044
405       P:000043 P:000043 070004            MOVE              X0,P:(0)
406       P:000044 P:000044 0C00B2            JMP     <START
407    
408                                 DOWNLOAD_PCI_DSP_CODE
409       P:000045 P:000045 0A8615            BCLR    #IAE,X:DPCR                       ; Do not insert PCI address with data
410       P:000046 P:000046 0A8982  DNL0      JCLR    #SRRQ,X:DSR,*                     ; Wait for a receiver word
                            000046
411       P:000048 P:000048 084E0B            MOVEP             X:DRXR,A                ; Read it
412       P:000049 P:000049 0140C5            CMP     #$555AAA,A                        ; Check for sanity header word
                            555AAA
413       P:00004B P:00004B 0E2046            JNE     <DNL0
414       P:00004C P:00004C 044EBA            MOVE              OMR,A
415       P:00004D P:00004D 0140C6            AND     #$FFFFF0,A
                            FFFFF0
416       P:00004F P:00004F 014C82            OR      #$00000C,A
417       P:000050 P:000050 000000            NOP
418       P:000051 P:000051 04CEBA            MOVE              A,OMR                   ; Set boot mode to $C = PCI
419       P:000052 P:000052 0AF080            JMP     $FF0000                           ; Jump to boot code internal to DSP
                            FF0000
420    
421       P:000054 P:000054                   DC      0,0,0,0,0,0,0,0,0,0,0,0           ; Filler
422       P:000060 P:000060                   DC      0,0                               ; $60 - PCI Transaction Termination
423       P:000062 P:000062                   DC      0,0,0,0,0,0,0,0,0                 ; $62-$71 Reserved PCI
424       P:00006B P:00006B                   DC      0,0,0,0,0,0,0,0,0
425    
426                                 ; These interrupts are non-maskable, called from the host with $80xx
427       P:000074 P:000074 0BF080            JSR     READ_NUMBER_OF_PIXELS_READ        ; $8075
                            0002AD
428       P:000076 P:000076 0BF080            JSR     CLEAN_UP_PCI                      ; $8077
                            000342
429       P:000078 P:000078 0BF080            JSR     ABORT_READOUT                     ; $8079
                            000326
430       P:00007A P:00007A 0BF080            JSR     BOOT_EEPROM                       ; $807B
                            0001C7
431       P:00007C P:00007C                   DC      0,0,0,0                           ; Available
432    
433                                 ; These vector interrupts are masked at IPL = 1
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 8



434       P:000080 P:000080 0BF080            JSR     READ_REPLY_HEADER                 ; $81
                            0005FF
435       P:000082 P:000082 0BF080            JSR     READ_REPLY_VALUE                  ; $83
                            0005EF
436       P:000084 P:000084 0BF080            JSR     CLEAR_HOST_FLAG                   ; $85
                            000601
437       P:000086 P:000086 0BF080            JSR     RESET_CONTROLLER                  ; $87
                            0002C7
438       P:000088 P:000088 0BF080            JSR     READ_IMAGE                        ; $89
                            00034C
439       P:00008A P:00008A                   DC      0,0                               ; Available
440       P:00008C P:00008C 0BF080            JSR     WRITE_BASE_PCI_ADDRESS            ; $8D
                            0002F3
441    
442       P:00008E P:00008E                   DC      0,0,0,0                           ; Available
443       P:000092 P:000092                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0
444       P:0000A0 P:0000A0                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
445    
446                                 ; New manual command for Version 1.6
447       P:0000B0 P:0000B0 0BF080            JSR     WRITE_COMMAND                     ; $B1
                            0001D2
448    
449       P:0000B2 P:0000B2 08F487  START     MOVEP             #>$00001,X:DPMC         ; 32-bit PCI <-> 24-bit DSP data
                            000001
450       P:0000B4 P:0000B4 0A8534            BSET    #20,X:DCTR                        ; HI32 mode = 1 => PCI
451       P:0000B5 P:0000B5 0A8515            BCLR    #21,X:DCTR
452       P:0000B6 P:0000B6 0A8516            BCLR    #22,X:DCTR
453       P:0000B7 P:0000B7 000000            NOP
454       P:0000B8 P:0000B8 0A8AAC            JSET    #12,X:DPSR,*                      ; Host data transfer not in progress
                            0000B8
455       P:0000BA P:0000BA 000000            NOP
456       P:0000BB P:0000BB 0A8632            BSET    #MACE,X:DPCR                      ; Master access counter enable
457       P:0000BC P:0000BC 000000            NOP                                       ; End of PCI programming
458    
459                                 ; Set operation mode register OMR to normal expanded
460       P:0000BD P:0000BD 0500BA            MOVEC             #$0000,OMR              ; Operating Mode Register = Normal Expanded
461       P:0000BE P:0000BE 0500BB            MOVEC             #0,SP                   ; Reset the Stack Pointer SP
462    
463                                 ; Move the table of constants from P: space to X: space
464       P:0000BF P:0000BF 61F400            MOVE              #CONSTANTS_TBL_START,R1 ; Start of table of constants
                            0006A8
465       P:0000C1 P:0000C1 300200            MOVE              #2,R0                   ; Leave X:0 for STATUS
466       P:0000C2 P:0000C2 061080            DO      #CONSTANTS_TBL_LENGTH,L_WRITE
                            0000C5
467       P:0000C4 P:0000C4 07D984            MOVE              P:(R1)+,X0
468       P:0000C5 P:0000C5 445800            MOVE              X0,X:(R0)+              ; Write the constants to X:
469                                 L_WRITE
470    
471                                 ; Program the serial port ESSI0 = Port C for serial transmission to
472                                 ;   the timing board
473       P:0000C6 P:0000C6 07F43F            MOVEP             #>0,X:PCRC              ; Software reset of ESSI0
                            000000
474       P:0000C8 P:0000C8 07F435            MOVEP             #$000809,X:CRA0         ; Divide 78.4 MHz by 20 to get 3.92 MHz
                            000809
475                                                                                     ; DC0-CD4 = 0 for non-network operation
476                                                                                     ; WL0-WL2 = ALC = 0 for 2-bit data words
477                                                                                     ; SSC1 = 0 for SC1 not used
478       P:0000CA P:0000CA 07F436            MOVEP             #$010120,X:CRB0         ; SCKD = 1 for internally generated clock
                            010120
479                                                                                     ; SHFD = 0 for MSB shifted first
480                                                                                     ; CKP = 0 for rising clock edge transitions
481                                                                                     ; TE0 = 1 to enable transmitter #0
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 9



482                                                                                     ; MOD = 0 for normal, non-networked mode
483                                                                                     ; FSL1 = 1, FSL0 = 0 for on-demand transmit
484       P:0000CC P:0000CC 07F43F            MOVEP             #%101000,X:PCRC         ; Control Register (0 for GPIO, 1 for ESSI)
                            000028
485                                                                                     ; Set SCK0 = P3, STD0 = P5 to ESSI0
486       P:0000CE P:0000CE 07F43E            MOVEP             #%010111,X:PRRC         ; Data Direction Register (0 for In, 1 for O
ut)
                            000017
487       P:0000D0 P:0000D0 07F43D            MOVEP             #%000101,X:PDRC         ; Data Register - ROM/FIFO* = 0, SC02 = 0,
                            000005
488                                                                                     ;   AUX1 = 0, AUX2 = AUX3 = 1
489    
490                                 ; Conversion from software bits to schematic labels for Port C and D
491                                 ;       PC0 = SC00 = AUX3               PD0 = SC10 = EF*
492                                 ;       PC1 = SC01 = ROM/FIFO*          PD1 = SC11 = HF*
493                                 ;       PC2 = SC02 = AUX2               PD2 = SC12 = RS*
494                                 ;       PC3 = SCK0 = Serial clock       PD3 = SCK1 = FSYNC*
495                                 ;       PC4 = SRD0 = AUX1               PD4 = SRD1 = MODE
496                                 ;       PC5 = STD0 = Serial data        PD5 = STD1 = WRFIFO*
497    
498                                 ; Program the serial port ESSI1 = Port D for general purpose I/O (GPIO)
499       P:0000D2 P:0000D2 07F42F            MOVEP             #%000000,X:PCRD         ; Control Register (0 for GPIO, 1 for ESSI)
                            000000
500       P:0000D4 P:0000D4 07F42E            MOVEP             #%010100,X:PRRD         ; Data Direction Register (0 for In, 1 for O
ut)
                            000014
501       P:0000D6 P:0000D6 07F42D            MOVEP             #%010000,X:PDRD         ; Data Register - Pulse RS* low, MODE = 1
                            000010
502       P:0000D8 P:0000D8 060AA0            REP     #10
503       P:0000D9 P:0000D9 000000            NOP
504       P:0000DA P:0000DA 07F42D            MOVEP             #%010100,X:PDRD
                            000014
505    
506                                 ; Program the SCI port to benign values
507       P:0000DC P:0000DC 07F41F            MOVEP             #%000,X:PCRE            ; Port Control Register = GPIO
                            000000
508       P:0000DE P:0000DE 07F41E            MOVEP             #%110,X:PRRE            ; Port Direction Register (0 = Input)
                            000006
509       P:0000E0 P:0000E0 07F41D            MOVEP             #%110,X:PDRE            ; Port Data Register
                            000006
510                                 ;       PE0 = RXD
511                                 ;       PE1 = TXD
512                                 ;       PE2 = SCLK
513    
514                                 ; Program the triple timer to assert TCI0 as a GPIO output = 1
515       P:0000E2 P:0000E2 07F40F            MOVEP             #$2800,X:TCSR0
                            002800
516       P:0000E4 P:0000E4 07F40B            MOVEP             #$2800,X:TCSR1
                            002800
517       P:0000E6 P:0000E6 07F407            MOVEP             #$2800,X:TCSR2
                            002800
518    
519                                 ; Program the AA1 pin to read the FIFO memory for incoming timing board data
520       P:0000E8 P:0000E8 08F4B8            MOVEP             #$FFFC21,X:AAR1         ; Y = $FFF000 to $FFFFFF asserts AA1 low tru
e
                            FFFC21
521    
522                                 ; Program the DRAM memory access and addressing
523       P:0000EA P:0000EA 08F4BB            MOVEP             #$000020,X:BCR          ; Bus Control Register
                            000020
524       P:0000EC P:0000EC 08F4BA            MOVEP             #$893A05,X:DCR          ; DRAM Control Register
                            893A05
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 10



525       P:0000EE P:0000EE 08F4B7            MOVEP             #$000122,X:AAR2         ; Y: $000000 to $7FFFFF asserts AA2
                            000122
526       P:0000F0 P:0000F0 08F4B9            MOVEP             #$800122,X:AAR0         ; Y: $800000 to $FFFFFF asserts AA0
                            800122
527       P:0000F2 P:0000F2 08F4B6            MOVEP             #$000112,X:AAR3         ; X: $000000 to $7FFFFF asserts AA3
                            000112
528    
529                                 ; Clear all PCI error conditions
530       P:0000F4 P:0000F4 084E0A            MOVEP             X:DPSR,A
531       P:0000F5 P:0000F5 0140C2            OR      #$1FE,A
                            0001FE
532       P:0000F7 P:0000F7 000000            NOP
533       P:0000F8 P:0000F8 08CE0A            MOVEP             A,X:DPSR
534    
535                                 ; Establish interrupt priority levels IPL
536       P:0000F9 P:0000F9 08F4BF            MOVEP             #$0001C0,X:IPRC         ; IRQC priority IPL = 2 (reset switch, edge)
                            0001C0
537                                                                                     ; IRQB priority IPL = 2 or 0
538                                                                                     ;     (FIFO half full - HF*, level)
539       P:0000FB P:0000FB 08F4BE            MOVEP             #>2,X:IPRP              ; Enable PCI Host interrupts, IPL = 1
                            000002
540       P:0000FD P:0000FD 0A8520            BSET    #HCIE,X:DCTR                      ; Enable host command interrupts
541       P:0000FE P:0000FE 0500B9            MOVE              #0,SR                   ; Don't mask any interrupts
542    
543                                 ; Initialize the fiber optic serial transmitter to zero
544       P:0000FF P:0000FF 01B786            JCLR    #TDE,X:SSISR0,*
                            0000FF
545       P:000101 P:000101 07F43C            MOVEP             #$000000,X:TX00
                            000000
546    
547                                 ; Clear out the PCI receiver and transmitter FIFOs
548       P:000103 P:000103 0A862E            BSET    #CLRT,X:DPCR                      ; Clear the master transmitter
549       P:000104 P:000104 0A86AE            JSET    #CLRT,X:DPCR,*                    ; Wait for the clearing to be complete
                            000104
550       P:000106 P:000106 0A8982  CLR0      JCLR    #SRRQ,X:DSR,CLR1                  ; Wait for the receiver to be empty
                            00010B
551       P:000108 P:000108 08440B            MOVEP             X:DRXR,X0               ; Read receiver to empty it
552       P:000109 P:000109 000000            NOP
553       P:00010A P:00010A 0C0106            JMP     <CLR0
554                                 CLR1
555    
556                                 ; Clear the host buffer size thus disabling wrap mode
557       P:00010B P:00010B 200013            CLR     A
558       P:00010C P:00010C 448600            MOVE              X:<FLAG_DONE,X0         ; Flag = 1 => Normal execution
559       P:00010D P:00010D 543600            MOVE              A1,X:<PCI_BUFSIZE_0     ; Non-wrap mode for pci transfer
560       P:00010E P:00010E 503700            MOVE              A0,X:<PCI_BUFSIZE_1     ; Non-wrap mode for pci transfer
561                                           IF      @SCP("SUPPORTED","SUPPORTED")
562       P:00010F P:00010F 54F400            MOVE              #2000,A1
                            0007D0
563       P:000111 P:000111 000000            NOP
564       P:000112 P:000112 543D00            MOVE              A1,X:<WAIT_RDA          ; nominal wait in RDA.
565                                           ENDIF
566    
567    
568                                           IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
569                                 ;    This is timer code contributed by one of Bob Leach's users.
570                                 ;
571                                 ;    Set up the timer parameters and start the timer
572                                 ;    We use two timers to generate a combined 45-bit counter.
573                                 ;       Timer 0 - fine grain timer
574                                 ;                 this timer is incremented using the internal
575                                 ;                 clock, so it is incremented at a rate of (CLK/2)
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 11



576                                 ;       Timer 1 - course grain timer
577                                 ;                 This uses the prescalar, which is set to count to
578                                 ;                 increment using the internal clock, and set to
579                                 ;                 trigger when it counts to '$1FFFFF', the maximum
580                                 ;                 21-bit value.
581                                 ;    Thus, 'Timer 1' is updated at a frequency '1/2^21' that of 'Timer 0',
582                                 ;    and consequently the MSB '3' bits of 'Timer 0' and the LSB '3' bits
583                                 ;    of 'Timer 1' are redundant.  ( Note that to ensure that these '3'
584                                 ;    bits are actually equal, we need to initially load 'TCR1' with '1'
585                                 ;    instead of '0', because the value from 'TLR1' is loaded when the
586                                 ;    prescalar initially triggers, which is after it has already counted
587                                 ;    to '$1FFFFF' once ).  The redundant '3' bits are actually useful because
588                                 ;    the two timers cannot be read atomically, so they will indicate if the
589                                 ;    fine-grain timer has wrapped between the times the two are read.
590                                 ;
591                                 ;************************************************************
592       P:000113 P:000113 010F00            BCLR    #TIM_BIT,X:TCSR0                  ; Disable the timer
593       P:000114 P:000114 010B00            BCLR    #TIM_BIT,X:TCSR1                  ; Disable the timer
594       P:000115 P:000115 07F403            MOVEP             #$1FFFFF,X:TPLR         ; Prescaler to generate msec timer,
                            1FFFFF
595                                                                                     ; counting from system clock/2 = 50 MHz
596       P:000117 P:000117 07F40F            MOVEP             #$200000,X:TCSR0        ; Clear timer 0 complete bit,
                            200000
597                                                                                     ; use internal (CLK/2) signal
598       P:000119 P:000119 07F40B            MOVEP             #$208000,X:TCSR1        ; Clear timer 1 complete bit,
                            208000
599                                                                                     ; use prescaler
600       P:00011B P:00011B 07F40E            MOVEP             #0,X:TLR0               ; Timer load register
                            000000
601       P:00011D P:00011D 07F40A            MOVEP             #1,X:TLR1               ; Timer 1 load register - use '1' here
                            000001
602                                                                                     ; because it is only loaded after
603                                                                                     ;'TPLR' is first decremented down to 0
604       P:00011F P:00011F 010F20            BSET    #TIM_BIT,X:TCSR0                  ; Enable the timer #0
605       P:000120 P:000120 010B20            BSET    #TIM_BIT,X:TCSR1                  ; Enable the timer #1
606                                           ENDIF
607    
608    
609                                 ; Repy = DONE host flags
610       P:000121 P:000121 441E00            MOVE              X0,X:<HOST_FLAG
611       P:000122 P:000122 0D01B2            JSR     <FO_WRITE_HOST_FLAG
612    
613                                           IF      @SCP("SUPPORTED","SUPPORTED")
614       P:000123 P:000123 63F400            MOVE              #PCI_HISTFIRST,R3       ; hist buffer ptr initialization
                            000800
615       P:000125 P:000125 633B00            MOVE              R3,X:<PCI_HISTFILL
616                                           ENDIF
617    
618       P:000126 P:000126 000000            NOP
619    
620                                 ; ********************************************************************
621                                 ;
622                                 ;                       REGISTER  USAGE
623                                 ;
624                                 ;       X0, X1, Y0, Y1, A and B are used freely in READ_IMAGE. Interrups
625                                 ;               during readout will clobber these registers, as a result
626                                 ;               of which only catastrophic commands such as ABORT_READOUT
627                                 ;               and BOOT_EEPROM are allowed during readout.
628                                 ;
629                                 ;       X0, X1 and A are used for all interrupt handling routines, such
630                                 ;               as CLEAR_HOST-FLAGS, command processing and so on.
631                                 ;
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 12



632                                 ;       Y0, Y1 and B are used for all fiber optic processing routines,
633                                 ;               which are not in interrupt service routines.
634                                 ;
635                                 ; *********************************************************************
636    
637    
638    
639                                 ; ************  Start of command interpreting code  ******************
640    
641                                 ; Test for fiber optic data on the FIFO. Discard the header for now
642    
643                                 ; Check for the header $AC in the first byte = Y0. Wait a little while and
644                                 ;  clear the FIFO if its not $AC - there was probably noise on the line.
645                                 ; We assume only two word replies here - Header = (S,D,#words)  Reply
646    
647                                 GET_FO
648                                           IF      @SCP("SUPPORTED","SUPPORTED")
649       P:000127 P:000127 20001B            CLR     B
650    
651       P:000128 P:000128 55BB00            MOVE              X:<PCI_HISTFILL,B1
652       P:000129 P:000129 000000            NOP
653       P:00012A P:00012A 0140CC            SUB     #PCI_HISTEND,B
                            001000
654       P:00012C P:00012C 000000            NOP
655       P:00012D P:00012D 0AF0A9            JLT     CHK_FO
                            000134
656       P:00012F P:00012F 55F400            MOVE              #PCI_HISTFIRST,B1       ; hist buffer ptr wrapped
                            000800
657       P:000131 P:000131 000000            NOP
658       P:000132 P:000132 553B00            MOVE              B1,X:<PCI_HISTFILL
659       P:000133 P:000133 000000            NOP
660    
661                                 CHK_FO
662                                           ENDIF
663    
664       P:000134 P:000134 01AD80            JCLR    #EF,X:PDRD,GET_FO                 ; Test for new fiber optic data
                            000127
665       P:000136 P:000136 0D063B            JSR     <RD_FO_TIMEOUT                    ; Move the FIFO reply into B1
666       P:000137 P:000137 0E81BD            JCS     <FO_ERR
667    
668                                 ; Check the header bytes for self-consistency
669       P:000138 P:000138 21A600            MOVE              B1,Y0
670       P:000139 P:000139 57F400            MOVE              #$FCFCF8,B              ; Test for S.LE.3 and D.LE.3 and N.LE.7
                            FCFCF8
671       P:00013B P:00013B 20005E            AND     Y0,B
672       P:00013C P:00013C 0E21BD            JNE     <FO_ERR                           ; Test failed
673       P:00013D P:00013D 57F400            MOVE              #$030300,B              ; Test for either S.NE.0 or D.NE.0
                            030300
674       P:00013F P:00013F 20005E            AND     Y0,B
675       P:000140 P:000140 0EA1BD            JEQ     <FO_ERR                           ; Test failed
676       P:000141 P:000141 57F400            MOVE              #>7,B
                            000007
677       P:000143 P:000143 20005E            AND     Y0,B                              ; Extract NWORDS, must be >= 2
678       P:000144 P:000144 01418D            CMP     #1,B
679       P:000145 P:000145 0EF1BD            JLE     <FO_ERR
680       P:000146 P:000146 20CF00            MOVE              Y0,B
681       P:000147 P:000147 0C1891            EXTRACTU #$008020,B,B                     ; Extract bits 15-8 = destination byte
                            008020
682       P:000149 P:000149 000000            NOP
683       P:00014A P:00014A 511F00            MOVE              B0,X:<FO_DEST
684    
685                                 ; Read the reply or command from the fiber optics FIFO
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 13



686       P:00014B P:00014B 0D063B            JSR     <RD_FO_TIMEOUT                    ; Move the FIFO reply into A1
687       P:00014C P:00014C 0E81BD            JCS     <FO_ERR
688       P:00014D P:00014D 552000            MOVE              B1,X:<FO_CMD
689    
690                                 ; Check for commands from the controller to the PCI board, FO_DEST = 1
691       P:00014E P:00014E 579F00            MOVE              X:<FO_DEST,B
692       P:00014F P:00014F 01418D            CMP     #1,B
693       P:000150 P:000150 0E215F            JNE     <HOSTCMD
694       P:000151 P:000151 57A000            MOVE              X:<FO_CMD,B
695       P:000152 P:000152 0140CD            CMP     #'RDA',B                          ; Read the image
                            524441
696       P:000154 P:000154 0EA34C            JEQ     <READ_IMAGE
697       P:000155 P:000155 0140CD            CMP     #'IIA',B
                            494941
698       P:000157 P:000157 0EA30C            JEQ     <INITIALIZE_NUMBER_OF_PIXELS      ; IPXLS = 0
699       P:000158 P:000158 0140CD            CMP     #'RDI',B
                            524449
700       P:00015A P:00015A 0EA194            JEQ     <READING_IMAGE                    ; Controller is reading an image
701       P:00015B P:00015B 0140CD            CMP     #'RDO',B
                            52444F
702       P:00015D P:00015D 0EA1AD            JEQ     <READING_IMAGE_OFF                ; Controller no longer reading an image
703       P:00015E P:00015E 0C0127            JMP     <GET_FO                           ; Not on the list -> just ignore it
704    
705                                 ; Check if the command or reply is for the host. If not just ignore it.
706       P:00015F P:00015F 579F00  HOSTCMD   MOVE              X:<FO_DEST,B
707       P:000160 P:000160 01408D            CMP     #0,B
708       P:000161 P:000161 0E2127            JNE     <GET_FO
709       P:000162 P:000162 57A000            MOVE              X:<FO_CMD,B             ; Get the command
710    
711                                           IF      @SCP("SUPPORTED","SUPPORTED")
712       P:000163 P:000163 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
713       P:000164 P:000164 000000            NOP
714       P:000165 P:000165 000000            NOP
715       P:000166 P:000166 000000            NOP
716       P:000167 P:000167 5D5B00            MOVE                          B1,Y:(R3)+
717       P:000168 P:000168 000000            NOP
718       P:000169 P:000169 57BC00            MOVE              X:<PCI_HISTON,B
719       P:00016A P:00016A 20000B            TST     B
720       P:00016B P:00016B 0AF0AA            JEQ     DO_REPLYHST
                            000171
721                                           IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
722       P:00016D P:00016D 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
723       P:00016E P:00016E 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
724                                           ENDIF
725       P:00016F P:00016F 633B00            MOVE              R3,X:<PCI_HISTFILL
726       P:000170 P:000170 000000            NOP
727                                 DO_REPLYHST
728       P:000171 P:000171 57A000            MOVE              X:<FO_CMD,B             ; Get the command
729       P:000172 P:000172 000000            NOP
730                                 ;       the fiber loop wraps PCI_HIST when it gets the chance.
731                                           ENDIF
732    
733       P:000173 P:000173 0140CD            CMP     #'DON',B
                            444F4E
734       P:000175 P:000175 0EA184            JEQ     <CONTROLLER_DONE                  ; Normal DONE reply
735       P:000176 P:000176 0140CD            CMP     #'ERR',B
                            455252
736       P:000178 P:000178 0EA188            JEQ     <CONTROLLER_ERROR                 ; Error reply
737       P:000179 P:000179 0140CD            CMP     #'BSY',B
                            425359
738       P:00017B P:00017B 0EA190            JEQ     <CONTROLLER_BUSY                  ; Controller is busy executing a command
739       P:00017C P:00017C 0140CD            CMP     #'SYR',B
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 14



                            535952
740       P:00017E P:00017E 0EA18C            JEQ     <CONTROLLER_RESET                 ; Controller system reset
741    
742                                 ; The controller reply is none of the above so return it as a reply
743       P:00017F P:00017F 551D00            MOVE              B1,X:<REPLY             ; Report value
744       P:000180 P:000180 468700            MOVE              X:<FLAG_REPLY,Y0        ; Flag = 2 => Reply with a value
745       P:000181 P:000181 461E00            MOVE              Y0,X:<HOST_FLAG
746       P:000182 P:000182 0D01B2            JSR     <FO_WRITE_HOST_FLAG
747       P:000183 P:000183 0C0127            JMP     <GET_FO
748    
749                                 CONTROLLER_DONE
750       P:000184 P:000184 468600            MOVE              X:<FLAG_DONE,Y0         ; Flag = 1 => Normal execution
751       P:000185 P:000185 461E00            MOVE              Y0,X:<HOST_FLAG
752       P:000186 P:000186 0D01B2            JSR     <FO_WRITE_HOST_FLAG
753       P:000187 P:000187 0C0127            JMP     <GET_FO                           ; Keep looping for fiber optic commands
754    
755                                 CONTROLLER_ERROR
756       P:000188 P:000188 468800            MOVE              X:<FLAG_ERR,Y0          ; Flag = 3 => controller error
757       P:000189 P:000189 461E00            MOVE              Y0,X:<HOST_FLAG
758       P:00018A P:00018A 0D01B2            JSR     <FO_WRITE_HOST_FLAG
759       P:00018B P:00018B 0C0127            JMP     <GET_FO                           ; Keep looping for fiber optic commands
760    
761                                 CONTROLLER_RESET
762       P:00018C P:00018C 468900            MOVE              X:<FLAG_SYR,Y0          ; Flag = 4 => controller reset
763       P:00018D P:00018D 461E00            MOVE              Y0,X:<HOST_FLAG
764       P:00018E P:00018E 0D01B2            JSR     <FO_WRITE_HOST_FLAG
765       P:00018F P:00018F 0C0127            JMP     <GET_FO                           ; Keep looping for fiber optic commands
766    
767                                 CONTROLLER_BUSY
768       P:000190 P:000190 468B00            MOVE              X:<FLAG_BUSY,Y0         ; Flag = 6 => controller busy
769       P:000191 P:000191 461E00            MOVE              Y0,X:<HOST_FLAG
770       P:000192 P:000192 0D01B2            JSR     <FO_WRITE_HOST_FLAG
771       P:000193 P:000193 0C0127            JMP     <GET_FO                           ; Keep looping for fiber optic commands
772    
773                                 ; A special handshaking here ensures that the host computer has read the 'DON'
774                                 ;   reply to the start_exposure command before the reading_image state is
775                                 ;   set in the host flags. Reading_image occurs only after a start_exposure
776                                 READING_IMAGE
777    
778                                           IF      @SCP("SUPPORTED","SUPPORTED")
779       P:000194 P:000194 57BC00            MOVE              X:<PCI_HISTON,B
780       P:000195 P:000195 20000B            TST     B
781       P:000196 P:000196 0AF0AA            JEQ     DO_IMG
                            0001A2
782       P:000198 P:000198 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
783       P:000199 P:000199 000000            NOP
784       P:00019A P:00019A 64F400            MOVE              #F_READING_IMAGE,R4     ; tag
                            524449
785       P:00019C P:00019C 000000            NOP
786       P:00019D P:00019D 6C5B00            MOVE                          R4,Y:(R3)+
787       P:00019E P:00019E 000000            NOP
788                                           IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
789       P:00019F P:00019F 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
790       P:0001A0 P:0001A0 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
791                                           ENDIF
792    
793       P:0001A1 P:0001A1 633B00            MOVE              R3,X:<PCI_HISTFILL
794                                 DO_IMG
795                                           ENDIF
796    
797                                 READING_IMG
798       P:0001A2 P:0001A2 579E00            MOVE              X:<HOST_FLAG,B          ; Retrieve current host flag value
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 15



799       P:0001A3 P:0001A3 448A00            MOVE              X:<FLAG_RDI,X0
800       P:0001A4 P:0001A4 20004D            CMP     X0,B                              ; If we're already in read_image
801       P:0001A5 P:0001A5 0EA127            JEQ     <GET_FO                           ;   mode then do nothing
802       P:0001A6 P:0001A6 20000B            TST     B                                 ; Wait for flag to be cleared, which
803       P:0001A7 P:0001A7 0E21A2            JNE     <READING_IMG                      ;  the host does when it gets the DONE
804    
805       P:0001A8 P:0001A8 0A8500            BCLR    #HCIE,X:DCTR                      ; Disable host command interrupts
806       P:0001A9 P:0001A9 468A00            MOVE              X:<FLAG_RDI,Y0
807       P:0001AA P:0001AA 461E00            MOVE              Y0,X:<HOST_FLAG
808       P:0001AB P:0001AB 0D01B2            JSR     <FO_WRITE_HOST_FLAG               ; Set Host Flag to "reading out"
809       P:0001AC P:0001AC 0C0127            JMP     <GET_FO                           ; Keep looping for fiber optic commands
810    
811                                 READING_IMAGE_OFF                                   ; Controller is no longer reading out
812       P:0001AD P:0001AD 468500            MOVE              X:<FLAG_ZERO,Y0
813       P:0001AE P:0001AE 461E00            MOVE              Y0,X:<HOST_FLAG
814       P:0001AF P:0001AF 0D01B2            JSR     <FO_WRITE_HOST_FLAG
815       P:0001B0 P:0001B0 0A8520            BSET    #HCIE,X:DCTR                      ; Enable host command interrupts
816       P:0001B1 P:0001B1 0C0127            JMP     <GET_FO                           ; Keep looping for fiber optic commands
817    
818                                 ; Write X:<HOST_FLAG to the DCTR flag bits 5,4,3, as a subroutine
819                                 FO_WRITE_HOST_FLAG
820       P:0001B2 P:0001B2 57F000            MOVE              X:DCTR,B
                            FFFFC5
821       P:0001B4 P:0001B4 469E00            MOVE              X:<HOST_FLAG,Y0
822       P:0001B5 P:0001B5 0140CE            AND     #$FFFFC7,B                        ; Clear bits 5,4,3
                            FFFFC7
823       P:0001B7 P:0001B7 000000            NOP
824       P:0001B8 P:0001B8 20005A            OR      Y0,B                              ; Set flags appropriately
825       P:0001B9 P:0001B9 000000            NOP
826       P:0001BA P:0001BA 577000            MOVE              B,X:DCTR
                            FFFFC5
827       P:0001BC P:0001BC 00000C            RTS
828    
829                                 ; There was an erroneous word on the fiber optic line -> clear the FIFO
830       P:0001BD P:0001BD 07F42D  FO_ERR    MOVEP             #%010000,X:PDRD         ; Clear FIFO RESET* for 2 milliseconds
                            000010
831       P:0001BF P:0001BF 46F400            MOVE              #200000,Y0
                            030D40
832       P:0001C1 P:0001C1 06C600            DO      Y0,*+3
                            0001C3
833       P:0001C3 P:0001C3 000000            NOP
834       P:0001C4 P:0001C4 07F42D            MOVEP             #%010100,X:PDRD         ; Data Register - Set RS* high
                            000014
835       P:0001C6 P:0001C6 0C0127            JMP     <GET_FO
836    
837                                 ; **************  Boot from byte-wide on-board EEPROM  *******************
838    
839                                 BOOT_EEPROM
840       P:0001C7 P:0001C7 08F4BB            MOVEP             #$0002A0,X:BCR          ; Bus Control Register for slow EEPROM
                            0002A0
841       P:0001C9 P:0001C9 013D21            BSET    #1,X:PDRC                         ; ROM/FIFO* = 1 to select ROM
842       P:0001CA P:0001CA 044EBA            MOVE              OMR,A
843       P:0001CB P:0001CB 0140C6            AND     #$FFFFF0,A
                            FFFFF0
844       P:0001CD P:0001CD 014982            OR      #$000009,A                        ; Boot mode = $9 = byte-wide EEPROM
845       P:0001CE P:0001CE 000000            NOP
846       P:0001CF P:0001CF 04CEBA            MOVE              A,OMR
847       P:0001D0 P:0001D0 0AF080            JMP     $FF0000                           ; Jump to boot code internal to DSP
                            FF0000
848    
849                                 ; ***************  Command processing  ****************
850    
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 16



851                                 WRITE_COMMAND
852                                 ;       JCLR    #SRRQ,X:DSR,ERROR       ; Error if receiver FIFO has no data
853       P:0001D2 P:0001D2 0A89A2            JSET    #SRRQ,X:DSR,WCSTG1                ; Error if receiver FIFO has no data
                            0001D7
854       P:0001D4 P:0001D4 56F400            MOVE              #F_WCMDSTG1,A
                            575331
855       P:0001D6 P:0001D6 0C0200            JMP     <WC_ERROR
856    
857                                 WCSTG1
858       P:0001D7 P:0001D7 084E0B            MOVEP             X:DRXR,A                ; Get the header
859       P:0001D8 P:0001D8 000000            NOP                                       ; Pipeline restriction
860       P:0001D9 P:0001D9 543000            MOVE              A1,X:<HEADER
861    
862                                 ; Check the header bytes for self-consistency
863       P:0001DA P:0001DA 218400            MOVE              A1,X0
864       P:0001DB P:0001DB 56F400            MOVE              #$FCFCF8,A              ; Test for S.LE.3 and D.LE.3 and N.LE.7
                            FCFCF8
865       P:0001DD P:0001DD 200046            AND     X0,A
866                                 ;       JNE     <ERROR                  ; Test failed
867       P:0001DE P:0001DE 0EA1E2            JEQ     <WCSTG2
868       P:0001DF P:0001DF 56F400            MOVE              #F_WCMDSTG2,A           ; Test failed, illegal bits set
                            575332
869       P:0001E1 P:0001E1 0C0200            JMP     <WC_ERROR
870    
871                                 WCSTG2
872       P:0001E2 P:0001E2 56F400            MOVE              #$030300,A              ; Test for either S.NE.0 or D.NE.0
                            030300
873       P:0001E4 P:0001E4 200046            AND     X0,A
874                                 ;       JEQ     <ERROR                  ; Test failed- both 0
875       P:0001E5 P:0001E5 0E21E9            JNE     <WCSTG3
876       P:0001E6 P:0001E6 56F400            MOVE              #F_WCMDSTG3,A           ; Test failed- both 0
                            575333
877       P:0001E8 P:0001E8 0C0200            JMP     <WC_ERROR
878    
879                                 WCSTG3
880       P:0001E9 P:0001E9 56F400            MOVE              #>7,A
                            000007
881       P:0001EB P:0001EB 200046            AND     X0,A                              ; Extract NUM_ARG, must be >= 0
882       P:0001EC P:0001EC 000000            NOP                                       ; Pipeline restriction
883       P:0001ED P:0001ED 014284            SUB     #2,A
884                                 ;       JLT     <ERROR                  ; Number of arguments >= 0
885       P:0001EE P:0001EE 0E11F2            JGE     <WCSTG4                           ; Number of arguments >= 1
886       P:0001EF P:0001EF 56F400            MOVE              #F_WCMDSTG4,A
                            575334
887       P:0001F1 P:0001F1 0C0200            JMP     <WC_ERROR
888    
889                                 WCSTG4
890       P:0001F2 P:0001F2 543500            MOVE              A1,X:<NUM_ARG           ; Store number of arguments in command
891       P:0001F3 P:0001F3 014685            CMP     #6,A                              ; Number of arguments <= 6
892                                 ;       JGT     <ERROR
893       P:0001F4 P:0001F4 0EF1F8            JLE     <WCSTG5
894       P:0001F5 P:0001F5 56F400            MOVE              #F_WCMDSTG5,A           ; too many arguments
                            575335
895       P:0001F7 P:0001F7 0C0200            JMP     <WC_ERROR
896    
897                                 WCSTG5
898                                 ; Get the DESTINATION number (1 = PCI, 2 = timing, 3 = utility)
899       P:0001F8 P:0001F8 208E00            MOVE              X0,A                    ; Still the header
900       P:0001F9 P:0001F9 0C1ED0            LSR     #8,A
901       P:0001FA P:0001FA 0140C6            AND     #>3,A                             ; Extract just three bits of
                            000003
902       P:0001FC P:0001FC 543400            MOVE              A1,X:<DESTINATION       ;   the destination byte
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 17



903                                 ;       JEQ     <ERROR                  ; Destination of zero = host not allowed
904       P:0001FD P:0001FD 0E2229            JNE     <WCSTG6                           ; Destination of zero = host not allowed
905       P:0001FE P:0001FE 56F400            MOVE              #F_WCMDSTG6,A           ; destination = host
                            575336
906    
907                                 WC_ERROR
908                                           IF      @SCP("SUPPORTED","SUPPORTED")
909       P:000200 P:000200 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
910       P:000201 P:000201 000000            NOP
911       P:000202 P:000202 000000            NOP
912       P:000203 P:000203 000000            NOP
913       P:000204 P:000204 5C5B00            MOVE                          A1,Y:(R3)+
914       P:000205 P:000205 000000            NOP
915       P:000206 P:000206 56BC00            MOVE              X:<PCI_HISTON,A
916       P:000207 P:000207 200003            TST     A
917       P:000208 P:000208 0EA20D            JEQ     <DO_FIFO0
918                                           IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
919       P:000209 P:000209 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
920       P:00020A P:00020A 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
921                                           ENDIF
922       P:00020B P:00020B 633B00            MOVE              R3,X:<PCI_HISTFILL
923       P:00020C P:00020C 000000            NOP
924    
925                                 ;       the fiber loop wraps PCI_HIST when it gets the chance.
926                                           ENDIF
927    
928                                 DO_FIFO0
929                                 ;       now clear out anything remaining in the fifo. If history is on, the
930                                 ;       second parameter (or the first if only 1) will be logged, assuming
931                                 ;       anything is there at all. It's really a violation of the command
932                                 ;       protocol and should never occur.
933       P:00020D P:00020D 0A8982            JCLR    #SRRQ,X:DSR,DO_ERROR              ; Is the receiver empty?
                            000228
934    
935       P:00020F P:00020F 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
936       P:000210 P:000210 000000            NOP                                       ; wait for flag to toggle
937       P:000211 P:000211 0A8982            JCLR    #SRRQ,X:DSR,LOG_RCV0              ; If now empty, go log parameter 1.
                            000215
938       P:000213 P:000213 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
939       P:000214 P:000214 000000            NOP                                       ; wait for flag to toggle
940                                 LOG_RCV0
941    
942                                           IF      @SCP("SUPPORTED","SUPPORTED")
943       P:000215 P:000215 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
944       P:000216 P:000216 000000            NOP
945       P:000217 P:000217 000000            NOP
946       P:000218 P:000218 000000            NOP
947       P:000219 P:000219 585B00            MOVE                          A0,Y:(R3)+
948       P:00021A P:00021A 000000            NOP
949       P:00021B P:00021B 56BC00            MOVE              X:<PCI_HISTON,A
950       P:00021C P:00021C 200003            TST     A
951       P:00021D P:00021D 0AF0AA            JEQ     DO_ENDFIFO0
                            000223
952                                           IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
953       P:00021F P:00021F 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
954       P:000220 P:000220 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
955                                           ENDIF
956       P:000221 P:000221 633B00            MOVE              R3,X:<PCI_HISTFILL
957       P:000222 P:000222 000000            NOP
958    
959                                 ;       the fiber loop wraps PCI_HIST when it gets the chance.
960                                           ENDIF
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 18



961    
962                                 DO_ENDFIFO0
963       P:000223 P:000223 0A8982            JCLR    #SRRQ,X:DSR,DO_ERROR              ; Wait for the receiver to be empty
                            000228
964       P:000225 P:000225 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
965       P:000226 P:000226 000000            NOP                                       ; wait for flag to toggle
966       P:000227 P:000227 0C0223            JMP     DO_ENDFIFO0
967    
968    
969                                 DO_ERROR
970       P:000228 P:000228 0C05DB            JMP     <ERROR                            ; various errors in cmd recognition
971    
972                                 WCSTG6
973    
974       P:000229 P:000229 014185            CMP     #1,A                              ; Destination byte for PCI board
975       P:00022A P:00022A 0EA262            JEQ     <PCI
976    
977                                 ; Write the controller command and its arguments to the fiber optics
978       P:00022B P:00022B 56B000            MOVE              X:<HEADER,A
979       P:00022C P:00022C 0BF080            JSR     XMT_WRD                           ; Write the word to the fiber optics
                            000619
980       P:00022E P:00022E 0A8982            JCLR    #SRRQ,X:DSR,ERROR                 ; Error if receiver FIFO has no data
                            0005DB
981       P:000230 P:000230 084E0B            MOVEP             X:DRXR,A                ; Write the command
982       P:000231 P:000231 0D0619            JSR     <XMT_WRD                          ; Write the command to the fiber optics
983    
984                                           IF      @SCP("SUPPORTED","SUPPORTED")
985       P:000232 P:000232 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
986       P:000233 P:000233 000000            NOP
987       P:000234 P:000234 000000            NOP
988       P:000235 P:000235 000000            NOP
989       P:000236 P:000236 5C5B00            MOVE                          A1,Y:(R3)+
990       P:000237 P:000237 000000            NOP
991       P:000238 P:000238 56BC00            MOVE              X:<PCI_HISTON,A
992       P:000239 P:000239 200003            TST     A
993       P:00023A P:00023A 0AF0AA            JEQ     DO_ARGS
                            000240
994                                           IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
995       P:00023C P:00023C 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
996       P:00023D P:00023D 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
997                                           ENDIF
998       P:00023E P:00023E 633B00            MOVE              R3,X:<PCI_HISTFILL
999       P:00023F P:00023F 000000            NOP
1000                                DO_ARGS
1001                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
1002                                          ENDIF
1003   
1004      P:000240 P:000240 063500            DO      X:<NUM_ARG,L_ARGS1                ; Do loop won't execute if NUM_ARG = 0
                            000244
1005      P:000242 P:000242 084E0B            MOVEP             X:DRXR,A                ; Get the arguments
1006      P:000243 P:000243 0D0619            JSR     <XMT_WRD                          ; Write the argument to the fiber optics
1007      P:000244 P:000244 000000            NOP                                       ; DO loop restriction
1008                                L_ARGS1
1009                                ;       now clear out anything remaining in the fifo. If history is on, the
1010                                ;       second parameter (or the first if only 1) will be logged, assuming
1011                                ;       anything is there at all. It's really a violation of the command
1012                                ;       protocol and should never occur.
1013      P:000245 P:000245 0A8982            JCLR    #SRRQ,X:DSR,END_CMCTRLR           ; Is the receiver empty?
                            000261
1014   
1015      P:000247 P:000247 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
1016      P:000248 P:000248 000000            NOP                                       ; wait for flag to toggle
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 19



1017      P:000249 P:000249 0A8982            JCLR    #SRRQ,X:DSR,LOG_RCV1              ; If now empty, go log parameter 1.
                            00024D
1018      P:00024B P:00024B 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
1019      P:00024C P:00024C 000000            NOP                                       ; wait for flag to toggle
1020                                LOG_RCV1
1021   
1022                                          IF      @SCP("SUPPORTED","SUPPORTED")
1023      P:00024D P:00024D 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1024      P:00024E P:00024E 000000            NOP
1025      P:00024F P:00024F 000000            NOP
1026      P:000250 P:000250 000000            NOP
1027      P:000251 P:000251 585B00            MOVE                          A0,Y:(R3)+
1028      P:000252 P:000252 000000            NOP
1029      P:000253 P:000253 56BC00            MOVE              X:<PCI_HISTON,A
1030      P:000254 P:000254 200003            TST     A
1031      P:000255 P:000255 0AF0AA            JEQ     DO_ENDFIFO1
                            00025C
1032                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1033      P:000257 P:000257 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1034      P:000258 P:000258 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1035                                          ENDIF
1036      P:000259 P:000259 633B00            MOVE              R3,X:<PCI_HISTFILL
1037      P:00025A P:00025A 000000            NOP
1038      P:00025B P:00025B 000000            NOP
1039   
1040                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
1041                                          ENDIF
1042   
1043                                DO_ENDFIFO1
1044      P:00025C P:00025C 0A8982            JCLR    #SRRQ,X:DSR,END_CMCTRLR           ; Wait for the receiver to be empty
                            000261
1045      P:00025E P:00025E 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
1046      P:00025F P:00025F 000000            NOP                                       ; wait for flag to toggle
1047      P:000260 P:000260 0C025C            JMP     DO_ENDFIFO1
1048   
1049                                END_CMCTRLR
1050      P:000261 P:000261 000004            RTI                                       ; The other board will generate reply
1051   
1052                                ; Since it's a PCI command store the command and its arguments in X: memory
1053      P:000262 P:000262 0A8982  PCI       JCLR    #SRRQ,X:DSR,ERROR                 ; Error if receiver FIFO has no data
                            0005DB
1054      P:000264 P:000264 08708B            MOVEP             X:DRXR,X:COMMAND        ; Get the command
                            000031
1055      P:000266 P:000266 56B500            MOVE              X:<NUM_ARG,A            ; Get number of arguments in command
1056      P:000267 P:000267 60F400            MOVE              #ARG1,R0                ; Starting address of argument list
                            000032
1057      P:000269 P:000269 06CE00            DO      A,L_ARGS2                         ; DO loop won't execute if A = 0
                            00026D
1058      P:00026B P:00026B 0A8982            JCLR    #SRRQ,X:DSR,ERROR                 ; Error if receiver FIFO has no data
                            0005DB
1059      P:00026D P:00026D 08588B            MOVEP             X:DRXR,X:(R0)+          ; Get arguments
1060                                L_ARGS2
1061   
1062                                ;       now clear out anything remaining in the fifo. If history is on, the
1063                                ;       second parameter (or the first if only 1) will be logged, assuming
1064                                ;       anything is there at all. It's really a violation of the command
1065                                ;       protocol and should never occur.
1066      P:00026E P:00026E 0A8982            JCLR    #SRRQ,X:DSR,PCI_COMMAND           ; Is the receiver empty?
                            000289
1067   
1068      P:000270 P:000270 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
1069      P:000271 P:000271 000000            NOP                                       ; wait for flag to toggle
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 20



1070      P:000272 P:000272 0A8982            JCLR    #SRRQ,X:DSR,LOG_RCV2              ; If now empty, go log parameter 1.
                            000276
1071      P:000274 P:000274 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
1072      P:000275 P:000275 000000            NOP                                       ; wait for flag to toggle
1073                                LOG_RCV2
1074   
1075                                          IF      @SCP("SUPPORTED","SUPPORTED")
1076      P:000276 P:000276 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1077      P:000277 P:000277 000000            NOP
1078      P:000278 P:000278 000000            NOP
1079      P:000279 P:000279 000000            NOP
1080      P:00027A P:00027A 585B00            MOVE                          A0,Y:(R3)+
1081      P:00027B P:00027B 000000            NOP
1082      P:00027C P:00027C 56BC00            MOVE              X:<PCI_HISTON,A
1083      P:00027D P:00027D 200003            TST     A
1084      P:00027E P:00027E 0AF0AA            JEQ     DO_ENDFIFO2
                            000284
1085                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1086      P:000280 P:000280 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1087      P:000281 P:000281 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1088                                          ENDIF
1089      P:000282 P:000282 633B00            MOVE              R3,X:<PCI_HISTFILL
1090      P:000283 P:000283 000000            NOP
1091   
1092                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
1093                                          ENDIF
1094   
1095                                DO_ENDFIFO2
1096      P:000284 P:000284 0A8982            JCLR    #SRRQ,X:DSR,PCI_COMMAND           ; Wait for the receiver to be empty
                            000289
1097      P:000286 P:000286 08480B            MOVEP             X:DRXR,A0               ; Read receiver to empty one word
1098      P:000287 P:000287 000000            NOP                                       ; wait for flag to toggle
1099      P:000288 P:000288 0C0284            JMP     DO_ENDFIFO2
1100   
1101   
1102                                ; Process a PCI board non-vector command
1103                                PCI_COMMAND
1104      P:000289 P:000289 56B100            MOVE              X:<COMMAND,A            ; Get the command
1105   
1106                                          IF      @SCP("SUPPORTED","SUPPORTED")
1107      P:00028A P:00028A 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1108      P:00028B P:00028B 000000            NOP
1109      P:00028C P:00028C 000000            NOP
1110      P:00028D P:00028D 000000            NOP
1111      P:00028E P:00028E 5C5B00            MOVE                          A1,Y:(R3)+
1112      P:00028F P:00028F 000000            NOP
1113      P:000290 P:000290 56BC00            MOVE              X:<PCI_HISTON,A
1114      P:000291 P:000291 200003            TST     A
1115      P:000292 P:000292 0AF0AA            JEQ     DO_CMDPCI
                            000298
1116                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1117      P:000294 P:000294 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1118      P:000295 P:000295 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1119                                          ENDIF
1120      P:000296 P:000296 633B00            MOVE              R3,X:<PCI_HISTFILL
1121      P:000297 P:000297 000000            NOP
1122                                DO_CMDPCI
1123      P:000298 P:000298 56B100            MOVE              X:<COMMAND,A            ; Get the command
1124      P:000299 P:000299 000000            NOP
1125                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
1126                                          ENDIF
1127   
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 21



1128      P:00029A P:00029A 0140C5            CMP     #'TRM',A                          ; Is it the test DRAM command?
                            54524D
1129      P:00029C P:00029C 0EA66D            JEQ     <TEST_DRAM
1130      P:00029D P:00029D 0140C5            CMP     #'TDL',A                          ; Is it the test data link command?
                            54444C
1131      P:00029F P:00029F 0EA554            JEQ     <TEST_DATA_LINK
1132      P:0002A0 P:0002A0 0140C5            CMP     #'RDM',A
                            52444D
1133      P:0002A2 P:0002A2 0EA556            JEQ     <READ_MEMORY                      ; Is it the read memory command?
1134      P:0002A3 P:0002A3 0140C5            CMP     #'WRM',A
                            57524D
1135      P:0002A5 P:0002A5 0EA581            JEQ     <WRITE_MEMORY                     ; Is it the write memory command?
1136   
1137                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1138      P:0002A6 P:0002A6 0140C5            CMP     #'GTK',A
                            47544B
1139      P:0002A8 P:0002A8 0EA5B1            JEQ     <GET_TICK                         ; Is it Get Ticks?
1140                                          ENDIF
1141      P:0002A9 P:0002A9 0140C5            CMP     #'INF',A
                            494E46
1142      P:0002AB P:0002AB 0EA5B9            JEQ     <GET_INFO                         ; Is it Get Info?
1143   
1144      P:0002AC P:0002AC 0C05DB            JMP     <ERROR                            ; Its not a recognized command
1145   
1146                                ; ********************  Vector commands  *******************
1147   
1148                                READ_NUMBER_OF_PIXELS_READ                          ; Write the reply to the DTXS FIFO
1149   
1150                                          IF      @SCP("SUPPORTED","SUPPORTED")
1151      P:0002AD P:0002AD 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1152      P:0002AE P:0002AE 000000            NOP
1153      P:0002AF P:0002AF 64F400            MOVE              #H_RDNUMPIX,R4
                            524E50
1154      P:0002B1 P:0002B1 6C5B00            MOVE                          R4,Y:(R3)+  ; tag
1155                                ;       the main readout loop wraps PCI_HISTFILL when it gets the chance.
1156                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1157      P:0002B2 P:0002B2 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1158      P:0002B3 P:0002B3 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1159                                          ENDIF
1160      P:0002B4 P:0002B4 000000            NOP
1161      P:0002B5 P:0002B5 633B00            MOVE              R3,X:<PCI_HISTFILL
1162      P:0002B6 P:0002B6 000000            NOP
1163                                          ENDIF
1164   
1165      P:0002B7 P:0002B7 0A3EA0            JSET    #0,X:<R_PXLS_CRIT,SEND_RPXLS_LAST ;are R_PXLS 'safe'?
                            0002BF
1166   
1167      P:0002B9 P:0002B9 08F08D            MOVEP             X:R_PXLS_0,X:DTXS       ; DSP-to-host slave transmit
                            000018
1168      P:0002BB P:0002BB 000000            NOP
1169      P:0002BC P:0002BC 08F08D            MOVEP             X:R_PXLS_1,X:DTXS       ; DSP-to-host slave transmit
                            000017
1170   
1171      P:0002BE P:0002BE 000004            RTI
1172   
1173                                ;       use the safe copy in RPXLS_SAFE
1174                                SEND_RPXLS_LAST
1175      P:0002BF P:0002BF 65F400            MOVE              #RPXLS_SAFE,R5
                            0007E0
1176      P:0002C1 P:0002C1 0A3E21            BSET    #1,X:<R_PXLS_CRIT                 ; mark race as having happened
1177      P:0002C2 P:0002C2 000000            NOP
1178      P:0002C3 P:0002C3 08DDCD            MOVEP             Y:(R5)+,X:DTXS          ;DSP-to-host slave transmit
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 22



1179      P:0002C4 P:0002C4 000000            NOP
1180      P:0002C5 P:0002C5 08DDCD            MOVEP             Y:(R5)+,X:DTXS          ;DSP-to-host slave transmit
1181   
1182      P:0002C6 P:0002C6 000004            RTI
1183   
1184                                ; Reset the controller by sending a special code for the preamble byte
1185                                RESET_CONTROLLER
1186      P:0002C7 P:0002C7 01B786            JCLR    #TDE,X:SSISR0,*
                            0002C7
1187      P:0002C9 P:0002C9 07F43C            MOVEP             #$000000,X:TX00
                            000000
1188      P:0002CB P:0002CB 000000            NOP
1189      P:0002CC P:0002CC 01B786            JCLR    #TDE,X:SSISR0,*                   ; Start bit
                            0002CC
1190      P:0002CE P:0002CE 07F43C            MOVEP             #$010000,X:TX00
                            010000
1191      P:0002D0 P:0002D0 000000            NOP
1192      P:0002D1 P:0002D1 01B786            JCLR    #TDE,X:SSISR0,*
                            0002D1
1193      P:0002D3 P:0002D3 07F43C            MOVEP             #$530000,X:TX00         ; Preamble byte = reset
                            530000
1194      P:0002D5 P:0002D5 000000            NOP
1195      P:0002D6 P:0002D6 060380            DO      #3,L_RESET
                            0002DB
1196      P:0002D8 P:0002D8 01B786            JCLR    #TDE,X:SSISR0,*                   ; Three data bytes = anything
                            0002D8
1197      P:0002DA P:0002DA 04CCDC            MOVEP             A1,X:TX00
1198      P:0002DB P:0002DB 000000            NOP
1199                                L_RESET
1200      P:0002DC P:0002DC 01B786            JCLR    #TDE,X:SSISR0,*                   ; Zeroes to bring TX00 low
                            0002DC
1201      P:0002DE P:0002DE 07F43C            MOVEP             #$000000,X:TX00
                            000000
1202      P:0002E0 P:0002E0 07F42D            MOVEP             #%010000,X:PDRD         ; Reset the receiver FIFO
                            000010
1203      P:0002E2 P:0002E2 060AA0            REP     #10
1204      P:0002E3 P:0002E3 000000            NOP
1205      P:0002E4 P:0002E4 07F42D            MOVEP             #%010100,X:PDRD         ; Stop resetting the FIFO
                            000014
1206   
1207                                ; Wait around for the 'SYR' reply from the controller
1208      P:0002E6 P:0002E6 0D063B            JSR     <RD_FO_TIMEOUT                    ; Move the FIFO reply into A1
1209      P:0002E7 P:0002E7 0E85DB            JCS     <ERROR
1210      P:0002E8 P:0002E8 0140CD            CMP     #$020002,B
                            020002
1211      P:0002EA P:0002EA 0E25DB            JNE     <ERROR                            ; There was an error
1212      P:0002EB P:0002EB 01AD80            JCLR    #EF,X:PDRD,*                      ; Test for new fiber optic data
                            0002EB
1213      P:0002ED P:0002ED 0D063B            JSR     <RD_FO_TIMEOUT                    ; Move the FIFO reply into A1
1214      P:0002EE P:0002EE 0E85DB            JCS     <ERROR
1215      P:0002EF P:0002EF 0140CD            CMP     #'SYR',B
                            535952
1216      P:0002F1 P:0002F1 0E25DB            JNE     <ERROR                            ; There was an error
1217      P:0002F2 P:0002F2 0C05DE            JMP     <SYR                              ; Reply to host, return from interrupt
1218   
1219                                ; ****************  Exposure and readout commands  ****************
1220   
1221                                WRITE_BASE_PCI_ADDRESS
1222      P:0002F3 P:0002F3 0A8982            JCLR    #SRRQ,X:DSR,ERROR                 ; Error if receiver FIFO has no data
                            0005DB
1223      P:0002F5 P:0002F5 08480B            MOVEP             X:DRXR,A0
1224      P:0002F6 P:0002F6 0A8982            JCLR    #SRRQ,X:DSR,ERROR                 ; Error if receiver FIFO has no data
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 23



                            0005DB
1225      P:0002F8 P:0002F8 08440B            MOVEP             X:DRXR,X0               ; Get most significant word
1226      P:0002F9 P:0002F9 0C1940            INSERT  #$010010,X0,A
                            010010
1227      P:0002FB P:0002FB 000000            NOP
1228      P:0002FC P:0002FC 501A00            MOVE              A0,X:<BASE_ADDR_0       ; BASE_ADDR is 8 + 24 bits
1229      P:0002FD P:0002FD 541900            MOVE              A1,X:<BASE_ADDR_1
1230   
1231                                          IF      @SCP("SUPPORTED","SUPPORTED")
1232      P:0002FE P:0002FE 56BC00            MOVE              X:<PCI_HISTON,A
1233      P:0002FF P:0002FF 200003            TST     A
1234      P:000300 P:000300 0AF0AA            JEQ     DO_DON
                            00030B
1235      P:000302 P:000302 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1236      P:000303 P:000303 000000            NOP
1237      P:000304 P:000304 64F400            MOVE              #H_BASEPCIADDR,R4       ; tag
                            574250
1238      P:000306 P:000306 6C5B00            MOVE                          R4,Y:(R3)+
1239      P:000307 P:000307 000000            NOP
1240                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1241      P:000308 P:000308 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1242      P:000309 P:000309 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1243                                          ENDIF
1244      P:00030A P:00030A 633B00            MOVE              R3,X:<PCI_HISTFILL
1245                                DO_DON
1246                                          ENDIF
1247   
1248                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
1249      P:00030B P:00030B 0C05D4            JMP     <FINISH                           ; Write 'DON' reply
1250   
1251                                ; Write the base PCI image address to the PCI address
1252                                INITIALIZE_NUMBER_OF_PIXELS
1253   
1254                                          IF      @SCP("SUPPORTED","SUPPORTED")
1255      P:00030C P:00030C 56BC00            MOVE              X:<PCI_HISTON,A
1256      P:00030D P:00030D 200003            TST     A
1257      P:00030E P:00030E 0AF0AA            JEQ     DO_NPIX
                            00031A
1258      P:000310 P:000310 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1259      P:000311 P:000311 000000            NOP
1260      P:000312 P:000312 64F400            MOVE              #F_INIT_NO_PIX,R4       ; tag
                            494941
1261      P:000314 P:000314 000000            NOP
1262      P:000315 P:000315 6C5B00            MOVE                          R4,Y:(R3)+
1263      P:000316 P:000316 000000            NOP
1264                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1265      P:000317 P:000317 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1266      P:000318 P:000318 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1267                                          ENDIF
1268      P:000319 P:000319 633B00            MOVE              R3,X:<PCI_HISTFILL
1269                                DO_NPIX
1270                                          ENDIF
1271   
1272      P:00031A P:00031A 200013            CLR     A
1273      P:00031B P:00031B 000000            NOP
1274      P:00031C P:00031C 541700            MOVE              A1,X:<R_PXLS_1          ; Up counter of number of pixels read
1275      P:00031D P:00031D 501800            MOVE              A0,X:<R_PXLS_0
1276      P:00031E P:00031E 503E00            MOVE              A0,X:<R_PXLS_CRIT       ; mark safe
1277      P:00031F P:00031F 503F00            MOVE              A0,X:<R_PXLS_RACE       ; clear stats
1278   
1279      P:000320 P:000320 509A00            MOVE              X:<BASE_ADDR_0,A0       ; BASE_ADDR is 2 x 16-bits
1280      P:000321 P:000321 549900            MOVE              X:<BASE_ADDR_1,A1
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 24



1281      P:000322 P:000322 000000            NOP
1282      P:000323 P:000323 501C00            MOVE              A0,X:<PCI_ADDR_0        ; PCI_ADDR is 8 + 24 bits
1283      P:000324 P:000324 541B00            MOVE              A1,X:<PCI_ADDR_1
1284   
1285   
1286      P:000325 P:000325 0C0184            JMP     <CONTROLLER_DONE                  ; Repy = DONE host flags
1287   
1288                                ; Send an abort readout command to the controller to stop image transmission
1289                                ABORT_READOUT
1290      P:000326 P:000326 448600            MOVE              X:<FLAG_DONE,X0
1291      P:000327 P:000327 441E00            MOVE              X0,X:<HOST_FLAG
1292      P:000328 P:000328 0D01B2            JSR     <FO_WRITE_HOST_FLAG
1293   
1294      P:000329 P:000329 568E00            MOVE              X:<C000202,A
1295      P:00032A P:00032A 0D0619            JSR     <XMT_WRD                          ; Timing board header word
1296      P:00032B P:00032B 56F400            MOVE              #'ABR',A
                            414252
1297      P:00032D P:00032D 0D0619            JSR     <XMT_WRD                          ; Abort Readout
1298   
1299      P:00032E P:00032E 200013            CLR     A
1300   
1301      P:00032F P:00032F 0140C0  ABR0      ADD     #>1,A
                            000001
1302                                ; Ensure that image data is no longer being received from the controller
1303      P:000331 P:000331 01AD80            JCLR    #EF,X:PDRD,ABR2                   ; Test for incoming FIFO data
                            000337
1304      P:000333 P:000333 09443F  ABR1      MOVEP             Y:RDFIFO,X0             ; Read the FIFO until its empty
1305      P:000334 P:000334 000000            NOP
1306      P:000335 P:000335 01ADA0            JSET    #EF,X:PDRD,ABR1
                            000333
1307      P:000337 P:000337 066089  ABR2      DO      #2400,ABR3                        ; Wait for about 30 microsec in case
                            000339
1308      P:000339 P:000339 000000            NOP                                       ;   FIFO data is still arriving
1309      P:00033A P:00033A 01ADA0  ABR3      JSET    #EF,X:PDRD,ABR1                   ; Keep emptying if more data arrived
                            000333
1310      P:00033C P:00033C 012D24            BSET    #MODE,X:PDRD                      ; Put the fiber optics in 32-bit mode
1311      P:00033D P:00033D 543A00            MOVE              A1,X:<ABT_PIXELS
1312      P:00033E P:00033E 06FF8F            DO      #4095,PUNT                        ; Wait
                            000340
1313      P:000340 P:000340 000000            NOP
1314      P:000341 P:000341 000000  PUNT      NOP
1315   
1316                                ; Clean up the PCI board from wherever it was executing
1317                                CLEAN_UP_PCI
1318      P:000342 P:000342 08F4BF            MOVEP             #$0001C0,X:IPRC         ; Disable HF* FIFO interrupt
                            0001C0
1319      P:000344 P:000344 0A8520            BSET    #HCIE,X:DCTR                      ; Enable host command interrupts
1320      P:000345 P:000345 0501BB            MOVEC             #1,SP                   ; Point stack pointer to the top
1321      P:000346 P:000346 05F43D            MOVEC             #$000200,SSL            ; SR = zero except for interrupts
                            000200
1322      P:000348 P:000348 0500BB            MOVEC             #0,SP                   ; Writing to SSH preincrements the SP
1323      P:000349 P:000349 05B2BC            MOVEC             #START,SSH              ; Set PC to for full initialization
1324      P:00034A P:00034A 000000            NOP
1325      P:00034B P:00034B 000004            RTI
1326   
1327                                ; Read the image - change the serial receiver to expect 16-bit (image) data
1328                                READ_IMAGE
1329   
1330                                          IF      @SCP("SUPPORTED","SUPPORTED")
1331                                                                                    ; give the host a chance to clear host flags
 (FWIW).
1332      P:00034C P:00034C 063D00            DO      X:<WAIT_RDA,*+3                   ; Do loop won't execute if WAIT_RDA = 0
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 25



                            00034E
1333      P:00034E P:00034E 000000            NOP
1334                                          ENDIF
1335   
1336      P:00034F P:00034F 0A8500            BCLR    #HCIE,X:DCTR                      ; Disable host command interrupts
1337      P:000350 P:000350 448A00            MOVE              X:<FLAG_RDI,X0
1338      P:000351 P:000351 441E00            MOVE              X0,X:<HOST_FLAG
1339      P:000352 P:000352 0D01B2            JSR     <FO_WRITE_HOST_FLAG               ; Set HCTR bits to "reading out"
1340      P:000353 P:000353 084E0A            MOVEP             X:DPSR,A                ; Clear all PCI error conditions
1341      P:000354 P:000354 0140C2            OR      #$1FE,A
                            0001FE
1342      P:000356 P:000356 000000            NOP
1343      P:000357 P:000357 08CE0A            MOVEP             A,X:DPSR
1344      P:000358 P:000358 0A862E            BSET    #CLRT,X:DPCR                      ; Clear the master transmitter FIFO
1345      P:000359 P:000359 0A86AE            JSET    #CLRT,X:DPCR,*                    ; Wait for the clearing to be complete
                            000359
1346   
1347                                          IF      @SCP("SUPPORTED","SUPPORTED")
1348      P:00035B P:00035B 56BC00            MOVE              X:<PCI_HISTON,A
1349      P:00035C P:00035C 200003            TST     A
1350      P:00035D P:00035D 0AF0AA            JEQ     DO_PXL
                            000369
1351      P:00035F P:00035F 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
1352      P:000360 P:000360 000000            NOP
1353      P:000361 P:000361 64F400            MOVE              #F_READ_IMAGE,R4        ; tag
                            524441
1354      P:000363 P:000363 000000            NOP
1355      P:000364 P:000364 6C5B00            MOVE                          R4,Y:(R3)+
1356      P:000365 P:000365 000000            NOP
1357                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1358      P:000366 P:000366 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
1359      P:000367 P:000367 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
1360                                          ENDIF
1361      P:000368 P:000368 633B00            MOVE              R3,X:<PCI_HISTFILL
1362                                DO_PXL
1363                                          ENDIF
1364   
1365   
1366                                ; Compute the number of pixels to read from the controller
1367      P:000369 P:000369 0D063B            JSR     <RD_FO_TIMEOUT                    ; Read number of columns
1368      P:00036A P:00036A 0E81BD            JCS     <FO_ERR
1369      P:00036B P:00036B 21A500            MOVE              B1,X1
1370      P:00036C P:00036C 0D063B            JSR     <RD_FO_TIMEOUT                    ; Read number of rows
1371      P:00036D P:00036D 0E81BD            JCS     <FO_ERR
1372      P:00036E P:00036E 012D04            BCLR    #MODE,X:PDRD                      ; Put the fiber optics in 16-bit mode
1373      P:00036F P:00036F 21A700            MOVE              B1,Y1                   ; Number of rows to read is in Y1
1374      P:000370 P:000370 2000F0            MPY     X1,Y1,A
1375      P:000371 P:000371 200022            ASR     A                                 ; Correct for 0 in LS bit after MPY
1376      P:000372 P:000372 000000            NOP
1377      P:000373 P:000373 541300            MOVE              A1,X:<NPXLS_1           ; NPXLS set by controller
1378      P:000374 P:000374 501400            MOVE              A0,X:<NPXLS_0
1379   
1380                                                                                    ; Make sure the PCI address is on a 512 pixe
l boundary
1381      P:000375 P:000375 569C00            MOVE              X:<PCI_ADDR_0,A         ; Current PCI address
1382      P:000376 P:000376 0140C6            AND     #$0003FF,A                        ; If addr .and. $3FF .ne. 0 then
                            0003FF
1383      P:000378 P:000378 0EA386            JEQ     <IM_INIT                          ;   addr = (addr + $400) .and. $FFFC00
1384      P:000379 P:000379 549B00            MOVE              X:<PCI_ADDR_1,A1
1385      P:00037A P:00037A 509C00            MOVE              X:<PCI_ADDR_0,A0
1386      P:00037B P:00037B 250000            MOVE              #0,X1
1387      P:00037C P:00037C 44F400            MOVE              #$400,X0
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 26



                            000400
1388      P:00037E P:00037E 200020            ADD     X,A
1389      P:00037F P:00037F 000000            NOP
1390      P:000380 P:000380 541B00            MOVE              A1,X:<PCI_ADDR_1
1391      P:000381 P:000381 210D00            MOVE              A0,B1
1392      P:000382 P:000382 0140CE            AND     #$FFFC00,B
                            FFFC00
1393      P:000384 P:000384 000000            NOP
1394      P:000385 P:000385 551C00            MOVE              B1,X:<PCI_ADDR_0
1395   
1396      P:000386 P:000386 20001B  IM_INIT   CLR     B
1397                                ;     a pad of zeroes as sentinel if we overrun on the DMA phase.
1398                                ;     clear the whole image buffer and again as much beyond.
1399      P:000387 P:000387 61F400            MOVE              #IMAGE_BUFER,R1
                            000000
1400      P:000389 P:000389 06D087            DO      #2000,Z_BUFFER
                            00038B
1401      P:00038B P:00038B 5D5900            MOVE                          B1,Y:(R1)+
1402                                Z_BUFFER
1403      P:00038C P:00038C 62F400            MOVE              #PCI_ERRLOGFIRST,R2     ; error buffer to record pci dma events
                            000400
1404      P:00038E P:00038E 552800            MOVE              B1,X:<PCI_BURST_NO      ; overall count of pci bursts completed
1405      P:00038F P:00038F 551500            MOVE              B1,X:<IPXLS_1           ; IPXLS = 0
1406      P:000390 P:000390 511600            MOVE              B0,X:<IPXLS_0
1407      P:000391 P:000391 212500            MOVE              B0,X1                   ; X = 512 = 1/2 the FIFO depth
1408      P:000392 P:000392 448C00            MOVE              X:<C512,X0
1409      P:000393 P:000393 66F400            MOVE              #RDFIFO,R6
                            FFFFFF
1410   
1411   
1412                                ; There are four separate stages of writing the image to the PCI bus
1413                                ;       a. Write complete 512 pixel FIFO half full blocks
1414                                ;       b. Write the pixels left over from the last complete FIFO block
1415                                ;               in blocks of 32 pixels
1416                                ;       c. Write the pixels left over from the last 32 pixel block
1417                                ;       d. If the number of pixels in the image is odd write the very last pixel
1418   
1419   
1420                                ; Compute the number of pixel pairs from the FIFO --> PCI bus
1421                                L_FIFO
1422   
1423                                          IF      @SCP("SUPPORTED","SUPPORTED")
1424      P:000395 P:000395 200013            CLR     A
1425   
1426      P:000396 P:000396 54BB00            MOVE              X:<PCI_HISTFILL,A1
1427      P:000397 P:000397 000000            NOP
1428      P:000398 P:000398 0140C4            SUB     #PCI_HISTEND,A
                            001000
1429      P:00039A P:00039A 000000            NOP
1430      P:00039B P:00039B 0AF0A9            JLT     CHK_FO_RDO
                            0003A1
1431      P:00039D P:00039D 54F400            MOVE              #PCI_HISTFIRST,A1       ; hist buffer ptr wrapped
                            000800
1432      P:00039F P:00039F 000000            NOP
1433      P:0003A0 P:0003A0 543B00            MOVE              A1,X:<PCI_HISTFILL
1434                                          ENDIF
1435   
1436                                CHK_FO_RDO
1437      P:0003A1 P:0003A1 200013            CLR     A
1438      P:0003A2 P:0003A2 549300            MOVE              X:<NPXLS_1,A1           ; Number of pixels to write to PCI
1439      P:0003A3 P:0003A3 509400            MOVE              X:<NPXLS_0,A0
1440      P:0003A4 P:0003A4 479500            MOVE              X:<IPXLS_1,Y1           ; Compare it to image pixels written.
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 27



1441      P:0003A5 P:0003A5 469600            MOVE              X:<IPXLS_0,Y0
1442      P:0003A6 P:0003A6 000000            NOP
1443      P:0003A7 P:0003A7 200034            SUB     Y,A                               ; If (Image size - Ipxls)  <= 512
1444      P:0003A8 P:0003A8 000000            NOP                                       ;   we're at the end of the image
1445      P:0003A9 P:0003A9 200024            SUB     X,A
1446      P:0003AA P:0003AA 0EF422            JLE     <WRITE_LAST_LITTLE_BIT_OF_IMAGE
1447   
1448   
1449                                ; (a) New DMA writing in burst mode, 128 pixels in a burst
1450                                WR_IMAGE
1451      P:0003AB P:0003AB 013D24            BSET    #4,X:PDRC
1452      P:0003AC P:0003AC 01ADA1            JSET    #HF,X:PDRD,*                      ; Wait for FIFO to be half full + 1
                            0003AC
1453      P:0003AE P:0003AE 000000            NOP
1454      P:0003AF P:0003AF 000000            NOP
1455      P:0003B0 P:0003B0 01ADA1            JSET    #HF,X:PDRD,WR_IMAGE               ; Protection against metastability
                            0003AB
1456      P:0003B2 P:0003B2 013D04            BCLR    #4,X:PDRC
1457   
1458                                ; Priming the pump:
1459                                ; Copy part of the fiber optic FIFO load  (512 pixels) to DSP Y: memory
1460                                ; We need a PCIBURST worth of pixels before we can  start a transfer to the bus.
1461      P:0003B3 P:0003B3 60F400            MOVE              #IMAGE_BUFER,R0
                            000000
1462      P:0003B5 P:0003B5 221100            MOVE              R0,R1                   ;R0,R1 to 'FIRST'
1463   
1464   
1465                                ;       BSET    #4,X:PDRC
1466      P:0003B6 P:0003B6 068080            DO      #PCIBURST,L_BUFFER
                            0003B8
1467      P:0003B8 P:0003B8 0958FF            MOVEP             Y:RDFIFO,Y:(R0)+
1468                                L_BUFFER
1469   
1470                                ; Priming the pump:
1471                                ; Prepare the HI32 DPMC and DPAR address registers
1472      P:0003B9 P:0003B9 549B00            MOVE              X:<PCI_ADDR_1,A1        ; Current PCI address
1473      P:0003BA P:0003BA 509C00            MOVE              X:<PCI_ADDR_0,A0
1474      P:0003BB P:0003BB 0C1D10            ASL     #8,A,A
1475      P:0003BC P:0003BC 000000            NOP
1476      P:0003BD P:0003BD 0140C2            ORI     #$3F0000,A                        ; Burst length = # of PCI writes (!!!)
                            3F0000
1477      P:0003BF P:0003BF 000000            NOP                                       ;   = # of pixels / 2 - 1
1478      P:0003C0 P:0003C0 547000            MOVE              A1,X:DPMC               ; DPMC = B[31:16] + $070000
                            FFFFC7
1479      P:0003C2 P:0003C2 0C1D20            ASL     #16,A,A                           ; Get PCI_ADDR[15:0] into A1[15:0]
1480      P:0003C3 P:0003C3 000000            NOP
1481      P:0003C4 P:0003C4 0140C6            AND     #$00FFFF,A                        ; Making sure it is just 16bits
                            00FFFF
1482      P:0003C6 P:0003C6 000000            NOP
1483      P:0003C7 P:0003C7 0140C2            OR      #$070000,A                        ; A1 will get written to DPAR register
                            070000
1484                                ; Make sure its always 512 pixels per loop = 1/2 FIFO (4 bursts -> PCI)
1485      P:0003C9 P:0003C9 617000            MOVE              R1,X:DSR0               ; Source address for DMA = pixel data
                            FFFFEF
1486      P:0003CB P:0003CB 08F4AE            MOVEP             #DTXM,X:DDR0            ; Destination = PCI master transmitter
                            FFFFCC
1487      P:0003CD P:0003CD 08F4AD            MOVEP             #>127,X:DCO0            ; DMA Count = # of pixels - 1 (!!!)
                            00007F
1488      P:0003CF P:0003CF 08F4AC            MOVEP             #$8EFA51,X:DCR0         ; Start DMA with control register DE=1
                            8EFA51
1489      P:0003D1 P:0003D1 08CC08            MOVEP             A1,X:DPAR               ; Initiate writing to the PCI bus
1490                                ;       NOP
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 28



1491                                ;       NOP
1492   
1493                                ; At  this point we have a PCI transfer underway to be checked later.
1494                                ; Enter the main loop which interleaves FO and PCI transfers.
1495                                ; R0 is now the 'FILL' ptr for the image buffer, and R1
1496                                ; is the empty ptr.  (R1 only reflects DMA successfully completed)
1497                                ; A0,1 holds the pci address
1498                                ; X0 holds a constant 512.
1499   
1500   
1501                                ;       BCLR    #4,X:PDRC
1502                                NEXTBURST
1503                                ; First try to read out the fiber optic. We want to read at least enough
1504                                ; to have one more pci burst worth ready to go (beyond the pci transfer
1505                                ; ongoing) but we cannot read past the 512 pixel limit authorized by the
1506                                ; HF flag on the fifo.
1507      P:0003D2 P:0003D2 20001B            CLR     B
1508      P:0003D3 P:0003D3 220D00            MOVE              R0,B1
1509      P:0003D4 P:0003D4 0140CC            SUB     #IMAGE_BUFER,B                    ; FILL - FIRST == available data (no wrap)
                            000000
1510      P:0003D6 P:0003D6 0140CC            SUB     #FOBURST,B
                            000200
1511      P:0003D8 P:0003D8 0E13E8            JGE     <PCIXFERPOLL                      ; No more pixels in this empty of FO.
1512      P:0003D9 P:0003D9 20001B            CLR     B
1513      P:0003DA P:0003DA 222600            MOVE              R1,Y0
1514      P:0003DB P:0003DB 220D00            MOVE              R0,B1
1515      P:0003DC P:0003DC 000000            NOP
1516      P:0003DD P:0003DD 20005C            SUB     Y0,B                              ;FILL- EMPTY == data not DMA'd (! wrap)
1517      P:0003DE P:0003DE 000000            NOP
1518      P:0003DF P:0003DF 21A600            MOVE              B1,Y0                   ; Image bytes already available for pci
1519      P:0003E0 P:0003E0 20001B            CLR     B
1520      P:0003E1 P:0003E1 57F400            MOVE              #PCI2BURST,B            ; want enough more for additional burst
                            000100
1521      P:0003E3 P:0003E3 20005C            SUB     Y0,B
1522      P:0003E4 P:0003E4 0EF3E8            JLE     <PCIXFERPOLL
1523      P:0003E5 P:0003E5 06CD00            DO      B1,FOXFER
                            0003E7
1524      P:0003E7 P:0003E7 0958FF            MOVEP             Y:RDFIFO,Y:(R0)+
1525                                FOXFER
1526                                ; we are guaranteed to have a transfer waiting here.
1527                                PCIXFERPOLL
1528      P:0003E8 P:0003E8 0A8A84            JCLR    #MARQ,X:DPSR,*                    ; Wait until the PCI operation is done
                            0003E8
1529                                ;       BCLR    #4,X:PDRC
1530      P:0003EA P:0003EA 0A8AAE            JSET    #MDT,X:DPSR,WR_OK0                ; If no error go to the next sub-block
                            0003ED
1531                                ;       BSET    #4,X:PDRC
1532      P:0003EC P:0003EC 0D050C            JSR     <PCI_ERROR_RECOVERY               ; clear h/w and then do the retry.
1533      P:0003ED P:0003ED 0140C0  WR_OK0    ADD     #>256,A                           ; PCI address = + 2 x # of pixels (!!!)
                            000100
1534      P:0003EF P:0003EF 20001B            CLR     B
1535      P:0003F0 P:0003F0 222D00            MOVE              R1,B1                   ; update R1 for the image buffer addr
1536      P:0003F1 P:0003F1 000000            NOP
1537      P:0003F2 P:0003F2 0140C8            ADD     #>128,B                           ; corresponding to the next pci block
                            000080
1538      P:0003F4 P:0003F4 000000            NOP
1539      P:0003F5 P:0003F5 21B100            MOVE              B1,R1
1540      P:0003F6 P:0003F6 20001B            CLR     B
1541      P:0003F7 P:0003F7 55A800            MOVE              X:<PCI_BURST_NO,B1      ;increment count of pci burst
1542      P:0003F8 P:0003F8 0140C8            ADD     #>1,B
                            000001
1543      P:0003FA P:0003FA 000000            NOP
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 29



1544      P:0003FB P:0003FB 552800            MOVE              B1,X:<PCI_BURST_NO
1545   
1546                                ;       BCLR    #4,X:PDRC
1547                                STARTBURST
1548                                ;       Is the DMA pending in the image buffer done here?
1549      P:0003FC P:0003FC 20001B            CLR     B
1550      P:0003FD P:0003FD 222600            MOVE              R1,Y0
1551      P:0003FE P:0003FE 220D00            MOVE              R0,B1
1552      P:0003FF P:0003FF 20005C            SUB     Y0,B
1553      P:000400 P:000400 0AF0AA            JEQ     CHECKENDBURST
                            00040B
1554                                ;       No go to the next burst block.
1555      P:000402 P:000402 0A862E            BSET    #CLRT,X:DPCR                      ; Clear the master transmitter
1556      P:000403 P:000403 0A86AE            JSET    #CLRT,X:DPCR,*                    ; Wait for the clearing to be complete
                            000403
1557      P:000405 P:000405 08F4AC            MOVEP             #$8EFA51,X:DCR0         ; Start DMA with control register DE=1
                            8EFA51
1558      P:000407 P:000407 08CC08            MOVEP             A1,X:DPAR               ; Initiate writing to the PCI bus
1559      P:000408 P:000408 000000            NOP
1560      P:000409 P:000409 000000            NOP
1561      P:00040A P:00040A 0C03D2            JMP     NEXTBURST
1562                                CHECKENDBURST
1563                                                                                    ; there's no more bytes to dma, check FO fil
l progress
1564      P:00040B P:00040B 20001B            CLR     B
1565      P:00040C P:00040C 220D00            MOVE              R0,B1
1566      P:00040D P:00040D 0140CC            SUB     #IMAGE_BUFER,B
                            000000
1567      P:00040F P:00040F 0140CC            SUB     #FOBURST,B
                            000200
1568      P:000411 P:000411 0E93D2            JLT     NEXTBURST
1569                                ; DMA is done and 512 bytes emptied.
1570   
1571   
1572                                ;       BCLR    #4,X:PDRC
1573                                ; Re-calculate and store the PCI address where image data is being written to
1574      P:000412 P:000412 200013            CLR     A
1575      P:000413 P:000413 509600            MOVE              X:<IPXLS_0,A0           ; Number of pixels to write to PCI
1576      P:000414 P:000414 549500            MOVE              X:<IPXLS_1,A1
1577      P:000415 P:000415 200020            ADD     X,A                               ; X = 512 = 1/2 FIFO size
1578      P:000416 P:000416 000000            NOP
1579      P:000417 P:000417 501600            MOVE              A0,X:<IPXLS_0           ; Number of pixels to write to PCI
1580      P:000418 P:000418 541500            MOVE              A1,X:<IPXLS_1
1581      P:000419 P:000419 549B00            MOVE              X:<PCI_ADDR_1,A1        ; Current PCI address
1582      P:00041A P:00041A 509C00            MOVE              X:<PCI_ADDR_0,A0
1583      P:00041B P:00041B 200020            ADD     X,A                               ; Add the byte increment = 1024
1584      P:00041C P:00041C 200020            ADD     X,A
1585   
1586      P:00041D P:00041D 000000            NOP
1587      P:00041E P:00041E 541B00            MOVE              A1,X:<PCI_ADDR_1        ; Incremented current PCI address
1588      P:00041F P:00041F 501C00            MOVE              A0,X:<PCI_ADDR_0
1589   
1590      P:000420 P:000420 0D04D9            JSR     <C_RPXLS                          ; Calculate number of pixels read
1591      P:000421 P:000421 0C0395            JMP     <L_FIFO                           ; Go process the next 1/2 FIFO
1592   
1593                                ; (b) Write the pixels left over, in 32 pixel blocks
1594                                WRITE_LAST_LITTLE_BIT_OF_IMAGE
1595      P:000422 P:000422 20001B            CLR     B
1596      P:000423 P:000423 200020            ADD     X,A                               ; Exit if there are no more pixels
1597      P:000424 P:000424 200003            TST     A
1598      P:000425 P:000425 0EF4BA            JLE     <ALLDONE
1599      P:000426 P:000426 51F400            MOVE              #>31,B0
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 30



                            00001F
1600      P:000428 P:000428 502100            MOVE              A0,X:<NUM_PIX           ; Number of pixels in the last block
1601                                ;       ADD     #>31,A                  ; round up to next 32 pixel block
1602      P:000429 P:000429 21A700            MOVE              B1,Y1
1603      P:00042A P:00042A 212600            MOVE              B0,Y0
1604      P:00042B P:00042B 000000            NOP
1605      P:00042C P:00042C 200030            ADD     Y,A
1606      P:00042D P:00042D 000000            NOP
1607   
1608      P:00042E P:00042E 0C1C0A            ASR     #5,A,A
1609      P:00042F P:00042F 000000            NOP
1610      P:000430 P:000430 502200            MOVE              A0,X:<NUM_BLOCKS        ; Number (upper) of small blocks at end
1611      P:000431 P:000431 200013            CLR     A                                 ; being safe (?)
1612      P:000432 P:000432 50A100            MOVE              X:<NUM_PIX,A0           ; being safe (?)
1613      P:000433 P:000433 000000            NOP
1614      P:000434 P:000434 0C1C0A            ASR     #5,A,A
1615      P:000435 P:000435 46F400            MOVE              #>16,Y0
                            000010
1616      P:000437 P:000437 210700            MOVE              A0,Y1
1617      P:000438 P:000438 2000B0            MPY     Y0,Y1,A
1618      P:000439 P:000439 000000            NOP
1619      P:00043A P:00043A 210600            MOVE              A0,Y0
1620      P:00043B P:00043B 56A100            MOVE              X:<NUM_PIX,A            ; LAST_BIT = NUM_PIX - INT(NUMPIX*32)
1621      P:00043C P:00043C 200054            SUB     Y0,A
1622      P:00043D P:00043D 000000            NOP
1623      P:00043E P:00043E 542300            MOVE              A1,X:<LAST_BIT          ; # of pixels in the last little bit
1624   
1625                                ; Prepare the HI32 DPMC and DPAR address registers
1626      P:00043F P:00043F 549B00            MOVE              X:<PCI_ADDR_1,A1        ; Current PCI address
1627      P:000440 P:000440 509C00            MOVE              X:<PCI_ADDR_0,A0
1628      P:000441 P:000441 0C1D10            ASL     #8,A,A
1629      P:000442 P:000442 000000            NOP
1630      P:000443 P:000443 0140C2            ORI     #$0F0000,A                        ; Burst length = # of PCI writes (!!!)
                            0F0000
1631      P:000445 P:000445 000000            NOP                                       ;   = # of pixels / 2 - 1
1632      P:000446 P:000446 547000            MOVE              A1,X:DPMC               ; DPMC = B[31:16] + $070000
                            FFFFC7
1633      P:000448 P:000448 0C1D20            ASL     #16,A,A                           ; Get PCI_ADDR[15:0] into A1[15:0]
1634      P:000449 P:000449 000000            NOP
1635      P:00044A P:00044A 0140C6            AND     #$00FFFF,A
                            00FFFF
1636      P:00044C P:00044C 000000            NOP
1637      P:00044D P:00044D 0140C2            OR      #$070000,A                        ; A1 will get written to DPAR register
                            070000
1638   
1639                                ; Write the image pixels from FIFO to PCI bus one 32 pixel block at a time
1640      P:00044F P:00044F 60F400            MOVE              #IMAGE_BUFER,R0
                            000000
1641      P:000451 P:000451 221100            MOVE              R0,R1
1642      P:000452 P:000452 08F4AE            MOVEP             #DTXM,X:DDR0            ; Destination = PCI master transmitter
                            FFFFCC
1643      P:000454 P:000454 08F4AD            MOVEP             #>31,X:DCO0             ; DMA Count = # of pixels - 1 (!!!)
                            00001F
1644      P:000456 P:000456 08D02F            MOVEP             R0,X:DSR0               ; Source address for DMA = pixel data
1645   
1646      P:000457 P:000457 062200            DO      X:<NUM_BLOCKS,L_SMALL_BLOCKS
                            000482
1647      P:000459 P:000459 20001B            CLR     B
1648      P:00045A P:00045A 55A200            MOVE              X:<NUM_BLOCKS,B1
1649      P:00045B P:00045B 000000            NOP
1650      P:00045C P:00045C 01418C            SUB     #$1,B
1651      P:00045D P:00045D 000000            NOP
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 31



1652      P:00045E P:00045E 552200            MOVE              B1,X:<NUM_BLOCKS        ; Decrement block count
1653      P:00045F P:00045F 20000B            TST     B
1654      P:000460 P:000460 0AF0A7            JGT     LGBLK
                            000467
1655      P:000462 P:000462 55A300            MOVE              X:<LAST_BIT,B1          ; this last block is small
1656      P:000463 P:000463 000000            NOP
1657      P:000464 P:000464 20000B            TST     B
1658      P:000465 P:000465 0AF0A7            JGT     SMFIFO                            ; unless LAST_BIT is 0
                            000469
1659                                LGBLK
1660      P:000467 P:000467 2D2000            MOVE              #32,B1
1661      P:000468 P:000468 000000            NOP
1662                                SMFIFO                                              ; copy pixels from fiber to Y: area
1663   
1664      P:000469 P:000469 06CD00            DO      B1,S_BUFFER
                            00046E
1665      P:00046B P:00046B 01AD80            JCLR    #EF,X:PDRD,*                      ; Wait for the pixel datum to be there
                            00046B
1666      P:00046D P:00046D 000000            NOP                                       ; Settling time
1667      P:00046E P:00046E 0958FF            MOVEP             Y:RDFIFO,Y:(R0)+
1668                                S_BUFFER
1669   
1670      P:00046F P:00046F 0A862E  AGAIN1    BSET    #CLRT,X:DPCR                      ; Clear the master transmitter FIFO
1671      P:000470 P:000470 0A86AE            JSET    #CLRT,X:DPCR,*                    ; Wait for the clearing to be complete
                            000470
1672      P:000472 P:000472 08F4AC            MOVEP             #$8EFA51,X:DCR0         ; Start DMA with control register DE=1
                            8EFA51
1673      P:000474 P:000474 08CC08            MOVEP             A1,X:DPAR               ; Initiate writing to the PCI bus
1674      P:000475 P:000475 000000            NOP
1675      P:000476 P:000476 000000            NOP
1676      P:000477 P:000477 0A8A84            JCLR    #MARQ,X:DPSR,*                    ; Wait until the PCI operation is done
                            000477
1677      P:000479 P:000479 0A8AAE            JSET    #MDT,X:DPSR,WR_OK1                ; If no error go to the next sub-block
                            000480
1678      P:00047B P:00047B 55B800            MOVE              X:<PCI_LSTERRS,B1
1679      P:00047C P:00047C 014188            ADD     #$1,B
1680      P:00047D P:00047D 000000            NOP
1681      P:00047E P:00047E 553800            MOVE              B1,X:<PCI_LSTERRS
1682      P:00047F P:00047F 0D050C            JSR     <PCI_ERROR_RECOVERY
1683      P:000480 P:000480 0140C0  WR_OK1    ADD     #>64,A                            ; PCI address = + 2 x # of pixels (!!!)
                            000040
1684      P:000482 P:000482 221100            MOVE              R0,R1
1685                                L_SMALL_BLOCKS
1686      P:000483 P:000483 0C04BA            JMP     <ALLDONE
1687   
1688                                ; (c) Write the pixels left over from the last 32 pixel block
1689      P:000484 P:000484 57A300            MOVE              X:<LAST_BIT,B           ; Skip over this if there are no
1690      P:000485 P:000485 20000B            TST     B                                 ;   pixels left to write to the PCI bus
1691      P:000486 P:000486 0EF4BA            JLE     <ALLDONE
1692      P:000487 P:000487 57F000            MOVE              X:DPMC,B                ; Burst length = 0
                            FFFFC7
1693      P:000489 P:000489 0140CE            AND     #$FFFF,B
                            00FFFF
1694      P:00048B P:00048B 557000            MOVE              B1,X:DPMC
                            FFFFC7
1695      P:00048D P:00048D 57A300            MOVE              X:<LAST_BIT,B
1696      P:00048E P:00048E 20002B            LSR     B
1697      P:00048F P:00048F 000000            NOP
1698      P:000490 P:000490 06CD00            DO      B1,L_BIT
                            0004A6
1699      P:000492 P:000492 01AD80            JCLR    #EF,X:PDRD,*
                            000492
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 32



1700      P:000494 P:000494 4CE600            MOVE                          Y:(R6),X0
1701      P:000495 P:000495 447000            MOVE              X0,X:DTXM
                            FFFFCC
1702      P:000497 P:000497 01AD80            JCLR    #EF,X:PDRD,*
                            000497
1703      P:000499 P:000499 4CE600            MOVE                          Y:(R6),X0
1704      P:00049A P:00049A 447000            MOVE              X0,X:DTXM
                            FFFFCC
1705   
1706      P:00049C P:00049C 08CC08  AGAIN2    MOVEP             A1,X:DPAR               ; Write to PCI bus
1707      P:00049D P:00049D 000000            NOP                                       ; Pipeline delay
1708      P:00049E P:00049E 000000            NOP
1709      P:00049F P:00049F 0A8A84            JCLR    #MARQ,X:DPSR,*                    ; Bit is clear if PCI is still active
                            00049F
1710      P:0004A1 P:0004A1 0A8AAE            JSET    #MDT,X:DPSR,DONE2                 ; If no error then we're all done
                            0004A4
1711                                ;       JSR     <PCI_ERROR_RECOVERY
1712      P:0004A3 P:0004A3 0C049C            JMP     <AGAIN2
1713      P:0004A4 P:0004A4 0140C0  DONE2     ADD     #>4,A                             ; Two bytes per PCI write
                            000004
1714      P:0004A6 P:0004A6 000000            NOP
1715                                L_BIT
1716   
1717                                ; (d) If the number of pixels in the image is odd write the very last pixel
1718      P:0004A7 P:0004A7 0A2380            JCLR    #0,X:<LAST_BIT,ALLDONE            ; All done if even number of pixels
                            0004BA
1719      P:0004A9 P:0004A9 01AD80            JCLR    #EF,X:PDRD,*
                            0004A9
1720      P:0004AB P:0004AB 4CE600            MOVE                          Y:(R6),X0
1721      P:0004AC P:0004AC 447000            MOVE              X0,X:DTXM
                            FFFFCC
1722      P:0004AE P:0004AE 240000            MOVE              #0,X0
1723      P:0004AF P:0004AF 447000            MOVE              X0,X:DTXM
                            FFFFCC
1724      P:0004B1 P:0004B1 08CC08  AGAIN3    MOVEP             A1,X:DPAR               ; Write to PCI bus
1725      P:0004B2 P:0004B2 000000            NOP                                       ; Pipeline delay
1726      P:0004B3 P:0004B3 000000            NOP
1727      P:0004B4 P:0004B4 0A8A84            JCLR    #MARQ,X:DPSR,*                    ; Bit is clear if PCI is still active
                            0004B4
1728      P:0004B6 P:0004B6 0A8AAE            JSET    #MDT,X:DPSR,ALLDONE               ; If no error then we're all done
                            0004BA
1729                                ;       JSR     <PCI_ERROR_RECOVERY
1730      P:0004B8 P:0004B8 0C04B1            JMP     <AGAIN3
1731      P:0004B9 P:0004B9 0C04BA            JMP     <ALLDONE
1732   
1733   
1734                                ; Calculate and store the PCI address where image data is being written to
1735                                ALLDONE
1736      P:0004BA P:0004BA 549B00            MOVE              X:<PCI_ADDR_1,A1        ; Current PCI address
1737      P:0004BB P:0004BB 509C00            MOVE              X:<PCI_ADDR_0,A0
1738      P:0004BC P:0004BC 44A100            MOVE              X:<NUM_PIX,X0           ; Add the byte increment = NUM_PIX * 2
1739      P:0004BD P:0004BD 250000            MOVE              #0,X1
1740      P:0004BE P:0004BE 200020            ADD     X,A
1741      P:0004BF P:0004BF 200020            ADD     X,A
1742      P:0004C0 P:0004C0 000000            NOP
1743      P:0004C1 P:0004C1 541B00            MOVE              A1,X:<PCI_ADDR_1        ; Incremented current PCI address
1744      P:0004C2 P:0004C2 501C00            MOVE              A0,X:<PCI_ADDR_0
1745      P:0004C3 P:0004C3 0D04D9            JSR     <C_RPXLS                          ; Calculate number of pixels read
1746   
1747                                ; see how many extra pixels need to be tossed
1748      P:0004C4 P:0004C4 200013            CLR     A
1749      P:0004C5 P:0004C5 01AD80            JCLR    #EF,X:PDRD,TOSS2                  ; Test for incoming FIFO data
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 33



                            0004CD
1750      P:0004C7 P:0004C7 0140C0  TOSS1     ADD     #>1,A
                            000001
1751      P:0004C9 P:0004C9 09443F            MOVEP             Y:RDFIFO,X0             ; Read the FIFO until its empty
1752      P:0004CA P:0004CA 000000            NOP
1753      P:0004CB P:0004CB 01ADA0            JSET    #EF,X:PDRD,TOSS1
                            0004C7
1754      P:0004CD P:0004CD 066089  TOSS2     DO      #2400,TOSS3                       ; Wait for about 30 microsec in case
                            0004CF
1755      P:0004CF P:0004CF 000000            NOP                                       ;   FIFO data is still arriving
1756      P:0004D0 P:0004D0 01ADA0  TOSS3     JSET    #EF,X:PDRD,TOSS1                  ; Keep emptying if more data arrived
                            0004C7
1757      P:0004D2 P:0004D2 543900            MOVE              A1,X:<TOSS_PIXELS
1758   
1759      P:0004D3 P:0004D3 012D24            BSET    #MODE,X:PDRD                      ; Put the fiber optics in 32-bit mode
1760      P:0004D4 P:0004D4 448600            MOVE              X:<FLAG_DONE,X0
1761      P:0004D5 P:0004D5 441E00            MOVE              X0,X:<HOST_FLAG
1762      P:0004D6 P:0004D6 0D01B2            JSR     <FO_WRITE_HOST_FLAG               ; Clear Host Flag to 'DONE'
1763      P:0004D7 P:0004D7 0A8520            BSET    #HCIE,X:DCTR                      ; Enable host command interrupts
1764      P:0004D8 P:0004D8 0C0127            JMP     <GET_FO                           ; We're all done, go process FO input
1765   
1766                                ; R_PXLS is the number of pixels read out since the last IIA command
1767                                ; in non-wrap mode. In wrap mode it represents the position of the FILL
1768                                ; ptr in the low order 26 bits, and the number of times the fill ptr has
1769                                ; wrapped, modulo 6 in the upper 6.
1770                                ;
1771                                ; C_RPXLS looks for a non-zero PCI_BUFSIZE to signal wrap mode-
1772                                ; and also where to wrap.
1773                                C_RPXLS
1774                                                                                    ; safe copy of R_PXLS_
1775      P:0004D9 P:0004D9 67F400            MOVE              #RPXLS_SAFE,R7
                            0007E0
1776      P:0004DB P:0004DB 519800            MOVE              X:<R_PXLS_0,B0
1777      P:0004DC P:0004DC 200013            CLR     A
1778      P:0004DD P:0004DD 595F00            MOVE                          B0,Y:(R7)+
1779      P:0004DE P:0004DE 519700            MOVE              X:<R_PXLS_1,B0
1780      P:0004DF P:0004DF 47B700            MOVE              X:<PCI_BUFSIZE_1,Y1
1781      P:0004E0 P:0004E0 595F00            MOVE                          B0,Y:(R7)+
1782      P:0004E1 P:0004E1 20001B            CLR     B
1783      P:0004E2 P:0004E2 0A3E20            BSET    #0,X:<R_PXLS_CRIT                 ; unsafe if R_PXLS_1,2 locs in xsition
1784   
1785      P:0004E3 P:0004E3 51B600            MOVE              X:<PCI_BUFSIZE_0,B0
1786      P:0004E4 P:0004E4 0C1971            INSERT  #$10010,Y1,B
                            010010
1787      P:0004E6 P:0004E6 469A00            MOVE              X:<BASE_ADDR_0,Y0       ; BASE_ADDR is 2 x 16-bits
1788      P:0004E7 P:0004E7 479900            MOVE              X:<BASE_ADDR_1,Y1
1789      P:0004E8 P:0004E8 549B00            MOVE              X:<PCI_ADDR_1,A1        ; Current PCI address
1790      P:0004E9 P:0004E9 509C00            MOVE              X:<PCI_ADDR_0,A0
1791      P:0004EA P:0004EA 200034            SUB     Y,A                               ; Current (PCI - BASE) address
1792      P:0004EB P:0004EB 200022            ASR     A                                 ; /2 => convert byte address to pixel
1793      P:0004EC P:0004EC 01408D            CMP     #$0000,B
1794      P:0004ED P:0004ED 0AF0AA            JEQ     RPXLS_NOWRAP                      ; wrap is moot if bufsize 0.
                            0004F9
1795      P:0004EF P:0004EF 20000D            CMP     A,B
1796      P:0004F0 P:0004F0 0AF0A7            JGT     RPXLS_NOWRAP                      ; wrap didn't happen
                            0004F9
1797      P:0004F2 P:0004F2 200014            SUB     B,A
1798      P:0004F3 P:0004F3 461C00            MOVE              Y0,X:<PCI_ADDR_0        ; reset pci address to base at wrap.
1799                                ; need to increment the fill wrap counter here.
1800      P:0004F4 P:0004F4 559700            MOVE              X:<R_PXLS_1,B1
1801      P:0004F5 P:0004F5 0140C8            ADD     #$400,B                           ; incr bit 26
                            000400
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 34



1802      P:0004F7 P:0004F7 471B00            MOVE              Y1,X:<PCI_ADDR_1        ; reset pci address to base at wrap.
1803      P:0004F8 P:0004F8 551700            MOVE              B1,X:<R_PXLS_1
1804                                RPXLS_NOWRAP
1805      P:0004F9 P:0004F9 501800            MOVE              A0,X:<R_PXLS_0          ; R_PXLS is 2 x 16 bits, number of
1806      P:0004FA P:0004FA 519700            MOVE              X:<R_PXLS_1,B0
1807      P:0004FB P:0004FB 0C1880            EXTRACTU #$00A010,A,A                     ;   hi order 10 bits of fill pixels.
                            00A010
1808      P:0004FD P:0004FD 0C1891            EXTRACTU #$00600A,B,B                     ;   preserve wrap counter for fill.
                            00600A
1809      P:0004FF P:0004FF 0C1D95            ASL     #$A,B,B
1810      P:000500 P:000500 200010            ADD     B,A
1811      P:000501 P:000501 000000            NOP
1812      P:000502 P:000502 501700            MOVE              A0,X:<R_PXLS_1
1813      P:000503 P:000503 0A3E00            BCLR    #0,X:<R_PXLS_CRIT                 ; safe if these two locs not in xsition
1814      P:000504 P:000504 0A3E81            JCLR    #1,X:<R_PXLS_CRIT,NORACE
                            00050B
1815      P:000506 P:000506 55BF00            MOVE              X:<R_PXLS_RACE,B1       ; increment race counter
1816      P:000507 P:000507 014188            ADD     #$1,B
1817      P:000508 P:000508 000000            NOP
1818      P:000509 P:000509 553F00            MOVE              B1,X:<R_PXLS_RACE
1819      P:00050A P:00050A 0A3E01            BCLR    #1,X:<R_PXLS_CRIT
1820                                NORACE
1821   
1822      P:00050B P:00050B 00000C            RTS
1823   
1824                                ; Recover from an error writing to the PCI bus. Trashes B register.
1825                                ; All it does now is clear error bit in DPSR and log/record event.
1826                                ; The PCI_BURST_NO must fit in 16 bits. (8 Mpix with 128 pixel burst)
1827                                PCI_ERROR_RECOVERY
1828      P:00050C P:00050C 55A700            MOVE              X:<PCI_ERRS,B1
1829      P:00050D P:00050D 014188            ADD     #$1,B
1830      P:00050E P:00050E 000000            NOP
1831      P:00050F P:00050F 552700            MOVE              B1,X:<PCI_ERRS
1832      P:000510 P:000510 20001B            CLR     B
1833      P:000511 P:000511 57A900            MOVE              X:<PCI_ERRLOG,B
1834      P:000512 P:000512 0140CD            CMP     #PCI_ERRMAGIC,B
                            FEEDEE
1835      P:000514 P:000514 0AF0A2            JNE     WR_ERR
                            000528
1836      P:000516 P:000516 20001B            CLR     B
1837      P:000517 P:000517 08490A            MOVEP             X:DPSR,B0
1838      P:000518 P:000518 000000            NOP
1839      P:000519 P:000519 0C1891            EXTRACTU #$08005,B,B
                            008005
1840      P:00051B P:00051B 212700            MOVE              B0,Y1
1841      P:00051C P:00051C 55A800            MOVE              X:<PCI_BURST_NO,B1
1842      P:00051D P:00051D 0C1971            INSERT  #$08028,Y1,B
                            008028
1843      P:00051F P:00051F 5D5A00            MOVE                          B1,Y:(R2)+  ; log this one to error buf.
1844      P:000520 P:000520 20001B            CLR     B
1845      P:000521 P:000521 224D00            MOVE              R2,B1
1846      P:000522 P:000522 0140CC            SUB     #PCI_ERRLOGLAST,B
                            000464
1847      P:000524 P:000524 0AF0AF            JLE     CLEAR_EBITS
                            000528
1848      P:000526 P:000526 62F400            MOVE              #PCI_ERRLOGFIRST,R2     ; error buffer ptr overflowed
                            000400
1849                                CLEAR_EBITS
1850                                ; Write the remaining pixels of the DMA block on a retry error
1851                                WR_ERR
1852   
1853                                ; Save DPMC and DPAR for later use
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 35



1854      P:000528 P:000528 087087            MOVEP             X:DPMC,X:SV_DPMC        ; These registers are changed here,
                            000024
1855      P:00052A P:00052A 542600            MOVE              A1,X:<SV_A1             ;   so save and restore them
1856   
1857                                WR_ERR_AGAIN
1858      P:00052B P:00052B 084E0A            MOVEP             X:DPSR,A                ; Get Remaining Data count bits[21:16]
1859      P:00052C P:00052C 0C1EE0            LSR     #16,A                             ; Put RDC field in A1
1860      P:00052D P:00052D 0A8A8F            JCLR    #RDCQ,X:DPSR,*+3
                            000530
1861      P:00052F P:00052F 014180            ADD     #1,A                              ; Add one if RDCQ is set
1862      P:000530 P:000530 000000            NOP
1863      P:000531 P:000531 218700            MOVE              A1,Y1                   ; Save Y1 = # of PCI words remaining
1864   
1865                                ; Compute number of bytes completed, using previous DPMC burst length
1866      P:000532 P:000532 084E07            MOVEP             X:DPMC,A
1867      P:000533 P:000533 0140C6            ANDI    #$3F0000,A
                            3F0000
1868      P:000535 P:000535 0C1EE0            LSR     #16,A
1869      P:000536 P:000536 200074            SUB     Y1,A                              ; A1 = # of PCI writes completed
1870      P:000537 P:000537 0C1E84            LSL     #2,A                              ; Convert to a byte address
1871      P:000538 P:000538 000000            NOP
1872      P:000539 P:000539 218600            MOVE              A1,Y0                   ; Byte address of # completed
1873   
1874      P:00053A P:00053A 084E08            MOVEP             X:DPAR,A                ; Save Y0 = DPAR + # of bytes completed
1875      P:00053B P:00053B 200050            ADD     Y0,A
1876      P:00053C P:00053C 000000            NOP
1877      P:00053D P:00053D 218600            MOVE              A1,Y0                   ; New DPAR value
1878   
1879                                ; Write the new burst length to the X:DPMC register
1880      P:00053E P:00053E 084E07            MOVEP             X:DPMC,A
1881      P:00053F P:00053F 0C1970            INSERT  #$006028,Y1,A                     ; Y1 = new burst length
                            006028
1882      P:000541 P:000541 000000            NOP
1883      P:000542 P:000542 08CC07            MOVEP             A1,X:DPMC               ; Update DPMC burst length
1884   
1885                                ; Clear all error condition and initiate the PCI writing
1886      P:000543 P:000543 084F0A            MOVEP             X:DPSR,B
1887      P:000544 P:000544 0140CA            OR      #$1FE,B
                            0001FE
1888      P:000546 P:000546 000000            NOP
1889      P:000547 P:000547 08CF0A            MOVEP             B,X:DPSR
1890      P:000548 P:000548 08C608            MOVEP             Y0,X:DPAR               ; Initiate writing to the PCI bus
1891      P:000549 P:000549 000000            NOP
1892      P:00054A P:00054A 000000            NOP
1893      P:00054B P:00054B 0A8A84            JCLR    #MARQ,X:DPSR,*                    ; Test for PCI operation completion
                            00054B
1894      P:00054D P:00054D 0A8AAE            JSET    #MDT,X:DPSR,WR_ERR_OK             ; Test for Master Data Transfer complete
                            000550
1895      P:00054F P:00054F 0C052B            JMP     <WR_ERR_AGAIN
1896                                WR_ERR_OK
1897      P:000550 P:000550 08F087            MOVEP             X:SV_DPMC,X:DPMC        ; Restore these two registers
                            000024
1898      P:000552 P:000552 54A600            MOVE              X:<SV_A1,A1
1899      P:000553 P:000553 00000C            RTS
1900   
1901                                ; ***** Test Data Link, Read Memory and Write Memory Commands ******
1902   
1903                                ; Test the data link by echoing back ARG1
1904                                TEST_DATA_LINK
1905      P:000554 P:000554 44B200            MOVE              X:<ARG1,X0
1906      P:000555 P:000555 0C05D7            JMP     <FINISH1
1907   
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 36



1908                                ; Read from PCI memory. The address is masked to 16 bits, so only
1909                                ;   the bottom 64k words of DRAM will be accessed.
1910                                READ_MEMORY
1911      P:000556 P:000556 56B200            MOVE              X:<ARG1,A               ; Get the address in an accumulator
1912      P:000557 P:000557 0140C6            AND     #$FFFF,A                          ; Mask off only 16 address bits
                            00FFFF
1913      P:000559 P:000559 219000            MOVE              A1,R0                   ; Get the address in an address register
1914      P:00055A P:00055A 56B200            MOVE              X:<ARG1,A               ; Get the address in an accumulator
1915      P:00055B P:00055B 000000            NOP
1916      P:00055C P:00055C 0ACE14            JCLR    #20,A,RDX                         ; Test address bit for Program memory
                            000560
1917      P:00055E P:00055E 07E084            MOVE              P:(R0),X0               ; Read from Program Memory
1918      P:00055F P:00055F 0C05D7            JMP     <FINISH1                          ; Send out a header with the value
1919      P:000560 P:000560 0ACE15  RDX       JCLR    #21,A,RDY                         ; Test address bit for X: memory
                            000564
1920      P:000562 P:000562 44E000            MOVE              X:(R0),X0               ; Write to X data memory
1921      P:000563 P:000563 0C05D7            JMP     <FINISH1                          ; Send out a header with the value
1922      P:000564 P:000564 0ACE16  RDY       JCLR    #22,A,RDR                         ; Test address bit for Y: memory
                            000568
1923      P:000566 P:000566 4CE000            MOVE                          Y:(R0),X0   ; Read from Y data memory
1924      P:000567 P:000567 0C05D7            JMP     <FINISH1                          ; Send out a header with the value
1925      P:000568 P:000568 0ACE17  RDR       JCLR    #23,A,ERROR                       ; Test address bit for read from EEPROM memo
ry
                            0005DB
1926   
1927                                ; Read the word from the PCI board EEPROM
1928      P:00056A P:00056A 013D21            BSET    #1,X:PDRC                         ; ROM/FIFO* = 1 to select ROM
1929      P:00056B P:00056B 08F4B8            MOVEP             #$008C29,X:AAR1         ; P: = $008000 to $008777 asserts AA1 low tr
ue
                            008C29
1930      P:00056D P:00056D 08F4BB            MOVEP             #$0002A0,X:BCR          ; Bus Control Register for slow EEPROM
                            0002A0
1931      P:00056F P:00056F 458300            MOVE              X:<THREE,X1             ; Convert to word address to a byte address
1932      P:000570 P:000570 220400            MOVE              R0,X0                   ; Get 16-bit address in a data register
1933      P:000571 P:000571 2000A0            MPY     X1,X0,A                           ; Multiply
1934      P:000572 P:000572 200022            ASR     A                                 ; Eliminate zero fill of fractional multiply
1935      P:000573 P:000573 211000            MOVE              A0,R0                   ; Need to address memory
1936      P:000574 P:000574 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
1937      P:000575 P:000575 060380            DO      #3,L1RDR
                            000579
1938      P:000577 P:000577 07D88A            MOVE              P:(R0)+,A2              ; Read each ROM byte
1939      P:000578 P:000578 0C1C10            ASR     #8,A,A                            ; Move right into A1
1940      P:000579 P:000579 000000            NOP
1941                                L1RDR
1942      P:00057A P:00057A 218400            MOVE              A1,X0                   ; Prepare for FINISH1
1943      P:00057B P:00057B 013D01            BCLR    #1,X:PDRC                         ; ROM/FIFO* = 0 to select FIFO
1944      P:00057C P:00057C 08F4B8            MOVEP             #$FFFC21,X:AAR1         ; Restore FIFO addressing
                            FFFC21
1945      P:00057E P:00057E 08F4BB            MOVEP             #$000020,X:BCR          ; Restore fast FIFO access
                            000020
1946      P:000580 P:000580 0C05D7            JMP     <FINISH1
1947   
1948                                ; Program WRMEM - write to PCI memory, reply = DONE host flags. The address is
1949                                ;  masked to 16 bits, so only the bottom 64k words of DRAM will be accessed.
1950                                WRITE_MEMORY
1951      P:000581 P:000581 56B200            MOVE              X:<ARG1,A               ; Get the address in an accumulator
1952      P:000582 P:000582 0140C6            AND     #$FFFF,A                          ; Mask off only 16 address bits
                            00FFFF
1953      P:000584 P:000584 219000            MOVE              A1,R0                   ; Get the address in an address register
1954      P:000585 P:000585 56B200            MOVE              X:<ARG1,A               ; Get the address in an accumulator
1955      P:000586 P:000586 44B300            MOVE              X:<ARG2,X0              ; Get the data to be written
1956      P:000587 P:000587 0ACE14            JCLR    #20,A,WRX                         ; Test address bit for Program memory
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 37



                            00058B
1957      P:000589 P:000589 076084            MOVE              X0,P:(R0)               ; Write to Program memory
1958      P:00058A P:00058A 0C05D4            JMP     <FINISH
1959      P:00058B P:00058B 0ACE15  WRX       JCLR    #21,A,WRY                         ; Test address bit for X: memory
                            00058F
1960      P:00058D P:00058D 446000            MOVE              X0,X:(R0)               ; Write to X: memory
1961      P:00058E P:00058E 0C05D4            JMP     <FINISH
1962      P:00058F P:00058F 0ACE16  WRY       JCLR    #22,A,WRR                         ; Test address bit for Y: memory
                            000593
1963      P:000591 P:000591 4C6000            MOVE                          X0,Y:(R0)   ; Write to Y: memory
1964      P:000592 P:000592 0C05D4            JMP     <FINISH
1965      P:000593 P:000593 0ACE17  WRR       JCLR    #23,A,ERROR                       ; Test address bit for write to EEPROM
                            0005DB
1966   
1967                                ; Write the word to the on-board PCI EEPROM
1968      P:000595 P:000595 013D21            BSET    #1,X:PDRC                         ; ROM/FIFO* = 1 to select ROM
1969      P:000596 P:000596 08F4B8            MOVEP             #$008C29,X:AAR1         ; P: = $008000 to $008777 asserts AA1 low tr
ue
                            008C29
1970      P:000598 P:000598 08F4BB            MOVEP             #$0002A0,X:BCR          ; Bus Control Register for slow EEPROM
                            0002A0
1971      P:00059A P:00059A 458300            MOVE              X:<THREE,X1             ; Convert to word address to a byte address
1972      P:00059B P:00059B 220400            MOVE              R0,X0                   ; Get 16-bit address in a data register
1973      P:00059C P:00059C 2000A0            MPY     X1,X0,A                           ; Multiply
1974      P:00059D P:00059D 200022            ASR     A                                 ; Eliminate zero fill of fractional multiply
1975      P:00059E P:00059E 211000            MOVE              A0,R0                   ; Need to address memory
1976      P:00059F P:00059F 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
1977      P:0005A0 P:0005A0 56B300            MOVE              X:<ARG2,A               ; Get the data to be written, again
1978      P:0005A1 P:0005A1 060380            DO      #3,L1WRR                          ; Loop over three bytes of the word
                            0005AA
1979      P:0005A3 P:0005A3 07588C            MOVE              A1,P:(R0)+              ; Write each EEPROM byte
1980      P:0005A4 P:0005A4 0C1C10            ASR     #8,A,A                            ; Move right one byte
1981      P:0005A5 P:0005A5 44F400            MOVE              #400000,X0
                            061A80
1982      P:0005A7 P:0005A7 06C400            DO      X0,L2WRR                          ; Delay by 5 millisec for EEPROM write
                            0005A9
1983      P:0005A9 P:0005A9 000000            NOP
1984                                L2WRR
1985      P:0005AA P:0005AA 000000            NOP                                       ; DO loop nesting restriction
1986                                L1WRR
1987      P:0005AB P:0005AB 013D01            BCLR    #1,X:PDRC                         ; ROM/FIFO* = 0 to select FIFO
1988      P:0005AC P:0005AC 08F4B8            MOVEP             #$FFFC21,X:AAR1         ; Restore FIFO addressing
                            FFFC21
1989      P:0005AE P:0005AE 08F4BB            MOVEP             #$000020,X:BCR          ; Restore fast FIFO access
                            000020
1990      P:0005B0 P:0005B0 0C05D4            JMP     <FINISH
1991   
1992   
1993                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
1994                                ; save timer values in Y memory communications area
1995                                GET_TICK
1996      P:0005B1 P:0005B1 67F400            MOVE              #PCI_YCOMM,R7
                            0007D0
1997      P:0005B3 P:0005B3 000000            NOP
1998      P:0005B4 P:0005B4 000000            NOP
1999      P:0005B5 P:0005B5 075F48            MOVEP             X:TCR1,Y:(R7)+
2000      P:0005B6 P:0005B6 000000            NOP
2001      P:0005B7 P:0005B7 07674C            MOVEP             X:TCR0,Y:(R7)
2002      P:0005B8 P:0005B8 0C05D4            JMP     <FINISH
2003                                          ENDIF
2004   
2005                                ; return information fields from a pseudo address space.
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 38



2006                                GET_INFO
2007      P:0005B9 P:0005B9 56B200            MOVE              X:<ARG1,A               ; Get the address in an accumulator
2008      P:0005BA P:0005BA 44F400            MOVE              #IVERSION,X0
                            0471C5
2009      P:0005BC P:0005BC 014085            CMP     #GET_VERSION,A
2010      P:0005BD P:0005BD 0EA5D7            JEQ     <FINISH1                          ; Is it Version?
2011      P:0005BE P:0005BE 44F400            MOVE              #IFLAVOR,X0
                            202020
2012      P:0005C0 P:0005C0 014185            CMP     #GET_FLAVOR,A
2013      P:0005C1 P:0005C1 0EA5D7            JEQ     <FINISH1                          ; Is it Flavor?
2014      P:0005C2 P:0005C2 44F400            MOVE              #ITIME0,X0
                            00B444
2015      P:0005C4 P:0005C4 014285            CMP     #GET_TIME0,A
2016      P:0005C5 P:0005C5 0EA5D7            JEQ     <FINISH1                          ; Is it Time0?
2017      P:0005C6 P:0005C6 44F400            MOVE              #ITIME1,X0
                            004AE4
2018      P:0005C8 P:0005C8 014385            CMP     #GET_TIME1,A
2019      P:0005C9 P:0005C9 0EA5D7            JEQ     <FINISH1                          ; Is it Time1?
2020      P:0005CA P:0005CA 44F400            MOVE              #ISVNREV,X0
                            0F5217
2021      P:0005CC P:0005CC 014485            CMP     #GET_SVNREV,A
2022      P:0005CD P:0005CD 0EA5D7            JEQ     <FINISH1                          ; Is it Svn rev?
2023      P:0005CE P:0005CE 44F400            MOVE              #>PCICAPABLE,X0
                            000007
2024      P:0005D0 P:0005D0 0140C5            CMP     #GET_CAPABLE,A
                            000100
2025      P:0005D2 P:0005D2 0EA5D7            JEQ     <FINISH1                          ; Is it Pci Capabilities?
2026      P:0005D3 P:0005D3 0C05DB            JMP     <ERROR
2027   
2028   
2029                                ;  ***** Subroutines for generating replies to command execution ******
2030                                ; Return from the interrupt with a reply = DONE host flags
2031      P:0005D4 P:0005D4 448600  FINISH    MOVE              X:<FLAG_DONE,X0         ; Flag = 1 => Normal execution
2032      P:0005D5 P:0005D5 441E00            MOVE              X0,X:<HOST_FLAG
2033      P:0005D6 P:0005D6 0C05E4            JMP     <RTI_WRITE_HOST_FLAG
2034   
2035                                ; Return from the interrupt with value in (X1,X0)
2036      P:0005D7 P:0005D7 441D00  FINISH1   MOVE              X0,X:<REPLY             ; Report value
2037      P:0005D8 P:0005D8 448700            MOVE              X:<FLAG_REPLY,X0        ; Flag = 2 => Reply with a value
2038      P:0005D9 P:0005D9 441E00            MOVE              X0,X:<HOST_FLAG
2039      P:0005DA P:0005DA 0C05E4            JMP     <RTI_WRITE_HOST_FLAG
2040   
2041                                ; Routine for returning from the interrupt on an error
2042      P:0005DB P:0005DB 448800  ERROR     MOVE              X:<FLAG_ERR,X0          ; Flag = 3 => Error value
2043      P:0005DC P:0005DC 441E00            MOVE              X0,X:<HOST_FLAG
2044      P:0005DD P:0005DD 0C05E4            JMP     <RTI_WRITE_HOST_FLAG
2045   
2046                                ; Routine for returning from the interrupt with a system reset
2047      P:0005DE P:0005DE 448900  SYR       MOVE              X:<FLAG_SYR,X0          ; Flag = 4 => System reset
2048      P:0005DF P:0005DF 441E00            MOVE              X0,X:<HOST_FLAG
2049      P:0005E0 P:0005E0 0C05E4            JMP     <RTI_WRITE_HOST_FLAG
2050   
2051                                ; Routine for returning a BUSY status from the controller
2052      P:0005E1 P:0005E1 448B00  BUSY      MOVE              X:<FLAG_BUSY,X0         ; Flag = 6 => Controller is busy
2053      P:0005E2 P:0005E2 441E00            MOVE              X0,X:<HOST_FLAG
2054      P:0005E3 P:0005E3 0C05E4            JMP     <RTI_WRITE_HOST_FLAG
2055   
2056                                ; Write X:<HOST_FLAG to the DCTR flag bits 5,4,3, as an interrupt
2057                                RTI_WRITE_HOST_FLAG
2058      P:0005E4 P:0005E4 56F000            MOVE              X:DCTR,A
                            FFFFC5
2059      P:0005E6 P:0005E6 449E00            MOVE              X:<HOST_FLAG,X0
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 39



2060      P:0005E7 P:0005E7 0140C6            AND     #$FFFFC7,A                        ; Clear bits 5,4,3
                            FFFFC7
2061      P:0005E9 P:0005E9 000000            NOP
2062      P:0005EA P:0005EA 200042            OR      X0,A                              ; Set flags appropriately
2063      P:0005EB P:0005EB 000000            NOP
2064      P:0005EC P:0005EC 567000            MOVE              A,X:DCTR
                            FFFFC5
2065      P:0005EE P:0005EE 000004            RTI
2066   
2067                                ; Put the reply value into the transmitter FIFO
2068                                READ_REPLY_VALUE
2069   
2070                                          IF      @SCP("SUPPORTED","SUPPORTED")
2071      P:0005EF P:0005EF 56BC00            MOVE              X:<PCI_HISTON,A
2072      P:0005F0 P:0005F0 200003            TST     A
2073      P:0005F1 P:0005F1 0AF0AA            JEQ     DO_REP
                            0005FC
2074      P:0005F3 P:0005F3 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
2075      P:0005F4 P:0005F4 000000            NOP
2076      P:0005F5 P:0005F5 64F400            MOVE              #H_RDREPLYVAL,R4        ; tag
                            525250
2077      P:0005F7 P:0005F7 6C5B00            MOVE                          R4,Y:(R3)+
2078      P:0005F8 P:0005F8 000000            NOP
2079                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
2080      P:0005F9 P:0005F9 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
2081      P:0005FA P:0005FA 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
2082                                          ENDIF
2083      P:0005FB P:0005FB 633B00            MOVE              R3,X:<PCI_HISTFILL
2084                                DO_REP
2085                                          ENDIF
2086   
2087                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
2088      P:0005FC P:0005FC 08F08D            MOVEP             X:REPLY,X:DTXS          ; DSP-to-host slave transmit
                            00001D
2089      P:0005FE P:0005FE 000004            RTI
2090   
2091                                READ_REPLY_HEADER
2092      P:0005FF P:0005FF 44B000            MOVE              X:<HEADER,X0
2093      P:000600 P:000600 0C05D7            JMP     <FINISH1
2094   
2095                                ; Clear the reply flags and receiver FIFO after a successful reply transaction,
2096                                ;   but leave the Read Image flags set if the controller is reading out.
2097                                CLEAR_HOST_FLAG
2098   
2099                                          IF      @SCP("SUPPORTED","SUPPORTED")
2100      P:000601 P:000601 56BC00            MOVE              X:<PCI_HISTON,A
2101      P:000602 P:000602 200003            TST     A
2102      P:000603 P:000603 0AF0AA            JEQ     DO_CLH
                            00060E
2103      P:000605 P:000605 63BB00            MOVE              X:<PCI_HISTFILL,R3      ; history buffer
2104      P:000606 P:000606 000000            NOP
2105      P:000607 P:000607 64F400            MOVE              #H_CLEARHOSTFLG,R4      ; tag
                            434846
2106      P:000609 P:000609 6C5B00            MOVE                          R4,Y:(R3)+
2107      P:00060A P:00060A 000000            NOP
2108                                          IF      @SCP("SUPPORTED","SUPPORTED")     ; Hardware timer
2109      P:00060B P:00060B 075B4C            MOVEP             X:TCR0,Y:(R3)+          ; lo order time
2110      P:00060C P:00060C 075B48            MOVEP             X:TCR1,Y:(R3)+          ; hi order time
2111                                          ENDIF
2112      P:00060D P:00060D 633B00            MOVE              R3,X:<PCI_HISTFILL
2113                                DO_CLH
2114                                          ENDIF
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 40



2115   
2116                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
2117   
2118      P:00060E P:00060E 448500            MOVE              X:<FLAG_ZERO,X0
2119      P:00060F P:00060F 441E00            MOVE              X0,X:<HOST_FLAG
2120      P:000610 P:000610 44F400            MOVE              #$FFFFC7,X0
                            FFFFC7
2121      P:000612 P:000612 56F000            MOVE              X:DCTR,A
                            FFFFC5
2122      P:000614 P:000614 200046            AND     X0,A
2123      P:000615 P:000615 000000            NOP
2124      P:000616 P:000616 547000            MOVE              A1,X:DCTR
                            FFFFC5
2125   
2126                                ;       the receiver clear below engendered a race condition with the
2127                                ;       host submitting the next cmd. We clear the receiver now -after-
2128                                ;       receipt of each command via WRITE-COMMAND.
2129   
2130                                ;CLR_RCV        JCLR    #SRRQ,X:DSR,CLR_RTS     ; Wait for the receiver to be empty
2131   
2132                                ;       MOVEP   X:DRXR,X0               ; Read receiver to empty it
2133   
2134                                ;       IF      @SCP("SUPPORTED","SUPPORTED")
2135                                ;       MOVE    X:<PCI_HISTON,A
2136                                ;       TST     A
2137                                ;       JEQ    DO_CLRR
2138                                ;        MOVE   X:<PCI_HISTFILL,R3              ; history buffer
2139                                ;       NOP
2140                                ;       MOVE    X0,R4                           ; tag
2141                                ;       NOP
2142                                ;       MOVE    R4,Y:(R3)+
2143                                ;       NOP
2144                                ;       IF      @SCP("SUPPORTED","SUPPORTED")   ; Hardware timer
2145                                ;        MOVEP   X:TCR0,Y:(R3)+                 ; lo order time
2146                                ;        MOVEP   X:TCR1,Y:(R3)+                 ; hi order time
2147                                ;       ENDIF
2148                                ;       MOVE   R3,X:<PCI_HISTFILL
2149                                ;DO_CLRR
2150                                ;       ENDIF
2151   
2152                                ;       the fiber loop wraps PCI_HIST when it gets the chance.
2153   
2154                                ;       NOP                             ; Wait for flag to change
2155                                ;       JMP     <CLR_RCV
2156                                ;CLR_RTS
2157      P:000618 P:000618 000004            RTI
2158   
2159                                ; *************  Miscellaneous subroutines used everywhere  *************
2160   
2161                                ; Transmit contents of Accumulator A1 to the timing board
2162      P:000619 P:000619 567000  XMT_WRD   MOVE              A,X:SV_A
                            000012
2163      P:00061B P:00061B 01B786            JCLR    #TDE,X:SSISR0,*
                            00061B
2164      P:00061D P:00061D 07F43C            MOVEP             #$000000,X:TX00
                            000000
2165      P:00061F P:00061F 0D0639            JSR     <XMT_DLY
2166      P:000620 P:000620 01B786            JCLR    #TDE,X:SSISR0,*                   ; Start bit
                            000620
2167      P:000622 P:000622 07F43C            MOVEP             #$010000,X:TX00
                            010000
2168      P:000624 P:000624 0D0639            JSR     <XMT_DLY
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 41



2169      P:000625 P:000625 01B786            JCLR    #TDE,X:SSISR0,*
                            000625
2170      P:000627 P:000627 07F43C            MOVEP             #$AC0000,X:TX00         ; Preamble byte
                            AC0000
2171      P:000629 P:000629 0D0639            JSR     <XMT_DLY
2172      P:00062A P:00062A 060380            DO      #3,L_XMIT
                            000630
2173      P:00062C P:00062C 01B786            JCLR    #TDE,X:SSISR0,*                   ; Three data bytes
                            00062C
2174      P:00062E P:00062E 04CCDC            MOVEP             A1,X:TX00
2175      P:00062F P:00062F 0D0639            JSR     <XMT_DLY
2176      P:000630 P:000630 0C1E90            LSL     #8,A
2177                                L_XMIT
2178      P:000631 P:000631 01B786            JCLR    #TDE,X:SSISR0,*                   ; Zeroes to bring TX00 low
                            000631
2179      P:000633 P:000633 07F43C            MOVEP             #$000000,X:TX00
                            000000
2180      P:000635 P:000635 0D0639            JSR     <XMT_DLY
2181      P:000636 P:000636 56F000            MOVE              X:SV_A,A
                            000012
2182      P:000638 P:000638 00000C            RTS
2183   
2184                                ; Short delay for reliability
2185      P:000639 P:000639 000000  XMT_DLY   NOP
2186      P:00063A P:00063A 00000C            RTS
2187   
2188                                ; Read one word of the fiber optic FIFO into B1 with a timeout
2189                                RD_FO_TIMEOUT
2190      P:00063B P:00063B 46F400            MOVE              #1000000,Y0             ; 13 millisecond timeout
                            0F4240
2191      P:00063D P:00063D 06C600            DO      Y0,LP_TIM
                            000647
2192      P:00063F P:00063F 01AD80            JCLR    #EF,X:PDRD,NOT_YET                ; Test for new fiber optic data
                            000647
2193      P:000641 P:000641 000000            NOP
2194      P:000642 P:000642 000000            NOP
2195      P:000643 P:000643 01AD80            JCLR    #EF,X:PDRD,NOT_YET                ; For metastability, check it twice
                            000647
2196      P:000645 P:000645 00008C            ENDDO
2197      P:000646 P:000646 0C064C            JMP     <RD_FIFO                          ; Go read the FIFO word
2198      P:000647 P:000647 000000  NOT_YET   NOP
2199      P:000648 P:000648 000000  LP_TIM    NOP
2200      P:000649 P:000649 0AF960            BSET    #0,SR                             ; Timeout reached, error return
2201      P:00064A P:00064A 000000            NOP
2202      P:00064B P:00064B 00000C            RTS
2203   
2204                                ; Read one word from the fiber optics FIFO, check it and put it in B1
2205      P:00064C P:00064C 09463F  RD_FIFO   MOVEP             Y:RDFIFO,Y0             ; Read the FIFO word
2206      P:00064D P:00064D 578D00            MOVE              X:<C00FF00,B            ; DMASK = $00FF00
2207      P:00064E P:00064E 20005E            AND     Y0,B
2208      P:00064F P:00064F 0140CD            CMP     #$00AC00,B
                            00AC00
2209      P:000651 P:000651 0EA65E            JEQ     <GT_RPLY                          ; If byte equalS $AC then continue
2210      P:000652 P:000652 07F42D            MOVEP             #%010000,X:PDRD         ; Clear RS* low for 2 milliseconds
                            000010
2211      P:000654 P:000654 47F400            MOVE              #200000,Y1
                            030D40
2212      P:000656 P:000656 06C700            DO      Y1,*+3
                            000658
2213      P:000658 P:000658 000000            NOP
2214      P:000659 P:000659 07F42D            MOVEP             #%010100,X:PDRD         ; Data Register - Set RS* high
                            000014
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 42



2215      P:00065B P:00065B 0AF960            BSET    #0,SR                             ; Set carry bit => error
2216      P:00065C P:00065C 000000            NOP
2217      P:00065D P:00065D 00000C            RTS
2218   
2219      P:00065E P:00065E 20CF00  GT_RPLY   MOVE              Y0,B
2220      P:00065F P:00065F 0C1EA1            LSL     #16,B                             ; Shift byte in D7-D0 to D23-D16
2221      P:000660 P:000660 000000            NOP
2222      P:000661 P:000661 21A700            MOVE              B1,Y1
2223      P:000662 P:000662 4EF000            MOVE                          Y:RDFIFO,Y0 ; Read the FIFO word
                            FFFFFF
2224      P:000664 P:000664 57F400            MOVE              #$00FFFF,B
                            00FFFF
2225      P:000666 P:000666 20005E            AND     Y0,B                              ; Select out D15-D0
2226      P:000667 P:000667 20007A            OR      Y1,B                              ; Add D23-D16 to D15-D0
2227      P:000668 P:000668 000000            NOP
2228      P:000669 P:000669 000000            NOP
2229      P:00066A P:00066A 0AF940            BCLR    #0,SR                             ; Clear carry bit => no error
2230      P:00066B P:00066B 000000            NOP
2231      P:00066C P:00066C 00000C            RTS
2232   
2233   
2234                                ; This might work with some effort
2235                                ;GT_RPLY        MOVE    Y:RDFIFO,B              ; Read the FIFO word
2236                                ;       EXTRACTU #$010018,B,B
2237                                ;       INSERT  #$008000,Y0,B           ; Add MSB to D23-D16
2238                                ;       NOP
2239                                ;       MOVE    B0,B1
2240                                ;       NOP
2241                                ;       NOP
2242                                ;       BCLR    #0,SR                   ; Clear carry bit => no error
2243                                ;       NOP
2244                                ;       RTS
2245   
2246                                ; ************************  Test on board DRAM  ***********************
2247                                ; Test Y: memory mapped to AA0 and AA2 from $000000 to $FFFFFF (16 megapixels)
2248                                ; DRAM definitions
2249   
2250                                TEST_DRAM
2251   
2252                                ; Test Y: memory mapped to AA0 and AA2 from $000000 to $FFFFFF (16 megapixels)
2253      P:00066D P:00066D 200013            CLR     A
2254      P:00066E P:00066E 000000            NOP
2255      P:00066F P:00066F 21D000            MOVE              A,R0
2256      P:000670 P:000670 26FF00            MOVE              #$FF0000,Y0             ; Y:$000000 to Y:$FEFFFF
2257      P:000671 P:000671 06C600            DO      Y0,L_WRITE_RAM0
                            000675
2258      P:000673 P:000673 5C5800            MOVE                          A1,Y:(R0)+
2259      P:000674 P:000674 014180            ADD     #1,A
2260      P:000675 P:000675 000000            NOP
2261                                L_WRITE_RAM0
2262   
2263      P:000676 P:000676 200013            CLR     A
2264      P:000677 P:000677 000000            NOP
2265      P:000678 P:000678 21D000            MOVE              A,R0
2266      P:000679 P:000679 26FF00            MOVE              #$FF0000,Y0
2267      P:00067A P:00067A 06C600            DO      Y0,L_CHECK_RAM0
                            000682
2268      P:00067C P:00067C 4CD800            MOVE                          Y:(R0)+,X0
2269      P:00067D P:00067D 0C1FF8            CMPU    X0,A
2270      P:00067E P:00067E 0EA681            JEQ     <L_RAM4
2271      P:00067F P:00067F 00008C            ENDDO
2272      P:000680 P:000680 0C069C            JMP     <ERROR_Y
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 43



2273      P:000681 P:000681 014180  L_RAM4    ADD     #1,A
2274      P:000682 P:000682 000000            NOP
2275                                L_CHECK_RAM0
2276   
2277                                ; Test X: memory mapped to AA3 from $1000 to $7FFFFF (8 megapixels)
2278      P:000683 P:000683 200013            CLR     A
2279      P:000684 P:000684 60F400            MOVE              #$1000,R0               ; Skip over internal X: memory
                            001000
2280      P:000686 P:000686 46F400            MOVE              #$7FF000,Y0             ; X:$001000 to X:$7FFFFF
                            7FF000
2281      P:000688 P:000688 06C600            DO      Y0,L_WRITE_RAM3
                            00068C
2282      P:00068A P:00068A 565800            MOVE              A,X:(R0)+
2283      P:00068B P:00068B 014180            ADD     #1,A
2284      P:00068C P:00068C 000000            NOP
2285                                L_WRITE_RAM3
2286   
2287      P:00068D P:00068D 200013            CLR     A
2288      P:00068E P:00068E 60F400            MOVE              #$1000,R0
                            001000
2289      P:000690 P:000690 46F400            MOVE              #$7FF000,Y0
                            7FF000
2290      P:000692 P:000692 06C600            DO      Y0,L_CHECK_RAM3
                            00069A
2291      P:000694 P:000694 44D800            MOVE              X:(R0)+,X0
2292      P:000695 P:000695 0C1FF8            CMPU    X0,A
2293      P:000696 P:000696 0EA699            JEQ     <L_RAM5
2294      P:000697 P:000697 00008C            ENDDO
2295      P:000698 P:000698 0C06A1            JMP     <ERROR_X
2296      P:000699 P:000699 014180  L_RAM5    ADD     #1,A
2297      P:00069A P:00069A 000000            NOP
2298                                L_CHECK_RAM3
2299      P:00069B P:00069B 0C05D4            JMP     <FINISH
2300   
2301      P:00069C P:00069C 44F400  ERROR_Y   MOVE              #'__Y',X0
                            5F5F59
2302      P:00069E P:00069E 440F00            MOVE              X0,X:<TRM_MEM
2303      P:00069F P:00069F 601000            MOVE              R0,X:<TRM_ADR
2304      P:0006A0 P:0006A0 0C05DB            JMP     <ERROR
2305      P:0006A1 P:0006A1 44F400  ERROR_X   MOVE              #'__X',X0
                            5F5F58
2306      P:0006A3 P:0006A3 440F00            MOVE              X0,X:<TRM_MEM
2307      P:0006A4 P:0006A4 601000            MOVE              R0,X:<TRM_ADR
2308      P:0006A5 P:0006A5 0C05DB            JMP     <ERROR
2309   
2310                                ;  ****************  Setup memory tables in X: space ********************
2311   
2312                                ; Define the address in P: space where the table of constants begins
2313   
2314      X:000000 P:0006A6                   ORG     X:VAR_TBL,P:
2315   
2316                                ; Parameters
2317      X:000000 P:0006A6         STATUS    DC      0                                 ; Execution status bits
2318      X:000001 P:0006A7                   DC      0                                 ; Reserved
2319   
2320                                          IF      @SCP("HOST","HOST")               ; Download via host computer
2321                                 CONSTANTS_TBL_START
2322      0006A8                              EQU     @LCV(L)
2323                                          ENDIF
2324   
2325                                          IF      @SCP("HOST","ROM")                ; Boot ROM code
2327                                          ENDIF
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 44



2328   
2329                                          IF      @SCP("HOST","ONCE")               ; Download via ONCE debugger
2331                                          ENDIF
2332   
2333                                ; Parameter table in P: space to be copied into X: space during
2334                                ;   initialization, and must be copied from ROM in the boot process
2335      X:000002 P:0006A8         ONE       DC      1                                 ; One
2336      X:000003 P:0006A9         THREE     DC      3                                 ; Three
2337      X:000004 P:0006AA         FOUR      DC      4                                 ; Four
2338   
2339                                ; Host flags are bits 5,4,3 of the HSTR
2340      X:000005 P:0006AB         FLAG_ZERO DC      0                                 ; Flag = 0 => command executing
2341      X:000006 P:0006AC         FLAG_DONE DC      $000008                           ; Flag = 1 => DONE
2342      X:000007 P:0006AD         FLAG_REPLY DC     $000010                           ; Flag = 2 => reply value available
2343      X:000008 P:0006AE         FLAG_ERR  DC      $000018                           ; Flag = 3 => error
2344      X:000009 P:0006AF         FLAG_SYR  DC      $000020                           ; Flag = 4 => controller reset
2345      X:00000A P:0006B0         FLAG_RDI  DC      $000028                           ; Flag = 5 => reading out image
2346      X:00000B P:0006B1         FLAG_BUSY DC      $000030                           ; Flag = 6 => controller is busy
2347      X:00000C P:0006B2         C512      DC      512                               ; 1/2 the FIFO size
2348      X:00000D P:0006B3         C00FF00   DC      $00FF00
2349      X:00000E P:0006B4         C000202   DC      $000202                           ; Timing board header
2350      X:00000F P:0006B5         TRM_MEM   DC      0                                 ; Test DRAM, memory type of failure
2351      X:000010 P:0006B6         TRM_ADR   DC      0                                 ; Test DRAM, address of failure
2352      X:000011 P:0006B7         DSP_VERS  DC      VERSION                           ; code version
2353   
2354                                ; Tack the length of the variable table onto the length of code to be booted
2355                                 CONSTANTS_TBL_LENGTH
2356      000010                              EQU     @CVS(P,*-ONE)                     ; Length of variable table
2357   
2358                                ; Ending address of program so its length can be calculated for bootstrapping
2359                                ; The constants defined after this are NOT initialized, so need not be
2360                                ;    downloaded.
2361   
2362      0006B8                    END_ADR   EQU     @LCV(L)                           ; End address of P: code written to ROM
2363   
2364                                ; Miscellaneous variables
2365      X:000012 P:0006B8         SV_A      DC      0                                 ; Place for saving accumulator A
2366      X:000013 P:0006B9         NPXLS_1   DC      0                                 ; # of pxls in current READ_IMAGE call, MS b
yte
2367      X:000014 P:0006BA         NPXLS_0   DC      0                                 ; # of pxls in current READ_IMAGE, LS 24-bit
s
2368      X:000015 P:0006BB         IPXLS_1   DC      0                                 ; Down pixel counter in READ_IMAGE, MS byte
2369      X:000016 P:0006BC         IPXLS_0   DC      0                                 ; Down pixel counter in READ_IMAGE, 24-bits
2370      X:000017 P:0006BD         R_PXLS_1  DC      0                                 ; Up Counter of # of pixels read, MS 16-bits
2371      X:000018 P:0006BE         R_PXLS_0  DC      0                                 ; Up Counter of # of pixels read, LS 16-bits
2372                                 BASE_ADDR_1
2373      X:000019 P:0006BF                   DC      0                                 ; Starting PCI address of image, MS byte
2374                                 BASE_ADDR_0
2375      X:00001A P:0006C0                   DC      0                                 ; Starting PCI address of image, LS 24-bits
2376      X:00001B P:0006C1         PCI_ADDR_1 DC     0                                 ; Current PCI address of image, MS byte
2377      X:00001C P:0006C2         PCI_ADDR_0 DC     0                                 ; Current PCI address of image, LS 24-bits
2378      X:00001D P:0006C3         REPLY     DC      0                                 ; Reply value
2379      X:00001E P:0006C4         HOST_FLAG DC      0                                 ; Value of host flags written to X:DCTR
2380      X:00001F P:0006C5         FO_DEST   DC      0                                 ; Whether host or PCI board receives command
2381      X:000020 P:0006C6         FO_CMD    DC      0                                 ; Fiber optic command or reply
2382      X:000021 P:0006C7         NUM_PIX   DC      0                                 ; Number of pixels in the last block
2383      X:000022 P:0006C8         NUM_BLOCKS DC     0                                 ; Number of small blocks at the end
2384      X:000023 P:0006C9         LAST_BIT  DC      0                                 ; # of pixels in the last little bit
2385      X:000024 P:0006CA         SV_DPMC   DC      0                                 ; Save register
2386      X:000025 P:0006CB         SV_A0     DC      0                                 ; Place for saving accumulator A
2387      X:000026 P:0006CC         SV_A1     DC      0                                 ; Accumulator A in interrupt service routine
2388      X:000027 P:0006CD         PCI_ERRS  DC      0                                 ; Detected error count for pci xfer, DMA onl
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 45



y.
2389                                 PCI_BURST_NO
2390      X:000028 P:0006CE                   DC      0                                 ; count of pci bursts for an image.
2391      X:000029 P:0006CF         PCI_ERRLOG DC     0                                 ; set to PCI_ERRMAGIC to get error logging i
n Y:
2392   
2393   
2394   
2395                                ; Check that the parameter table is not too big
2396                                          IF      @CVS(N,*)>=ARG_TBL
2398                                          ENDIF
2399   
2400      X:000030 P:0006D0                   ORG     X:ARG_TBL,P:
2401   
2402                                ; Table that contains the header, command and its arguments
2403      X:000030 P:0006D0         HEADER    DC      0                                 ; (Source, Destination, Number of words)
2404      X:000031 P:0006D1         COMMAND   DC      0                                 ; Manual command
2405      X:000032 P:0006D2         ARG1      DC      0                                 ; First command argument
2406      X:000033 P:0006D3         ARG2      DC      0                                 ; Second command argument
2407                                 DESTINATION
2408      X:000034 P:0006D4                   DC      0                                 ; Derived from header
2409      X:000035 P:0006D5         NUM_ARG   DC      0                                 ; Derived from header
2410   
2411                                ;        ORG     X:VAR2_TBL,P:
2412   
2413                                ; If PCI_BUFSIZE_1 is set non-zero (by host) PCI_BUFSIZE* is understood to
2414                                ; be the size of the mapped dma buffer in the host, and if the dma transfer
2415                                ; for an image exceeds this size, the transfer will wrap back to the start
2416                                ; of the buffer at BASE_ADDR*. The size MUST be a multiple of 512 pixels.
2417                                ; PCI_BUFSIZE* is in units of pixels.
2418                                ;
2419                                ; The value returned by the
2420                                ; READ_NUMBER_OF_PIXELS_READ command is modified as follows: Bits 25-0 are
2421                                ; the difference between BASE_ADDR* and the next location into which data
2422                                ; will transfer, serving as a "FILL" ptr for the transfer. Bits 31-26 are
2423                                ; the low order 6 bits of the number of times the FILL has wrapped. Note that
2424                                ; if the FILL ptr does not wrap (for example, if the BUFSIZE exceeds the image
2425                                ; size) the READ_NUMBER_OF_PIXELS_READ will return the same values in either
2426                                ; mode. Ordinarily, the wrapping mode is used for continuous or effectively
2427                                ; continuous transfers in strip scan or occultation modes, and an extremely
2428                                ; large count of rows is given to the controller. The transfer ends when this
2429                                ; effective image size is exhausted or the image is aborted. The maximum image
2430                                ; size that can be handled in this way is 2**48 pixels.
2431   
2432                                 PCI_BUFSIZE_0
2433      X:000036 P:0006D6                   DC      0
2434                                 PCI_BUFSIZE_1
2435      X:000037 P:0006D7                   DC      0
2436                                 PCI_LSTERRS
2437      X:000038 P:0006D8                   DC      0                                 ; pci errors in the "last little bit"- these
 are
2438                                                                                    ; also recorded in PCI_ERRS.
2439   
2440                                 TOSS_PIXELS
2441      X:000039 P:0006D9                   DC      0                                 ; count of pixels thrown away in end of read
out,
2442      X:00003A P:0006DA         ABT_PIXELS DC     0                                 ; count of pixels thrown away in ABORT_READO
UT
2443   
2444                                          IF      @SCP("SUPPORTED","SUPPORTED")
2445                                 PCI_HISTFILL
2446      X:00003B P:0006DB                   DC      0                                 ; Current history fill ptr.
Motorola DSP56300 Assembler  Version 6.2.23   109-10-25  13:25:41  pciboot.s  Page 46



2447      X:00003C P:0006DC         PCI_HISTON DC     0                                 ; If zero all history log suppressed save NM
I.
2448                                          ENDIF
2449   
2450                                          IF      @SCP("SUPPORTED","SUPPORTED")
2451      X:00003D P:0006DD         WAIT_RDA  DC      0                                 ; time units to wait to enter rdi after RDA
2452                                          ENDIF
2453   
2454                                 R_PXLS_CRIT
2455      X:00003E P:0006DE                   DC      0                                 ; if non-zero R_PXL's are in a transitory st
ate..
2456                                 R_PXLS_RACE
2457      X:00003F P:0006DF                   DC      0                                 ; if non-zero R_PXL's are in a transitory st
ate..
2458   
2459      Y:000000 P:0006E0                   ORG     Y:0,P:
2460   
2461                                ; This must be the LAST constant definition, because it is a large table
2462                                 IMAGE_BUFER
2463      Y:000000 P:0006E0                   DC      0                                 ; Copy image data from FIFO to here
2464   
2465   
2466                                ; End of program
2467                                          END

0    Errors
0    Warnings


