Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  tim.s  Page 1



1                        ; This file is used to generate DSP code for the TimII second generation
2                        ;   timing board. This is Rev. 3.00 software.
3                        ;
4                        ; This file contains two subroutines and X and Y data areas.  The two
5                        ; subroutines are RDCCD (with secondary entry point RCCD1) and CLOCK.
6                        ; These need to be in fast P memory.  The boot code and tim.s are there.
7                        ; tim.s includes timmisc.s and timCCDmisc.s at the
8                        ; beginning and the waveforms file at the end in Y memory.
9      
10                                 PAGE    132                               ; Printronix page width - 132 columns
11     
12                       ; Define a section name so it doesn't conflict with other application programs
13                                 SECTION TIMEEV57
14     
15                       ; Include a header file that defines global parameters
16                                 INCLUDE "timhdr.s"
17                              COMMENT *
18     
19                       This is a header file that is shared between the fiber optic timing board
20                       boot and application code files
21                               *
22     
23                                 PAGE    132                               ; Printronix page width - 132 columns
24     
25                       ; Some basic structural definitions
26        000130         APL_ADR   EQU     $130                              ; P: memory location where application code begins
27        0000D0         APL_LEN   EQU     $200-APL_ADR                      ; Maximum length of application program
28        000030         IMGVAR_ADR EQU    $30                               ;  Special Image Mode variables Starting Address in X:
29     
30                       ; CHANGING MISC_LEN FROM 0X280 TO A LARGER NUMBER BREAKS THE ROM COPY APPROACH!
31                       ; However if all you do is download there is a lot more memory available.
32        000450         MISC_LEN  EQU     $450                              ; Maximum length of "miscellanous" code
33                       ;MISC_LEN EQU   $3F0    ; Maximum length of "miscellanous" code
34                       ; MISC_LEN EQU  $280    ; Maximum length of "miscellanous" code
35     
36        000040         COM_LEN   EQU     $40                               ; Length of memory for application commands
37        00003C         TIM_ISR   EQU     $3C                               ; DSP timer interrupt service routine address
38        00003E         PGM_CON   EQU     $3E                               ; Program continues on here
39        000080         COM_TBL   EQU     $80                               ; Starting address of command table in X: memory
40        000500         N_W_APL   EQU     $500                              ; Number of words in each application
41        000028         NUM_COM   EQU     40                                ; Number of entries in command table
42     
43        000000         RST_ISR   EQU     $00                               ; Hardware reset interrupt
44        000006         ROM_ID    EQU     $06                               ; Location of program Identification = SWI interrupt
45        000008         START     EQU     $08                               ; Starting address of program
46        000060         RCV_BUF   EQU     $60                               ; Starting address of receiver buffer in X:
47        00000F         TBL_ADR   EQU     $0F                               ; (IR) Waveform tables starting address
48     
49        004000         ROM_OFF   EQU     $4000                             ; Boot program offset address in EEPROM
50        004200         LD_X      EQU     $4200                             ; Assembler loads X: starting at this EEPROM address
51        00C600         RD_X      EQU     $C600                             ; DSP reads X: from this EEPROM address
52     
53                       ; Define DSP port addresses
54        00FF80         WRSS      EQU     $FF80                             ; Write clock driver and VP switch states
55        00FFC0         RDFO      EQU     $FFC0                             ; Read serial receiver fiber optic contents
56        00FFC0         WRFO      EQU     $FFC0                             ; Write to fiber optic serial transmitter
57        00FFA0         RDAD      EQU     $FFA0                             ; Read A/D datum into DSP
58        00FFA0         RDAD0     EQU     $FFA0                             ; Address for reading A/D #0
59        00FFA1         RDAD1     EQU     $FFA1                             ; Address for reading A/D #1
60        00FFC1         WRLATCH   EQU     $FFC1                             ; Write to timing board latch
61        006000         RSTWDT    EQU     $6000                             ; Address to reset the timing board watchdog timer
62        00FFFE         BCR       EQU     $FFFE                             ; Bus (=Port A) Control Register -> Wait States
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timhdr.s  Page 2



63        00FFE0         PBC       EQU     $FFE0                             ; Port B Control Register
64        00FFE2         PBDDR     EQU     $FFE2                             ; Port B Data Direction Register
65        00FFE4         PBD       EQU     $FFE4                             ; Port B Data Register
66        00FFE1         PCC       EQU     $FFE1                             ; Port C Control Register
67        00FFE3         PCDDR     EQU     $FFE3                             ; PortC Data Direction Register
68        00FFE5         PCD       EQU     $FFE5                             ; Port C Data Register
69        00FFFF         IPR       EQU     $FFFF                             ; Interrupt Priority Register
70        00FFEF         SSITX     EQU     $FFEF                             ; SSI Transmit and Receive data register
71        00FFEF         SSIRX     EQU     $FFEF                             ; SSI Transmit and Receive data register
72        00FFEE         SSISR     EQU     $FFEE                             ; SSI Status Register
73        00FFEC         CRA       EQU     $FFEC                             ; SSI Control Register A
74        00FFED         CRB       EQU     $FFED                             ; SSI Control Regsiter B
75        00FFDE         TCSR      EQU     $FFDE                             ; Timer control and status register
76        00FFDF         TCR       EQU     $FFDF                             ; Timer count register
77     
78                       ; Hardware bit definitions all over the place
79        000006         SSI_TDE   EQU     6                                 ; SSI Transmitter data register empty
80        000007         SSI_RDF   EQU     7                                 ; SSI Receiver data register full
81        000002         LVEN      EQU     2                                 ; Low voltage enable (+/-15 volt nominal)
82        000003         HVEN      EQU     3                                 ; Enable high voltage (+32V nominal)
83        000005         TIM_U_RST EQU     5                                 ; Timing to utility board reset bit number in U25
84        00000D         PWRST     EQU     13                                ; Power control board reset
85        000007         RST_FIFO  EQU     7                                 ; Reset FIFO bit number in control latch U25
86        000009         EF        EQU     9                                 ; FIFO empty flag, low true
87        000000         TIM_BIT   EQU     0                                 ; Timer status bit
88        000001         WW        EQU     1                                 ; Word width = 1 for 16-bit image data, 0 for 24-bit
89        000000         CDAC      EQU     0                                 ; Bit number in U25 for clearing DACs
90        000002         ENCK      EQU     2                                 ; Bit number in U25 for enabling analog switches
91        000001         DUALCLK   EQU     1                                 ; Set to clock two halves of clock driver board togethe
r
92     
93                       ; Software status bits, defined at X:<STATUS = X:0
94        000000         ST_RCV    EQU     0                                 ; Set if FO, cleared if SSI
95        00000A         TST_IMG   EQU     10                                ; Set if controller is to generate a test image
96        00000B         SHUT      EQU     11                                ; Set if opening shutter at beginning of exposure
97     
98                       ; Software status bits, defined at X:<STATUS = X:0
99        000002         IDLMODE   EQU     2                                 ; Set if need to idle after readout
100       000003         ST_SHUT   EQU     3                                 ; Set to indicate shutter is closed, clear for open
101       000004         ST_RDC    EQU     4                                 ; Set if executing 'RDC' command - reading out
102       000005         SPLIT_S   EQU     5                                 ; Set if split serial
103       000006         SPLIT_P   EQU     6                                 ; Set if split parallel
104       000007         MPP       EQU     7                                 ; Set if parallels are in MPP mode
105       000008         TRIGGER   EQU     8                                 ; Set if a Hardware triggered exposure
106    
107    
108                      ; Image mode bits, defined at X:<IMAGE_MODE
109    
110       000000         FDOTS     EQU     0                                 ; Fast Dots
111       000001         FIND      EQU     1                                 ; Find
112       000002         SDOTS     EQU     2                                 ; Slow Dots
113       000003         SERIES    EQU     3                                 ; Series
114       000004         SINGLE    EQU     4                                 ; Single
115       000005         STRIP     EQU     5                                 ; Stripscan
116       000006         F_OCC     EQU     6                                 ; Fast occultation, keep as 6 for compatibility
117       000007         B_OCC     EQU     7                                 ; Basic occultation
118       000008         P_OCC     EQU     8                                 ; Pipelined occultation
119    
120                      ; Image Status, define at X:<ISTATUS
121       000000         NO_SKIP   EQU     0                                 ; Set for slow dots, fast and pipelined occultation mod
e
122                                                                          ; to avoid parallel skipping to the subframe boundary.
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timhdr.s  Page 3



123       000001         OPEN_CLOSE EQU    1                                 ; Set if shutter opens/closes each image
124                                                                          ; Clear if shutter stays open for many images
125       000002         STORAGE   EQU     2                                 ; Set if storage area is to be clocked
126    
127    
128                      ; Specify controller configuration bits of the X:STATUS word
129                      ;   to describe the software capabilities of this application file
130                      ; The bit is set (=1) if the capability is supported by the controller
131    
132    
133                              COMMENT *
134    
135                      BIT #'s         FUNCTION
136                      2,1,0           Video Processor
137                                              000     CCD Rev. 3
138                                              001     CCD Gen I
139                                              010     IR Rev. 4
140                                              011     IR Coadder
141    
142                      4,3             Timing Board
143                                              00      Rev. 4, Gen II
144                                              01      Gen I
145    
146                      6,5             Utility Board
147                                              00      No utility board
148                                              01      Utility Rev. 3
149    
150                      7               Shutter
151                                              0       No shutter support
152                                              1       Yes shutter support
153    
154                      9,8             Temperature readout
155                                              00      No temperature readout
156                                              01      Polynomial Diode calibration
157                                              10      Linear temperature sensor calibration
158    
159                      10              Subarray readout
160                                              0       Not supported
161                                              1       Yes supported
162    
163                      11              Binning
164                                              0       Not supported
165                                              1       Yes supported
166    
167                      12              Split-Serial readout
168                                              0       Not supported
169                                              1       Yes supported
170    
171                      13              Split-Parallel readout
172                                              0       Not supported
173                                              1       Yes supported
174    
175                      14              MPP = Inverted parallel clocks
176                                              0       Not supported
177                                              1       Yes supported
178    
179                      16,15           Clock Driver Board
180                                              00      Rev. 3
181                                              11      No clock driver board (Gen I)
182    
183                      19,18,17                Special implementations
184                                              000     Somewhere else
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timhdr.s  Page 4



185                                              001     Mount Laguna Observatory
186                                              010     NGST Aladdin
187                                              xxx     Other
188                              *
189    
190                      CCDVIDREV3B
191       000000                   EQU     $000000                           ; CCD Video Processor Rev. 3
192       000001         VIDGENI   EQU     $000001                           ; CCD Video Processor Gen I
193       000002         IRREV4    EQU     $000002                           ; IR Video Processor Rev. 4
194       000003         COADDER   EQU     $000003                           ; IR Coadder
195       000000         TIMREV4   EQU     $000000                           ; Timing Rev. 4
196       000008         TIMGENI   EQU     $000008                           ; Timing Gen I
197       000020         UTILREV3  EQU     $000020                           ; Utility Rev. 3 supported
198       000080         SHUTTER_CC EQU    $000080                           ; Shutter supported
199       000100         TEMP_POLY EQU     $000100                           ; Polynomial calibration
200                      TEMP_LINEAR
201       000200                   EQU     $000200                           ; Linear calibration
202       000400         SUBARRAY  EQU     $000400                           ; Subarray readout supported
203       000800         BINNING   EQU     $000800                           ; Binning supported
204                      SPLIT_SERIAL
205       001000                   EQU     $001000                           ; Split serial supported
206                      SPLIT_PARALLEL
207       002000                   EQU     $002000                           ; Split parallel supported
208       004000         MPP_CC    EQU     $004000                           ; Inverted clocks supported
209       018000         CLKDRVGENI EQU    $018000                           ; No clock driver board - Gen I
210       020000         MLO       EQU     $020000                           ; Set if Mount Laguna Observatory
211       040000         NGST      EQU     $040000                           ; NGST Aladdin implementation
212                                INCLUDE "infospec.s"
213                      ; General DSP info field specifications.
214                      ; These values are 'addresses' and used as the argument for the INF command.
215    
216                      GET_VERSION
217       000000                   EQU     0                                 ; IVERSION field
218       000001         GET_FLAVOR EQU    1                                 ; IFLAVOR field
219       000002         GET_TIME0 EQU     2                                 ; ITIME0 field (lo order, time of compile)
220       000003         GET_TIME1 EQU     3                                 ; ITIME1 field (hi order, time of compile)
221       000004         GET_SVNREV EQU    4                                 ; ISVNREV field (highest svn rev if available)
222    
223                                INCLUDE "timinfospec.s"
224                      ; TIM DSP info field specifications.
225                      ; These values are 'addresses' and used as the argument for the INF command.
226    
227                      GET_CAPABLE
228       000100                   EQU     $100                              ; ICAPABLE field (what dsp supports).
229                      GET_INT_TIM
230       000101                   EQU     $101                              ; Integration time per pixel in leach units
231                      GET_R_DELAY
232       000102                   EQU     $102                              ; Serial overlap in leach units
233                      GET_SI_DELAY
234       000103                   EQU     $103                              ; Parallel overlap in leach units
235    
236                                INCLUDE "timinfo.s"
237                      ; DSP Version
238       04407F         IVERSION  EQU     278655                            ; 1.4/1
239    
240       612020         IFLAVOR   EQU     'a  '                             ; a
241    
242       008416         ITIME0    EQU     33814                             ; lo order time: 2011 8 9  19:1:42 GMT
243    
244       004E41         ITIME1    EQU     20033                             ; hi order time: 2011 8 9  19:1:42 GMT
245    
246       000000         ISVNREV   EQU     0                                 ; most recent code svn rev
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timinfo.s  Page 5



247    
248                      ; tim capability definitions
249                      FINDCAPABLE
250       000001                   EQU     1                                 ; Find exposure mode
251                      SNGLCAPABLE
252       000002                   EQU     2                                 ; Single exposure mode
253                      SERICAPABLE
254       000004                   EQU     4                                 ; Series exposure mode
255                      BASCCAPABLE
256       000008                   EQU     8                                 ; Basic occ exposure mode
257                      FASTCAPABLE
258       000010                   EQU     16                                ; Fast occ exposure mode
259                      PIPECAPABLE
260       000020                   EQU     32                                ; Pipeline occ exposure mode
261                      FDOTCAPABLE
262       000040                   EQU     64                                ; Fast dots exposure mode
263                      SDOTCAPABLE
264       000080                   EQU     128                               ; Slow dots exposure mode
265                      STRPCAPABLE
266       000100                   EQU     256                               ; Slow dots exposure mode
267       0001FB         TIMCAPABLE EQU    FINDCAPABLE+SNGLCAPABLE+STRPCAPABLE+BASCCAPABLE+FASTCAPABLE+PIPECAPABLE+FDOTCAPABLE+SDOTC
APABLE
268    
269       000000         APL_NUM   EQU     0                                 ; Application number from 0 to 3
270    
271       001420         CC        EQU     CCDVIDREV3B+TIMREV4+UTILREV3+SUBARRAY+SPLIT_SERIAL
272    
273                      ; Include miscellaneous timing commands
274                                INCLUDE "timmisc.s"                       ; Custom
275                      ; This file is for utilities that are in common to all the timing board
276                      ;   programs, located starting at P:$200 in external SRAM
277    
278    
279                      ;  ****************  PROGRAM CODE IN SRAM PROGRAM SPACE    *******************
280                      ; Put all the following code in SRAM, starting at P:$200.
281                                IF      @SCP("HOST","HOST")
282       P:0200 P:0200                   ORG     P:$200,P:$200                     ; Download address
283                                       ELSE
285                                       ENDIF
286    
287                             ; Fast clear of CCD, executed as a command
288       P:0200 P:0200 0D0202  CLEAR     JSR     <CLR_CCD
289       P:0201 P:0201 0C0000            JMP     <FINISH
290    
291                             ; Fast clear image before each exposure, executed as a subroutine.  Uses DG
292       P:0202 P:0202 060440  CLR_CCD   DO      Y:<NPCLR,LPCLR                    ; Loop over number of lines in image
                        000207
293       P:0204 P:0204 60F400            MOVE              #IS_CLEAR,R0            ; Address of parallel transfer waveform
                        000060
294       P:0206 P:0206 0D01E9            JSR     <CLOCK                            ; Go clock out the CCD charge
295       P:0207 P:0207 000000            NOP                                       ; Do loop restriction
296                             LPCLR
297       P:0208 P:0208 60F400            MOVE              #DUMP_SERIAL,R0
                        000068
298       P:020A P:020A 0D01E9            JSR     <CLOCK                            ; and wipe out the dregs in the SR
299       P:020B P:020B 44F400            MOVE              #TST_RCV,X0             ; Wait for commands during exposure
                        000000
300       P:020D P:020D 440000            MOVE              X0,X:<IDL_ADR           ;  instead of idling
301       P:020E P:020E 00000C            RTS
302    
303                             ; Keep the CCD idling when not reading out
304       P:020F P:020F 060140  IDLE      DO      Y:<NSR,IDL1                       ; Loop over number of pixels per line
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timmisc.s  Page 6



                        000217
305       P:0211 P:0211 306E00            MOVE              #<SERIAL_IDLE,R0        ; Serial transfer on pixel
306       P:0212 P:0212 0D01E9            JSR     <CLOCK                            ; Go to it
307       P:0213 P:0213 0D0000            JSR     <GET_RCV                          ; Check for FO or SSI commands
308       P:0214 P:0214 0E0217            JCC     <NO_COM                           ; Continue IDLE if no commands received
309       P:0215 P:0215 00008C            ENDDO                                     ; Cancel the DO loop
310       P:0216 P:0216 0C0000            JMP     <CHK_SSI                          ; Go process header and command
311       P:0217 P:0217 000000  NO_COM    NOP
312                             IDL1
313       P:0218 P:0218 306000            MOVE              #<IS_CLEAR,R0           ; Address of parallel clocking waveform
314       P:0219 P:0219 0D01E9            JSR     <CLOCK                            ; Go clock out the CCD charge
315       P:021A P:021A 0C020F            JMP     <IDLE
316    
317    
318                             ; Select which readouts to process
319                             ;   'SOS'  Amplifier_name
320                             ;       Amplifier_name = '__L', '__R', '_LR'
321    
322       P:021B P:021B 44DC00  SEL_OS    MOVE              X:(R4)+,X0              ; Get amplifier(s) name
323       P:021C P:021C 0D021E            JSR     <SELECT_OUTPUT_SOURCE
324       P:021D P:021D 0C0000            JMP     <FINISH1
325    
326                             ; A massive subroutine for setting all the addresses depending on the
327                             ; output source(s) selection and binning parameter.  Most of the
328                             ; waveforms are in fast Y memory (< 0xFF) but there isn't enough
329                             ; space for the fast serial binning waveforms for binning factors
330                             ; 1 through 5.  These are in high Y memory and have to be copied in.
331    
332                             SELECT_OUTPUT_SOURCE
333                             ; Set all the waveform addresses depending on which readout/binning mode
334       P:021E P:021E 56F400            MOVE              #'__L',A                ; LEFT Amplifier = readout #0
                        5F5F4C
335       P:0220 P:0220 200045            CMP     X0,A
336       P:0221 P:0221 0E226C            JNE     <CMP_R
337       P:0222 P:0222 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
338       P:0223 P:0223 56F400            MOVE              #SERIAL_SKIP_LEFT,A
                        0000E8
339       P:0225 P:0225 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
340       P:0227 P:0227 56F400            MOVE              #INITIAL_CLOCK_LEFT,A
                        000093
341       P:0229 P:0229 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
342       P:022B P:022B 56F400            MOVE              #SERIAL_CLOCK_LEFT,A
                        0000AD
343       P:022D P:022D 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
344       P:022F P:022F 56F400            MOVE              #(CLK2+$030000+000+000+000+000+H2L+H2R+000+000),A
                        032012
345       P:0231 P:0231 5E7000            MOVE                          A,Y:CCLK_1
                        0000B5
346       P:0233 P:0233 0A7005            BCLR    #SPLIT_S,X:STATUS
                        000000
347                             ; Now go through copying in the serial read waveform if binning more than 5.
348       P:0235 P:0235 200013            CLR     A
349       P:0236 P:0236 20001B            CLR     B
350       P:0237 P:0237 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
351       P:0238 P:0238 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
352       P:0239 P:0239 50F400            MOVE              #>5,A0
                        000005
353       P:023B P:023B 200005            CMP     B,A
354       P:023C P:023C 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timmisc.s  Page 7



355       P:023D P:023D 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
356       P:023E P:023E 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
357       P:023F P:023F 0A3781  TRY_1_L   JCLR    #1,X:<BINBIT,TRY_2_L
                        000248
358                             ;       MOVE    #1,A0                   ; HACK
359                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
360       P:0241 P:0241 60F400            MOVE              #SERIAL_READ_LEFT_1,R0  ; Here if left amp, bin by 1
                        00013E
361       P:0243 P:0243 51F400            MOVE              #(END_SERIAL_READ_LEFT_1-SERIAL_READ_LEFT_1),B0
                        00000D
362       P:0245 P:0245 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
363       P:0246 P:0246 0D030D            JSR     <WAVECPY                          ; Copy the waveform
364       P:0247 P:0247 0C0307            JMP     <CMP_END
365       P:0248 P:0248 0A3782  TRY_2_L   JCLR    #2,X:<BINBIT,TRY_3_L
                        000251
366       P:024A P:024A 60F400            MOVE              #SERIAL_READ_LEFT_2,R0  ; Here if left amp, bin by 2
                        000165
367       P:024C P:024C 51F400            MOVE              #(END_SERIAL_READ_LEFT_2-SERIAL_READ_LEFT_2),B0
                        000013
368       P:024E P:024E 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
369       P:024F P:024F 0D030D            JSR     <WAVECPY                          ; Copy the waveform
370       P:0250 P:0250 0C0307            JMP     <CMP_END
371       P:0251 P:0251 0A3783  TRY_3_L   JCLR    #3,X:<BINBIT,TRY_4_L
                        00025A
372       P:0253 P:0253 60F400            MOVE              #SERIAL_READ_LEFT_3,R0  ; Here if left amp, bin by 3
                        00019E
373       P:0255 P:0255 51F400            MOVE              #(END_SERIAL_READ_LEFT_3-SERIAL_READ_LEFT_3),B0
                        000019
374       P:0257 P:0257 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
375       P:0258 P:0258 0D030D            JSR     <WAVECPY                          ; Copy the waveform
376       P:0259 P:0259 0C0307            JMP     <CMP_END
377       P:025A P:025A 0A3784  TRY_4_L   JCLR    #4,X:<BINBIT,TRY_5_L
                        000263
378       P:025C P:025C 60F400            MOVE              #SERIAL_READ_LEFT_4,R0  ; Here if left amp, bin by 4
                        0001E9
379       P:025E P:025E 51F400            MOVE              #(END_SERIAL_READ_LEFT_4-SERIAL_READ_LEFT_4),B0
                        00001F
380       P:0260 P:0260 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
381       P:0261 P:0261 0D030D            JSR     <WAVECPY                          ; Copy the waveform
382       P:0262 P:0262 0C0307            JMP     <CMP_END
383       P:0263 P:0263 0A3785  TRY_5_L   JCLR    #5,X:<BINBIT,CMP_END
                        000307
384       P:0265 P:0265 60F400            MOVE              #SERIAL_READ_LEFT_5,R0  ; Here if left amp, bin by 5
                        000246
385       P:0267 P:0267 51F400            MOVE              #(END_SERIAL_READ_LEFT_5-SERIAL_READ_LEFT_5),B0
                        000025
386       P:0269 P:0269 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
387       P:026A P:026A 0D030D            JSR     <WAVECPY                          ; Copy the waveform
388       P:026B P:026B 0C0307            JMP     <CMP_END
389    
390       P:026C P:026C 56F400  CMP_R     MOVE              #'__R',A                ; RIGHT Amplifier = readout #1
                        5F5F52
391       P:026E P:026E 200045            CMP     X0,A
392       P:026F P:026F 0E22BA            JNE     <CMP_LR
393       P:0270 P:0270 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
394       P:0271 P:0271 56F400            MOVE              #SERIAL_SKIP_RIGHT,A
                        0000F0
395       P:0273 P:0273 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
396       P:0275 P:0275 56F400            MOVE              #INITIAL_CLOCK_RIGHT,A
                        000087
397       P:0277 P:0277 5E7000            MOVE                          A,Y:INITIAL_CLOCK
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timmisc.s  Page 8



                        00000E
398       P:0279 P:0279 56F400            MOVE              #SERIAL_CLOCK_RIGHT,A
                        0000A6
399       P:027B P:027B 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
400       P:027D P:027D 56F400            MOVE              #(CLK2+$030000+000+000+H1L+H1R+000+000+000+000),A
                        032009
401       P:027F P:027F 5E7000            MOVE                          A,Y:CCLK_1
                        0000B5
402       P:0281 P:0281 0A7005            BCLR    #SPLIT_S,X:STATUS
                        000000
403                             ; Now go through copying in the serial read waveform if binning more than 5.
404       P:0283 P:0283 200013            CLR     A
405       P:0284 P:0284 20001B            CLR     B
406       P:0285 P:0285 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
407       P:0286 P:0286 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
408       P:0287 P:0287 50F400            MOVE              #>5,A0
                        000005
409       P:0289 P:0289 200005            CMP     B,A
410       P:028A P:028A 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
411       P:028B P:028B 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
412       P:028C P:028C 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
413       P:028D P:028D 0A3781  TRY_1_R   JCLR    #1,X:<BINBIT,TRY_2_R
                        000296
414                             ;       MOVE    #2,A0                   ; HACK
415                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
416       P:028F P:028F 60F400            MOVE              #SERIAL_READ_RIGHT_1,R0 ; Here if right amp, bin by 1
                        00014B
417       P:0291 P:0291 51F400            MOVE              #(END_SERIAL_READ_RIGHT_1-SERIAL_READ_RIGHT_1),B0
                        00000D
418       P:0293 P:0293 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
419       P:0294 P:0294 0D030D            JSR     <WAVECPY                          ; Copy the waveform
420       P:0295 P:0295 0C0307            JMP     <CMP_END
421       P:0296 P:0296 0A3782  TRY_2_R   JCLR    #2,X:<BINBIT,TRY_3_R
                        00029F
422       P:0298 P:0298 60F400            MOVE              #SERIAL_READ_RIGHT_2,R0 ; Here if right amp, bin by 2
                        000178
423       P:029A P:029A 51F400            MOVE              #(END_SERIAL_READ_RIGHT_2-SERIAL_READ_RIGHT_2),B0
                        000013
424       P:029C P:029C 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
425       P:029D P:029D 0D030D            JSR     <WAVECPY                          ; Copy the waveform
426       P:029E P:029E 0C0307            JMP     <CMP_END
427       P:029F P:029F 0A3783  TRY_3_R   JCLR    #3,X:<BINBIT,TRY_4_R
                        0002A8
428       P:02A1 P:02A1 60F400            MOVE              #SERIAL_READ_RIGHT_3,R0 ; Here if right amp, bin by 3
                        0001B7
429       P:02A3 P:02A3 51F400            MOVE              #(END_SERIAL_READ_RIGHT_3-SERIAL_READ_RIGHT_3),B0
                        000019
430       P:02A5 P:02A5 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
431       P:02A6 P:02A6 0D030D            JSR     <WAVECPY                          ; Copy the waveform
432       P:02A7 P:02A7 0C0307            JMP     <CMP_END
433       P:02A8 P:02A8 0A3784  TRY_4_R   JCLR    #4,X:<BINBIT,TRY_5_R
                        0002B1
434       P:02AA P:02AA 60F400            MOVE              #SERIAL_READ_RIGHT_4,R0 ; Here if right amp, bin by 4
                        000208
435       P:02AC P:02AC 51F400            MOVE              #(END_SERIAL_READ_RIGHT_4-SERIAL_READ_RIGHT_4),B0
                        00001F
436       P:02AE P:02AE 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
437       P:02AF P:02AF 0D030D            JSR     <WAVECPY                          ; Copy the waveform
438       P:02B0 P:02B0 0C0307            JMP     <CMP_END
439       P:02B1 P:02B1 0A3785  TRY_5_R   JCLR    #5,X:<BINBIT,CMP_END
                        000307
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timmisc.s  Page 9



440       P:02B3 P:02B3 60F400            MOVE              #SERIAL_READ_RIGHT_5,R0 ; Here if right amp, bin by 5
                        00026B
441       P:02B5 P:02B5 51F400            MOVE              #(END_SERIAL_READ_RIGHT_5-SERIAL_READ_RIGHT_5),B0
                        000025
442       P:02B7 P:02B7 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
443       P:02B8 P:02B8 0D030D            JSR     <WAVECPY                          ; Copy the waveform
444       P:02B9 P:02B9 0C0307            JMP     <CMP_END
445    
446       P:02BA P:02BA 56F400  CMP_LR    MOVE              #'_LR',A                ; LEFT and RIGHT = readouts #0 and #1
                        5F4C52
447       P:02BC P:02BC 200045            CMP     X0,A
448       P:02BD P:02BD 0E230A            JNE     <CMP_ERROR
449       P:02BE P:02BE 4C3D00            MOVE                          X0,Y:<AMPVAL ; save the amp value
450       P:02BF P:02BF 56F400            MOVE              #SERIAL_SKIP_SPLIT,A
                        0000F8
451       P:02C1 P:02C1 5E7000            MOVE                          A,Y:SERIAL_SKIP
                        00000B
452       P:02C3 P:02C3 56F400            MOVE              #INITIAL_CLOCK_SPLIT,A
                        00007B
453       P:02C5 P:02C5 5E7000            MOVE                          A,Y:INITIAL_CLOCK
                        00000E
454       P:02C7 P:02C7 56F400            MOVE              #SERIAL_CLOCK_SPLIT,A
                        00009F
455       P:02C9 P:02C9 5E7000            MOVE                          A,Y:SERIAL_CLOCK
                        00000D
456       P:02CB P:02CB 56F400            MOVE              #(CLK2+$030000+000+000+000+H1R+H2L+000+000+000),A
                        03200A
457       P:02CD P:02CD 5E7000            MOVE                          A,Y:CCLK_1
                        0000B5
458       P:02CF P:02CF 0A7025            BSET    #SPLIT_S,X:STATUS
                        000000
459                             ; Now go through copying in the serial read waveform if binning more than 5.
460       P:02D1 P:02D1 200013            CLR     A
461       P:02D2 P:02D2 20001B            CLR     B
462       P:02D3 P:02D3 573700            MOVE              B,X:<BINBIT             ; Clear BINBIT.  This is for 6 or greater
463       P:02D4 P:02D4 598500            MOVE                          Y:<NSBIN,B0 ; is bin factor more than 5?
464       P:02D5 P:02D5 50F400            MOVE              #>5,A0
                        000005
465       P:02D7 P:02D7 200005            CMP     B,A
466       P:02D8 P:02D8 0E9307            JLT     <CMP_END                          ; If binning 6 or more, don't copy.
467       P:02D9 P:02D9 0D0314            JSR     <SET_BINBIT                       ; else set BINBIT
468       P:02DA P:02DA 37C000            MOVE              #<SERIAL_READ,R7        ; R7 is the destination address for all copies
469       P:02DB P:02DB 0A3781  TRY_1_S   JCLR    #1,X:<BINBIT,TRY_2_S
                        0002E4
470                             ;       MOVE    #3,A0                   ; HACK
471                             ;       MOVE    A0,Y:<INTERVAL          ; HACK
472       P:02DD P:02DD 60F400            MOVE              #SERIAL_READ_SPLIT_1,R0 ; Here if split amp, bin by 1
                        000158
473       P:02DF P:02DF 51F400            MOVE              #(END_SERIAL_READ_SPLIT_1-SERIAL_READ_SPLIT_1),B0
                        00000D
474       P:02E1 P:02E1 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
475       P:02E2 P:02E2 0D030D            JSR     <WAVECPY                          ; Copy the waveform
476       P:02E3 P:02E3 0C0307            JMP     <CMP_END
477       P:02E4 P:02E4 0A3782  TRY_2_S   JCLR    #2,X:<BINBIT,TRY_3_S
                        0002ED
478       P:02E6 P:02E6 60F400            MOVE              #SERIAL_READ_SPLIT_2,R0 ; Here if split amp, bin by 2
                        00018B
479       P:02E8 P:02E8 51F400            MOVE              #(END_SERIAL_READ_SPLIT_2-SERIAL_READ_SPLIT_2),B0
                        000013
480       P:02EA P:02EA 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
481       P:02EB P:02EB 0D030D            JSR     <WAVECPY                          ; Copy the waveform
482       P:02EC P:02EC 0C0307            JMP     <CMP_END
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timmisc.s  Page 10



483       P:02ED P:02ED 0A3783  TRY_3_S   JCLR    #3,X:<BINBIT,TRY_4_S
                        0002F6
484       P:02EF P:02EF 60F400            MOVE              #SERIAL_READ_SPLIT_3,R0 ; Here if split amp, bin by 3
                        0001D0
485       P:02F1 P:02F1 51F400            MOVE              #(END_SERIAL_READ_SPLIT_3-SERIAL_READ_SPLIT_3),B0
                        000019
486       P:02F3 P:02F3 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
487       P:02F4 P:02F4 0D030D            JSR     <WAVECPY                          ; Copy the waveform
488       P:02F5 P:02F5 0C0307            JMP     <CMP_END
489       P:02F6 P:02F6 0A3784  TRY_4_S   JCLR    #4,X:<BINBIT,TRY_5_S
                        0002FF
490       P:02F8 P:02F8 60F400            MOVE              #SERIAL_READ_SPLIT_4,R0 ; Here if split amp, bin by 4
                        000227
491       P:02FA P:02FA 51F400            MOVE              #(END_SERIAL_READ_SPLIT_4-SERIAL_READ_SPLIT_4),B0
                        00001F
492       P:02FC P:02FC 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
493       P:02FD P:02FD 0D030D            JSR     <WAVECPY                          ; Copy the waveform
494       P:02FE P:02FE 0C0307            JMP     <CMP_END
495       P:02FF P:02FF 0A3785  TRY_5_S   JCLR    #5,X:<BINBIT,CMP_END
                        000307
496       P:0301 P:0301 60F400            MOVE              #SERIAL_READ_SPLIT_5,R0 ; Here if split amp, bin by 5
                        000290
497       P:0303 P:0303 51F400            MOVE              #(END_SERIAL_READ_SPLIT_5-SERIAL_READ_SPLIT_5),B0
                        000025
498       P:0305 P:0305 590C00            MOVE                          B0,Y:<SERWAVLEN ; Source address & length now set
499       P:0306 P:0306 0D030D            JSR     <WAVECPY                          ; Copy the waveform
500    
501       P:0307 P:0307 44F400  CMP_END   MOVE              #'DON',X0
                        444F4E
502       P:0309 P:0309 00000C            RTS
503                             CMP_ERROR
504       P:030A P:030A 44F400            MOVE              #'ERR',X0
                        455252
505       P:030C P:030C 00000C            RTS
506    
507                             ; Short function to copy in waveforms from high Y to fast Y memory.
508                             ; R0 is the source address, R7 the destination, and X0 is intermediary reg.
509                             WAVECPY
510       P:030D P:030D 06C900            DO      B0,WAVELP                         ; Copy the waveform; B0 is SERWAVLEN already
                        000311
511       P:030F P:030F 4CD800            MOVE                          Y:(R0)+,X0
512       P:0310 P:0310 4C5F00            MOVE                          X0,Y:(R7)+
513       P:0311 P:0311 000000            NOP
514                             WAVELP
515       P:0312 P:0312 000000            NOP
516       P:0313 P:0313 00000C            RTS
517    
518                             ; Short function to set the correct bit in BINBIT based on NSBIN
519                             ; Called only if NSBIN is less than 6.
520    
521                             SET_BINBIT
522                             ;       MOVE    Y:<TESTLOC1,A0                  ; HACK - test if this code is executed
523                             ;       INC     A                               ; HACK
524                             ;       MOVE    A0,Y:<TESTLOC1                  ; HACK
525       P:0314 P:0314 50F400            MOVE              #>1,A0                  ; Put a bit in A and shift to right spot
                        000001
526       P:0316 P:0316 060540            DO      Y:<NSBIN,BINLOOP                  ; Bit zero position not used, 1-5 used
                        000318
527       P:0318 P:0318 200032            ASL     A
528                             BINLOOP
529       P:0319 P:0319 503700            MOVE              A0,X:<BINBIT            ; set bit 1-5 for SELECT_OUTPUT_SOURCE jump tabl
e
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timmisc.s  Page 11



530       P:031A P:031A 00000C            RTS
531    
532    
533                             ; Set the number of rows and columns and binning factors
534                             SET_ROWS_COLUMNS
535       P:031B P:031B 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NSR = NAXIS1
536       P:031C P:031C 4C7000            MOVE                          X0,Y:NSR
                        000001
537       P:031E P:031E 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NPR = NAXIS2
538       P:031F P:031F 4C7000            MOVE                          X0,Y:NPR
                        000002
539       P:0321 P:0321 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NSBIN
540       P:0322 P:0322 4C7000            MOVE                          X0,Y:NSBIN
                        000005
541       P:0324 P:0324 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the NPBIN
542       P:0325 P:0325 4C7000            MOVE                          X0,Y:NPBIN
                        000006
543       P:0327 P:0327 4CBD00            MOVE                          Y:<AMPVAL,X0 ; Get ampval in X0 for SOS call
544       P:0328 P:0328 0D021E            JSR     <SELECT_OUTPUT_SOURCE             ; Update serial read waveform in case binning ch
anged
545       P:0329 P:0329 0C0000            JMP     <FINISH
546    
547                             ; Set the variables for the time-resolved modes
548                             SET_IMAGE_PARAM
549       P:032A P:032A 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Image mode
550       P:032B P:032B 447000            MOVE              X0,X:IMAGE_MODE
                        000030
551       P:032D P:032D 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Iframes = NAXIS3
552       P:032E P:032E 4C7000            MOVE                          X0,Y:IFRAMES
                        00003A
553       P:0330 P:0330 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Srows
554       P:0331 P:0331 4C7000            MOVE                          X0,Y:SROWS
                        000038
555       P:0333 P:0333 44DC00            MOVE              X:(R4)+,X0              ; Set the value of the Interval
556                             ;       MOVE    X0,Y:INTERVAL           ; HACK - Using Interval as a test location
557       P:0334 P:0334 0C0000            JMP     <FINISH
558    
559    
560                             ; Set the hardware trigger bit, executed as a command
561                             SET_TRIGGER
562       P:0335 P:0335 44DC00            MOVE              X:(R4)+,X0              ; Get the trigger value
563       P:0336 P:0336 56F400            MOVE              #'_ON',A
                        5F4F4E
564       P:0338 P:0338 200045            CMP     X0,A
565       P:0339 P:0339 0AF0A2            JNE     NO_TRIGGER
                        000340
566       P:033B P:033B 0AA4AB            JSET    #11,X:PBD,TRIG_CLR                ; Is Trigger running?
                        00033E
567       P:033D P:033D 0C0000            JMP     <ERROR                            ; Yes! report Error!  Why do this?
568                             TRIG_CLR
569       P:033E P:033E 0A0028            BSET    #TRIGGER,X:<STATUS                ; Set status bit, hardware trigger
570       P:033F P:033F 0C0000            JMP     <FINISH
571                             NO_TRIGGER
572       P:0340 P:0340 0A0008            BCLR    #TRIGGER,X:<STATUS                ; Clear Status bit, software timing
573       P:0341 P:0341 0C0000            JMP     <FINISH
574    
575                             ; Calculate the fast read parameters for each readout box
576                             SETUP_SUBROUTINE
577       P:0342 P:0342 4C8C00            MOVE                          Y:<SERWAVLEN,X0 ; # of waveforms
578       P:0343 P:0343 4D9000            MOVE                          Y:<NSERIALS_READ,X1 ; Number of pixels to read
579       P:0344 P:0344 0D0468            JSR     <FASTSKP                          ; Compute number of clocks required
580       P:0345 P:0345 4D1300            MOVE                          X1,Y:<NREAD ; Number of waveforms per line
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timmisc.s  Page 12



581       P:0346 P:0346 5E9A00            MOVE                          Y:<NR_BIAS,A ; Number of pixels to read
582       P:0347 P:0347 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                        00034A
583       P:0349 P:0349 200022            ASR     A
584       P:034A P:034A 21C500            MOVE              A,X1                    ; Number of waveforms per line
585       P:034B P:034B 0D0468            JSR     <FASTSKP                          ; Compute number of clocks required
586       P:034C P:034C 4D1500            MOVE                          X1,Y:<NBIAS ; Number of waveforms per line
587       P:034D P:034D 44F400            MOVE              #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT),X0 ; # of waveforms
                        000006
588       P:034F P:034F 4D8300            MOVE                          Y:<NS_CLR,X1 ; Number of pixels to skip
589       P:0350 P:0350 0D0468            JSR     <FASTSKP                          ; Compute number of clocks required
590       P:0351 P:0351 4D1100            MOVE                          X1,Y:<NSCLR ; Number of waveforms per line
591       P:0352 P:0352 4D9700            MOVE                          Y:<NS_SKP1,X1 ; Number of pixels to skip
592       P:0353 P:0353 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
593       P:0354 P:0354 2000F0            MPY     Y1,X1,A
594       P:0355 P:0355 200022            ASR     A
595       P:0356 P:0356 210500            MOVE              A0,X1
596       P:0357 P:0357 0D0468            JSR     <FASTSKP                          ; Compute number of clocks required
597       P:0358 P:0358 4D1200            MOVE                          X1,Y:<NSKIP1 ; Number of waveforms per line
598       P:0359 P:0359 4D9800            MOVE                          Y:<NS_SKP2,X1 ; Number of pixels to skip
599       P:035A P:035A 4F8500            MOVE                          Y:<NSBIN,Y1 ; Adjust for binning
600       P:035B P:035B 2000F0            MPY     Y1,X1,A
601       P:035C P:035C 200022            ASR     A
602       P:035D P:035D 210500            MOVE              A0,X1
603       P:035E P:035E 0D0468            JSR     <FASTSKP                          ; Compute number of clocks required
604       P:035F P:035F 4D1400            MOVE                          X1,Y:<NSKIP2 ; Number of waveforms per line
605       P:0360 P:0360 4D9600            MOVE                          Y:<NP_SKIP,X1
606       P:0361 P:0361 4F8600            MOVE                          Y:<NPBIN,Y1
607       P:0362 P:0362 2000F0            MPY     X1,Y1,A
608       P:0363 P:0363 200022            ASR     A
609       P:0364 P:0364 581600            MOVE                          A0,Y:<NP_SKIP
610       P:0365 P:0365 00000C            RTS
611    
612                             ; Returns immediately if hardware triggering is not being used
613                             ; Blocks until the trigger is found to be high twice in a row.
614                             ; Waits until the trigger goes high
615                             WAIT_UNTIL_TRIGGER
616       P:0366 P:0366 0A0088            JCLR    #TRIGGER,X:STATUS,UNTIL_TRIGGER_RETURN
                        00036F
617       P:0368 P:0368 000000            NOP
618       P:0369 P:0369 0AA48B            JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER      ; Is Trigger Low?
                        000366
619       P:036B P:036B 000000            NOP                                       ; Pause
620       P:036C P:036C 0AA48B            JCLR    #11,X:PBD,WAIT_UNTIL_TRIGGER      ; Is Trigger still Low?
                        000366
621       P:036E P:036E 000000            NOP
622                             UNTIL_TRIGGER_RETURN
623       P:036F P:036F 00000C            RTS
624    
625                             ; Returns immediately if hardware triggering is not being used
626                             ; Blocks until the trigger is found to be low twice in a row.
627                             ; Waits while the trigger is high
628                             WAIT_WHILE_TRIGGER
629       P:0370 P:0370 0A0088            JCLR    #TRIGGER,X:STATUS,WHILE_TRIGGER_RETURN
                        000379
630       P:0372 P:0372 000000            NOP
631       P:0373 P:0373 0AA4AB            JSET    #11,X:PBD,WAIT_WHILE_TRIGGER      ; Is Trigger High?
                        000370
632       P:0375 P:0375 000000            NOP                                       ; Pause
633       P:0376 P:0376 0AA4AB            JSET    #11,X:PBD,WAIT_WHILE_TRIGGER      ; Is Trigger still High?
                        000370
634       P:0378 P:0378 000000            NOP
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timmisc.s  Page 13



635                             WHILE_TRIGGER_RETURN
636       P:0379 P:0379 00000C            RTS
637    
638                             ; Like WAIT_WHILE_TRIGGER but clears the CCD while waiting
639                             ; Pro:  Clears CCD while waiting.  Con: timing rattiness of 1 parallel time
640                             ; Returns immediately if hardware triggering is not being used
641                             ; Blocks until the trigger is found to be low twice in a row.
642                             ; Waits while the trigger is high
643                             CLEAR_WHILE_TRIGGER
644       P:037A P:037A 0A0088            JCLR    #TRIGGER,X:STATUS,CLEAR_TRIG_RETURN
                        000385
645       P:037C P:037C 60F400            MOVE              #IS_CLEAR,R0            ; Address of parallel transfer waveform
                        000060
646       P:037E P:037E 0D01E9            JSR     <CLOCK                            ; Go clock out the CCD charge
647       P:037F P:037F 0AA4AB            JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER     ; Is Trigger High?
                        00037A
648       P:0381 P:0381 000000            NOP                                       ; Pause
649       P:0382 P:0382 0AA4AB            JSET    #11,X:PBD,CLEAR_WHILE_TRIGGER     ; Is Trigger still High?
                        00037A
650       P:0384 P:0384 000000            NOP
651                             CLEAR_TRIG_RETURN
652       P:0385 P:0385 00000C            RTS
653    
654                             ; Subroutine to compute SROWS in unbinned pixels and store in UBSROWS
655    
656                             UB_CONV
657       P:0386 P:0386 4CB800            MOVE                          Y:<SROWS,X0
658       P:0387 P:0387 4D8600            MOVE                          Y:<NPBIN,X1 ; Adjust for for parallel binning factor
659       P:0388 P:0388 2000A0            MPY     X0,X1,A
660       P:0389 P:0389 200022            ASR     A
661       P:038A P:038A 583900            MOVE                          A0,Y:<UBSROWS ; Put unbinned number in UBSROWS
662       P:038B P:038B 00000C            RTS
663    
664                             ; Key code segments for the HIPO modes.
665                             ; Jump table to the various modes - see also timhdr.s
666                             START_FT_EXPOSURE
667       P:038C P:038C 0A30A1            JSET    #FIND,X:IMAGE_MODE,SINGLE_PROC
                        0003BD
668       P:038E P:038E 0A30A4            JSET    #SINGLE,X:IMAGE_MODE,SINGLE_PROC
                        0003BD
669                             ;       JSET    #SERIES,X:IMAGE_MODE,SERIES_PROC        ; defunct.  Use basic occ.
670       P:0390 P:0390 0A30A0            JSET    #FDOTS,X:IMAGE_MODE,FDOT_PROC
                        00039F
671       P:0392 P:0392 0A30A2            JSET    #SDOTS,X:IMAGE_MODE,SDOT_PROC     ; slow dots & strips use sdot_proc
                        0003DE
672       P:0394 P:0394 0A30A5            JSET    #STRIP,X:IMAGE_MODE,SDOT_PROC
                        0003DE
673       P:0396 P:0396 0A30A7            JSET    #B_OCC,X:IMAGE_MODE,SINGLE_PROC   ; basic occ uses single_proc
                        0003BD
674       P:0398 P:0398 0A30A6            JSET    #F_OCC,X:IMAGE_MODE,FPO_PROC      ; fast & pipelined occ use occ_proc
                        0003FF
675       P:039A P:039A 0A30A8            JSET    #P_OCC,X:IMAGE_MODE,FPO_PROC
                        0003FF
676       P:039C P:039C 44F400            MOVE              #'ERR',X0               ; error if not a valid mode
                        455252
677       P:039E P:039E 0C0000            JMP     <ERROR
678    
679                             FDOT_PROC                                           ; used by fdots only
680                             ; Start by replacing SROWS (binned rows) with unbinned rows.  Will get rewritten on next SEX command
681                             ; Leave the DO loop in here - no reason to change it - won't exceed 65535 dots, for sure!
682       P:039F P:039F 0D0386            JSR     UB_CONV                           ; Fill in unbinned SROWS
683       P:03A0 P:03A0 5E8200            MOVE                          Y:<NPR,A
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timmisc.s  Page 14



684       P:03A1 P:03A1 5E1C00            MOVE                          A,Y:<NP_READ ; Make sure that NP_READ=NPR in case of subfram
e
685       P:03A2 P:03A2 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
686       P:03A3 P:03A3 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for FDOTS
687       P:03A4 P:03A4 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
688       P:03A5 P:03A5 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        00042F
689       P:03A7 P:03A7 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
690       P:03A8 P:03A8 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
691                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
692       P:03A9 P:03A9 0D046F            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
693       P:03AA P:03AA 063A40            DO      Y:<IFRAMES,FDOT_LOOP              ; Loop over the number of FDOTS
                        0003B5
694       P:03AC P:03AC 0A00A8            JSET    #TRIGGER,X:STATUS,FDX_END         ; If no triggering jump to expose image function
                        0003B1
695       P:03AE P:03AE 67F400            MOVE              #FDX_END,R7             ; Store the Address into R7
                        0003B1
696       P:03B0 P:03B0 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
697       P:03B1 P:03B1 0D0366  FDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
698       P:03B2 P:03B2 4DB900            MOVE                          Y:<UBSROWS,X1 ; Number of unbinned rows per shift
699       P:03B3 P:03B3 0D0444            JSR     <ISHIFT                           ; Clock out the waveforms
700       P:03B4 P:03B4 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
701       P:03B5 P:03B5 000000            NOP
702                             FDOT_LOOP
703       P:03B6 P:03B6 0D0476            JSR     <C_CSHUT                          ; Conditionally close shutter
704       P:03B7 P:03B7 063A40            DO      Y:<IFRAMES,FDOT_LP1               ; Loop over the number of FDOTS during readout
                        0003BA
705       P:03B9 P:03B9 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD
706       P:03BA P:03BA 000000            NOP
707                             FDOT_LP1
708                             ;       JSR     <WAIT_UNTIL_TRIGGER             ; If taking more than one set of dots sync. trigger.
  Vestigial?
709       P:03BB P:03BB 0AF080            JMP     CLEANUP                           ; clean up after command.
                        00043C
710    
711                             SINGLE_PROC                                         ; Used by find, single, and basic occ
712       P:03BD P:03BD 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for find & basic occ
713       P:03BE P:03BE 0A3084            JCLR    #SINGLE,X:IMAGE_MODE,*+3          ; But if single mode,
                        0003C1
714       P:03C0 P:03C0 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
715       P:03C1 P:03C1 0A3102            BCLR    #STORAGE,X:<ISTATUS               ; Do the FT, no storage clocks only during reado
ut
716       P:03C2 P:03C2 0A3100            BCLR    #NO_SKIP,X:<ISTATUS               ; Do parallel skip up to the subframe boundary
717       P:03C3 P:03C3 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        00042F
718       P:03C5 P:03C5 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
719       P:03C6 P:03C6 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
720                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
721       P:03C7 P:03C7 58BA00            MOVE                          Y:<IFRAMES,A0
722       P:03C8 P:03C8 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
723       P:03C9 P:03C9 0D046F  SN_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
724       P:03CA P:03CA 0A00A8            JSET    #TRIGGER,X:STATUS,SNX_END         ; If no triggering jump to expose image function
                        0003CF
725       P:03CC P:03CC 67F400            MOVE              #SNX_END,R7             ; Store the Address into R7
                        0003CF
726       P:03CE P:03CE 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
727       P:03CF P:03CF 0D0366  SNX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
728       P:03D0 P:03D0 0D0476            JSR     <C_CSHUT                          ; Close shutter if open-close bit is set
729       P:03D1 P:03D1 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD
730       P:03D2 P:03D2 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
731       P:03D3 P:03D3 200013            CLR     A
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timmisc.s  Page 15



732       P:03D4 P:03D4 58BE00            MOVE                          Y:<IFLPCNT,A0
733       P:03D5 P:03D5 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
734       P:03D6 P:03D6 583E00            MOVE                          A0,Y:<IFLPCNT
735       P:03D7 P:03D7 200003            TST     A
736       P:03D8 P:03D8 0E23C9            JNE     SN_LP                             ; End of IFRAMES loop
737       P:03D9 P:03D9 0A30A1            JSET    #FIND,X:IMAGE_MODE,*+3
                        0003DC
738       P:03DB P:03DB 0D0478            JSR     <CSHUT                            ; Close the shutter unless in find mode
739       P:03DC P:03DC 0AF080            JMP     CLEANUP                           ; clean up after command.
                        00043C
740    
741                             SDOT_PROC                                           ; Used by slow dots and strips
742       P:03DE P:03DE 5EB800            MOVE                          Y:<SROWS,A
743       P:03DF P:03DF 5E1C00            MOVE                          A,Y:<NP_READ ; Make sure that NP_READ=SROWS
744       P:03E0 P:03E0 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for strips
745       P:03E1 P:03E1 0A3082            JCLR    #SDOTS,X:IMAGE_MODE,*+3           ; But if sdots mode,
                        0003E4
746       P:03E3 P:03E3 0A3121            BSET    #OPEN_CLOSE,X:<ISTATUS            ; set the open-close bit
747       P:03E4 P:03E4 0A3122            BSET    #STORAGE,X:<ISTATUS               ; Don't shift the storage array for SDOTS and st
rips
748       P:03E5 P:03E5 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
749       P:03E6 P:03E6 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        00042F
750       P:03E8 P:03E8 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
751       P:03E9 P:03E9 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
752                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
753       P:03EA P:03EA 58BA00            MOVE                          Y:<IFRAMES,A0
754       P:03EB P:03EB 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
755       P:03EC P:03EC 0D046F  SD_LP     JSR     <C_OSHUT                          ; Open shutter if not a dark frame
756       P:03ED P:03ED 0A00A8            JSET    #TRIGGER,X:STATUS,SDX_END         ; If no triggering jump to expose image function
                        0003F2
757       P:03EF P:03EF 67F400            MOVE              #SDX_END,R7             ; Store the Address into R7
                        0003F2
758       P:03F1 P:03F1 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
759       P:03F2 P:03F2 0D0366  SDX_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
760       P:03F3 P:03F3 0D0476            JSR     <C_CSHUT                          ; Close shutter if open-close is set
761       P:03F4 P:03F4 0D0130            JSR     <RDCCD                            ; Finally, read out the CCD.
762                                                                                 ; No FT or parallel skip since STORAGE=1
763       P:03F5 P:03F5 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
764       P:03F6 P:03F6 200013            CLR     A
765       P:03F7 P:03F7 58BE00            MOVE                          Y:<IFLPCNT,A0
766       P:03F8 P:03F8 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
767       P:03F9 P:03F9 583E00            MOVE                          A0,Y:<IFLPCNT
768       P:03FA P:03FA 200003            TST     A
769       P:03FB P:03FB 0E23EC            JNE     SD_LP                             ; End of IFRAMES loop
770       P:03FC P:03FC 0D0478            JSR     <CSHUT                            ; Unconditionally close shutter
771       P:03FD P:03FD 0AF080            JMP     CLEANUP                           ; clean up after command.
                        00043C
772    
773                             FPO_PROC                                            ; Used by fast and pipelined occultation modes
774       P:03FF P:03FF 5E9C00            MOVE                          Y:<NP_READ,A
775       P:0400 P:0400 5E3800            MOVE                          A,Y:<SROWS  ; Make sure that SROWS=NP_READ
776       P:0401 P:0401 0D0386            JSR     UB_CONV                           ; Fill in unbinned SROWS in UBSROWS
777       P:0402 P:0402 0A3101            BCLR    #OPEN_CLOSE,X:<ISTATUS            ; clear open-close for both of these modes
778       P:0403 P:0403 0A3102            BCLR    #STORAGE,X:<ISTATUS               ; Storage clocks only during readout
779       P:0404 P:0404 0A3120            BSET    #NO_SKIP,X:<ISTATUS               ; Don't parallel skip up to the subframe boundar
y
780       P:0405 P:0405 0BF080            JSR     IMG_INI                           ; Set up the status bits and PCI card
                        00042F
781       P:0407 P:0407 0D0202            JSR     <CLR_CCD                          ; Clear out the CCD
782       P:0408 P:0408 0D0370            JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger, or
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timmisc.s  Page 16



783                             ;       JSR     <CLEAR_WHILE_TRIGGER            ; clear while waiting for low trigger
784       P:0409 P:0409 0D046F            JSR     <C_OSHUT                          ; Open shutter if not a dark frame
785       P:040A P:040A 58BA00            MOVE                          Y:<IFRAMES,A0
786       P:040B P:040B 583E00            MOVE                          A0,Y:<IFLPCNT ; Set up 24-bit loop counter in IFLPCNT
787       P:040C P:040C 0A00A8  FP_LP     JSET    #TRIGGER,X:STATUS,FPO_END         ; If no triggering jump to expose image function
                        000411
788       P:040E P:040E 67F400            MOVE              #FPO_END,R7             ; Store the Address into R7
                        000411
789       P:0410 P:0410 0C0000            JMP     <EXPOSE                           ; Delay for specified exposure time
790       P:0411 P:0411 0D0366  FPO_END   JSR     <WAIT_UNTIL_TRIGGER               ; wait for high trigger or fall through
791       P:0412 P:0412 4DB900            MOVE                          Y:<UBSROWS,X1 ; Shift down UBSROWS unbinned rows
792       P:0413 P:0413 0BF080            JSR     ISHIFT                            ; Clock down subframe height
                        000444
793       P:0415 P:0415 0A30A8            JSET    #P_OCC,X:IMAGE_MODE,FPO_RD        ; Shift the rest of the way for F_OCC
                        00041F
794                                                                                 ; Go straight to readout if P_OCC
795       P:0417 P:0417 4CF000            MOVE                          Y:S_SIZE,X0
                        00003B
796       P:0419 P:0419 208E00            MOVE              X0,A                    ; Get only least significant 24 bits
797       P:041A P:041A 4CB900            MOVE                          Y:<UBSROWS,X0
798       P:041B P:041B 200044            SUB     X0,A                              ;
799       P:041C P:041C 21C500            MOVE              A,X1                    ; X1 = S_SIZE - UBSROWS
800       P:041D P:041D 0BF080            JSR     SSHIFT                            ; Clock storage the rest of the way
                        00044D
801       P:041F P:041F 0D0134  FPO_RD    JSR     <RCCD1                            ; Finally, read out the CCD.  Skip the FT
802       P:0420 P:0420 0A30A6            JSET    #F_OCC,X:IMAGE_MODE,FPO_SK        ; Shift back up by UBSROWS if P_OCC
                        000425
803       P:0422 P:0422 4DB900            MOVE                          Y:<UBSROWS,X1 ; Shift UBSROWS unbinned rows back up
804       P:0423 P:0423 0BF080            JSR     RSHIFT                            ; Clock subframe height back up
                        000456
805       P:0425 P:0425 0D0370  FPO_SK    JSR     <WAIT_WHILE_TRIGGER               ; wait for low trigger
806       P:0426 P:0426 200013            CLR     A
807       P:0427 P:0427 58BE00            MOVE                          Y:<IFLPCNT,A0
808       P:0428 P:0428 00000A            DEC     A                                 ; Get loop count, decrement, and loop till zero
809       P:0429 P:0429 583E00            MOVE                          A0,Y:<IFLPCNT
810       P:042A P:042A 200003            TST     A
811       P:042B P:042B 0E240C            JNE     FP_LP                             ; End of IFRAMES loop
812       P:042C P:042C 0D0478            JSR     <CSHUT                            ; Unconditionally close shutter
813       P:042D P:042D 0AF080            JMP     CLEANUP                           ; clean up after command.
                        00043C
814    
815                             ; Support subroutines and code fragments used in the various mode code
816                             ; IMG_INI, CLEANUP, ISHIFT, SSHIFT, RSHIFT
817                             ;  Image initialization subroutine.  Sets up status bits & PCI card
818    
819       P:042F P:042F 09F480  IMG_INI   MOVEP             #$020102,Y:WRFO         ; Transmit header word
                        020102
820       P:0431 P:0431 060FA0            REP     #15                               ; Delay for transmission
821       P:0432 P:0432 000000            NOP
822       P:0433 P:0433 09F480            MOVEP             #'IIA',Y:WRFO           ; Initialize Image Address
                        494941
823       P:0435 P:0435 060FA0            REP     #15
824       P:0436 P:0436 000000            NOP
825       P:0437 P:0437 0A0024            BSET    #ST_RDC,X:<STATUS                 ; Set status to reading out
826       P:0438 P:0438 0D05E4            JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
827       P:0439 P:0439 0AA421            BSET    #WW,X:PBD                         ; Set WW = 1 for 16-bit image data
828       P:043A P:043A 000000            NOP
829       P:043B P:043B 00000C            RTS
830    
831                             ; Cleanup code fragment (not a subroutine) for the end all modes.  JMP to it.
832    
833       P:043C P:043C 0AA401  CLEANUP   BCLR    #WW,X:PBD                         ; Clear WW to 0 for 32-bit commands
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timmisc.s  Page 17



834       P:043D P:043D 0A0004            BCLR    #ST_RDC,X:<STATUS                 ; Clear status to NOT reading out
835                             ; Restore the controller to non-image data transfer and idling if necessary
836       P:043E P:043E 0A0082            JCLR    #IDLMODE,X:<STATUS,START          ; Don't idle after readout
                        000008
837       P:0440 P:0440 44F400            MOVE              #IDLE,X0
                        00020F
838       P:0442 P:0442 440000            MOVE              X0,X:<IDL_ADR
839       P:0443 P:0443 0C0008            JMP     <START                            ; Wait for a new command
840    
841                             ; Shift image and storage areas down by the number of rows in X1
842                             ISHIFT
843       P:0444 P:0444 06C500            DO      X1,ISH_LOOP                       ; Number of rows to shift is in X1
                        000448
844       P:0446 P:0446 306000            MOVE              #<IS_CLEAR,R0           ; Ganged clocks with DG running
845       P:0447 P:0447 0D01E9            JSR     <CLOCK                            ; Parallel clocking
846       P:0448 P:0448 000000            NOP
847                             ISH_LOOP
848       P:0449 P:0449 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                        000068
849       P:044B P:044B 0D01E9            JSR     <CLOCK
850       P:044C P:044C 00000C            RTS                                       ; End of ISHIFT
851    
852                             ; Shift storage area only down by the number of rows in X1
853                             SSHIFT
854       P:044D P:044D 06C500            DO      X1,SSH_LOOP                       ; Number of rows to shift is in X1
                        000451
855       P:044F P:044F 305000            MOVE              #<S_CLEAR,R0            ; Storage clocks only with DG running
856       P:0450 P:0450 0D01E9            JSR     <CLOCK                            ; Parallel clocking
857       P:0451 P:0451 000000            NOP
858                             SSH_LOOP
859       P:0452 P:0452 60F400            MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel clear
                        000068
860       P:0454 P:0454 0D01E9            JSR     <CLOCK
861       P:0455 P:0455 00000C            RTS                                       ; End of SSHIFT
862    
863                             ; Used by pipelined occultation mode to move the storage area back up to
864                             ; the seam following read of a subframe
865                             RSHIFT
866       P:0456 P:0456 06C500            DO      X1,RVS_SHIFT                      ; Number of rows to read out
                        00045A
867       P:0458 P:0458 304800            MOVE              #<R_S_PARALLEL,R0       ; Reverse parallel waveform
868       P:0459 P:0459 0D01E9            JSR     <CLOCK                            ; Parallel clocking
869       P:045A P:045A 000000            NOP
870                             RVS_SHIFT
871       P:045B P:045B 00000C            RTS                                       ; End of RSHIFT
872                                       INCLUDE "timCCDmisc.s"                    ; Generic
873                             ; This file is for utilities that are in common to all the timing board
874                             ;   programs, located starting at P:$200 in external SRAM
875    
876                                     COMMENT *
877    
878                             The following commands are supported in this "timmisc.s" file
879                             PAL_DLY                 Subroutine to delay by about 8 microseconds
880                             SET_DAC                 Transfer DAC values in (R0) table to the DACs
881                             FASTSKP                 Compute number of waveform table entries in a readout
882                                                             for fast clocking
883                             SYNTHETIC_IMAGE         Generate a synthetic image for system testing
884                             OSHUT                   Subroutine call for opening the shutter
885                             CSHUT                   Subroutine call for closing the shutter
886                             OPEN_SHUTTER            Command for opening the shutter
887                             CLOSE_SHUTTER           Command for closing the shutter
888                             SET_EXP_TIME            Write desired exposure time to timing board variable
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timCCDmisc.s  Page 18



889                             RD_EXP_TIME             Read elapsed exposure time
890                             START_EXPOSURE          Start an exposure - 'DON' reply, clear FPA, open
891                                                     shutter, expose, close shutter, delay Y:SH_DLY, readout
892                             PAUSE_EXPOSURE          Close shutter, stop exposure timer
893                             RESUME_EXPOSURE         Open shutter if necessary, resume exposure timer
894                             ABORT_EXPOSURE          Close shutter, stop exposure timer
895                             INF                     Return version and timing information
896                             IDL                     Put FPA to clocking when not processing commands or
897                                                     reading out
898                             STP                     Put FPA to not clocking when not processing commands or
899                                                     reading out
900                             READ_CONTROLLER_CONFIGURATION
901    
902                             PWR_OFF                 Turn off ananlog power supply voltages to backplane
903                             PWR_ON                  Turn on analog power supply voltages to backplane
904                             SETBIAS                 Command to call SET_BIASES and reply 'DON'
905                             SET_BIASES              Subroutine to turn on all bias and clock voltages
906                                                     by reading them from the waveform tables and writing
907                                                     them to the DACs
908                             SER_ANA                 Direct the timing board DSP's synchronous serial
909                                                     transmitter to the analog boards (clock driver, video)
910                             SER_UTL                 Direct the timing board DSP's synchronous serial
911                                                     transmitter to the utility board
912                             CLR_SWS                 Clear the analog switches in the clock driver and
913                                                     video boards to lower their power consumption, as a
914                                                     command with a 'DON' reply
915                             CLEAR_SWITCHES          A subroutine call for CLR_WSW
916                             ST_GAIN                 Set the video processor gain to one of four values
917                             WR_CNTRL
918                             SET_DC
919                             SET_BIAS_NUMBER
920                             SET_MUX
921    
922                                     *
923    
924                             ;  ** Place this file after the custom timmisc.s file so it continues
925                             ;       to be written in the P:$200 address space  ****
926    
927                             ; Hardware control bit definitions
928       000004                SHUTTER   EQU     4                                 ; Shutter control bit = TIM-LATCH0, A30
929    
930    
931                             ; Delay for serial writes to the PALs and DACs by 8 microsec
932       P:045C P:045C 06FA80  PAL_DLY   DO      #250,DLY                          ; Wait 8 usec for serial data transmission
                        00045E
933       P:045E P:045E 000000            NOP
934       P:045F P:045F 000000  DLY       NOP
935       P:0460 P:0460 00000C            RTS
936    
937                             ;  Update the DACs
938       P:0461 P:0461 4CD800  SET_DAC   MOVE                          Y:(R0)+,X0  ; Get the number of table entries
939       P:0462 P:0462 06C400            DO      X0,SET_L0                         ; Repeat X0 times
                        000466
940       P:0464 P:0464 08D8EF            MOVEP             Y:(R0)+,X:SSITX         ; Send out the waveform
941       P:0465 P:0465 0D045C            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
942       P:0466 P:0466 000000            NOP                                       ; Do loop restriction
943                             SET_L0
944       P:0467 P:0467 00000C            RTS                                       ; Return from subroutine
945    
946                             ; Subroutine for computing number of fast clocks needed
947       P:0468 P:0468 2000A8  FASTSKP   MPY     X0,X1,B                           ; X1 = number of pixels to skip,
948                                                                                 ; X0 = number of waveform table entries
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timCCDmisc.s  Page 19



949       P:0469 P:0469 20002A            ASR     B                                 ; Correct for multiplication left shift
950       P:046A P:046A 212E00            MOVE              B0,A                    ; Get only least significant 24 bits
951       P:046B P:046B 458000            MOVE              X:<ONE,X1
952       P:046C P:046C 200064            SUB     X1,A                              ; Subtract 1
953       P:046D P:046D 21C500            MOVE              A,X1                    ; X1 = X0 * X1 - 1
954       P:046E P:046E 00000C            RTS
955    
956                             ; Subroutine with two entry points.  C_OSHUT is conditional on SHUT
957                             ; Open the shutter conditionally based on the shutter status bit
958                             ; Open the shutter by setting the backplane bit TIM-LATCH0
959       P:046F P:046F 0A008B  C_OSHUT   JCLR    #SHUT,X:STATUS,OSH_RTN
                        000475
960       P:0471 P:0471 0A0023  OSHUT     BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
961       P:0472 P:0472 0A0004            BCLR    #SHUTTER,X:<LATCH                 ; Clear hardware shutter bit to open
962       P:0473 P:0473 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                        000000
963       P:0475 P:0475 00000C  OSH_RTN   RTS
964    
965                             ; Subroutine with two entry points.  C_CSHUT is conditional on OPEN_CLOSE
966                             ; Close the shutter conditionally based on the open-close ISTATUS bit
967                             ; Close the shutter by clearing the backplane bit TIM-LATCH0
968       P:0476 P:0476 0A3181  C_CSHUT   JCLR    #OPEN_CLOSE,X:ISTATUS,CSH_RTN     ; Don't close if always open
                        000488
969       P:0478 P:0478 0A0003  CSHUT     BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
970       P:0479 P:0479 0A0024            BSET    #SHUTTER,X:<LATCH                 ; Set hardware shutter bit to close
971       P:047A P:047A 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                        000000
972       P:047C P:047C 5E8900            MOVE                          Y:<SH_DEL,A
973       P:047D P:047D 200003            TST     A
974       P:047E P:047E 0EF487            JLE     <S_DEL0
975       P:047F P:047F 44F400            MOVE              #25000,X0
                        0061A8
976       P:0481 P:0481 06CE00            DO      A,S_DEL0                          ; Delay by Y:SH_DEL milliseconds
                        000486
977       P:0483 P:0483 06C400            DO      X0,S_DEL1
                        000485
978       P:0485 P:0485 000000            NOP
979       P:0486 P:0486 000000  S_DEL1    NOP
980       P:0487 P:0487 000000  S_DEL0    NOP
981       P:0488 P:0488 00000C  CSH_RTN   RTS
982    
983                             ; Open the shutter from the timing board, executed as a command
984                             OPEN_SHUTTER
985       P:0489 P:0489 0D0471            JSR     <OSHUT
986       P:048A P:048A 0C0000            JMP     <FINISH
987    
988                             ; Close the shutter from the timing board, executed as a command
989                             CLOSE_SHUTTER
990       P:048B P:048B 0D0478            JSR     <CSHUT
991       P:048C P:048C 0C0000            JMP     <FINISH
992    
993                             ; Set the desired exposure time
994                             SET_EXP_TIME
995       P:048D P:048D 44DC00            MOVE              X:(R4)+,X0
996       P:048E P:048E 440000            MOVE              X0,X:<EXP_TIM           ; Write to magic address
997       P:048F P:048F 440000            MOVE              X0,X:<TGT_TIM
998       P:0490 P:0490 0C0000            JMP     <FINISH
999    
1000   
1001                            ; Abort exposure - close the shutter, stop the timer and resume idle mode
1002                            ABORT_EXPOSURE
1003      P:0491 P:0491 0A9E00            BCLR    #TIM_BIT,X:TCSR                   ; Disable the DSP exposure timer
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timCCDmisc.s  Page 20



1004      P:0492 P:0492 0D0478            JSR     <CSHUT                            ; Close the shutter
1005      P:0493 P:0493 0A0082            JCLR    #IDLMODE,X:<STATUS,FINISH         ; Check whether to idle after readout
                        000000
1006      P:0495 P:0495 44F400            MOVE              #IDLE,X0                ; Idle after readout
                        00020F
1007      P:0497 P:0497 440000            MOVE              X0,X:<IDL_ADR
1008      P:0498 P:0498 0C0000            JMP     <FINISH
1009   
1010                            ;       Process INF according to the single addressing parameter
1011                            GET_INFO
1012      P:0499 P:0499 56DC00            MOVE              X:(R4)+,A               ; 0-4 is generic, >= 0x100 tim specific
1013      P:049A P:049A 44F400            MOVE              #IVERSION,X0
                        04407F
1014      P:049C P:049C 46F400            MOVE              #>GET_VERSION,Y0
                        000000
1015      P:049E P:049E 200055            CMP     Y0,A
1016      P:049F P:049F 0EA000            JEQ     <FINISH1
1017      P:04A0 P:04A0 44F400            MOVE              #IFLAVOR,X0
                        612020
1018      P:04A2 P:04A2 46F400            MOVE              #>GET_FLAVOR,Y0
                        000001
1019      P:04A4 P:04A4 200055            CMP     Y0,A
1020      P:04A5 P:04A5 0EA000            JEQ     <FINISH1
1021      P:04A6 P:04A6 44F400            MOVE              #ITIME0,X0
                        008416
1022      P:04A8 P:04A8 46F400            MOVE              #>GET_TIME0,Y0
                        000002
1023      P:04AA P:04AA 200055            CMP     Y0,A
1024      P:04AB P:04AB 0EA000            JEQ     <FINISH1                          ; Is it Time0?
1025      P:04AC P:04AC 44F400            MOVE              #ITIME1,X0
                        004E41
1026      P:04AE P:04AE 46F400            MOVE              #>GET_TIME1,Y0
                        000003
1027      P:04B0 P:04B0 200055            CMP     Y0,A
1028      P:04B1 P:04B1 0EA000            JEQ     <FINISH1                          ; Is it Time1?
1029      P:04B2 P:04B2 240000            MOVE              #ISVNREV,X0
1030      P:04B3 P:04B3 46F400            MOVE              #>GET_SVNREV,Y0
                        000004
1031      P:04B5 P:04B5 200055            CMP     Y0,A
1032      P:04B6 P:04B6 0EA000            JEQ     <FINISH1                          ; Is it Svn rev?
1033      P:04B7 P:04B7 44F400            MOVE              #TIMCAPABLE,X0
                        0001FB
1034      P:04B9 P:04B9 46F400            MOVE              #>GET_CAPABLE,Y0
                        000100
1035      P:04BB P:04BB 200055            CMP     Y0,A
1036      P:04BC P:04BC 0EA000            JEQ     <FINISH1                          ; Is it Tim Capabilities?
1037      P:04BD P:04BD 44F400            MOVE              #INT_TIM,X0
                        080000
1038      P:04BF P:04BF 46F400            MOVE              #>GET_INT_TIM,Y0
                        000101
1039      P:04C1 P:04C1 200055            CMP     Y0,A
1040      P:04C2 P:04C2 0EA000            JEQ     <FINISH1                          ; Is it Integration time?
1041      P:04C3 P:04C3 44F400            MOVE              #R_DELAY,X0
                        000000
1042      P:04C5 P:04C5 46F400            MOVE              #>GET_R_DELAY,Y0
                        000102
1043      P:04C7 P:04C7 200055            CMP     Y0,A
1044      P:04C8 P:04C8 0EA000            JEQ     <FINISH1                          ; Is it Serial time?
1045      P:04C9 P:04C9 44F400            MOVE              #SI_DELAY,X0
                        020000
1046      P:04CB P:04CB 46F400            MOVE              #>GET_SI_DELAY,Y0
                        000103
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timCCDmisc.s  Page 21



1047      P:04CD P:04CD 200055            CMP     Y0,A
1048      P:04CE P:04CE 0EA000            JEQ     <FINISH1                          ; Is it Parallel time?
1049      P:04CF P:04CF 0C0000            JMP     <ERROR
1050   
1051   
1052                            ; Set software to IDLE mode
1053      P:04D0 P:04D0 44F400  IDL       MOVE              #IDLE,X0                ; Exercise clocks when idling
                        00020F
1054      P:04D2 P:04D2 440000            MOVE              X0,X:<IDL_ADR
1055      P:04D3 P:04D3 0A0022            BSET    #IDLMODE,X:<STATUS                ; Idle after readout
1056      P:04D4 P:04D4 0C0000            JMP     <FINISH                           ; Need to send header and 'DON'
1057   
1058                            ; Come to here on a 'STP' command so 'DON' can be sent
1059      P:04D5 P:04D5 44F400  STP       MOVE              #TST_RCV,X0             ; Wait for commands during exposure
                        000000
1060      P:04D7 P:04D7 440000            MOVE              X0,X:<IDL_ADR           ;  instead of exercising clocks
1061      P:04D8 P:04D8 0A0002            BCLR    #IDLMODE,X:<STATUS                ; Don't idle after readout
1062      P:04D9 P:04D9 0C0000            JMP     <FINISH
1063   
1064                            ; Let the host computer read the controller configuration
1065                            READ_CONTROLLER_CONFIGURATION
1066      P:04DA P:04DA 4C8A00            MOVE                          Y:<CONFIG,X0 ; Just transmit the configuration
1067      P:04DB P:04DB 0C0000            JMP     <FINISH1
1068   
1069                            ; Power off
1070      P:04DC P:04DC 0D052B  PWR_OFF   JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1071      P:04DD P:04DD 0AA202            BCLR    #LVEN,X:PBDDR                     ; Set these signals to DSP inputs
1072      P:04DE P:04DE 0AA20D            BCLR    #PWRST,X:PBDDR
1073      P:04DF P:04DF 0AA203            BCLR    #HVEN,X:PBDDR
1074      P:04E0 P:04E0 0AA422            BSET    #LVEN,X:PBD                       ; LVEN = HVEN = 1 => Power reset
1075      P:04E1 P:04E1 0AA42D            BSET    #PWRST,X:PBD
1076      P:04E2 P:04E2 0AA423            BSET    #HVEN,X:PBD
1077      P:04E3 P:04E3 0C0000            JMP     <FINISH
1078   
1079                            ; Start power-on cycle
1080      P:04E4 P:04E4 0AA222  PWR_ON    BSET    #LVEN,X:PBDDR                     ; Set these signals to DSP outputs
1081      P:04E5 P:04E5 0AA22D            BSET    #PWRST,X:PBDDR
1082      P:04E6 P:04E6 0AA223            BSET    #HVEN,X:PBDDR
1083      P:04E7 P:04E7 0D052B            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1084   
1085                            ; Ramp up the low voltages (+/- 6.5V, 16.5V) and then delay
1086      P:04E8 P:04E8 0AA402            BCLR    #LVEN,X:PBD                       ; LVEN = Low => Turn on +/- 6.5V,
1087      P:04E9 P:04E9 0AA40D            BCLR    #PWRST,X:PBD
1088      P:04EA P:04EA 44F400            MOVE              #60000,X0
                        00EA60
1089      P:04EC P:04EC 06C400            DO      X0,WT_PON1                        ; Wait 10 millisec or so for settling
                        0004F1
1090      P:04EE P:04EE 07708E            MOVE              A,P:RSTWDT              ; Reset watchdog timer
                        006000
1091      P:04F0 P:04F0 07708E            MOVE              A,P:RSTWDT
                        006000
1092                            WT_PON1
1093   
1094                            ; Ramp up the high +36 volt power line and then delay
1095      P:04F2 P:04F2 0AA403            BCLR    #HVEN,X:PBD                       ; HVEN = Low => Turn on +36V
1096      P:04F3 P:04F3 44F400            MOVE              #60000,X0
                        00EA60
1097      P:04F5 P:04F5 06C400            DO      X0,WT_PON2                        ; Wait 10 millisec or so for settling
                        0004FA
1098      P:04F7 P:04F7 07708E            MOVE              A,P:RSTWDT              ; Reset watchdog timer
                        006000
1099      P:04F9 P:04F9 07708E            MOVE              A,P:RSTWDT
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timCCDmisc.s  Page 22



                        006000
1100                            WT_PON2
1101      P:04FB P:04FB 0D0502            JSR     <SET_BIASES                       ; Turn on the DC bias supplies
1102      P:04FC P:04FC 44F400            MOVE              #IDLE,X0
                        00020F
1103      P:04FE P:04FE 440000            MOVE              X0,X:<IDL_ADR
1104      P:04FF P:04FF 0C0000            JMP     <FINISH                           ; All done with 'DON'
1105   
1106      P:0500 P:0500 0D0502  SETBIAS   JSR     <SET_BIASES
1107      P:0501 P:0501 0C0000            JMP     <FINISH
1108   
1109                            ; Set all the DC bias voltages and video processor offset values, reading
1110                            ;   them from the table labeled DACS in this file
1111                            SET_BIASES
1112      P:0502 P:0502 0D051B            JSR     <SER_ANA
1113      P:0503 P:0503 0A0020            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
1114      P:0504 P:0504 0A0022            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
1115      P:0505 P:0505 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Disable clear of DAC and enable clocks
                        000000
1116      P:0507 P:0507 0D045C            JSR     <PAL_DLY                          ; Delay for all this to happen
1117      P:0508 P:0508 0D045C            JSR     <PAL_DLY                          ; Delay for all this to happen
1118   
1119                            ; Disable simultaneous update of clock driver boards
1120      P:0509 P:0509 0A0001            BCLR    #1,X:<LATCH
1121      P:050A P:050A 09F081            MOVEP             X:LATCH,Y:WRLATCH
                        000000
1122   
1123                            ; Read DAC values from a table, and set DACs
1124      P:050C P:050C 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                        000100
1125      P:050E P:050E 0D0461            JSR     <SET_DAC
1126   
1127                            ; Set all video processor analog switches to open to disable them (1 => OFF)
1128      P:050F P:050F 56F400            MOVE              #$000FFF,A
                        000FFF
1129      P:0511 P:0511 566600            MOVE              A,X:(R6)                ; Send out the waveform
1130      P:0512 P:0512 000000            NOP
1131   
1132                            ; Let the DAC voltages all ramp up before exiting
1133      P:0513 P:0513 56F400            MOVE              #400,A                  ; Delay 4 millisec
                        000190
1134      P:0515 P:0515 06CE00            DO      A,L_SBI1
                        000518
1135      P:0517 P:0517 0D045C            JSR     <PAL_DLY                          ; Delay for all this to happen
1136      P:0518 P:0518 000000            NOP
1137                            L_SBI1
1138      P:0519 P:0519 0D0522            JSR     <SER_UTL                          ; SSI -> utility board communication
1139      P:051A P:051A 00000C            RTS
1140   
1141                            ; Enable serial communication to the analog boards
1142      P:051B P:051B 0AA420  SER_ANA   BSET    #0,X:PBD                          ; Set H0 for analog boards SSI
1143      P:051C P:051C 08F4A1            MOVEP             #$0000,X:PCC            ; Software reset of SSI
                        000000
1144      P:051E P:051E 0AAD0A            BCLR    #10,X:CRB                         ; SSI -> continuous clock for analog
1145      P:051F P:051F 08F4A1            MOVEP             #$0160,X:PCC            ; Re-enable the SSI
                        000160
1146      P:0521 P:0521 00000C            RTS
1147   
1148                            ; Enable serial communication to the utility board
1149      P:0522 P:0522 08F4A1  SER_UTL   MOVEP             #$0000,X:PCC            ; Software reset of SSI
                        000000
1150      P:0524 P:0524 0AAD2A            BSET    #10,X:CRB                         ; SSI -> gated clock for util board
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timCCDmisc.s  Page 23



1151      P:0525 P:0525 08F4A1            MOVEP             #$0160,X:PCC            ; Enable the SSI
                        000160
1152      P:0527 P:0527 0AA400            BCLR    #0,X:PBD                          ; Clear H0 for utility board SSI
1153      P:0528 P:0528 00000C            RTS
1154   
1155      P:0529 P:0529 0D052B  CLR_SWS   JSR     <CLEAR_SWITCHES
1156      P:052A P:052A 0C0000            JMP     <FINISH
1157   
1158                            ; Clear all video processor analog switches to lower their power dissipation
1159                            CLEAR_SWITCHES
1160      P:052B P:052B 0D051B            JSR     <SER_ANA                          ; Set SSI to analog board communication
1161      P:052C P:052C 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                        0C3000
1162      P:052E P:052E 20001B            CLR     B
1163      P:052F P:052F 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC writes
1164      P:0530 P:0530 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writes
                        001000
1165      P:0532 P:0532 060F80            DO      #15,L_VIDEO                       ; Fifteen video processor boards maximum
                        000539
1166      P:0534 P:0534 08CE2F            MOVEP             A,X:SSITX               ; Gain, integrate speed
1167      P:0535 P:0535 200040            ADD     X0,A
1168      P:0536 P:0536 577000            MOVE              B,X:WRSS
                        00FF80
1169      P:0538 P:0538 0D045C            JSR     <PAL_DLY                          ; Delay for the serial data transmission
1170      P:0539 P:0539 200068            ADD     X1,B
1171                            L_VIDEO
1172      P:053A P:053A 0A0000            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
1173      P:053B P:053B 0A0002            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
1174      P:053C P:053C 09F081            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                        000000
1175      P:053E P:053E 44F400            MOVE              #IDLE,X0
                        00020F
1176      P:0540 P:0540 440000            MOVE              X0,X:<IDL_ADR
1177      P:0541 P:0541 0D0522            JSR     <SER_UTL                          ; Return SSI to utility board
1178      P:0542 P:0542 00000C            RTS
1179   
1180                            ; Set the clock multiplexers
1181      P:0543 P:0543 0D051B  SET_MUX   JSR     <SER_ANA                          ; Set SSI to analog board communication
1182      P:0544 P:0544 56DC00            MOVE              X:(R4)+,A               ; Clock driver board number
1183      P:0545 P:0545 0614A0            REP     #20
1184      P:0546 P:0546 200033            LSL     A
1185      P:0547 P:0547 44F400            MOVE              #$003000,X0
                        003000
1186      P:0549 P:0549 200042            OR      X0,A
1187      P:054A P:054A 21C500            MOVE              A,X1                    ; Move here for storage
1188   
1189                            ; Get the first MUX number
1190      P:054B P:054B 56DC00            MOVE              X:(R4)+,A               ; Get the first MUX number
1191      P:054C P:054C 0AF0A9            JLT     ERR_SM1
                        00058E
1192      P:054E P:054E 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                        000018
1193      P:0550 P:0550 200045            CMP     X0,A
1194      P:0551 P:0551 0AF0A1            JGE     ERR_SM1
                        00058E
1195      P:0553 P:0553 21CF00            MOVE              A,B
1196      P:0554 P:0554 44F400            MOVE              #>7,X0
                        000007
1197      P:0556 P:0556 20004E            AND     X0,B
1198      P:0557 P:0557 44F400            MOVE              #>$18,X0
                        000018
1199      P:0559 P:0559 200046            AND     X0,A
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timCCDmisc.s  Page 24



1200      P:055A P:055A 0E255D            JNE     <SMX_1                            ; Test for 0 <= MUX number <= 7
1201      P:055B P:055B 0ACD63            BSET    #3,B1
1202      P:055C P:055C 0C0568            JMP     <SMX_A
1203      P:055D P:055D 44F400  SMX_1     MOVE              #>$08,X0
                        000008
1204      P:055F P:055F 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1205      P:0560 P:0560 0E2563            JNE     <SMX_2
1206      P:0561 P:0561 0ACD64            BSET    #4,B1
1207      P:0562 P:0562 0C0568            JMP     <SMX_A
1208      P:0563 P:0563 44F400  SMX_2     MOVE              #>$10,X0
                        000010
1209      P:0565 P:0565 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1210      P:0566 P:0566 0E258E            JNE     <ERR_SM1
1211      P:0567 P:0567 0ACD65            BSET    #5,B1
1212      P:0568 P:0568 20006A  SMX_A     OR      X1,B1                             ; Add prefix to MUX numbers
1213      P:0569 P:0569 21A700            MOVE              B1,Y1
1214   
1215                            ; Add on the second MUX number
1216      P:056A P:056A 56DC00            MOVE              X:(R4)+,A               ; Get the next MUX number
1217      P:056B P:056B 0AF0A9            JLT     ERR_SM2
                        00058F
1218      P:056D P:056D 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                        000018
1219      P:056F P:056F 200045            CMP     X0,A
1220      P:0570 P:0570 0AF0A1            JGE     ERR_SM2
                        00058F
1221      P:0572 P:0572 0606A0            REP     #6
1222      P:0573 P:0573 200033            LSL     A
1223      P:0574 P:0574 21CF00            MOVE              A,B
1224      P:0575 P:0575 44F400            MOVE              #$1C0,X0
                        0001C0
1225      P:0577 P:0577 20004E            AND     X0,B
1226      P:0578 P:0578 44F400            MOVE              #>$600,X0
                        000600
1227      P:057A P:057A 200046            AND     X0,A
1228      P:057B P:057B 0E257E            JNE     <SMX_3                            ; Test for 0 <= MUX number <= 7
1229      P:057C P:057C 0ACD69            BSET    #9,B1
1230      P:057D P:057D 0C0589            JMP     <SMX_B
1231      P:057E P:057E 44F400  SMX_3     MOVE              #>$200,X0
                        000200
1232      P:0580 P:0580 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1233      P:0581 P:0581 0E2584            JNE     <SMX_4
1234      P:0582 P:0582 0ACD6A            BSET    #10,B1
1235      P:0583 P:0583 0C0589            JMP     <SMX_B
1236      P:0584 P:0584 44F400  SMX_4     MOVE              #>$400,X0
                        000400
1237      P:0586 P:0586 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1238      P:0587 P:0587 0E258F            JNE     <ERR_SM2
1239      P:0588 P:0588 0ACD6B            BSET    #11,B1
1240      P:0589 P:0589 200078  SMX_B     ADD     Y1,B                              ; Add prefix to MUX numbers
1241   
1242      P:058A P:058A 08CD2F            MOVEP             B1,X:SSITX
1243      P:058B P:058B 0D045C            JSR     <PAL_DLY                          ; Delay for all this to happen
1244      P:058C P:058C 0D0522            JSR     <SER_UTL                          ; Return SSI to utility board communication
1245      P:058D P:058D 0C0000            JMP     <FINISH
1246      P:058E P:058E 56DC00  ERR_SM1   MOVE              X:(R4)+,A
1247      P:058F P:058F 0D0522  ERR_SM2   JSR     <SER_UTL                          ; Return SSI to utility board communication
1248      P:0590 P:0590 0C0000            JMP     <ERROR
1249   
1250   
1251                            ; Set the video processor gain and integrator speed for all video boards
1252                            ;  Command syntax is  SGN  #GAIN  #SPEED, #GAIN = 1, 2, 5 or 10
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timCCDmisc.s  Page 25



1253                            ;                                         #SPEED = 0 for slow, 1 for fast
1254      P:0591 P:0591 0D051B  ST_GAIN   JSR     <SER_ANA                          ; Set SSI to analog board communication
1255      P:0592 P:0592 56DC00            MOVE              X:(R4)+,A               ; Gain value (1,2,5 or 10)
1256      P:0593 P:0593 44F400            MOVE              #>1,X0
                        000001
1257      P:0595 P:0595 200045            CMP     X0,A                              ; Check for gain = x1
1258      P:0596 P:0596 0E259A            JNE     <STG2
1259      P:0597 P:0597 57F400            MOVE              #>$77,B
                        000077
1260      P:0599 P:0599 0C05AE            JMP     <STG_A
1261      P:059A P:059A 44F400  STG2      MOVE              #>2,X0                  ; Check for gain = x2
                        000002
1262      P:059C P:059C 200045            CMP     X0,A
1263      P:059D P:059D 0E25A1            JNE     <STG5
1264      P:059E P:059E 57F400            MOVE              #>$BB,B
                        0000BB
1265      P:05A0 P:05A0 0C05AE            JMP     <STG_A
1266      P:05A1 P:05A1 44F400  STG5      MOVE              #>5,X0                  ; Check for gain = x5
                        000005
1267      P:05A3 P:05A3 200045            CMP     X0,A
1268      P:05A4 P:05A4 0E25A8            JNE     <STG10
1269      P:05A5 P:05A5 57F400            MOVE              #>$DD,B
                        0000DD
1270      P:05A7 P:05A7 0C05AE            JMP     <STG_A
1271      P:05A8 P:05A8 44F400  STG10     MOVE              #>10,X0                 ; Check for gain = x10
                        00000A
1272      P:05AA P:05AA 200045            CMP     X0,A
1273      P:05AB P:05AB 0E2000            JNE     <ERROR
1274      P:05AC P:05AC 57F400            MOVE              #>$EE,B
                        0000EE
1275   
1276      P:05AE P:05AE 56DC00  STG_A     MOVE              X:(R4)+,A               ; Integrator Speed (0 for slow, 1 for fast)
1277      P:05AF P:05AF 0ACC00            JCLR    #0,A1,STG_B
                        0005B3
1278      P:05B1 P:05B1 0ACD68            BSET    #8,B1
1279      P:05B2 P:05B2 0ACD69            BSET    #9,B1
1280      P:05B3 P:05B3 44F400  STG_B     MOVE              #$0C3C00,X0
                        0C3C00
1281      P:05B5 P:05B5 20004A            OR      X0,B
1282      P:05B6 P:05B6 5F0000            MOVE                          B,Y:<GAIN   ; Store the GAIN value for later us
1283   
1284                            ; Send this same value to 15 video processor boards whether they exist or not
1285      P:05B7 P:05B7 241000            MOVE              #$100000,X0             ; Increment value
1286      P:05B8 P:05B8 060F80            DO      #15,STG_LOOP
                        0005BD
1287      P:05BA P:05BA 577000            MOVE              B,X:SSITX               ; Transmit the SSI word
                        00FFEF
1288      P:05BC P:05BC 0D045C            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
1289      P:05BD P:05BD 200048            ADD     X0,B                              ; Increment the video processor board number
1290                            STG_LOOP
1291   
1292      P:05BE P:05BE 0D0522            JSR     <SER_UTL                          ; Return SSI to utility board communication
1293      P:05BF P:05BF 0C0000            JMP     <FINISH
1294      P:05C0 P:05C0 56DC00  ERR_SGN   MOVE              X:(R4)+,A
1295      P:05C1 P:05C1 0D0522            JSR     <SER_UTL                          ; Return SSI to utility board communication
1296      P:05C2 P:05C2 0C0000            JMP     <ERROR
1297   
1298                            ; Write an arbitraty control word over the SSI link to any register, any board
1299                            ; Command syntax is  WRC number, number is 24-bit number to be sent to any board
1300                            ;WR_CNTRL
1301                            ;       JSR     <SER_ANA        ; Set SSI to analog board communication
1302                            ;       JSR     <PAL_DLY        ; Wait for the number to be sent
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timCCDmisc.s  Page 26



1303                            ;        MOVEP  X:(R4)+,X:SSITX ; Send out the waveform
1304                            ;       JSR     <PAL_DLY        ; Wait for SSI and PAL to be empty
1305                            ;       JSR     <SER_UTL        ; Return SSI to utility board communication
1306                            ;       JMP     <FINISH
1307   
1308   
1309   
1310                            ; Specify subarray readout coordinates, one rectangle only
1311                            ; Call this subroutine BEFORE SET_SUBARRAY_POSITIONS since it
1312                            ; initializes NBOXES
1313                            SET_SUBARRAY_SIZES
1314      P:05C3 P:05C3 200013            CLR     A
1315      P:05C4 P:05C4 5E1900            MOVE                          A,Y:<NBOXES ; Number of subimage boxes = 0 to start
1316      P:05C5 P:05C5 44DC00            MOVE              X:(R4)+,X0
1317      P:05C6 P:05C6 4C1A00            MOVE                          X0,Y:<NR_BIAS ; Number of bias pixels to read
1318      P:05C7 P:05C7 44DC00            MOVE              X:(R4)+,X0
1319      P:05C8 P:05C8 4C1B00            MOVE                          X0,Y:<NS_READ ; Number of columns in subimage read
1320      P:05C9 P:05C9 44DC00            MOVE              X:(R4)+,X0
1321      P:05CA P:05CA 4C1C00            MOVE                          X0,Y:<NP_READ ; Number of rows in subimage read
1322      P:05CB P:05CB 0C0000            JMP     <FINISH
1323   
1324                            ; Call this routine once for every subarray to be added to the table
1325                            ; Note that the way the variables are arranged the subframes all are the
1326                            ; same dimensions.  They also cannot overlap in the row direction.
1327                            ; SET_SUBARRAY_SIZES must be called first to initialize NBOXES
1328                            SET_SUBARRAY_POSITIONS
1329      P:05CC P:05CC 4C9900            MOVE                          Y:<NBOXES,X0 ; Next available slot
1330      P:05CD P:05CD 458000            MOVE              X:<THREE,X1
1331      P:05CE P:05CE 2000A0            MPY     X0,X1,A
1332      P:05CF P:05CF 200022            ASR     A
1333      P:05D0 P:05D0 210C00            MOVE              A0,A1
1334      P:05D1 P:05D1 44F400            MOVE              #>24,X0
                        000018
1335      P:05D3 P:05D3 200045            CMP     X0,A
1336      P:05D4 P:05D4 0E7000            JGT     <ERROR                            ; Error if number of boxes > 9
1337      P:05D5 P:05D5 44F400            MOVE              #READ_TABLE,X0
                        00001D
1338      P:05D7 P:05D7 200040            ADD     X0,A
1339      P:05D8 P:05D8 219700            MOVE              A1,R7
1340      P:05D9 P:05D9 44DC00            MOVE              X:(R4)+,X0
1341      P:05DA P:05DA 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of rows (parallels) to clear
1342      P:05DB P:05DB 44DC00            MOVE              X:(R4)+,X0
1343      P:05DC P:05DC 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears before
1344      P:05DD P:05DD 44DC00            MOVE              X:(R4)+,X0              ;  the box readout
1345      P:05DE P:05DE 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears after
1346      P:05DF P:05DF 5E9900            MOVE                          Y:<NBOXES,A ;  the box readout
1347      P:05E0 P:05E0 448000            MOVE              X:<ONE,X0
1348      P:05E1 P:05E1 200040            ADD     X0,A                              ; Update the next available slot position
1349      P:05E2 P:05E2 5E1900            MOVE                          A,Y:<NBOXES
1350      P:05E3 P:05E3 0C0000            JMP     <FINISH
1351   
1352                            ; Alert the PCI interface board that images are coming soon
1353                            ; This tells the PCI card how many pixels to expect for each SEX command
1354                            ; This is fairly complex.  The first value sent is NSR*NPR (NAXIS1*NAXIS2).
1355                            ; The second value is IFRAMES, but if NBOXES > 0, it is IFRAMES*NBOXES
1356                            PCI_READ_IMAGE
1357      P:05E4 P:05E4 44F400            MOVE              #$020104,X0             ; Send header word to the FO transmitter
                        020104
1358      P:05E6 P:05E6 0D05FF            JSR     <XMT_FO
1359      P:05E7 P:05E7 44F400            MOVE              #'RDA',X0
                        524441
1360      P:05E9 P:05E9 0D05FF            JSR     <XMT_FO
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  timCCDmisc.s  Page 27



1361      P:05EA P:05EA 4CF000            MOVE                          Y:NSR,X0    ; NSR = NAXIS1
                        000001
1362      P:05EC P:05EC 4DF000            MOVE                          Y:NPR,X1    ; NPR = NAXIS2
                        000002
1363      P:05EE P:05EE 2000A8            MPY     X0,X1,B
1364      P:05EF P:05EF 20002A            ASR     B                                 ; Correct for multiplication left shift
1365      P:05F0 P:05F0 212400            MOVE              B0,X0
1366      P:05F1 P:05F1 0D05FF            JSR     <XMT_FO                           ; Send NSR*NPR to PCI card
1367      P:05F2 P:05F2 4CF000            MOVE                          Y:IFRAMES,X0 ; IFRAMES = NAXIS3
                        00003A
1368      P:05F4 P:05F4 5E9900            MOVE                          Y:<NBOXES,A ; If NBOXES = 0, transmit that to PCI
1369      P:05F5 P:05F5 200003            TST     A
1370      P:05F6 P:05F6 0AF0AA            JEQ     XMT
                        0005FC
1371      P:05F8 P:05F8 4D9900            MOVE                          Y:<NBOXES,X1 ; If NBOXES = 0, transmit that to PCI
1372      P:05F9 P:05F9 2000A8            MPY     X0,X1,B                           ; If not, multiply by NBOXES, then send
1373      P:05FA P:05FA 20002A            ASR     B                                 ; Correct for multiplication left shift
1374      P:05FB P:05FB 212400            MOVE              B0,X0                   ; Get only least significant 24 bits
1375      P:05FC P:05FC 000000  XMT       NOP
1376      P:05FD P:05FD 0D05FF            JSR     <XMT_FO
1377      P:05FE P:05FE 00000C            RTS
1378   
1379      P:05FF P:05FF 09C400  XMT_FO    MOVEP             X0,Y:WRFO
1380      P:0600 P:0600 060FA0            REP     #15
1381      P:0601 P:0601 000000            NOP
1382      P:0602 P:0602 00000C            RTS
1383   
1384                            ; Check for program overflow
1385                                      IF      @CVS(N,*)-$200>MISC_LEN
1387                                      ENDIF                                     ;  will not overflow
1388   
1389   
1390                            ;**************************************************************************
1391                            ;                                                                         *
1392                            ;    Permanent address register assignments                               *
1393                            ;        R1 - Address of SSI receiver contents                            *
1394                            ;        R2 - Address of SCI receiver contents                            *
1395                            ;        R3 - Pointer to current top of command buffer                    *
1396                            ;        R4 - Pointer to processed contents of command buffer             *
1397                            ;        R5 - Temporary register for processing SSI and SCI contents      *
1398                            ;        R6 - CCD clock driver address for CCD #0 = $FF80                 *
1399                            ;                It is also the A/D address of analog board #0            *
1400                            ;                                                                         *
1401                            ;    Other registers                                                      *
1402                            ;        R0, R7 - Temporary registers used all over the place.            *
1403                            ;        R5 - Can be used as a temporary register but is circular,        *
1404                            ;               modulo 32.                                                *
1405                            ;**************************************************************************
1406   
1407                            ;  Specify execution and load addresses
1408                                      IF      @SCP("HOST","HOST")
1409      P:0130 P:0130                   ORG     P:APL_ADR,P:APL_ADR               ; Download address
1410                                      ELSE
1412                                      ENDIF
1413   
1414                            ;  ***********************   CCD  READOUT   ***********************
1415                            ; RDCCD is now a subroutine
1416   
1417                            RDCCD
1418      P:0130 P:0130 0A31A2            JSET    #STORAGE,X:ISTATUS,RCCD1
                        000134
1419                            ; Do the frame transfer if STORAGE==0, else skip it.
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  tim.s  Page 28



1420      P:0132 P:0132 4DBB00            MOVE                          Y:<S_SIZE,X1
1421      P:0133 P:0133 0D0444            JSR     ISHIFT                            ; Do the frame transfer
1422   
1423                            ; Calculate some readout parameters.
1424                            ; This is also an alternative entry point for skipping the frame transfer
1425                            ; STORAGE also selects ganged or storage only parallels during readout
1426                            ; NO_SKIP skips over the section that parallel skips to the subframe start
1427   
1428      P:0134 P:0134 5E9900  RCCD1     MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1429      P:0135 P:0135 200003            TST     A
1430      P:0136 P:0136 0E2140            JNE     <SUB_IMG
1431      P:0137 P:0137 5C1600            MOVE                          A1,Y:<NP_SKIP ; Zero these all out.  Full frame
1432      P:0138 P:0138 5C1700            MOVE                          A1,Y:<NS_SKP1
1433      P:0139 P:0139 5C1800            MOVE                          A1,Y:<NS_SKP2
1434      P:013A P:013A 5E8100            MOVE                          Y:<NSR,A    ; NSERIALS_READ = NSR
1435      P:013B P:013B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                        00013E
1436      P:013D P:013D 200022            ASR     A                                 ; Split serials require / 2
1437      P:013E P:013E 5E1000            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1438      P:013F P:013F 0C014F            JMP     <SETUP
1439   
1440                            ; Loop over the required number of subimage boxes if NBOXES > 0
1441      P:0140 P:0140 67F400  SUB_IMG   MOVE              #READ_TABLE,R7          ; Parameter table for subimage readout
                        00001D
1442      P:0142 P:0142 061940            DO      Y:<NBOXES,L_NBOXES                ; Loop over number of boxes
                        0001E5
1443      P:0144 P:0144 4CDF00            MOVE                          Y:(R7)+,X0
1444      P:0145 P:0145 4C1600            MOVE                          X0,Y:<NP_SKIP
1445      P:0146 P:0146 4CDF00            MOVE                          Y:(R7)+,X0
1446      P:0147 P:0147 4C1700            MOVE                          X0,Y:<NS_SKP1
1447      P:0148 P:0148 4CDF00            MOVE                          Y:(R7)+,X0
1448      P:0149 P:0149 4C1800            MOVE                          X0,Y:<NS_SKP2
1449      P:014A P:014A 5E9B00            MOVE                          Y:<NS_READ,A
1450      P:014B P:014B 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                        00014E
1451      P:014D P:014D 200022            ASR     A
1452      P:014E P:014E 5E1000            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1453   
1454                            ; Calculate the fast readout parameters
1455      P:014F P:014F 0D0342  SETUP     JSR     <SETUP_SUBROUTINE
1456   
1457                            ; Skip over the required number of rows for subimage readout
1458                            ; If #NO_SKIP == 0 skip rows up to first subframe, storage clocks only
1459      P:0150 P:0150 0A31A0            JSET    #NO_SKIP,X:ISTATUS,CLR_SR
                        00015A
1460      P:0152 P:0152 5E9600            MOVE                          Y:<NP_SKIP,A ; Number of rows NP_SKIP to skip
1461      P:0153 P:0153 200003            TST     A
1462      P:0154 P:0154 0EA15A            JEQ     <CLR_SR                           ; If zero, skip this shift
1463      P:0155 P:0155 061640            DO      Y:<NP_SKIP,L_SKIP1                ; Clock number of rows to skip
                        000159
1464      P:0157 P:0157 305000            MOVE              #<S_CLEAR,R0            ; SR kept clear with DG
1465      P:0158 P:0158 0D01E9            JSR     <CLOCK
1466      P:0159 P:0159 000000            NOP
1467                            L_SKIP1
1468   
1469                            ; Clear out the accumulated charge from the serial shift register
1470                            ; Leave this commented-out code in until we can test it with a subframe
1471                            ; CLR_SR MOVE   #(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1472                            ;       MOVE    Y:<SERIAL_SKIP,R1       ; Waveform table starting address
1473                            ;       NOP
1474                            ;       MOVE    Y:(R1)+,A               ; Start the pipeline
1475                            ;       DO      Y:<NSCLR,*+3            ; Number of waveform entries total
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  tim.s  Page 29



1476                            ;       MOVE    A,X:(R6) Y:(R1)+,A      ; Send out the waveform
1477                            ;       MOVE    A,X:(R6)                ; Flush out the pipeline
1478   
1479      P:015A P:015A 60F400  CLR_SR    MOVE              #DUMP_SERIAL,R0         ; clear the SR after parallel skip
                        000068
1480      P:015C P:015C 0D01E9            JSR     <CLOCK
1481   
1482                            ; Parallel shift the image into the serial shift register
1483      P:015D P:015D 4C8200            MOVE                          Y:<NPR,X0   ; Number of rows set by host computer
1484      P:015E P:015E 5E9900            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1485      P:015F P:015F 200003            TST     A
1486      P:0160 P:0160 0EA162            JEQ     *+2
1487      P:0161 P:0161 4C9C00            MOVE                          Y:<NP_READ,X0 ; If NBOXES .NE. 0 use subimage table
1488   
1489                            ; Main loop over each line to be read out
1490                            ; If split parallels have to divide NPR by two to be loop counter
1491                            ; Subimages implicitly assumes that parallels are not split
1492      P:0162 P:0162 0A0086            JCLR    #SPLIT_P,X:STATUS,PLOOP           ; skip this if not split parallels
                        000168
1493      P:0164 P:0164 5EF000            MOVE                          Y:NPR,A     ; Get NPR
                        000002
1494      P:0166 P:0166 200022            ASR     A                                 ; Divide by 2
1495      P:0167 P:0167 21C400            MOVE              A,X0                    ; Overwrite loop counter in X0
1496   
1497                            ; Finally start the row loop
1498      P:0168 P:0168 06C400  PLOOP     DO      X0,LPR                            ; Number of rows to read out
                        0001E4
1499   
1500                            ; Check for a command once per line. Only the ABORT command is allowed
1501      P:016A P:016A 0D0000            JSR     <GET_RCV                          ; Was a command received?
1502      P:016B P:016B 0E0175            JCC     <CONT_RD                          ; If no, continue reading out
1503      P:016C P:016C 0C0000            JMP     <CHK_SSI                          ; If yes, go process it
1504   
1505                            ; Abort the readout currently underway
1506      P:016D P:016D 0A0084  ABR_RDC   JCLR    #ST_RDC,X:<STATUS,ABORT_EXPOSURE
                        000491
1507      P:016F P:016F 00008C            ENDDO                                     ; Properly terminate row loop
1508      P:0170 P:0170 5E9900            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1509      P:0171 P:0171 200003            TST     A
1510      P:0172 P:0172 0EA174            JEQ     *+2
1511      P:0173 P:0173 00008C            ENDDO                                     ; Properly terminate box loop
1512      P:0174 P:0174 00000C            RTS                                       ; Return early from subroutine
1513   
1514                            ; Move the row into the serial register.
1515      P:0175 P:0175 060640  CONT_RD   DO      Y:<NPBIN,LPR_I                    ; Transfer # of rows, with binning
                        00017C
1516      P:0177 P:0177 305800            MOVE              #<IS_PARALLEL,R0
1517      P:0178 P:0178 0A31A2            JSET    #STORAGE,X:ISTATUS,GANGED         ; if STORAGE == 1 ganged parallels
                        00017B
1518      P:017A P:017A 304000            MOVE              #<S_PARALLEL,R0         ; if STORAGE == 0 store clocks only
1519      P:017B P:017B 0D01E9  GANGED    JSR     <CLOCK                            ; Parallel clocking
1520      P:017C P:017C 000000            NOP
1521                            LPR_I
1522   
1523                            ; Skip over NS_SKP1 columns for subimage readout
1524      P:017D P:017D 5E9700            MOVE                          Y:<NS_SKP1,A ; Number of columns to skip
1525      P:017E P:017E 200003            TST     A
1526      P:017F P:017F 0EA188            JEQ     <L_READ
1527      P:0180 P:0180 0505A1            MOVE              #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
1528      P:0181 P:0181 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1529      P:0182 P:0182 000000            NOP
1530      P:0183 P:0183 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  tim.s  Page 30



1531      P:0184 P:0184 061240            DO      Y:<NSKIP1,LS_SKIP1                ; Number of waveform entries total
                        000186
1532      P:0186 P:0186 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1533                            LS_SKIP1
1534      P:0187 P:0187 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1535   
1536                            ; Finally read some real pixels - this is the serial binning routine
1537      P:0188 P:0188 200013  L_READ    CLR     A
1538      P:0189 P:0189 20001B            CLR     B
1539      P:018A P:018A 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1540      P:018B P:018B 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                        000006
1541      P:018D P:018D 200005            CMP     B,A                               ; else do special waveforms via NO_BIN
1542      P:018E P:018E 0E719F            JGT     <NO_BIN                           ; Skip over general serial binning software
1543      P:018F P:018F 00000B            DEC     B                                 ; serial binning factor minus 1
1544      P:0190 P:0190 212700            MOVE              B0,Y1
1545      P:0191 P:0191 061040            DO      Y:<NSERIALS_READ,LSR_BIN          ; Number of pixels to read out
                        00019D
1546      P:0193 P:0193 688E00            MOVE                          Y:<INITIAL_CLOCK,R0 ; (already /2 if split serials)
1547      P:0194 P:0194 0D01E9            JSR     <CLOCK
1548                            ;       DO      Y:<NSBIN,LSR_I          ; Bin serially NSBIN times
1549      P:0195 P:0195 06C700            DO      Y1,LSR_I                          ; Bin serially NSBIN times
                        000199
1550      P:0197 P:0197 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1551      P:0198 P:0198 0D01E9            JSR     <CLOCK                            ;   shift register
1552      P:0199 P:0199 000000            NOP
1553                            LSR_I
1554      P:019A P:019A 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                        0000B4
1555      P:019C P:019C 0D01E9            JSR     <CLOCK
1556                            ;       MOVE    Y1,Y:<INTERVAL          ; HACK.  Use for debugging
1557      P:019D P:019D 000000            NOP
1558                            LSR_BIN
1559      P:019E P:019E 0C01A9            JMP     <OVER_RD                          ; All done binning
1560   
1561                            ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1562      P:019F P:019F 588C00  NO_BIN    MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1563      P:01A0 P:01A0 00000A            DEC     A                                 ; waveform - 1 into M1
1564      P:01A1 P:01A1 04C8A1            MOVE              A0,M1                   ; Modularity
1565      P:01A2 P:01A2 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1566      P:01A3 P:01A3 000000            NOP
1567      P:01A4 P:01A4 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1568      P:01A5 P:01A5 061340            DO      Y:<NREAD,LSR                      ; Number of waveform entries total
                        0001A7
1569      P:01A7 P:01A7 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1570                            LSR
1571      P:01A8 P:01A8 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1572   
1573                            ; If NR_BIAS=0 clobber SR with DG and skip to end of row loop
1574      P:01A9 P:01A9 5E9A00  OVER_RD   MOVE                          Y:<NR_BIAS,A ; Is NR_BIAS zero?
1575      P:01AA P:01AA 200003            TST     A
1576      P:01AB P:01AB 0E21B1            JNE     <OVR_RD1                          ; no, go to the NS_SKP2 section
1577      P:01AC P:01AC 60F400            MOVE              #DUMP_SERIAL,R0         ; yes, clobber SR with DG
                        000068
1578      P:01AE P:01AE 0D01E9            JSR     <CLOCK
1579      P:01AF P:01AF 0AF080            JMP     END_ROW                           ; and go to the end of the row loop
                        0001E4
1580                            ; Skip over NS_SKP2 columns for subimage readout to get to overscan region
1581      P:01B1 P:01B1 5E9800  OVR_RD1   MOVE                          Y:<NS_SKP2,A ; Number of columns to skip
1582      P:01B2 P:01B2 200003            TST     A
1583      P:01B3 P:01B3 0EA1BC            JEQ     <L_BIAS
1584      P:01B4 P:01B4 0505A1            MOVE              #<(END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1),M1 ; Modularity
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  tim.s  Page 31



1585      P:01B5 P:01B5 698B00            MOVE                          Y:<SERIAL_SKIP,R1 ; Waveform table starting address
1586      P:01B6 P:01B6 000000            NOP
1587      P:01B7 P:01B7 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1588      P:01B8 P:01B8 061440            DO      Y:<NSKIP2,LS_SKIP2                ; Number of waveform entries total
                        0001BA
1589      P:01BA P:01BA FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1590                            LS_SKIP2
1591      P:01BB P:01BB 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1592   
1593                            ; And read the bias pixels if in subimage readout mode
1594                            ; I think this means that if NBOXES==0 you have to have NSR include bias px.
1595      P:01BC P:01BC 5E9900  L_BIAS    MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1596      P:01BD P:01BD 200003            TST     A
1597      P:01BE P:01BE 0EA1E4            JEQ     <END_ROW
1598   
1599                            ; Finally read some real bias pixels
1600      P:01BF P:01BF 200013            CLR     A
1601      P:01C0 P:01C0 20001B            CLR     B
1602      P:01C1 P:01C1 598500            MOVE                          Y:<NSBIN,B0 ; Serial binning parameter
1603      P:01C2 P:01C2 50F400            MOVE              #>6,A0                  ; If binning > 5, do general binning
                        000006
1604      P:01C4 P:01C4 200005            CMP     B,A                               ; else do special waveforms via NO_BIN_BIAS
1605      P:01C5 P:01C5 0E71DA            JGT     <NO_BIN_BIAS                      ; Skip over general serial binning software
1606      P:01C6 P:01C6 00000B            DEC     B                                 ; serial binning factor minus 1
1607      P:01C7 P:01C7 212700            MOVE              B0,Y1
1608      P:01C8 P:01C8 5E9A00            MOVE                          Y:<NR_BIAS,A
1609      P:01C9 P:01C9 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                        0001CC
1610      P:01CB P:01CB 200022            ASR     A                                 ; Split serials require / 2
1611      P:01CC P:01CC 06CE00            DO      A,LBIAS_BIN                       ; Number of pixels to read out
                        0001D8
1612      P:01CE P:01CE 688E00            MOVE                          Y:<INITIAL_CLOCK,R0
1613      P:01CF P:01CF 0D01E9            JSR     <CLOCK
1614      P:01D0 P:01D0 06C700            DO      Y1,LBIAS_I                        ; Bin serially NSBIN times
                        0001D4
1615                            ;       DO      Y:<NSBIN,LBIAS_I        ; Bin serially NSBIN times
1616      P:01D2 P:01D2 688D00            MOVE                          Y:<SERIAL_CLOCK,R0 ; Clock the charge in the serial
1617      P:01D3 P:01D3 0D01E9            JSR     <CLOCK                            ;   shift register
1618      P:01D4 P:01D4 000000            NOP
1619                            LBIAS_I
1620      P:01D5 P:01D5 60F400            MOVE              #VIDEO_PROCESS,R0       ; Video process the binned pixel
                        0000B4
1621      P:01D7 P:01D7 0D01E9            JSR     <CLOCK
1622      P:01D8 P:01D8 000000            NOP
1623                            LBIAS_BIN
1624      P:01D9 P:01D9 0C01E4            JMP     <END_ROW                          ; All done binning
1625   
1626                            ; This is the routine for serial binning from 1 to 5 using hardwired waveforms
1627                            ; NBIAS is already divided by 2 in SETUP_SUBROUTINE if split serials.
1628                            NO_BIN_BIAS
1629      P:01DA P:01DA 588C00            MOVE                          Y:<SERWAVLEN,A0 ; Put length of serial read
1630      P:01DB P:01DB 00000A            DEC     A                                 ; waveform - 1 into M1
1631      P:01DC P:01DC 04C8A1            MOVE              A0,M1                   ; Modularity
1632      P:01DD P:01DD 31C000            MOVE              #<SERIAL_READ,R1        ; Waveform table starting address
1633      P:01DE P:01DE 000000            NOP
1634      P:01DF P:01DF 5ED900            MOVE                          Y:(R1)+,A   ; Start the pipeline
1635      P:01E0 P:01E0 061540            DO      Y:<NBIAS,*+3                      ; Number of waveform entries total
                        0001E2
1636      P:01E2 P:01E2 FA2600            MOVE              A,X:(R6)    Y:(R1)+,A   ; Send out the waveform
1637      P:01E3 P:01E3 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1638      P:01E4 P:01E4 000000  END_ROW   NOP
1639      P:01E5 P:01E5 000000  LPR       NOP                                       ; End of parallel loop
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  tim.s  Page 32



1640      P:01E6 P:01E6 000000  L_NBOXES  NOP                                       ; End of subimage boxes loop
1641      P:01E7 P:01E7 000000            NOP
1642      P:01E8 P:01E8 00000C            RTS
1643   
1644                            ; ***************** END OF CCD READOUT SUBROUTINE  ************
1645   
1646                            ; Core subroutine for clocking out CCD charge
1647                            ; Must keep in tim.s to insure that it is in fast P memory
1648   
1649      P:01E9 P:01E9 4CD800  CLOCK     MOVE                          Y:(R0)+,X0  ; # of waveform entries
1650      P:01EA P:01EA 5ED800            MOVE                          Y:(R0)+,A   ; Start the pipeline
1651      P:01EB P:01EB 06C400            DO      X0,CLK1                           ; Repeat X0 times
                        0001ED
1652      P:01ED P:01ED FA0600            MOVE              A,X:(R6)    Y:(R0)+,A   ; Send out the waveform
1653                            CLK1
1654      P:01EE P:01EE 566600            MOVE              A,X:(R6)                ; Flush out the pipeline
1655      P:01EF P:01EF 00000C            RTS                                       ; Return from subroutine
1656   
1657                            ; Check for program overflow
1658                                      IF      @CVS(N,*)>$200
1660                                      ENDIF                                     ;  will not overflow
1661   
1662                            ; ***********  DATA AREAS - READOUT PARAMETERS AND WAVEFORMS  ************
1663                                      IF      @SCP("HOST","HOST")
1664      X:0030 X:0030                   ORG     X:IMGVAR_ADR,X:IMGVAR_ADR
1665      X:0030 X:0030         IMAGE_MODE DC     0
1666      X:0031 X:0031         ISTATUS   DC      0
1667      X:0032 X:0032         DSP_VERS  DC      VERSION                           ; code version must stay in loc,n 32!!
1668      X:0033 X:0033         DSP_FLAV  DC      FLAVOR                            ;  type of dsp support must stay in loc,n 33!!
1669                            ; The next three locations are for tracking the readout timing for gain
1670                            ; calculation, exp-int calculation, and greed factor calculation
1671                            ; They are locations 0x34, 35, and 36
1672      X:0034 X:0034         INTTIM    DC      INT_TIM                           ; per-pixel integration in Leach units
1673      X:0035 X:0035         RDELAY    DC      R_DELAY                           ; serial overlap in Leach units
1674      X:0036 X:0036         SIDELAY   DC      SI_DELAY                          ; parallel overlap in Leach units
1675      X:0037 X:0037         BINBIT    DC      2                                 ; Bit representation of bin factor, bits 1-5
1676                                                                                ; 2 = bit 1 set. Bit zero not used.
1677                                      ENDIF
1678   
1679                            ; Command table - make sure there are exactly 32 entries in it
1680                                      IF      @SCP("HOST","HOST")
1681      X:0080 X:0080                   ORG     X:COM_TBL,X:COM_TBL               ; Download address
1682                                      ELSE
1684                                      ENDIF
1685      X:0080 X:0080                   DC      'IDL',IDL                         ; Put CCD in IDLE mode
1686      X:0082 X:0082                   DC      'STP',STP                         ; Exit IDLE mode
1687      X:0084 X:0084                   DC      'SBV',SETBIAS                     ; Set DC bias supply voltages
1688      X:0086 X:0086                   DC      'RDC',RDCCD                       ; Begin CCD readout
1689      X:0088 X:0088                   DC      'CLR',CLEAR                       ; Fast clear the CCD
1690      X:008A X:008A                   DC      'SGN',ST_GAIN                     ; Set video processor gain
1691      X:008C X:008C                   DC      'SMX',SET_MUX                     ; Set clock driver MUX output
1692   
1693      X:008E X:008E                   DC      'ABR',ABR_RDC                     ; Abort readout
1694      X:0090 X:0090                   DC      'CRD',CONT_RD                     ; Continue reading out
1695      X:0092 X:0092                   DC      'CSW',CLR_SWS                     ; Clear analog switches to lower power
1696      X:0094 X:0094                   DC      'SOS',SEL_OS                      ; Select output source
1697      X:0096 X:0096                   DC      'RCC',READ_CONTROLLER_CONFIGURATION
1698      X:0098 X:0098                   DC      'SSS',SET_SUBARRAY_SIZES
1699      X:009A X:009A                   DC      'SSP',SET_SUBARRAY_POSITIONS
1700      X:009C X:009C                   DC      'DON',START                       ; Nothing special
1701      X:009E X:009E                   DC      'OSH',OPEN_SHUTTER
1702      X:00A0 X:00A0                   DC      'CSH',CLOSE_SHUTTER
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  tim.s  Page 33



1703      X:00A2 X:00A2                   DC      'PON',PWR_ON                      ; Turn on all camera biases and clocks
1704      X:00A4 X:00A4                   DC      'POF',PWR_OFF                     ; Turn +/- 15V power supplies off
1705      X:00A6 X:00A6                   DC      'SET',SET_EXP_TIME                ; Set exposure time
1706      X:00A8 X:00A8                   DC      'SEX',START_FT_EXPOSURE           ; Goes to mode-dependent jump table
1707      X:00AA X:00AA                   DC      'AEX',ABORT_EXPOSURE
1708      X:00AC X:00AC                   DC      'STG',SET_TRIGGER                 ;  Set Trigger Mode on or off
1709      X:00AE X:00AE                   DC      'SIP',SET_IMAGE_PARAM
1710      X:00B0 X:00B0                   DC      'SRC',SET_ROWS_COLUMNS            ; Set NSR, NPR, and binning
1711      X:00B2 X:00B2                   DC      'INF',GET_INFO                    ; info command for versioning and more
1712      X:00B4 X:00B4                   DC      ,0,START,0,START,0,START,0,START
1713   
1714                                      IF      @SCP("HOST","HOST")
1715      Y:0000 Y:0000                   ORG     Y:0,Y:0                           ; Download address
1716                                      ELSE
1718                                      ENDIF
1719   
1720                            ; NSR, NPR, NSBIN, and NPBIN are set by SET_ROWS_COLUMNS
1721      Y:0000 Y:0000         GAIN      DC      0                                 ; Video processor gain and integrator speed
1722      Y:0001 Y:0001         NSR       DC      280                               ; Number Serial Read, prescan + image + bias
1723      Y:0002 Y:0002         NPR       DC      264                               ; Number Parallel Read
1724      Y:0003 Y:0003         NS_CLR    DC      280                               ; To clear serial register, twice
1725      Y:0004 Y:0004         NPCLR     DC      528                               ; To clear parallel register, twice
1726      Y:0005 Y:0005         NSBIN     DC      1                                 ; Serial binning parameter
1727      Y:0006 Y:0006         NPBIN     DC      1                                 ; Parallel binning parameter
1728      Y:0007 Y:0007         NROWS     DC      264                               ; Number of physical rows in CCD
1729      Y:0008 Y:0008         NCOLS     DC      280                               ; Number of physical columns in CCD
1730   
1731                            ; Miscellaneous definitions
1732                            ; Delete TST_DAT since it isn't used.  Need the space so S_SIZE doesn't barf.
1733                            ; TST_DAT       DC      0               ; Temporary definition for test images
1734      Y:0009 Y:0009         SH_DEL    DC      3                                 ; Delay in milliseconds between shutter closing
1735                                                                                ;   and image readout.  Actual delay is 1.5x
1736                                                                                ;   as long as advertised, e.g. 4.5 ms for 3.
1737      Y:000A Y:000A         CONFIG    DC      CC                                ; Controller configuration
1738                            ; Readout peculiarity parameters
1739                             SERIAL_SKIP
1740      Y:000B Y:000B                   DC      SERIAL_SKIP_LEFT                  ; Serial skipping waveforms
1741      Y:000C Y:000C         SERWAVLEN DC      5                                 ; Serial read waveform table length
1742                             SERIAL_CLOCK
1743      Y:000D Y:000D                   DC      SERIAL_CLOCK_LEFT                 ; Serial waveform table
1744                             INITIAL_CLOCK
1745      Y:000E Y:000E                   DC      INITIAL_CLOCK_LEFT                ; Serial waveform table
1746                             PARALLEL_CLOCK
1747      Y:000F Y:000F                   DC      IS_PARALLEL                       ; Addr. of parallel clocking
1748   
1749                             NSERIALS_READ
1750      Y:0010 Y:0010                   DC      0                                 ; Number of serials to read
1751      Y:0011 Y:0011         NSCLR     DC      0                                 ; Number of waveforms in fast mode
1752      Y:0012 Y:0012         NSKIP1    DC      0                                 ; Number of waveforms in fast mode
1753      Y:0013 Y:0013         NREAD     DC      0                                 ; Number of waveforms in fast mode
1754      Y:0014 Y:0014         NSKIP2    DC      0                                 ; Number of waveforms in fast mode
1755      Y:0015 Y:0015         NBIAS     DC      0                                 ; Number of waveforms in fast mode
1756   
1757                            ; These three parameters are read from the READ_TABLE when needed by the
1758                            ;   RDCCD routine as it loops through the required number of boxes
1759      Y:0016 Y:0016         NP_SKIP   DC      0                                 ; Number of rows to skip
1760      Y:0017 Y:0017         NS_SKP1   DC      0                                 ; Number of serials to clear before read
1761      Y:0018 Y:0018         NS_SKP2   DC      0                                 ; Number of serials to clear after read
1762   
1763                            ; Subimage readout parameters. Ten subimage boxes maximum.
1764                            ; All subimage boxes are the same size, NS_READ x NP_READ
1765                            ; NR_BIAS, NS_READ, and NP_READ are set by SET_SUBARRAY_SIZES
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  tim.s  Page 34



1766                            ; The READ_TABLE entries and implicitly NBOXES are set by SET_SUBARRAY_POSITIONS
1767      Y:0019 Y:0019         NBOXES    DC      0                                 ; Number of boxes to read
1768      Y:001A Y:001A         NR_BIAS   DC      0                                 ; Number of bias pixels to read
1769      Y:001B Y:001B         NS_READ   DC      0                                 ; Number of columns per box
1770      Y:001C Y:001C         NP_READ   DC      0                                 ; Number of rows per box
1771      Y:001D Y:001D         READ_TABLE DC     0,0,0                             ; #1 = Number of rows to clear,
1772      Y:0020 Y:0020                   DC      0,0,0                             ; #2 = Number of columns to skip before
1773      Y:0023 Y:0023                   DC      0,0,0                             ;   subimage read
1774      Y:0026 Y:0026                   DC      0,0,0                             ; #3 = Number of columns to clear after
1775      Y:0029 Y:0029                   DC      0,0,0                             ;   subimage read to get to overscan area
1776      Y:002C Y:002C                   DC      0,0,0
1777      Y:002F Y:002F                   DC      0,0,0
1778      Y:0032 Y:0032                   DC      0,0,0
1779      Y:0035 Y:0035                   DC      0,0,0
1780   
1781                            ; IMAGE_MODE, SROWS, IFRAMES, and INTERVAL are set by SET_IMAGE_PARAM
1782                            ; UBSROWS is set later on by UB_CONV.  S_SIZE is hardwired.
1783      Y:0038 Y:0038         SROWS     DC      1                                 ; Number of Storage image rows to Loop over
1784      Y:0039 Y:0039         UBSROWS   DC      1                                 ; SROWS in unbinned pixels.  Set by UB_CONV
1785      Y:003A Y:003A         IFRAMES   DC      1                                 ; Number of Series frames to Loop over
1786      Y:003B Y:003B         S_SIZE    DC      264                               ; Number of rows in the Storage Array
1787                                                                                ; NOTE: Not equal to # rows in image area!
1788      Y:003C Y:003C         INTERVAL  DC      7                                 ; Interval to pause for soft trigger
1789      Y:003D Y:003D         AMPVAL    DC      0                                 ; Amplifier selected
1790      Y:003E Y:003E         IFLPCNT   DC      0                                 ; 24-bit IFRAMES loop counter for timmisc.s
1791      Y:003F Y:003F         TESTLOC1  DC      0                                 ; Test location
1792                            ; NOTE:  TESTLOC1 is address 63 in the Y memory.  There are addressing problems
1793                            ; starting at the next address (64).
1794   
1795                            ; Include the waveform table
1796                                      INCLUDE "HIPO_Red.waveforms.s"            ; Readout and clocking waveforms
1797                            ; Waveform tables and definitions for the e2v CCD67 256 sq. frame
1798                            ; transfer CCD for HIPO.
1799                            ;
1800   
1801                            ; CCD clock voltage definitions
1802      000000                VIDEO     EQU     $000000                           ; Video processor board select = 0
1803      002000                CLK2      EQU     $002000                           ; Clock driver board select = 2
1804      003000                CLK3      EQU     $003000                           ; Clock driver board select = 3
1805      000800                CLK_ZERO  EQU     $000800                           ; Zero volts on clock driver line
1806      000800                BIAS_ZERO EQU     $000800                           ;
1807   
1808                            ; For HIPO uncomment one of these lines at a time
1809                            ;INT_TIM        EQU     $040000 ; 0.85 us/px - use gain 9.5, experimental
1810      080000                INT_TIM   EQU     $080000                           ; 1.0 us/px - use gain 9.5, doesn't clip
1811                            ; Old CCD47 ones below.
1812                            ;INT_TIM        EQU     $150000 ; 1.5 us/px - use gain 9.5, clips @ ADC
1813                            ;INT_TIM                EQU     $1D0000 ; 1.8 us/px - use gain 4.75, best overall
1814                            ;INT_TIM        EQU     $470000 ; 3.5 us/px - use gain 2, slower & quieter
1815                            ;INT_TIM        EQU     $920000 ; 6.5 us/px - use gain 1, slower & quieter
1816                            ;INT_TIM        EQU     $6D0000 ; 5.0 us/px - use gain 2 or 4.75, clips @ ADC
1817   
1818                            ;ADC_TIM                EQU     $0C0000 ; Slow ADC TIME
1819      000000                ADC_TIM   EQU     $000000                           ; Fast ADC TIME
1820                            ; Delay numbers in clocking
1821                            ;SI_DELAY       EQU     $C00000 ; Started with 0x36 Parallel clock delay
1822                            ;SI_DELAY       EQU     $860000 ; Fast Storage/Image Delay
1823      020000                SI_DELAY  EQU     $020000                           ; 120 ns parallel overlaps
1824                            ;R_DELAY                EQU     $080000 ; Serial register transfer delay
1825      000000                R_DELAY   EQU     $000000                           ; Fast serial regisiter transfer delay
1826      000000                SKIP_DELAY EQU    $000000                           ; Serial register skipping delay
1827   
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 35



1828                            ; Clock voltages in volts
1829      3.000000E+000         RG_HI     EQU     +3.0                              ; Reset
1830      -9.000000E+000        RG_LO     EQU     -9.0                              ;
1831      2.000000E+000         R_HI      EQU     +2.0                              ; Serials
1832      -8.000000E+000        R_LO      EQU     -8.0                              ;
1833      3.000000E+000         SI_HI     EQU     +3.0                              ; Parallels
1834      -9.000000E+000        SI_LO     EQU     -9.0                              ;
1835      3.000000E+000         DG_HI     EQU     +3.0                              ; Dump Gate
1836      -9.000000E+000        DG_LO     EQU     -9.0                              ;
1837   
1838                            ; DC Bias voltages in volts
1839      2.000000E+001         VODL      EQU     20.0                              ; Output Drain Left
1840      2.000000E+001         VODR      EQU     20.0                              ; Output Drain Right
1841      9.800000E+000         VRDL      EQU     9.80                              ; Reset Drain Left. | To produce +9.0 in real li
fe
1842      9.800000E+000         VRDR      EQU     9.80                              ; Reset Drain Right | on the red side.
1843      -6.000000E+000        VOG       EQU     -6.0                              ; Output Gate
1844      -6.000000E+000        VABG      EQU     -6.0                              ; Anti-blooming gate
1845      000700                OFFSET    EQU     $700
1846      000700                OFFSET0   EQU     $700                              ; Left Side Of Frame
1847      0006EF                OFFSET1   EQU     $6EF                              ; Right Side Of Frame
1848   
1849                            ; Define switch state bits for the lower CCD clock driver bank CLK2
1850      000001                H1L       EQU     1                                 ; Serial #1 Left, Pin 1 - clock 0
1851      000002                H2L       EQU     2                                 ; Serial #2 Left, Pin 2 - clock 1
1852      000004                H3L       EQU     4                                 ; Serial #3 Left, Pin 3 - clock 2
1853      000008                H1R       EQU     8                                 ; Serial #1 Right, Pin 4 - clock 3
1854      000010                H2R       EQU     $10                               ; Serial #2 Right, Pin 5 - clock 4
1855      000020                H3R       EQU     $20                               ; Serial #2 Right, Pin 6 - clock 5
1856      000100                RGL       EQU     $100                              ; Reset Gate Left, Pin 9 - clock 8
1857      000200                RGR       EQU     $200                              ; Reset Gate Right, Pin 10 - clock 9
1858   
1859                            ; Pins 9-12 are not used
1860   
1861                            ; Define switch state bits for the upper CCD clock driver bank CLK3
1862      000001                I1        EQU     1                                 ; Image, phase #1, Pin 13 - clock 12
1863      000002                I2        EQU     2                                 ; Image, phase #2, Pin 14 - clock 13
1864      000004                I3        EQU     4                                 ; Image, phase #3, Pin 15 - clock 14
1865      000008                S1        EQU     8                                 ; Storage, phase #1, Pin 16 - clock 15
1866      000010                S2        EQU     $10                               ; Storage, phase #2, Pin 17 - clock 16
1867      000020                S3        EQU     $20                               ; Storage, phase #3, Pin 18 - clock 17
1868      000100                DG        EQU     $100                              ; Dump Gate, Pin 34 - clock 20
1869   
1870                            ;  ***  Definitions for Y: memory waveform tables  *****
1871                            ; Clock only the Storage clocks : S1->S2->S3
1872                            S_PARALLEL
1873      Y:0040 Y:0040                   DC      END_S_PARALLEL-S_PARALLEL-2
1874      Y:0041 Y:0041                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1875                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
1876      Y:0042 Y:0042                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00
1877      Y:0043 Y:0043                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00
1878      Y:0044 Y:0044                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3
1879      Y:0045 Y:0045                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3
1880      Y:0046 Y:0046                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3
1881      Y:0047 Y:0047                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
1882                            END_S_PARALLEL
1883   
1884                            ; Reverse clock only the Storage clocks : S1->S3->S2->S1
1885                            ; Use in pipelined occultation mode
1886                            R_S_PARALLEL
1887      Y:0048 Y:0048                   DC      END_R_S_PARALLEL-R_S_PARALLEL-2
1888      Y:0049 Y:0049                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 36



1889      Y:004A Y:004A                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3
1890      Y:004B Y:004B                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3
1891      Y:004C Y:004C                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3
1892      Y:004D Y:004D                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00
1893      Y:004E Y:004E                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00
1894      Y:004F Y:004F                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
1895                            END_R_S_PARALLEL
1896   
1897                            ; Clock only the Storage clocks : S1->S2->S3 with DG
1898                            S_CLEAR
1899      Y:0050 Y:0050                   DC      END_S_CLEAR-S_CLEAR-2
1900      Y:0051 Y:0051                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1901                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
1902      Y:0052 Y:0052                   DC      CLK3+SI_DELAY+I1+00+00+S1+S2+00+DG
1903      Y:0053 Y:0053                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+00+DG
1904      Y:0054 Y:0054                   DC      CLK3+SI_DELAY+I1+00+00+00+S2+S3+DG
1905      Y:0055 Y:0055                   DC      CLK3+SI_DELAY+I1+00+00+00+00+S3+DG
1906      Y:0056 Y:0056                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+S3+DG
1907      Y:0057 Y:0057                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
1908                            END_S_CLEAR
1909                            ; 2 microsecond delay before readout starts may be needed here
1910                            ;       DC      CLK3+$600000+I1+00+00+S1+00+0000
1911   
1912                            ; Clock both the Storage and Image clocks : I1->I2->I3 and S1->S2->S3
1913                            IS_PARALLEL
1914      Y:0058 Y:0058                   DC      END_IS_PARALLEL-IS_PARALLEL-2
1915      Y:0059 Y:0059                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1916                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00 ; Probably not needed
1917      Y:005A Y:005A                   DC      CLK3+SI_DELAY+I1+I2+00+S1+S2+00
1918      Y:005B Y:005B                   DC      CLK3+SI_DELAY+00+I2+00+00+S2+00
1919      Y:005C Y:005C                   DC      CLK3+SI_DELAY+00+I2+I3+00+S2+S3
1920      Y:005D Y:005D                   DC      CLK3+SI_DELAY+00+00+I3+00+00+S3
1921      Y:005E Y:005E                   DC      CLK3+SI_DELAY+I1+00+I3+S1+00+S3
1922      Y:005F Y:005F                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00
1923                            END_IS_PARALLEL
1924   
1925                            ; Clock both the Storage and Image clocks : I1->I2->I3 and S1->S2->S3
1926                            IS_CLEAR
1927      Y:0060 Y:0060                   DC      IS_CLEAR_END-IS_CLEAR-2
1928      Y:0061 Y:0061                   DC      CLK2+00000000+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1929                            ;       DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+00 ; Probably not needed
1930      Y:0062 Y:0062                   DC      CLK3+SI_DELAY+I1+I2+00+S1+S2+00+DG
1931      Y:0063 Y:0063                   DC      CLK3+SI_DELAY+00+I2+00+00+S2+00+DG
1932      Y:0064 Y:0064                   DC      CLK3+SI_DELAY+00+I2+I3+00+S2+S3+DG
1933      Y:0065 Y:0065                   DC      CLK3+SI_DELAY+00+00+I3+00+00+S3+DG
1934      Y:0066 Y:0066                   DC      CLK3+SI_DELAY+I1+00+I3+S1+00+S3+DG
1935      Y:0067 Y:0067                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
1936                            IS_CLEAR_END
1937   
1938                            DUMP_SERIAL
1939      Y:0068 Y:0068                   DC      END_DUMP_SERIAL-DUMP_SERIAL-2
1940      Y:0069 Y:0069                   DC      CLK2+SI_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1941      Y:006A Y:006A                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+DG
1942      Y:006B Y:006B                   DC      CLK2+SI_DELAY+RGL+RGR+000+000+000+000+000+000
1943      Y:006C Y:006C                   DC      CLK3+SI_DELAY+I1+00+00+S1+00+00+00
1944      Y:006D Y:006D                   DC      CLK2+SI_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1945                            END_DUMP_SERIAL
1946                                    COMMENT *
1947                            ; Michigan AIMO clocking - this is vestigial and commented out
1948                            PARALLEL DC     PARALLEL_CLEAR-PARALLEL-2
1949                                    DC      CLK2+$000000+RGL+RGR+H1L+H1R+H2L+H2R+00+000+000+00
1950                                    DC      CLK3+P_DELAY+00+00+I3
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 37



1951                                    DC      CLK3+P_DELAY+00+00+I3
1952                                    DC      CLK3+P_DELAY+I1+00+I3
1953                                    DC      CLK3+P_DELAY+I1+00+00
1954                                    DC      CLK3+P_DELAY+I1+I2+00
1955                                    DC      CLK3+P_DELAY+00+I2+00
1956                                    DC      CLK3+P_DELAY+00+I2+I3
1957                                    DC      CLK3+P_DELAY+00+00+I3
1958                                    DC      CLK3+P_DELAY+00+00+I3
1959                                    DC      CLK3+P_DELAY+00+00+00
1960                                    *
1961   
1962                            ; For serial clocking we know that the serial registers are laid out as
1963                            ; follows for a backside part per communication with Paul Jorden:
1964   
1965                            ;          Right Side               Left Side
1966                            ;       OG  3  2  1  3 .........  3  2  1  3  OG
1967   
1968                            ; Left amp is   2 -> 1 -> 3
1969                            ; Right amp is  1 -> 2 -> 3
1970   
1971                            ; For a frontside part the left and right are reversed.
1972                            ; Parallel phase 3 dumps into serial 1 and 2.
1973   
1974                            ; Between serial clock code lumps the serials are left as follows:
1975                            ; LEFT  Phase 2 L and R both high
1976                            ; RIGHT Phase 1 L and R both high
1977                            ; SPLIT H1R and H2L are high
1978   
1979                            ; Video processor bit definition
1980                            ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
1981   
1982                            SERIAL_IDLE                                         ; Split serial
1983      Y:006E Y:006E                   DC      END_SERIAL_IDLE-SERIAL_IDLE-2
1984      Y:006F Y:006F                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
1985      Y:0070 Y:0070                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
1986      Y:0071 Y:0071                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
1987      Y:0072 Y:0072                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
1988      Y:0073 Y:0073                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
1989      Y:0074 Y:0074                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
1990      Y:0075 Y:0075                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
1991      Y:0076 Y:0076                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
1992      Y:0077 Y:0077                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
1993      Y:0078 Y:0078                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
1994      Y:0079 Y:0079                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
1995      Y:007A Y:007A                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
1996                            ; Not needed, so comment out
1997                            ;       DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
1998                            END_SERIAL_IDLE
1999   
2000                            ; The following waveforms are for binned operation.  This is tricky with the
2001                            ; CCD47 because it doesn't have a summing well.  The reset level integration
2002                            ; has to happen before serial 3 drops for the first time and the data level
2003                            ; integration has to happen after it drops for the last time.  The initial
2004                            ; clocks go through the reset integration, the serial clocks are the
2005                            ; intervening clocks for additional pixels binned with the first one, and
2006                            ; the video process is left to do the last clock and data integration.
2007   
2008                            INITIAL_CLOCK_SPLIT                                 ; Both amplifiers
2009      Y:007B Y:007B                   DC      END_INITIAL_CLOCK_SPLIT-INITIAL_CLOCK_SPLIT-2
2010      Y:007C Y:007C                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2011      Y:007D Y:007D                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2012      Y:007E Y:007E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 38



2013      Y:007F Y:007F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2014      Y:0080 Y:0080                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2015      Y:0081 Y:0081                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2016      Y:0082 Y:0082                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2017      Y:0083 Y:0083                   DC      $00F020                           ; Transmit A/D data to host
2018      Y:0084 Y:0084                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2019      Y:0085 Y:0085                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2020      Y:0086 Y:0086                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2021                            END_INITIAL_CLOCK_SPLIT
2022   
2023                            INITIAL_CLOCK_RIGHT                                 ; Serial right, Swap S1L and S2L
2024      Y:0087 Y:0087                   DC      END_INITIAL_CLOCK_RIGHT-INITIAL_CLOCK_RIGHT-2
2025      Y:0088 Y:0088                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2026      Y:0089 Y:0089                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2027      Y:008A Y:008A                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2028      Y:008B Y:008B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2029      Y:008C Y:008C                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2030      Y:008D Y:008D                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2031      Y:008E Y:008E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2032      Y:008F Y:008F                   DC      $00F021                           ; Transmit A/D data to host
2033      Y:0090 Y:0090                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2034      Y:0091 Y:0091                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2035      Y:0092 Y:0092                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2036                            END_INITIAL_CLOCK_RIGHT
2037   
2038                            INITIAL_CLOCK_LEFT                                  ; Serial left, Swap S1R and S2R
2039      Y:0093 Y:0093                   DC      END_INITIAL_CLOCK_LEFT-INITIAL_CLOCK_LEFT-2
2040      Y:0094 Y:0094                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2041      Y:0095 Y:0095                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2042      Y:0096 Y:0096                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2043      Y:0097 Y:0097                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2044      Y:0098 Y:0098                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2045      Y:0099 Y:0099                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2046      Y:009A Y:009A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2047      Y:009B Y:009B                   DC      $00F000                           ; Transmit A/D data to host
2048      Y:009C Y:009C                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2049      Y:009D Y:009D                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2050      Y:009E Y:009E                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2051                            END_INITIAL_CLOCK_LEFT
2052   
2053                            SERIAL_CLOCK_SPLIT                                  ; Both amplifiers
2054      Y:009F Y:009F                   DC      END_SERIAL_CLOCK_SPLIT-SERIAL_CLOCK_SPLIT-2
2055      Y:00A0 Y:00A0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2056      Y:00A1 Y:00A1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2057      Y:00A2 Y:00A2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2058      Y:00A3 Y:00A3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2059      Y:00A4 Y:00A4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2060      Y:00A5 Y:00A5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2061                            END_SERIAL_CLOCK_SPLIT
2062   
2063                            SERIAL_CLOCK_RIGHT                                  ; Serial right, Swap S1L and S2L
2064      Y:00A6 Y:00A6                   DC      END_SERIAL_CLOCK_RIGHT-SERIAL_CLOCK_RIGHT-2
2065      Y:00A7 Y:00A7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2066      Y:00A8 Y:00A8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2067      Y:00A9 Y:00A9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2068      Y:00AA Y:00AA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2069      Y:00AB Y:00AB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2070      Y:00AC Y:00AC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2071                            END_SERIAL_CLOCK_RIGHT
2072   
2073                            SERIAL_CLOCK_LEFT                                   ; Serial left, Swap S1R and S2R
2074      Y:00AD Y:00AD                   DC      END_SERIAL_CLOCK_LEFT-SERIAL_CLOCK_LEFT-2
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 39



2075      Y:00AE Y:00AE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2076      Y:00AF Y:00AF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2077      Y:00B0 Y:00B0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2078      Y:00B1 Y:00B1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2079      Y:00B2 Y:00B2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2080      Y:00B3 Y:00B3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2081                            END_SERIAL_CLOCK_LEFT
2082   
2083                            VIDEO_PROCESS
2084      Y:00B4 Y:00B4                   DC      END_VIDEO_PROCESS-VIDEO_PROCESS-2
2085                            CCLK_1                                              ; The following line is overwritten by timmisc.s
2086      Y:00B5 Y:00B5                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2087      Y:00B6 Y:00B6                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2088      Y:00B7 Y:00B7                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2089                            CCLK_2                                              ; The following line is overwritten by timmisc.s
, but is correct as is.
2090                            ; Actually it shouldn't be needed so comment it out.
2091                            ;       DC      CLK2+S_DLY+S1R+S2R+000+S1L+S2L+000+000+000+000+000
2092                            END_VIDEO_PROCESS
2093   
2094                            ; Starting Y: address of circular waveforms for no-overhead access
2095      0000C0                STRT_CIR  EQU     $C0
2096      000620                ROM_DISP  EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+STRT_CIR
2097      000660                DAC_DISP  EQU     APL_NUM*N_W_APL+APL_LEN+MISC_LEN+COM_LEN+$100
2098   
2099                            ; Check for Y: data memory overflow
2100                                      IF      @CVS(N,*)>STRT_CIR
2102                                      ENDIF                                     ;  will not overflow
2103   
2104                            ; The fast serial code with the circulating address register must start
2105                            ;   on a boundary that is a multiple of the address register modulus.
2106   
2107                                      IF      @SCP("HOST","HOST")
2108      Y:00C0 Y:00C0                   ORG     Y:STRT_CIR,Y:STRT_CIR             ; Download address
2109                                      ELSE
2111                                      ENDIF
2112   
2113                            ; This is an area to copy in the serial fast binned waveforms from high Y memory
2114                            ; It is 0x28 = 40 locations long, enough to put in a binned-by-five waveform
2115                            ;            xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2116                            SERIAL_READ
2117      Y:00C0 Y:00C0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2118      Y:00C1 Y:00C1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2119      Y:00C2 Y:00C2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2120      Y:00C3 Y:00C3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2121      Y:00C4 Y:00C4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2122      Y:00C5 Y:00C5                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2123                            SXMIT
2124      Y:00C6 Y:00C6                   DC      $00F000                           ; Transmit A/D data to host
2125      Y:00C7 Y:00C7                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2126      Y:00C8 Y:00C8                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2127      Y:00C9 Y:00C9                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2128      Y:00CA Y:00CA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2129      Y:00CB Y:00CB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2130      Y:00CC Y:00CC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2131      Y:00CD Y:00CD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2132      Y:00CE Y:00CE                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2133      Y:00CF Y:00CF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2134      Y:00D0 Y:00D0                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2135      Y:00D1 Y:00D1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2136      Y:00D2 Y:00D2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2137      Y:00D3 Y:00D3                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 40



2138      Y:00D4 Y:00D4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2139      Y:00D5 Y:00D5                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2140      Y:00D6 Y:00D6                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2141      Y:00D7 Y:00D7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2142      Y:00D8 Y:00D8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2143      Y:00D9 Y:00D9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2144      Y:00DA Y:00DA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2145      Y:00DB Y:00DB                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2146      Y:00DC Y:00DC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2147      Y:00DD Y:00DD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2148      Y:00DE Y:00DE                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2149      Y:00DF Y:00DF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2150      Y:00E0 Y:00E0                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2151      Y:00E1 Y:00E1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2152      Y:00E2 Y:00E2                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2153      Y:00E3 Y:00E3                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2154      Y:00E4 Y:00E4                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2155                            END_SERIAL
2156   
2157                            ; Serial clocking waveform for skipping
2158                                      IF      @SCP("HOST","HOST")
2159      Y:00E8 Y:00E8                   ORG     Y:STRT_CIR+$28,Y:STRT_CIR+$28     ; Download address
2160                                      ELSE
2162                                      ENDIF
2163   
2164                            ; There are three serial skip waveforms that must all be the same length
2165                            SERIAL_SKIP_LEFT
2166                            ;       DC      END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-2
2167      Y:00E8 Y:00E8                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2168      Y:00E9 Y:00E9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2169      Y:00EA Y:00EA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2170      Y:00EB Y:00EB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2171      Y:00EC Y:00EC                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2172      Y:00ED Y:00ED                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2173                            END_SERIAL_SKIP_LEFT
2174   
2175                                      IF      @SCP("HOST","HOST")
2176      Y:00F0 Y:00F0                   ORG     Y:STRT_CIR+$30,Y:STRT_CIR+$30     ; Download address
2177                                      ELSE
2179                                      ENDIF
2180   
2181                            SERIAL_SKIP_RIGHT
2182                            ;       DC      END_SERIAL_SKIP_RIGHT-SERIAL_SKIP_RIGHT-2
2183      Y:00F0 Y:00F0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2184      Y:00F1 Y:00F1                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2185      Y:00F2 Y:00F2                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2186      Y:00F3 Y:00F3                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2187      Y:00F4 Y:00F4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2188      Y:00F5 Y:00F5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2189                            END_SERIAL_SKIP_RIGHT
2190   
2191                                      IF      @SCP("HOST","HOST")
2192      Y:00F8 Y:00F8                   ORG     Y:STRT_CIR+$38,Y:STRT_CIR+$38     ; Download address
2193                                      ELSE
2195                                      ENDIF
2196   
2197                            SERIAL_SKIP_SPLIT
2198                            ;       DC      END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-2
2199      Y:00F8 Y:00F8                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2200      Y:00F9 Y:00F9                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2201      Y:00FA Y:00FA                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2202      Y:00FB Y:00FB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 41



2203      Y:00FC Y:00FC                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2204      Y:00FD Y:00FD                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2205                            END_SERIAL_SKIP_SPLIT
2206   
2207                            ; Put all the following code in SRAM.
2208                                      IF      @SCP("HOST","HOST")
2209      Y:0100 Y:0100                   ORG     Y:$100,Y:$100                     ; Download address
2210                                      ELSE
2212                                      ENDIF
2213   
2214                            ; Initialization of clock driver and video processor DACs and switches
2215      Y:0100 Y:0100         DACS      DC      END_DACS-DACS-1
2216      Y:0101 Y:0101                   DC      (CLK2<<8)+(0<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S1 Left High, pin 1
2217      Y:0102 Y:0102                   DC      (CLK2<<8)+(1<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S1 Left Low
2218      Y:0103 Y:0103                   DC      (CLK2<<8)+(2<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S2 Left Right High, pin 2
2219      Y:0104 Y:0104                   DC      (CLK2<<8)+(3<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S2 Left Low
2220      Y:0105 Y:0105                   DC      (CLK2<<8)+(4<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S3 Left High, pin 3
2221      Y:0106 Y:0106                   DC      (CLK2<<8)+(5<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S3 Left Low
2222      Y:0107 Y:0107                   DC      (CLK2<<8)+(6<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S1 Right High, pin 4
2223      Y:0108 Y:0108                   DC      (CLK2<<8)+(7<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S1 Right Low
2224      Y:0109 Y:0109                   DC      (CLK2<<8)+(8<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S2 Right High, pin 5
2225      Y:010A Y:010A                   DC      (CLK2<<8)+(9<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S2 Right Low
2226      Y:010B Y:010B                   DC      (CLK2<<8)+(10<<14)+@CVI((R_HI+10.0)/20.0*4095) ; S3 Right High, pin 6
2227      Y:010C Y:010C                   DC      (CLK2<<8)+(11<<14)+@CVI((R_LO+10.0)/20.0*4095) ; S3 Right Low
2228      Y:010D Y:010D                   DC      (CLK2<<8)+(12<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 7
2229      Y:010E Y:010E                   DC      (CLK2<<8)+(13<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2230      Y:010F Y:010F                   DC      (CLK2<<8)+(14<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 8
2231      Y:0110 Y:0110                   DC      (CLK2<<8)+(15<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2232      Y:0111 Y:0111                   DC      (CLK2<<8)+(16<<14)+@CVI((RG_HI+10.0)/20.0*4095) ; RG Left High, pin 9
2233      Y:0112 Y:0112                   DC      (CLK2<<8)+(17<<14)+@CVI((RG_LO+10.0)/20.0*4095) ; RG Left Low
2234      Y:0113 Y:0113                   DC      (CLK2<<8)+(18<<14)+@CVI((RG_HI+10.0)/20.0*4095) ; RG Right High, pin 10
2235      Y:0114 Y:0114                   DC      (CLK2<<8)+(19<<14)+@CVI((RG_LO+10.0)/20.0*4095) ; RG Rightd Low
2236      Y:0115 Y:0115                   DC      (CLK2<<8)+(20<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 11
2237      Y:0116 Y:0116                   DC      (CLK2<<8)+(21<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2238      Y:0117 Y:0117                   DC      (CLK2<<8)+(22<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 12
2239      Y:0118 Y:0118                   DC      (CLK2<<8)+(23<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2240      Y:0119 Y:0119                   DC      (CLK2<<8)+(24<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; I1 High, pin 13
2241      Y:011A Y:011A                   DC      (CLK2<<8)+(25<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; I1 Low
2242      Y:011B Y:011B                   DC      (CLK2<<8)+(26<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; I2 High, pin 14
2243      Y:011C Y:011C                   DC      (CLK2<<8)+(27<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; I2 Low
2244      Y:011D Y:011D                   DC      (CLK2<<8)+(28<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; I3 High, pin 15
2245      Y:011E Y:011E                   DC      (CLK2<<8)+(29<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; I3 Low
2246      Y:011F Y:011F                   DC      (CLK2<<8)+(30<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; S1 High, pin 16
2247      Y:0120 Y:0120                   DC      (CLK2<<8)+(31<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; S1 Low
2248      Y:0121 Y:0121                   DC      (CLK2<<8)+(32<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; S2 High, pin 17
2249      Y:0122 Y:0122                   DC      (CLK2<<8)+(33<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; S2 Low
2250      Y:0123 Y:0123                   DC      (CLK2<<8)+(34<<14)+@CVI((SI_HI+10.0)/20.0*4095) ; S3 High, pin 18
2251      Y:0124 Y:0124                   DC      (CLK2<<8)+(35<<14)+@CVI((SI_LO+10.0)/20.0*4095) ; S3 Low
2252      Y:0125 Y:0125                   DC      (CLK2<<8)+(36<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 19
2253      Y:0126 Y:0126                   DC      (CLK2<<8)+(37<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2254      Y:0127 Y:0127                   DC      (CLK2<<8)+(38<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 33
2255      Y:0128 Y:0128                   DC      (CLK2<<8)+(39<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2256      Y:0129 Y:0129                   DC      (CLK2<<8)+(40<<14)+@CVI((DG_HI+10.0)/20.0*4095) ; DG High, pin 34
2257      Y:012A Y:012A                   DC      (CLK2<<8)+(41<<14)+@CVI((DG_LO+10.0)/20.0*4095) ; DG Low
2258      Y:012B Y:012B                   DC      (CLK2<<8)+(42<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 35
2259      Y:012C Y:012C                   DC      (CLK2<<8)+(43<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2260      Y:012D Y:012D                   DC      (CLK2<<8)+(44<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused High, pin 36
2261      Y:012E Y:012E                   DC      (CLK2<<8)+(45<<14)+@CVI((CLK_ZERO+10.0)/20.0*4095) ; Unused Low
2262      Y:012F Y:012F                   DC      (CLK2<<8)+(46<<14)+@CVI((VABG+10.0)/20.0*4095) ; Anti-Blooming Gate High, pin 37
2263      Y:0130 Y:0130                   DC      (CLK2<<8)+(47<<14)+@CVI((VABG+10.0)/20.0*4095) ; Anti-Blooming Gate Low
2264   
2265                            ; Set gain and integrator speed
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 42



2266      Y:0131 Y:0131                   DC      $0c3fee                           ; Gain, speed
2267   
2268                            ;       DC      $0c3f77                 ; Gain x1, fast integ speed, board #0
2269                            ;       DC      $0c3fbb                 ; Gain x2, fast integ speed, board #0
2270                            ;       DC      $0c3fdd                 ; Gain x4.75, fast integ speed, board #0
2271                            ;       DC      $0c3fee                 ; Gain x9.50, fast integ speed, board #0
2272                            ;       DC      $0c3cee                 ; Gain x9.50, slow integ speed, board #0
2273   
2274                            ; Input offset voltages for DC coupling. Target is U4#6 = 24 volts
2275      Y:0132 Y:0132                   DC      $0c0880                           ; Input offset, ch. A
2276      Y:0133 Y:0133                   DC      $0c8880                           ; Input offset, ch. B
2277   
2278                            ; Output offset voltages
2279      Y:0134 Y:0134                   DC      $0c4000+OFFSET0                   ; Output video offset, ch. A
2280      Y:0135 Y:0135                   DC      $0cc000+OFFSET1                   ; Output video offset, ch. B
2281   
2282                            ; Output and reset drain DC bias voltages
2283      Y:0136 Y:0136                   DC      $0d0000+@CVI((VODL-7.50)/22.5*4095) ; VODL pin #1
2284      Y:0137 Y:0137                   DC      $0d4000+@CVI((VODR-7.50)/22.5*4095) ; VODR pin #2
2285      Y:0138 Y:0138                   DC      $0d8000+@CVI((VRDL-5.00)/15.0*4095) ; VRDL pin #3
2286      Y:0139 Y:0139                   DC      $0dc000+@CVI((VRDR-5.00)/15.0*4095) ; VRDR pin #4
2287   
2288   
2289                            ; Output and anti-blooming gates
2290      Y:013A Y:013A                   DC      $0f0000+BIAS_ZERO                 ; Unused pin #9
2291      Y:013B Y:013B                   DC      $0f4000+BIAS_ZERO                 ; Unused pin #10
2292      Y:013C Y:013C                   DC      $0f8000+@CVI((VOG+10.0)/20.0*4095) ; Unused pin #11
2293      Y:013D Y:013D                   DC      $0fc000+@CVI((VABG+10.0)/20.0*4095) ; Unused pin #12
2294                            END_DACS
2295   
2296   
2297                            ;       These are the 15 fast serial read waveforms for left, right,
2298                            ;       and split reads for serial binning factors from 1 to 5.
2299   
2300                            ;       Unbinned waveforms
2301                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2302                            SERIAL_READ_LEFT_1
2303      Y:013E Y:013E                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2304      Y:013F Y:013F                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2305      Y:0140 Y:0140                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2306      Y:0141 Y:0141                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2307      Y:0142 Y:0142                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2308      Y:0143 Y:0143                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2309                            SXMIT_LEFT_1
2310      Y:0144 Y:0144                   DC      $00F000                           ; Transmit A/D data to host
2311      Y:0145 Y:0145                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2312      Y:0146 Y:0146                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2313      Y:0147 Y:0147                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2314      Y:0148 Y:0148                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2315      Y:0149 Y:0149                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2316      Y:014A Y:014A                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2317                            END_SERIAL_READ_LEFT_1
2318   
2319                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2320                            SERIAL_READ_RIGHT_1
2321      Y:014B Y:014B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2322      Y:014C Y:014C                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2323      Y:014D Y:014D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2324      Y:014E Y:014E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2325      Y:014F Y:014F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2326      Y:0150 Y:0150                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2327                            SXMIT_RIGHT_1
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 43



2328      Y:0151 Y:0151                   DC      $00F021                           ; Transmit A/D data to host
2329      Y:0152 Y:0152                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2330      Y:0153 Y:0153                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2331      Y:0154 Y:0154                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2332      Y:0155 Y:0155                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2333      Y:0156 Y:0156                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2334      Y:0157 Y:0157                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2335                            END_SERIAL_READ_RIGHT_1
2336   
2337                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2338                            SERIAL_READ_SPLIT_1
2339      Y:0158 Y:0158                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2340      Y:0159 Y:0159                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2341      Y:015A Y:015A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2342      Y:015B Y:015B                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2343      Y:015C Y:015C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2344      Y:015D Y:015D                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2345                            SXMIT_SPLIT_1
2346      Y:015E Y:015E                   DC      $00F020                           ; Transmit A/D data to host
2347      Y:015F Y:015F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2348      Y:0160 Y:0160                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2349      Y:0161 Y:0161                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2350      Y:0162 Y:0162                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2351      Y:0163 Y:0163                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2352      Y:0164 Y:0164                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2353                            END_SERIAL_READ_SPLIT_1
2354   
2355                            ; Bin by 2 waveforms
2356                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2357                            SERIAL_READ_LEFT_2
2358      Y:0165 Y:0165                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2359      Y:0166 Y:0166                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2360      Y:0167 Y:0167                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2361      Y:0168 Y:0168                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2362      Y:0169 Y:0169                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2363      Y:016A Y:016A                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2364                            SXMIT_LEFT_2
2365      Y:016B Y:016B                   DC      $00F000                           ; Transmit A/D data to host
2366      Y:016C Y:016C                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2367      Y:016D Y:016D                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2368      Y:016E Y:016E                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2369      Y:016F Y:016F                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2370      Y:0170 Y:0170                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2371      Y:0171 Y:0171                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2372      Y:0172 Y:0172                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2373      Y:0173 Y:0173                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2374      Y:0174 Y:0174                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2375      Y:0175 Y:0175                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2376      Y:0176 Y:0176                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2377      Y:0177 Y:0177                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2378                            END_SERIAL_READ_LEFT_2
2379   
2380                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2381                            SERIAL_READ_RIGHT_2
2382      Y:0178 Y:0178                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2383      Y:0179 Y:0179                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2384      Y:017A Y:017A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2385      Y:017B Y:017B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2386      Y:017C Y:017C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2387      Y:017D Y:017D                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2388                            SXMIT_RIGHT_2
2389      Y:017E Y:017E                   DC      $00F021                           ; Transmit A/D data to host
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 44



2390      Y:017F Y:017F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2391      Y:0180 Y:0180                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2392      Y:0181 Y:0181                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2393      Y:0182 Y:0182                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2394      Y:0183 Y:0183                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2395      Y:0184 Y:0184                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2396      Y:0185 Y:0185                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2397      Y:0186 Y:0186                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2398      Y:0187 Y:0187                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2399      Y:0188 Y:0188                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2400      Y:0189 Y:0189                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2401      Y:018A Y:018A                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2402                            END_SERIAL_READ_RIGHT_2
2403   
2404                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2405                            SERIAL_READ_SPLIT_2
2406      Y:018B Y:018B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2407      Y:018C Y:018C                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2408      Y:018D Y:018D                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2409      Y:018E Y:018E                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2410      Y:018F Y:018F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2411      Y:0190 Y:0190                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2412                            SXMIT_SPLIT_2
2413      Y:0191 Y:0191                   DC      $00F020                           ; Transmit A/D data to host
2414      Y:0192 Y:0192                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2415      Y:0193 Y:0193                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2416      Y:0194 Y:0194                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2417      Y:0195 Y:0195                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2418      Y:0196 Y:0196                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2419      Y:0197 Y:0197                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2420      Y:0198 Y:0198                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2421      Y:0199 Y:0199                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2422      Y:019A Y:019A                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2423      Y:019B Y:019B                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2424      Y:019C Y:019C                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2425      Y:019D Y:019D                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2426                            END_SERIAL_READ_SPLIT_2
2427   
2428   
2429                            ;       Binned by 3 waveforms
2430                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2431                            SERIAL_READ_LEFT_3
2432      Y:019E Y:019E                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2433      Y:019F Y:019F                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2434      Y:01A0 Y:01A0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2435      Y:01A1 Y:01A1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2436      Y:01A2 Y:01A2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2437      Y:01A3 Y:01A3                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2438                            SXMIT_LEFT_3
2439      Y:01A4 Y:01A4                   DC      $00F000                           ; Transmit A/D data to host
2440      Y:01A5 Y:01A5                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2441      Y:01A6 Y:01A6                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2442      Y:01A7 Y:01A7                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2443      Y:01A8 Y:01A8                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2444      Y:01A9 Y:01A9                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2445      Y:01AA Y:01AA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2446      Y:01AB Y:01AB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2447      Y:01AC Y:01AC                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2448      Y:01AD Y:01AD                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2449      Y:01AE Y:01AE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2450      Y:01AF Y:01AF                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2451      Y:01B0 Y:01B0                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 45



2452      Y:01B1 Y:01B1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2453      Y:01B2 Y:01B2                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2454      Y:01B3 Y:01B3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2455      Y:01B4 Y:01B4                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2456      Y:01B5 Y:01B5                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2457      Y:01B6 Y:01B6                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2458                            END_SERIAL_READ_LEFT_3
2459   
2460                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2461                            SERIAL_READ_RIGHT_3
2462      Y:01B7 Y:01B7                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2463      Y:01B8 Y:01B8                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2464      Y:01B9 Y:01B9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2465      Y:01BA Y:01BA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2466      Y:01BB Y:01BB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2467      Y:01BC Y:01BC                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2468                            SXMIT_RIGHT_3
2469      Y:01BD Y:01BD                   DC      $00F021                           ; Transmit A/D data to host
2470      Y:01BE Y:01BE                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2471      Y:01BF Y:01BF                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2472      Y:01C0 Y:01C0                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2473      Y:01C1 Y:01C1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2474      Y:01C2 Y:01C2                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2475      Y:01C3 Y:01C3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2476      Y:01C4 Y:01C4                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2477      Y:01C5 Y:01C5                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2478      Y:01C6 Y:01C6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2479      Y:01C7 Y:01C7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2480      Y:01C8 Y:01C8                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2481      Y:01C9 Y:01C9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2482      Y:01CA Y:01CA                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2483      Y:01CB Y:01CB                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2484      Y:01CC Y:01CC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2485      Y:01CD Y:01CD                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2486      Y:01CE Y:01CE                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2487      Y:01CF Y:01CF                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2488                            END_SERIAL_READ_RIGHT_3
2489   
2490                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2491                            SERIAL_READ_SPLIT_3
2492      Y:01D0 Y:01D0                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2493      Y:01D1 Y:01D1                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2494      Y:01D2 Y:01D2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2495      Y:01D3 Y:01D3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2496      Y:01D4 Y:01D4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2497      Y:01D5 Y:01D5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2498                            SXMIT_SPLIT_3
2499      Y:01D6 Y:01D6                   DC      $00F020                           ; Transmit A/D data to host
2500      Y:01D7 Y:01D7                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2501      Y:01D8 Y:01D8                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2502      Y:01D9 Y:01D9                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2503      Y:01DA Y:01DA                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2504      Y:01DB Y:01DB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2505      Y:01DC Y:01DC                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2506      Y:01DD Y:01DD                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2507      Y:01DE Y:01DE                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2508      Y:01DF Y:01DF                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2509      Y:01E0 Y:01E0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2510      Y:01E1 Y:01E1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2511      Y:01E2 Y:01E2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2512      Y:01E3 Y:01E3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2513      Y:01E4 Y:01E4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 46



2514      Y:01E5 Y:01E5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2515      Y:01E6 Y:01E6                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2516      Y:01E7 Y:01E7                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2517      Y:01E8 Y:01E8                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2518                            END_SERIAL_READ_SPLIT_3
2519   
2520                            ;       Binned by 4 waveforms
2521                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2522                            SERIAL_READ_LEFT_4
2523      Y:01E9 Y:01E9                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2524      Y:01EA Y:01EA                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2525      Y:01EB Y:01EB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2526      Y:01EC Y:01EC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2527      Y:01ED Y:01ED                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2528      Y:01EE Y:01EE                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
2529                            SXMIT_LEFT_4
2530      Y:01EF Y:01EF                   DC      $00F000                           ; Transmit A/D data to host
2531      Y:01F0 Y:01F0                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2532      Y:01F1 Y:01F1                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2533      Y:01F2 Y:01F2                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2534      Y:01F3 Y:01F3                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2535      Y:01F4 Y:01F4                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2536      Y:01F5 Y:01F5                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2537      Y:01F6 Y:01F6                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2538      Y:01F7 Y:01F7                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2539      Y:01F8 Y:01F8                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2540      Y:01F9 Y:01F9                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2541      Y:01FA Y:01FA                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2542      Y:01FB Y:01FB                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2543      Y:01FC Y:01FC                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2544      Y:01FD Y:01FD                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2545      Y:01FE Y:01FE                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2546      Y:01FF Y:01FF                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2547      Y:0200 Y:0200                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2548      Y:0201 Y:0201                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2549      Y:0202 Y:0202                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2550      Y:0203 Y:0203                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2551      Y:0204 Y:0204                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2552      Y:0205 Y:0205                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2553      Y:0206 Y:0206                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2554      Y:0207 Y:0207                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2555                            END_SERIAL_READ_LEFT_4
2556   
2557                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2558                            SERIAL_READ_RIGHT_4
2559      Y:0208 Y:0208                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2560      Y:0209 Y:0209                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2561      Y:020A Y:020A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2562      Y:020B Y:020B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2563      Y:020C Y:020C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2564      Y:020D Y:020D                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2565                            SXMIT_RIGHT_4
2566      Y:020E Y:020E                   DC      $00F021                           ; Transmit A/D data to host
2567      Y:020F Y:020F                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2568      Y:0210 Y:0210                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2569      Y:0211 Y:0211                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2570      Y:0212 Y:0212                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2571      Y:0213 Y:0213                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2572      Y:0214 Y:0214                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2573      Y:0215 Y:0215                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2574      Y:0216 Y:0216                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2575      Y:0217 Y:0217                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 47



2576      Y:0218 Y:0218                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2577      Y:0219 Y:0219                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2578      Y:021A Y:021A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2579      Y:021B Y:021B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2580      Y:021C Y:021C                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2581      Y:021D Y:021D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2582      Y:021E Y:021E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2583      Y:021F Y:021F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2584      Y:0220 Y:0220                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2585      Y:0221 Y:0221                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2586      Y:0222 Y:0222                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2587      Y:0223 Y:0223                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2588      Y:0224 Y:0224                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2589      Y:0225 Y:0225                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2590      Y:0226 Y:0226                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2591                            END_SERIAL_READ_RIGHT_4
2592   
2593                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2594                            SERIAL_READ_SPLIT_4
2595      Y:0227 Y:0227                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2596      Y:0228 Y:0228                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2597      Y:0229 Y:0229                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2598      Y:022A Y:022A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2599      Y:022B Y:022B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2600      Y:022C Y:022C                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2601                            SXMIT_SPLIT_4
2602      Y:022D Y:022D                   DC      $00F020                           ; Transmit A/D data to host
2603      Y:022E Y:022E                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2604      Y:022F Y:022F                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2605      Y:0230 Y:0230                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2606      Y:0231 Y:0231                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2607      Y:0232 Y:0232                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2608      Y:0233 Y:0233                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2609      Y:0234 Y:0234                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2610      Y:0235 Y:0235                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2611      Y:0236 Y:0236                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2612      Y:0237 Y:0237                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2613      Y:0238 Y:0238                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2614      Y:0239 Y:0239                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2615      Y:023A Y:023A                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2616      Y:023B Y:023B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2617      Y:023C Y:023C                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2618      Y:023D Y:023D                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2619      Y:023E Y:023E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2620      Y:023F Y:023F                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2621      Y:0240 Y:0240                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2622      Y:0241 Y:0241                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2623      Y:0242 Y:0242                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2624      Y:0243 Y:0243                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2625      Y:0244 Y:0244                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2626      Y:0245 Y:0245                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2627                            END_SERIAL_READ_SPLIT_4
2628   
2629                            ;       Binned by 5 waveforms
2630                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2631                            SERIAL_READ_LEFT_5
2632      Y:0246 Y:0246                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2633      Y:0247 Y:0247                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2634      Y:0248 Y:0248                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2635      Y:0249 Y:0249                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2636      Y:024A Y:024A                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2637      Y:024B Y:024B                   DC      CLK2+$000000+000+000+000+000+H2L+H2R+H3L+H3R
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 48



2638                            SXMIT_LEFT_5
2639      Y:024C Y:024C                   DC      $00F000                           ; Transmit A/D data to host
2640      Y:024D Y:024D                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2641      Y:024E Y:024E                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2642      Y:024F Y:024F                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2643      Y:0250 Y:0250                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2644      Y:0251 Y:0251                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2645      Y:0252 Y:0252                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2646      Y:0253 Y:0253                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2647      Y:0254 Y:0254                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2648      Y:0255 Y:0255                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2649      Y:0256 Y:0256                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2650      Y:0257 Y:0257                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2651      Y:0258 Y:0258                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2652      Y:0259 Y:0259                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2653      Y:025A Y:025A                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2654      Y:025B Y:025B                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2655      Y:025C Y:025C                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2656      Y:025D Y:025D                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2657      Y:025E Y:025E                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2658      Y:025F Y:025F                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2659      Y:0260 Y:0260                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2660      Y:0261 Y:0261                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2661      Y:0262 Y:0262                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2662      Y:0263 Y:0263                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2663      Y:0264 Y:0264                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2664      Y:0265 Y:0265                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2665      Y:0266 Y:0266                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2666      Y:0267 Y:0267                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2667      Y:0268 Y:0268                   DC      CLK2+$030000+000+000+000+000+H2L+H2R+000+000
2668      Y:0269 Y:0269                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2669      Y:026A Y:026A                   DC      VIDEO+ADC_TIM+%0011011            ; Stop integrate, A/D is sampling
2670                            END_SERIAL_READ_LEFT_5
2671   
2672                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2673                            SERIAL_READ_RIGHT_5
2674      Y:026B Y:026B                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2675      Y:026C Y:026C                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2676      Y:026D Y:026D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2677      Y:026E Y:026E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2678      Y:026F Y:026F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2679      Y:0270 Y:0270                   DC      CLK2+$000000+000+000+H1L+H1R+000+000+H3L+H3R
2680                            SXMIT_RIGHT_5
2681      Y:0271 Y:0271                   DC      $00F021                           ; Transmit A/D data to host
2682      Y:0272 Y:0272                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2683      Y:0273 Y:0273                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2684      Y:0274 Y:0274                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2685      Y:0275 Y:0275                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2686      Y:0276 Y:0276                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2687      Y:0277 Y:0277                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2688      Y:0278 Y:0278                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2689      Y:0279 Y:0279                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2690      Y:027A Y:027A                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2691      Y:027B Y:027B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2692      Y:027C Y:027C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2693      Y:027D Y:027D                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2694      Y:027E Y:027E                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2695      Y:027F Y:027F                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2696      Y:0280 Y:0280                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2697      Y:0281 Y:0281                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2698      Y:0282 Y:0282                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2699      Y:0283 Y:0283                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  HIPO_Red.waveforms.s  Page 49



2700      Y:0284 Y:0284                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2701      Y:0285 Y:0285                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2702      Y:0286 Y:0286                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2703      Y:0287 Y:0287                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+000+000
2704      Y:0288 Y:0288                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2705      Y:0289 Y:0289                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+000+000
2706      Y:028A Y:028A                   DC      CLK2+R_DELAY+000+000+000+000+H2L+H2R+H3L+H3R
2707      Y:028B Y:028B                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2708      Y:028C Y:028C                   DC      CLK2+R_DELAY+000+000+H1L+H1R+000+000+H3L+H3R
2709      Y:028D Y:028D                   DC      CLK2+$030000+000+000+H1L+H1R+000+000+000+000
2710      Y:028E Y:028E                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2711      Y:028F Y:028F                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2712                            END_SERIAL_READ_RIGHT_5
2713   
2714                            ;       xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
2715                            SERIAL_READ_SPLIT_5
2716      Y:0290 Y:0290                   DC      CLK2+R_DELAY+RGL+RGR+H1L+H1R+H2L+H2R+000+000
2717      Y:0291 Y:0291                   DC      VIDEO+$000000+%1110100            ; Change nearly everything
2718      Y:0292 Y:0292                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2719      Y:0293 Y:0293                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2720      Y:0294 Y:0294                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2721      Y:0295 Y:0295                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2722                            SXMIT_SPLIT_5
2723      Y:0296 Y:0296                   DC      $00F020                           ; Transmit A/D data to host
2724      Y:0297 Y:0297                   DC      VIDEO+$000000+%1110111            ; Stop resetting integrator
2725      Y:0298 Y:0298                   DC      VIDEO+INT_TIM+%0000111            ; Integrate reset level
2726      Y:0299 Y:0299                   DC      VIDEO+$000000+%0011011            ; Stop Integrate
2727      Y:029A Y:029A                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2728      Y:029B Y:029B                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2729      Y:029C Y:029C                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2730      Y:029D Y:029D                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2731      Y:029E Y:029E                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2732      Y:029F Y:029F                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2733      Y:02A0 Y:02A0                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2734      Y:02A1 Y:02A1                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2735      Y:02A2 Y:02A2                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2736      Y:02A3 Y:02A3                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2737      Y:02A4 Y:02A4                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2738      Y:02A5 Y:02A5                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2739      Y:02A6 Y:02A6                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2740      Y:02A7 Y:02A7                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2741      Y:02A8 Y:02A8                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2742      Y:02A9 Y:02A9                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2743      Y:02AA Y:02AA                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2744      Y:02AB Y:02AB                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2745      Y:02AC Y:02AC                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+000+000
2746      Y:02AD Y:02AD                   DC      CLK2+R_DELAY+000+000+H1L+H1R+H2L+H2R+000+000
2747      Y:02AE Y:02AE                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+000+000
2748      Y:02AF Y:02AF                   DC      CLK2+R_DELAY+000+000+H1L+000+000+H2R+H3L+H3R
2749      Y:02B0 Y:02B0                   DC      CLK2+R_DELAY+000+000+000+000+000+000+H3L+H3R
2750      Y:02B1 Y:02B1                   DC      CLK2+R_DELAY+000+000+000+H1R+H2L+000+H3L+H3R
2751      Y:02B2 Y:02B2                   DC      CLK2+$030000+000+000+000+H1R+H2L+000+000+000
2752      Y:02B3 Y:02B3                   DC      VIDEO+INT_TIM+%0001011            ; Integrate signal level
2753      Y:02B4 Y:02B4                   DC      VIDEO+$000000+%0011011            ; Stop integrate, A/D is sampling
2754                            END_SERIAL_READ_SPLIT_5
2755   
2756   
2757                                      IF      @SCP("HOST","EEPROM")
2761                                      ENDIF
2762   
2763                               ENDSEC                                    ; End of section TIMEEV57
2764   
Motorola DSP56000 Assembler  Version 6.2.0   111-08-09  12:42:26  tim.s  Page 50



2765                     ;  End of program
2766                               END

0    Errors
0    Warnings


